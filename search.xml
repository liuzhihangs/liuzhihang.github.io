<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring 源码学习 12：registerBeanPostProcessors</title>
      <link href="2021/01/01/source-spring-12.html"/>
      <url>2021/01/01/source-spring-12.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前面通过 invokeBeanFactoryPostProcessors 这一步了解到了什么是 BeanFactoryPostProcessor ，以及 BeanFactoryPostProcessor 的使用及作用，并通过 invokeBeanFactoryPostProcessors 这一步源码，对 BeanFactoryPostProcessor 的加载流程有了进一步了解。</p><p>现在就一起进入下一个环节：</p><p><code>registerBeanPostProcessors(beanFactory);</code></p><p>这一步主要的作用是加载 BeanPostProcessor，从名字也可以看出，只是加载，并没有执行。</p><p>不过，在进入源码之前，依然是结合官网，先了解以下几个问题：</p><ol><li>什么是 BeanPostProcessor？</li><li>BeanPostProcessor 是如何使用的？</li><li>BeanPostProcessor 有什么用？</li></ol><h3 id="什么是-BeanPostProcessor-？"><a href="#什么是-BeanPostProcessor-？" class="headerlink" title="什么是 BeanPostProcessor ？"></a>什么是 BeanPostProcessor ？</h3><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/PqDpkg-Wujih5.png"></p><p>如截图所示，在官网 <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-extension-bpp" title="Spring 官方文档">1.8.1 Customizing Beans by Using a BeanPostProcessor</a> 中介绍， <code>BeanPostProcessor</code> 接口定义回调方法，可以实现这些方法，从而在 Bean 实例化期间修改 Bean 的属性。</p><h3 id="BeanPostProcessor-是如何使用的"><a href="#BeanPostProcessor-是如何使用的" class="headerlink" title="BeanPostProcessor 是如何使用的?"></a>BeanPostProcessor 是如何使用的?</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> UserComponent) &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;BeanPostProcessor 开始执行 初始化前...&quot;</span> + beanName);</span><br><span class="line"></span><br><span class="line">UserComponent userComponent = (UserComponent) bean;</span><br><span class="line">userComponent.setUserName(<span class="string">&quot;liuzhihang-postProcessBeforeInitialization&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> userComponent;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> UserComponent) &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;BeanPostProcessor 开始执行 初始化后...&quot;</span> + beanName);</span><br><span class="line"></span><br><span class="line">UserComponent userComponent = (UserComponent) bean;</span><br><span class="line">userComponent.setUserName(<span class="string">&quot;liuzhihang-postProcessAfterInitialization&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> userComponent;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如代码所示，只需要声明一个自己的 MyBeanPostProcessor 来实现 <code>BeanPostProcessor</code> 并重写其方法：</p><p>postProcessBeforeInitialization ：在 Bean 实例后调用初始化方法之前进行处理。</p><p>postProcessAfterInitialization ：在 Bean 实例化后调用初始化方法之后进行处理。</p><p>并且在测试时可以发现，BeanPostProcessor 修改的属性会覆盖 BeanFactoryPostProcessor，至于原因可以阅读下 <a href="https://mp.weixin.qq.com/s/6VrVDg4m6yi7V4rZZB-6tA">Spring 源码学习 11：invokeBeanFactoryPostProcessors</a> 这篇文章，相信对 BeanFactoryPostProcessor 有了一定的了解之后，一定会有自己的答案。</p><p>当然我个人的理解就是 BeanFactoryPostProcessor 是在 Bean 实例化之前，是通过修改元数据从而修改的 Bean 的元素信息。</p><p>这块也可以通过代码进行验证。</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/mHNyKC-SBWUcw.png"></p><p>可以看出，执行顺序是</p><p><code>BeanFactoryPostProcessor#postProcessBeanFactory</code><br>-&gt;<br><code>BeanPostProcessor#postProcessBeforeInitialization</code><br>-&gt;<br><code>BeanPostProcessor#postProcessAfterInitialization</code></p><p>所以，后面修改的属性，会覆盖之前修改的属性。</p><p>至于 <code>BeanPostProcessor</code> 是如何修改属性的，在这里先不做介绍，继续进入本节的主角 <code>registerBeanPostProcessors 源码分析</code> </p><h3 id="registerBeanPostProcessors-源码"><a href="#registerBeanPostProcessors-源码" class="headerlink" title="registerBeanPostProcessors 源码"></a>registerBeanPostProcessors 源码</h3><p>在 Spring refresh 方法中，执行 registerBeanPostProcessors 主要作用是将 BeanPostProcessor 注册到容器中，源码如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用了 <code>PostProcessorRegistrationDelegate</code> 类的静态方法，继续跟进：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找 BeanPostProcessor 类型的 Bean 的名称集合, 就是获取所有继承了 BeanPostProcessor 的类</span></span><br><span class="line">    String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register BeanPostProcessorChecker that logs an info message when</span></span><br><span class="line">    <span class="comment">// a bean is created during BeanPostProcessor instantiation, i.e. when</span></span><br><span class="line">    <span class="comment">// a bean is not eligible for getting processed by all BeanPostProcessors.</span></span><br><span class="line">    <span class="comment">//  注册一个 BeanPostProcessorChecker，用来记录 bean 在 BeanPostProcessor 实例化时的信息。</span></span><br><span class="line">    <span class="keyword">int</span> beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + <span class="number">1</span> + postProcessorNames.length;</span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Separate between BeanPostProcessors that implement PriorityOrdered,</span></span><br><span class="line">    <span class="comment">// Ordered, and the rest.</span></span><br><span class="line">    <span class="comment">// 四个集合 区分实现不同接口的 BeanPostProcessors</span></span><br><span class="line">    List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;BeanPostProcessor&gt; internalPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">        <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">            BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">            priorityOrderedPostProcessors.add(pp);</span><br><span class="line">            <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">                internalPostProcessors.add(pp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">            orderedPostProcessorNames.add(ppName);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// First, register the BeanPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">    <span class="comment">// 排序后执行 实现 PriorityOrdered 的 BeanPostProcessors</span></span><br><span class="line">    sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">    registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Next, register the BeanPostProcessors that implement Ordered.</span></span><br><span class="line">    List&lt;BeanPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line">    <span class="keyword">for</span> (String ppName : orderedPostProcessorNames) &#123;</span><br><span class="line">        BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">        orderedPostProcessors.add(pp);</span><br><span class="line">        <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">            internalPostProcessors.add(pp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">    registerBeanPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now, register all regular BeanPostProcessors.</span></span><br><span class="line">    List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line">    <span class="keyword">for</span> (String ppName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">        BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">        nonOrderedPostProcessors.add(pp);</span><br><span class="line">        <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">            internalPostProcessors.add(pp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finally, re-register all internal BeanPostProcessors.</span></span><br><span class="line">    sortPostProcessors(internalPostProcessors, beanFactory);</span><br><span class="line">    registerBeanPostProcessors(beanFactory, internalPostProcessors);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-register post-processor for detecting inner beans as ApplicationListeners,</span></span><br><span class="line">    <span class="comment">// moving it to the end of the processor chain (for picking up proxies etc).</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(applicationContext));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中添加了相应的注释，相信读过上一篇文章（invokeBeanFactoryPostProcessors 源码）的小伙伴，一定会感觉非常熟悉，这个方法的逻辑和上面基本一致，都是声明集合，排序，注册到 BeanFactory 中。</p><p>不过还是有区别的：</p><p><code>registerBeanPostProcessors 这一步仅仅将 BeanPostProcessor 注册到 BeanFactory 中，并没有执行！！！</code></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文源码部分相对比较简单，主要花费部分篇幅介绍什么是 BeanPostProcessor 以及 BeanPostProcessor 的使用方法。</p><p>一句话总结这一步就是：注册 BeanPostProcessor 到 BeanFactory 中，但是没有执行。</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/dHDiOq-CxKXF8.png"></p><h4 id="相关推荐"><a href="#相关推荐" class="headerlink" title="相关推荐"></a>相关推荐</h4><ul><li><a href="https://mp.weixin.qq.com/s/6VrVDg4m6yi7V4rZZB-6tA">Spring 源码学习 11：invokeBeanFactoryPostProcessors</a></li><li><a href="https://mp.weixin.qq.com/s/6vTqVFC4frjhqdMirGPCnQ">Spring 源码学习 10：prepareBeanFactory 和 postProcessBeanFactory</a></li><li><a href="https://mp.weixin.qq.com/s/i6vdCmOO2ZMsYWfheSLc6g">Spring 源码学习 09：refresh 大概流程</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 源码笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 源码学习 11：invokeBeanFactoryPostProcessors</title>
      <link href="2020/12/28/source-spring-11.html"/>
      <url>2020/12/28/source-spring-11.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>invokeBeanFactoryPostProcessors 会执行 BeanFactory 的后置处理器。看到这里会有疑问：</p><ol><li>什么是 BeanFactoryPostProcessor ？</li><li>BeanfactoryPostProcessor 该如何使用？</li></ol><p>知道了上面两个问题的答案，对 BeanFactoryPostProcessor 有了了解之后，然后再深入源码，继续阅读 invokeBeanFactoryPostProcessors 这个方法。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>资料还是在<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-extension-factory-postprocessors" title="Customizing Configuration Metadata with a BeanFactoryPostProcessor">官网</a>可以找到答案:</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/ZCnfJ9-tR3MFK.png"></p><p>阅读了一下，大概意思是 <code>Spring IoC 容器允许 BeanFactoryPostProcessor 读取配置元数据，并有可能在容器实例化除 BeanFactoryPostProcessor 实例以外的任何 bean 之前更改它。</code></p><p>同样可以使用 Ordered 接口对 BeanFactoryPostProcessor 进行排序。</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/XmG0jo-mewyfG.png"></p><p>BeanFactoryPostProcessor 操作的是 BeanDefinition ，即元数据。但是同样可以通过获取到 BeanFactory 进行实例化 Bean，但是官网很不建议这样使用。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="使用-BeanFactoryPostProcessor"><a href="#使用-BeanFactoryPostProcessor" class="headerlink" title="使用 BeanFactoryPostProcessor"></a>使用 BeanFactoryPostProcessor</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改 BeanDefinition 信息</span></span><br><span class="line">        BeanDefinition userComponentBeanDefinition = beanFactory.getBeanDefinition(<span class="string">&quot;userComponent&quot;</span>);</span><br><span class="line">        userComponentBeanDefinition.setLazyInit(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改 Bean 的信息</span></span><br><span class="line">        <span class="comment">// xxx 非常不推荐 beanFactory.getBean 过早的实例化 Bean</span></span><br><span class="line">        UserComponent bean = beanFactory.getBean(UserComponent.class);</span><br><span class="line">        bean.setUserName(<span class="string">&quot;liuzhihang-01&quot;</span>);</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建自己的 BeanFactoryPostProcessor 并实现 BeanFactoryPostProcessor 接口，添加注解即可。</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/8dEPpR-aN53mU.png"></p><p>当然除了实现 BeanFactoryPostProcessor 接口，还有其他接口可以实现：</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/llYeQ9-DTwOme.png"></p><h4 id="使用-BeanDefinitionRegistryPostProcessor"><a href="#使用-BeanDefinitionRegistryPostProcessor" class="headerlink" title="使用 BeanDefinitionRegistryPostProcessor"></a>使用 BeanDefinitionRegistryPostProcessor</h4><p>BeanDefinitionRegistryPostProcessor 继承了 BeanFactoryPostProcessor，同时扩展了增加了 <code>postProcessBeanDefinitionRegistry</code> 方法。可以支持在 BeanDefinition 注册之后 Bean 实例化之前对 BeanDefinition 进行操作。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanDefinitionRegistryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">// 修改 BeanDefinition 信息</span></span><br><span class="line">        BeanDefinition userComponentBeanDefinition = beanFactory.getBeanDefinition(<span class="string">&quot;userComponent&quot;</span>);</span><br><span class="line">        userComponentBeanDefinition.setLazyInit(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改 Bean 的信息</span></span><br><span class="line">        <span class="comment">// xxx 非常不推荐 beanFactory.getBean 过早的实例化 Bean</span></span><br><span class="line">        UserComponent bean = beanFactory.getBean(UserComponent.class);</span><br><span class="line">        bean.setUserName(<span class="string">&quot;liuzhihang-01&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册一个 BeanDefinition</span></span><br><span class="line">        BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(OrderComponent.class);</span><br><span class="line"></span><br><span class="line">        AbstractBeanDefinition orderComponentBeanDefinition = builder.getBeanDefinition();</span><br><span class="line"></span><br><span class="line">        registry.registerBeanDefinition(<span class="string">&quot;orderComponent&quot;</span>, orderComponentBeanDefinition);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是测试代码截图：</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/OAsBSh-FPE9FY.png"></p><p>OrderComponent 类没有添加任何注解，然后注册为 BeanDefinition 之后，从容器中可以获取到 orderComponent。</p><h4 id="如何修改字段属性"><a href="#如何修改字段属性" class="headerlink" title="如何修改字段属性"></a>如何修改字段属性</h4><p>在 Spring 文档上说明，非常不建议在 BeanFactoryPostProcessor 中实例化 Bean，那这时候想修改 Bean 的信息，改如何操作？</p><p>其实可以通过获取到 <code>MutablePropertyValues</code> 后进行操作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改 BeanDefinition 信息</span></span><br><span class="line">        BeanDefinition userComponentBeanDefinition = beanFactory.getBeanDefinition(<span class="string">&quot;userComponent&quot;</span>);</span><br><span class="line">        userComponentBeanDefinition.setLazyInit(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        MutablePropertyValues userComponentPropertyValues = userComponentBeanDefinition.getPropertyValues();</span><br><span class="line"></span><br><span class="line">        userComponentPropertyValues.addPropertyValue(<span class="string">&quot;userName&quot;</span>, <span class="string">&quot;liuzhihang-02&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改 Bean 的信息</span></span><br><span class="line">        <span class="comment">// xxx 非常不推荐 beanFactory.getBean 过早的实例化 Bean</span></span><br><span class="line">        <span class="comment">// UserComponent bean = beanFactory.getBean(UserComponent.class);</span></span><br><span class="line">        <span class="comment">// bean.setUserName(&quot;liuzhihang-01&quot;);</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="invokeBeanFactoryPostProcessors"><a href="#invokeBeanFactoryPostProcessors" class="headerlink" title="invokeBeanFactoryPostProcessors"></a>invokeBeanFactoryPostProcessors</h3><p>看完前面，我想已经知道了 BeanFactoryPostProcessor 是做什么用的了，而这一步的主要作用就是实例化所有的 BeanFactoryPostProcessor。</p><p>进入源码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime</span></span><br><span class="line">    <span class="comment">// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)</span></span><br><span class="line">    <span class="keyword">if</span> (!IN_NATIVE_IMAGE &amp;&amp; beanFactory.getTempClassLoader() == <span class="keyword">null</span> &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">        beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 getBeanFactoryPostProcessors 方法获取的是自己添加的 BeanFactoryPostProcessor。这句话是什么意思呢？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;BeanFactoryPostProcessor&gt; <span class="title">getBeanFactoryPostProcessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.beanFactoryPostProcessors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看源码，就是直接从 beanFactoryPostProcessors 获取的，那如何向其中添加呢？</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/jWhWAu-MicUEW.png"></p><p>其实调用容器的 <code>addBeanFactoryPostProcessor</code> 方法即可。</p><p>继续阅读重点代码 <code>invokeBeanFactoryPostProcessors</code> ：</p><p>注意注意，这块代码非常长！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Invoke BeanDefinitionRegistryPostProcessors first, if any.</span></span><br><span class="line">    Set&lt;String&gt; processedBeans = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否为 BeanDefinitionRegistry</span></span><br><span class="line">    <span class="comment">// debug 发现 这里传入的是 DefaultListableBeanFactory</span></span><br><span class="line">    <span class="comment">// DefaultListableBeanFactory 实现了 BeanDefinitionRegistry</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> BeanDefinitionRegistry) &#123;</span><br><span class="line">        BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建了两个 List 集合, 用来存放处理器</span></span><br><span class="line">        <span class="comment">// BeanDefinitionRegistryPostProcessor 是 BeanFactoryPostProcessor 的子接口</span></span><br><span class="line">        <span class="comment">// BeanDefinitionRegistryPostProcessor 还可以额外处理 BeanDefinition, 添加 BeanDefinition</span></span><br><span class="line">        <span class="comment">// 用法可以参考示例</span></span><br><span class="line">        List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环 beanFactoryPostProcessors</span></span><br><span class="line">        <span class="comment">// beanFactoryPostProcessors 是使用 API context.addBeanFactoryPostProcessor 添加进来的</span></span><br><span class="line">        <span class="keyword">for</span> (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// BeanDefinitionRegistryPostProcessor 要单独添加到 registryProcessors</span></span><br><span class="line">            <span class="keyword">if</span> (postProcessor <span class="keyword">instanceof</span> BeanDefinitionRegistryPostProcessor) &#123;</span><br><span class="line">                BeanDefinitionRegistryPostProcessor registryProcessor =</span><br><span class="line">                        (BeanDefinitionRegistryPostProcessor) postProcessor;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 处理 Bean 的信息</span></span><br><span class="line">                registryProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">                registryProcessors.add(registryProcessor);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                regularPostProcessors.add(postProcessor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">        <span class="comment">// uninitialized to let the bean factory post-processors apply to them!</span></span><br><span class="line">        <span class="comment">// Separate between BeanDefinitionRegistryPostProcessors that implement</span></span><br><span class="line">        <span class="comment">// PriorityOrdered, Ordered, and the rest.</span></span><br><span class="line">        <span class="comment">// 上面循环是执行的我们调用 API 添加的 BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">        <span class="comment">// 下面执行 Spring 自己的 BeanDefinitionRegistryPostProcessor 集合</span></span><br><span class="line">        <span class="comment">// 先执行实现了 PriorityOrdered接口的，然后是 Ordered 接口的，最后执行剩下的</span></span><br><span class="line">        List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">        <span class="comment">// 第一步先调用 BeanDefinitionRegistryPostProcessors 它实现了PriorityOrdered</span></span><br><span class="line">        <span class="comment">// 在初始化 reader 时 在注册了 ConfigurationClassPostProcessor 到容器里面</span></span><br><span class="line">        <span class="comment">// BeanDefinitionRegistryPostProcessor 实现了 BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">        String[] postProcessorNames =</span><br><span class="line">                beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">                <span class="comment">// 添加 bean</span></span><br><span class="line">                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">                <span class="comment">// 这里只添加了名字 后面用来判断谁已经执行过了</span></span><br><span class="line">                processedBeans.add(ppName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">        registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环执行 processors 的 postProcessBeanDefinitionRegistry 方法</span></span><br><span class="line">        <span class="comment">// 这个得在仔细看</span></span><br><span class="line">        <span class="comment">// debug 看到 执行完这一步我另一个加 @Component 注解的类 注册到 Registry 里面了</span></span><br><span class="line">        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());</span><br><span class="line">        <span class="comment">// 清除</span></span><br><span class="line">        currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.</span></span><br><span class="line">        <span class="comment">// 处理实现 Ordered 的 processor</span></span><br><span class="line">        postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">            <span class="comment">// 只有不包含的才执行, 执行完之后会添加进 processedBeans</span></span><br><span class="line">            <span class="keyword">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">                processedBeans.add(ppName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 同上</span></span><br><span class="line">        sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">        registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());</span><br><span class="line">        currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.</span></span><br><span class="line">        <span class="comment">// 最后执行其他</span></span><br><span class="line">        <span class="keyword">boolean</span> reiterate = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (reiterate) &#123;</span><br><span class="line">            reiterate = <span class="keyword">false</span>;</span><br><span class="line">            postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">                <span class="comment">// 只有不包含的才执行, 执行完之后会添加进 processedBeans</span></span><br><span class="line">                <span class="keyword">if</span> (!processedBeans.contains(ppName)) &#123;</span><br><span class="line">                    currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">                    processedBeans.add(ppName);</span><br><span class="line">                    reiterate = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">            registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">            invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());</span><br><span class="line">            currentRegistryProcessors.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Now, invoke the postProcessBeanFactory callback of all processors handled so far.</span></span><br><span class="line">        <span class="comment">// 上面处理的都是 postProcessBeanDefinitionRegistry 是在 -&gt; BeanDefinitionRegistryPostProcessor 中</span></span><br><span class="line">        <span class="comment">// 下面开始处理 postProcessBeanFactory  -&gt; 是在 BeanFactoryPostProcessor 中</span></span><br><span class="line">        invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);</span><br><span class="line">        invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Invoke factory processors registered with the context instance.</span></span><br><span class="line">        <span class="comment">// 不是 BeanDefinitionRegistry 则是普通 BeanFactory 直接执行 beanFactoryPostProcessors 即可</span></span><br><span class="line">        invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">    <span class="comment">// uninitialized to let the bean factory post-processors apply to them!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二部分</span></span><br><span class="line">    <span class="comment">// 上面执行的是 BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">    <span class="comment">// 下面开始执行 BeanFactoryPostProcessor</span></span><br><span class="line">    String[] postProcessorNames =</span><br><span class="line">            beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,</span></span><br><span class="line">    <span class="comment">// Ordered, and the rest.</span></span><br><span class="line">    <span class="comment">// 按照顺序执行</span></span><br><span class="line">    List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">        <span class="keyword">if</span> (processedBeans.contains(ppName)) &#123;</span><br><span class="line">            <span class="comment">// skip - already processed in first phase above</span></span><br><span class="line">            <span class="comment">// 说明上面已经执行了, 下面忽略</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">            priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">            orderedPostProcessorNames.add(ppName);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">    <span class="comment">// 执行实现 PriorityOrdered 的</span></span><br><span class="line">    sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">    invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Next, invoke the BeanFactoryPostProcessors that implement Ordered.</span></span><br><span class="line">    List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line">    <span class="keyword">for</span> (String postProcessorName : orderedPostProcessorNames) &#123;</span><br><span class="line">        orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">    &#125;</span><br><span class="line">    sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">    invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finally, invoke all other BeanFactoryPostProcessors.</span></span><br><span class="line">    List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line">    <span class="keyword">for</span> (String postProcessorName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">        nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">    &#125;</span><br><span class="line">    invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clear cached merged bean definitions since the post-processors might have</span></span><br><span class="line">    <span class="comment">// modified the original metadata, e.g. replacing placeholders in values...</span></span><br><span class="line">    <span class="comment">// 清空不必要的元数据信息</span></span><br><span class="line">    beanFactory.clearMetadataCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面总体可以分为两部分：</p><ol><li>执行 BeanDefinitionRegistryPostProcessor 接口里面的两个方法：postProcessBeanDefinitionRegistry 和 postProcessBeanFactory。</li><li>执行 BeanFactoryPostProcessor 接口里面的 postProcessBeanFactory 方法。</li></ol><p>以第一部分为例：</p><ol><li>首先判断传入的 BeanFactory 是否为 BeanDefinitionRegistry<ol><li>声明两个 List 集合，regularPostProcessors 用来存储 BeanFactoryPostProcessor，registryProcessors 用来存储 BeanDefinitionRegistryPostProcessor<ol><li>循环 beanFactoryPostProcessors，这个就是我们使用 API 方式添加进来的 BeanFactoryPostProcessor。</li><li>在循环中 BeanDefinitionRegistryPostProcessor 的 postProcessBeanDefinitionRegistry 会被执行，也就是说我示例的那个添加 BeanDefinition 演示的方法会被执行。</li></ol></li><li>开始执行 Spring 自己的 BeanDefinitionRegistryPostProcessor， 处理顺序为 PriorityOrdered, Ordered, and the rest<ol><li>循环，将对应的 BeanDefinitionRegistryPostProcessor 添加到 currentRegistryProcessors 集合和processedBeans集合表示为已经处理。</li><li>排序后添加到第一步的 registryProcessors 中。</li><li>调用 invokeBeanDefinitionRegistryPostProcessors 执行所有的 Processor 里面的 postProcessBeanDefinitionRegistry 方法</li></ol></li><li>执行完 1 和 2 之后，所有的 postProcessBeanDefinitionRegistry 已经被执行完了，但是两个集合（registryProcessors、regularPostProcessors）里面的 postProcessBeanFactory 方法还没有被执行。最后会循环执行。</li></ol></li><li>如果不是 BeanDefinitionRegistry 类型，则直接执行传入的 beanFactoryPostProcessors 即可。</li></ol><p>下面是对应的代码截图</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/vc4xUC-rCOdvD.png"></p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/1A06zT-DDaqjY.png"></p><p>以上只是这个方法的前半部分，执行了 BeanDefinitionRegistryPostProcessor 里面的 postProcessBeanDefinitionRegistry 和 postProcessBeanFactory。</p><p>因为还有直接实现 BeanFactoryPostProcessor 的处理器，下面则开始处理 BeanFactoryPostProcessor 的处理器。过程和上面类似。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过以上的阅读，对 <code>invokeBeanFactoryPostProcessors(beanFactory);</code> 这一步方法进行总结。</p><h4 id="BeanFactoryPostProcessor-作用"><a href="#BeanFactoryPostProcessor-作用" class="headerlink" title="BeanFactoryPostProcessor 作用"></a>BeanFactoryPostProcessor 作用</h4><p>BeanFactoryPostProcessor 主要作用是在注册 BeanDefinition 之后，在 Bean 初始化之前，修改 BeanDefinition 的信息。</p><p>BeanFactoryPostProcessor 有个实现叫 BeanDefinitionRegistryPostProcessor，它可以额外的注册新的 BeanDefinition 到容器中。</p><h4 id="流程概述"><a href="#流程概述" class="headerlink" title="流程概述"></a>流程概述</h4><ol><li>这一步主要是处理 BeanFactoryPostProcessor，分为两步。</li><li>执行 BeanDefinitionRegistryPostProcessor 接口里面的两个方法：postProcessBeanDefinitionRegistry 和 postProcessBeanFactory。</li><li>执行 BeanFactoryPostProcessor 接口里面的 postProcessBeanFactory 方法。</li></ol><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/hoPCO0-yAfXNu.png"></p><h4 id="相关推荐"><a href="#相关推荐" class="headerlink" title="相关推荐"></a>相关推荐</h4><ul><li><a href="https://mp.weixin.qq.com/s/6vTqVFC4frjhqdMirGPCnQ">Spring 源码学习 10：prepareBeanFactory 和 postProcessBeanFactory</a></li><li><a href="https://mp.weixin.qq.com/s/i6vdCmOO2ZMsYWfheSLc6g">Spring 源码学习 09：refresh 大概流程</a></li><li><a href="https://mp.weixin.qq.com/s/XPljpjGBpD7t2cmPAofm7A">Spring 源码学习 08：register 注册配置类</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 源码笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 源码学习 10：prepareBeanFactory 和 postProcessBeanFactory</title>
      <link href="2020/12/27/source-spring-10.html"/>
      <url>2020/12/27/source-spring-10.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>根据 refresh 流程，当 <code>obtainFreshBeanFactory</code> 执行结束后，下一步会执行 <code>prepareBeanFactory</code> ，顾名思义，这个方法主要是<code>准备 BeanFactory</code>，下面一起看一看这部分逻辑。</p><h3 id="prepareBeanFactory"><a href="#prepareBeanFactory" class="headerlink" title="prepareBeanFactory"></a>prepareBeanFactory</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Tell the internal bean factory to use the context&#x27;s class loader etc.</span></span><br><span class="line"><span class="comment">// 设置beanFactory的类加载器</span></span><br><span class="line">beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line"><span class="comment">// spring.spel.ignore 属性控制是否解析 SpEL 表达式</span></span><br><span class="line"><span class="keyword">if</span> (!shouldIgnoreSpel) &#123;</span><br><span class="line">beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置属性解析器</span></span><br><span class="line">beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> ResourceEditorRegistrar(<span class="keyword">this</span>, getEnvironment()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Configure the bean factory with context callbacks.</span></span><br><span class="line"><span class="comment">// 添加到后置处理器列表, 新创建的 ApplicationContextAwareProcessor 入参为当前 ApplicationContext</span></span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 忽略自动装配</span></span><br><span class="line"><span class="comment">// 默认情况下 只有BeanFactoryAware 被忽略 要忽略其他类型，需要单独设置</span></span><br><span class="line">beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(ApplicationStartup.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// BeanFactory interface not registered as resolvable type in a plain factory.</span></span><br><span class="line"><span class="comment">// MessageSource registered (and found for autowiring) as a bean.</span></span><br><span class="line"><span class="comment">// 注册自动装配的类</span></span><br><span class="line">beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="keyword">this</span>);</span><br><span class="line">beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="keyword">this</span>);</span><br><span class="line">beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register early post-processor for detecting inner beans as ApplicationListeners.</span></span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found.</span></span><br><span class="line"><span class="comment">// 是否需要类加载期间织入  增加Aspectj的支持</span></span><br><span class="line"><span class="keyword">if</span> (!IN_NATIVE_IMAGE &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line"><span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register default environment beans.</span></span><br><span class="line"><span class="comment">// 注册其他的 bean</span></span><br><span class="line"><span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!beanFactory.containsLocalBean(APPLICATION_STARTUP_BEAN_NAME)) &#123;</span><br><span class="line">beanFactory.registerSingleton(APPLICATION_STARTUP_BEAN_NAME, getApplicationStartup());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这块代码比较长，但是逻辑比较简单，就直接贴代码了。</p><p>再对代码进行分析，主要经历以下几个阶段：</p><ol><li>addBeanPostProcessor 添加 BeanPostProcessor</li><li>registerResolvableDependency 注册依赖关系</li><li>registerSingleton 注册其他的单例 Bean</li></ol><p>下面可以 Debug 看一下。</p><h3 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h3><p>方法调用前：</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/NJwbIq-S5vLU0.png"></p><p>registerResolvableDependency 执行之后</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/aRpomY-pOoRdu.png"></p><p>这里发现调用 <code>registerResolvableDependency</code> 执行结束之后，<code>beanDefinitionNames</code> 中并没有多添加相关对象。</p><p>查看源码发现其实是添加到了 <code>resolvableDependencies</code> 这个 Map 中了。</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/r83Zdu-IywxsL.png"></p><blockquote><p>回顾</p><p>在介绍 <code>DefaultListableBeanFactory</code> 时，说 BeanDefinition 是存储在 beanDefinitionMap 中的。<br>而这里的依赖关系是则是存储在 <code>resolvableDependencies</code> 中的。</p></blockquote><h3 id="postProcessBeanFactory"><a href="#postProcessBeanFactory" class="headerlink" title="postProcessBeanFactory"></a>postProcessBeanFactory</h3><p>在执行 prepareBeanFactory 之后，当看到 <code>postProcessBeanFactory(beanFactory);</code> 方法的时候就很疑惑， 因为这个是需要子类实现的，只是作为一个模板方法，子类实现之后，可以在里面添加自己的逻辑。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这篇文章相对比较简单，就是准备 BeanFactory 向其中添加系统的依赖以及 bean, 而 postProcessBeanFactory 则是一个模版方法用来供子类实现。</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/nDmWFO-dHVLOp.png"></p><h4 id="相关推荐"><a href="#相关推荐" class="headerlink" title="相关推荐"></a>相关推荐</h4><ul><li><a href="https://mp.weixin.qq.com/s/i6vdCmOO2ZMsYWfheSLc6g">Spring 源码学习 09：refresh 大概流程</a></li><li><a href="https://mp.weixin.qq.com/s/XPljpjGBpD7t2cmPAofm7A">Spring 源码学习 08：register 注册配置类</a></li><li><a href="https://mp.weixin.qq.com/s/VnUugIxZkUcqDvt9Yv47iQ">Spring 源码学习 07：ClassPathBeanDefinitionScanner</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 源码笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 源码学习 09：refresh 大概流程</title>
      <link href="2020/12/16/source-spring-09.html"/>
      <url>2020/12/16/source-spring-09.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前面的准备工作结束之后，就是进入核心代码 refresh。</p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        StartupStep contextRefresh = <span class="keyword">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.refresh&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 准备一些上下文</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取准备后的 beanFactory  DefaultListableBeanFactory</span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 准备 BeanFactory</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 允许在上下文子类中对bean工厂进行后处理。</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">            StartupStep beanPostProcess = <span class="keyword">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.beans.post-process&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 在上下文中调用注册为 beanFactory 后置处理器</span></span><br><span class="line">            <span class="comment">// 就是实现了 BeanFactoryPostProcessor 的 bean</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注册后置处理的Bean到容器当中</span></span><br><span class="line">            <span class="comment">// 就是扩展了 BeanPostProcessor 的 Bean</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line">            beanPostProcess.end();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 为此上下文初始化消息源。</span></span><br><span class="line">            <span class="comment">// 初始化国际化工具 MessageSource</span></span><br><span class="line">            initMessageSource();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 为此上下文初始化事件广播器。</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 在特定上下文子类中初始化其他特殊bean。子类可以自己实现</span></span><br><span class="line">            onRefresh();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查并注册监听器。</span></span><br><span class="line">            registerListeners();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 实例化所有剩余的（非延迟初始化）单例。</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 最后一步: 完成此上下文的刷新，调用 LifecycleProcessor 的 onRefresh（）方法并发布</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 销毁已创建的单例以避免资源悬挂。</span></span><br><span class="line">            destroyBeans();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 重置活动状态</span></span><br><span class="line">            cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">            <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">            resetCommonCaches();</span><br><span class="line">            contextRefresh.end();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码就是密密麻麻的一大堆，源码上有相应的注释。</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/qaUQQJ-l1bAsm.png"></p><p>下面就根据流程，一步一步的深入源码，了解到每一步都是做什么了。</p><h3 id="容器刷新准备"><a href="#容器刷新准备" class="headerlink" title="容器刷新准备"></a>容器刷新准备</h3><p><code>prepareRefresh</code> 这一步主要是准备一些上下文信息。就不过多介绍了。</p><h3 id="obtainFreshBeanFactory"><a href="#obtainFreshBeanFactory" class="headerlink" title="obtainFreshBeanFactory"></a>obtainFreshBeanFactory</h3><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/nD4PyL-DFi913.png"></p><p>下面关注初始化 BeanFactory 这一步：</p><p>进入源码：</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/4RezAZ-ngEGKj.png"></p><p>通过 Debug 可以看出 <code>refreshBeanFactory()</code> 这一步调用的是 <code>org.springframework.context.support.GenericApplicationContext#refreshBeanFactory</code> 中实现的方法。</p><p>继续跟进</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/nhZCwD-I9EXrp.png"></p><p>发现这块判断了一个 <code>refreshed</code> 刷新状态。</p><p><code>refreshBeanFactory</code> 方法也有另一个实现是在 <code>AbstractRefreshableApplicationContext</code> 中， 只不过我的断点没有断进去，这块也一起看下。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">// 如果存在 BeanFactory 则销毁 Bean 并关闭 BeanFactory</span></span><br><span class="line">    <span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">        destroyBeans();</span><br><span class="line">        closeBeanFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个默认的 BeanFactory</span></span><br><span class="line">        DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">        beanFactory.setSerializationId(getId());</span><br><span class="line">        <span class="comment">// 设置属性</span></span><br><span class="line">        customizeBeanFactory(beanFactory);</span><br><span class="line">        <span class="comment">// 加载 Bean 信息</span></span><br><span class="line">        loadBeanDefinitions(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">&quot;I/O error parsing bean definition source for &quot;</span> + getDisplayName(), ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中会创建 BeanFactory 并加载 BeanDefinition。只不过我暂时没有断到，所以等后面遇到之后再详细介绍。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/3JfDRw-4a5C5Y.png"></p><p>本文简单介绍了 refresh 的流程，并介绍了前两个部分：</p><ol><li>prepareRefresh 准备上下文信息</li><li>obtainFreshBeanFactory 初始化 BeanFactory</li></ol><h4 id="相关推荐"><a href="#相关推荐" class="headerlink" title="相关推荐"></a>相关推荐</h4><ul><li><a href="https://mp.weixin.qq.com/s/XPljpjGBpD7t2cmPAofm7A">Spring 源码学习 08：register 注册配置类</a></li><li><a href="https://mp.weixin.qq.com/s/VnUugIxZkUcqDvt9Yv47iQ">Spring 源码学习 07：ClassPathBeanDefinitionScanner</a></li><li><a href="https://mp.weixin.qq.com/s/u40NdypoO2ow2wdV293eow">Spring 源码学习 06：AnnotatedBeanDefinitionReader</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 源码笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 源码学习 08：register 注册配置类</title>
      <link href="2020/12/06/source-spring-08.html"/>
      <url>2020/12/06/source-spring-08.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>看完无参构造的源码及流程之后，后面将会执行 <code>register</code> 方法。</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/iURj3q-YF3Fqe.png"></p><p>register 方法，入参是我们的配置类 <code>JavaConfig.class</code> ，下面跟着源码继续往下走！</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/72gJH7-cF6JtX.png"></p><p><code>this.reader.register(componentClasses);</code></p><p>这里执行的是 reader 的方法，入参就是传入的 <code>JavaConfig.class</code>。</p><blockquote><p>reader 在之前初始化，就是注册一些 PostProcessor。</p></blockquote><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/OL9u7q-Y6NATv.png"></p><ol><li>循环，注册所有的配置类；</li><li>doRegisterBean 开始注册。</li></ol><p><code>doRegisterBean</code> 才是真正注册 Bean 的逻辑，从名字也可以有所猜测。下面开始进入 <code>doRegisterBean</code> 的源码阅读：</p><h4 id="doRegisterBean"><a href="#doRegisterBean" class="headerlink" title="doRegisterBean"></a>doRegisterBean</h4><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/OXRMeM-cMgaGt.png"></p><p>此处代码较长，以截图代替。</p><p>通过源码可以看出，这块主要流程：</p><ol><li>校验传入的 <code>JavaConfig.class</code> 的注解（是否需要忽略）；</li><li>处理通用注解；</li><li>封装为 BeanDefinitionHolder 后，注册到容器中。</li></ol><h4 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h4><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/QfGRrs-tdXZRz.png"></p><p>通过 debug 可以看出，在执行完 <code>register</code> 之后，相当于将 JavaConfig 作为一个 Bean 注册到容器中。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/mcTElg-qWdJKu.png"></p><p>在我看来前面的部分主要涉及到准备工作，至于更深层次的研究，分析，暂时没有深入。</p><h4 id="相关推荐"><a href="#相关推荐" class="headerlink" title="相关推荐"></a>相关推荐</h4><ul><li><a href="https://mp.weixin.qq.com/s/VnUugIxZkUcqDvt9Yv47iQ">Spring 源码学习 07：ClassPathBeanDefinitionScanner</a></li><li><a href="https://mp.weixin.qq.com/s/u40NdypoO2ow2wdV293eow">Spring 源码学习 06：AnnotatedBeanDefinitionReader</a></li><li><a href="https://mp.weixin.qq.com/s/b7QhZguNTM_6C83b4IiMdg">Spring 源码学习 05：BeanDefinition 概念及其实现</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 源码笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 源码学习 07：ClassPathBeanDefinitionScanner</title>
      <link href="2020/12/05/source-spring-07.html"/>
      <url>2020/12/05/source-spring-07.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>AnnotationConfigApplicationContext 构造函数除了初始化一个 <code>reader</code> ，还有一个 <code>scanner</code>，下面来一起看看 <code>ClassPathBeanDefinitionScanner</code> 都有什么逻辑。</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/aag0Mf-hC4vg6.png"></p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p><code>this.scanner = new ClassPathBeanDefinitionScanner(this);</code> 代码如下所示：</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/dIkTFJ-9bYFDo.png"></p><p>其中 <code>useDefaultFilters</code> 默认设置的 true。所以最终会执行下面三部分代码：</p><ol><li>registerDefaultFilters();</li><li>setEnvironment(environment);</li><li>setResourceLoader(resourceLoader);</li></ol><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/7IpG0J-yzsRns.png"></p><p>再来看下 UML ：</p><p><code>ClassPathBeanDefinitionScanner</code> 继承了 <code>ClassPathScanningCandidateComponentProvider</code>，而上面说的这三个方法，其实都是父类 <code>ClassPathScanningCandidateComponentProvider</code> 的方法。</p><p>对应的这三个操作就是给它的参数赋值：</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/P15SfZ-To57wW.png"></p><h4 id="registerDefaultFilters"><a href="#registerDefaultFilters" class="headerlink" title="registerDefaultFilters"></a>registerDefaultFilters</h4><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/EjGINh-OGlb4j.png"></p><p>本步骤主要是添加过滤器，对 includeFilters 赋值。 注册过滤器 <code>@Component</code>，<code>@Controller</code> <code>@Service</code>、 <code>@Repository</code> 也会被添加进去。</p><p>也会注册添加 JSR-250 的 @ManagedBean 和 JSR-330 的 @Named 注解。</p><h4 id="setEnvironment"><a href="#setEnvironment" class="headerlink" title="setEnvironment"></a>setEnvironment</h4><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/HLHo9N-l5MfXo.png"></p><h4 id="setResourceLoader"><a href="#setResourceLoader" class="headerlink" title="setResourceLoader"></a>setResourceLoader</h4><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/NTEYuH-nYXQTF.png"></p><p><code>setEnvironment</code> 和 <code>setResourceLoader</code> 赋值操作，基本上如代码所示。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/cWzzC7-zOZGjH.png"></p><p>这一步主要是初始化类扫描器，在它初始化的时候，会初始化一些需要被扫描的注解，以及资源加载器。</p><h4 id="相关推荐"><a href="#相关推荐" class="headerlink" title="相关推荐"></a>相关推荐</h4><ul><li><a href="https://mp.weixin.qq.com/s/u40NdypoO2ow2wdV293eow">Spring 源码学习 06：AnnotatedBeanDefinitionReader</a></li><li><a href="https://mp.weixin.qq.com/s/b7QhZguNTM_6C83b4IiMdg">Spring 源码学习 05：BeanDefinition 概念及其实现</a></li><li><a href="https://mp.weixin.qq.com/s/JwRsKHqJ0ZcJ6Cgbp5BKiw">Spring 源码学习 04：初始化容器与 DefaultListableBeanFactory</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 源码笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 源码学习 06：AnnotatedBeanDefinitionReader</title>
      <link href="2020/12/04/source-spring-06.html"/>
      <url>2020/12/04/source-spring-06.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>BeanDefinition 的概念也了解了，也知道一个 Bean 在 Spring 中定义的信息有哪些之后，继续言归正传。</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/erZhOh-c50rG0.png"></p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>在初始化时会先生成一个 reader ，进入方法，其实是走的下面的逻辑：</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/RPkIz4-hjaaG4.png"></p><p>其中 <code>getOrCreateEnvironment(registry)</code> 会返回一个 <code>Environment</code> 用来表示当前的运行环境之类的。</p><p><code>ConditionEvaluator</code> 是用来完成对 <code>@Conditional</code> 这个条件注解的判断。</p><p>这块可以参考官网：<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-environment">Environment Abstraction 章节</a></p><p><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java-conditional">Conditionally Include @Configuration Classes or @Bean Methods 章节</a></p><blockquote><p><strong>补充</strong></p><p>BeanDefinitionRegistry：就是对 BeanDefinition 进行注册、移除、获取等操作的一个接口。<br>比如：registerBeanDefinition、removeBeanDefinition、containsBeanDefinition 看名字也能猜个大概意思。</p></blockquote><h4 id="registerAnnotationConfigProcessors"><a href="#registerAnnotationConfigProcessors" class="headerlink" title="registerAnnotationConfigProcessors"></a>registerAnnotationConfigProcessors</h4><p>下面来看最后一行代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="keyword">this</span>.registry);</span><br></pre></td></tr></table></figure><p>这个代码相对较长，还是以截图代替。</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/6wAV8a-8qbZoP.png"></p><p>对 beanFactory 添加依赖比较器 和 自动装配解析器 后开始添加各种处理器。</p><p>添加处理器时，下面收缩的代码和唯一展开的 <code>ConfigurationClassPostProcessor</code> 内部逻辑相同，都是调用 <code>registerPostProcessor</code> 方法，下面再介绍下这几个处理器的作用：</p><ul><li>ConfigurationClassPostProcessor 用于对 @Configuration 类进行引导处理。</li><li>AutowiredAnnotationBeanPostProcessor 处理 @Autowired @Value 和 JSR-330的@Inject 还有 @Lookup 注解</li><li>CommonAnnotationBeanPostProcessor 用来处理 @PostConstruct @PreDestroy @Resource。</li><li>PersistenceAnnotationBeanPostProcessor 当支持 JPA 时添加这个。</li><li>EventListenerMethodProcessor 支持 @EventListener。</li></ul><h4 id="registerPostProcessor"><a href="#registerPostProcessor" class="headerlink" title="registerPostProcessor"></a>registerPostProcessor</h4><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/uaUJJU-bcIdE3.png"></p><p>registerPostProcessor 方法有两个逻辑：</p><ol><li>将这几个 Processor 注册到 beanFactory；</li><li>处理器封装为 BeanDefinitionHolder 对象。</li></ol><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/jdTJln-hqvIeJ.png" alt="BeanDefinitionHolder"></p><p>BeanDefinitionHolder 就是封装了下 BeanDefinition ，说明这个 BeanDefinition 的持有者 name 是谁。 </p><h4 id="大胆猜测"><a href="#大胆猜测" class="headerlink" title="大胆猜测"></a>大胆猜测</h4><p>执行完这一行之后，在 AnnotationConfigApplicationContext 里面有了 这几个 BeanDefinition。</p><h4 id="小心求证"><a href="#小心求证" class="headerlink" title="小心求证"></a>小心求证</h4><p>Debug 走起！</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/wFyqjc-OROaV6.png"></p><p>额……  只有四个，假装是对的。还是一步一步看一看吧！原来是没有 JSR-250 和 JPA，那这个就正常了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/jMZmN5-GpjdYh.png"></p><p>其实简而言之，这一步就是注册了一些 Spring 自己的 PostProcessor。</p><h4 id="相关推荐"><a href="#相关推荐" class="headerlink" title="相关推荐"></a>相关推荐</h4><ul><li><a href="https://mp.weixin.qq.com/s/b7QhZguNTM_6C83b4IiMdg">Spring 源码学习 05：BeanDefinition 概念及其实现</a></li><li><a href="https://mp.weixin.qq.com/s/JwRsKHqJ0ZcJ6Cgbp5BKiw">Spring 源码学习 04：初始化容器与 DefaultListableBeanFactory</a></li><li><a href="https://mp.weixin.qq.com/s/V7SjmIFKAXyppBF_KHbxXQ">Spring 源码学习 03：创建 IoC 容器的几种方式</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 源码笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 源码学习 05：BeanDefinition 概念及其实现</title>
      <link href="2020/12/03/source-spring-05.html"/>
      <url>2020/12/03/source-spring-05.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>BeanDefinition：顾名思义，就是 Bean 的定义，是用来描述一个 Bean 都有什么信息。前面说在初始化 <code>DefaultListableBeanFactory</code> 时，会初始化一个 <code>Map&lt;String, BeanDefinition&gt;</code>，这个 Map 的功能暂且不说，（PS：查资料说的是存储 bean），所以今天就结合官方文档以及源码，一起了解一下 <code>BeanDefinition</code>！</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/RQNh7C-qiNl5V.png"></p><p>在容器内部，使用 <code>BeanDefinition</code> 对象定义一个 Bean。而定义的信息包含 类名、作用域、是否懒加载、构造参数、初始化方法、销毁方式等等。</p><p>了解了概念之后，开始阅读源码，源码部分比较长。</p><h3 id="源码介绍"><a href="#源码介绍" class="headerlink" title="源码介绍"></a>源码介绍</h3><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/BeanDefinition-pzN9Uc.png" alt="BeanDefinition"></p><p>通过 UML 可以看出 BeanDefinition 接口继承了 AttributeAccessor 和 BeanMetadataElement 两个接口。</p><h4 id="AttributeAccessor"><a href="#AttributeAccessor" class="headerlink" title="AttributeAccessor"></a>AttributeAccessor</h4><p>AttributeAccessor：定义用于将元数据附加到任意对象或从任意对象访问元数据的通用协定的接口。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AttributeAccessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(String name, <span class="meta">@Nullable</span> Object value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">Object <span class="title">getAttribute</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">Object <span class="title">removeAttribute</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasAttribute</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">String[] attributeNames();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过接口方法可以看出，AttributeAccessor 主要定义了对元数据<code>属性</code>的增删改查。</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/uZKzQo-PU9mzG.png"></p><p><code>AttributeAccessorSupport</code> 是 AttributeAccessor 接口的一个实现，通过实现可以看出，其内部使用了 Map 保存名称和属性值。</p><h4 id="BeanMetadataElement"><a href="#BeanMetadataElement" class="headerlink" title="BeanMetadataElement"></a>BeanMetadataElement</h4><p>BeanMetadataElement：由包含配置源对象的 bean 元数据元素实现的接口。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanMetadataElement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Object <span class="title">getSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口内部只有一个 <code>getSource()</code> 方法，其含义为：<strong>返回此元数据元素的配置源Object （可以为null ）。</strong></p><p>其实还是不知道啥意思……</p><p>在子类（<code>BeanMetadataAttributeAccessor</code>）中加上断点，debug</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/bR6lTo-GEmj33.png"></p><p>这里 source 里面存储了 Class 类文件在磁盘的真实路径。当然姑且可以这么认为，毕竟我这也是刚开始学习源码，当前的结论只是 debug 到的，也有可能在别的实现类中存储的是别的信息。</p><h4 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h4><p>BeanDefinition 方法较多，就不贴代码，或者截图了。详细可以通过 <a href="https://github.com/liuzhihang/spring-framework/blob/master/spring-beans/src/main/java/org/springframework/beans/factory/config/BeanDefinition.java">我的 GitHub</a> 进行阅读，上面添加了相关注释。</p><p>不过还是简要介绍一下方法，大概有 Bean 的名字、作用范围、是否首选、以及 Bean 的初始化销毁方法等等。</p><p>BeanDefinition 只是一个接口，其实现又分为好几种。</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/AbstractBeanDefinition-x4hCMm.png" alt="AbstractBeanDefinition"></p><h4 id="AbstractBeanDefinition"><a href="#AbstractBeanDefinition" class="headerlink" title="AbstractBeanDefinition"></a>AbstractBeanDefinition</h4><p>AbstractBeanDefinition 作为 BeanDefinition 的抽象实现类，内部定义了很多属性，以满足 BeanDefinition 定义的接口功能。</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/avOyP7-LBkQNL.png"></p><p>这些属性的操作，就对应着 BeanDefinition 定义的接口方法。</p><h4 id="AbstractBeanDefinition-的三个实现类"><a href="#AbstractBeanDefinition-的三个实现类" class="headerlink" title="AbstractBeanDefinition 的三个实现类"></a>AbstractBeanDefinition 的三个实现类</h4><p>AbstractBeanDefinition 的实现又分为三个：分别是 <code>ChildBeanDefinition</code>、 <code>RootBeanDefinition</code>、 <code>GenericBeanDefinition</code>。</p><ol><li><p>ChildBeanDefinition：可以从 Parent Definition 里面继承一些公共定义（初始化方法、销毁方法、是否懒加载等等）不过</p></li><li><p>RootBeanDefinition：定义 Bean Definition 的公共属性，该定义在运行时支持Spring BeanFactory中的特定bean。 而 RootBeanDefinition 是不可以设置 parentName 指定 Parent Definition 的。</p></li><li><p>GenericBeanDefinition：是一个通用的 Bean Definition，是一站式服务，用于标准bean定义。 像任何bean定义一样，它允许指定一个类以及可选的构造函数参数值和属性值。 另外，可以通过 <code>parentName</code> 属性灵活地配置从父bean定义派生的内容。所以现在一般使用 GenericBeanDefinition。</p></li></ol><blockquote><p>从 Spring 2.5 开始，以编程方式注册 Bean Definition 的首选方法是 GenericBeanDefinition 类，该类允许通过 GenericBeanDefinition.setParentName 方法动态定义父依赖项。 </p></blockquote><p>GenericBeanDefinition 下面还有两个实现：<code>ScannedGenericBeanDefinition</code> 、<code>AnnotatedGenericBeanDefinition</code></p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/mX91iq-VpxacB.png"></p><p>二者并无太大区别，只不过 <code>AnnotatedGenericBeanDefinition</code> 比 <code>ScannedGenericBeanDefinition</code> 多了一个 <code>factoryMethodMetadata</code> 的定义。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过阅读 BeanDefinition 的源码，并对其实现类的源码进行阅读之后，大致了解 BeanDefinition 的概念及其含义。大概作图总结如下：</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/lrjeS3-Mn06Yj.png"></p><h4 id="相关推荐"><a href="#相关推荐" class="headerlink" title="相关推荐"></a>相关推荐</h4><ul><li><a href="https://mp.weixin.qq.com/s/JwRsKHqJ0ZcJ6Cgbp5BKiw">Spring 源码学习 04：初始化容器与 DefaultListableBeanFactory</a></li><li><a href="https://mp.weixin.qq.com/s/V7SjmIFKAXyppBF_KHbxXQ">Spring 源码学习 03：创建 IoC 容器的几种方式</a></li><li><a href="https://mp.weixin.qq.com/s/YPDPU7ePtii0vlrynexb_w">Spring 源码学习 02：关于 Spring IoC 和 Bean 的概念</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 源码笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 源码学习 04：初始化容器与 DefaultListableBeanFactory</title>
      <link href="2020/12/02/source-spring-04.html"/>
      <url>2020/12/02/source-spring-04.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/Sf8fRH-D6nt5n.png"></p><p>在前一篇文章：<a href="https://mp.weixin.qq.com/s/V7SjmIFKAXyppBF_KHbxXQ">创建 IoC 容器的几种方式</a>中，介绍了四种方式，这里以 <code>AnnotationConfigApplicationContext</code> 为例，跟进代码，看看 IoC 的启动流程。</p><h3 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h3><p>从 JavaConfig 中加载配置的 <code>AnnotationConfigApplicationContext</code> 启动方式如下：</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/NbaqT1-SIKlXs.png"></p><p>进去之后发现构造其实是调用的当前无参构造。</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/dA7SqR-pnWaJ0.png"></p><p>所以在启动时也可以直接声明无参构造，改写为下面这种：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationConfigApplicationTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line"></span><br><span class="line">context.register(JavaConfig.class);</span><br><span class="line">context.refresh();</span><br><span class="line"></span><br><span class="line">System.out.println(context.getBean(UserComponent.class));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>今天就研究研究无参构造这一部分究竟做了什么逻辑！</p><h4 id="无参构造"><a href="#无参构造" class="headerlink" title="无参构造"></a>无参构造</h4><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/VfQDRi-qtFJay.png"></p><p>其中的 <code>StartupStep</code> 是 5.3 新增的类，看代码注释的意思是：表示用来记录启动过程中的一些指标信息等。暂时不做研究。</p><p>主要研究红框部分！注意，<strong>这一块并不代表只有红框部分</strong>！</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/jHZiO9-lClEgy.png"></p><p>因为 <code>AnnotationConfigApplicationContext</code> 继承了 <code>GenericApplicationContext</code>，所以会先执行父类的构造方法。</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/T9dF4r-BeA6nA.png"></p><p>所以这里会创建一个 <code>DefaultListableBeanFactory</code> 的容器。</p><h3 id="DefaultListableBeanFactory"><a href="#DefaultListableBeanFactory" class="headerlink" title="DefaultListableBeanFactory"></a>DefaultListableBeanFactory</h3><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/DefaultListableBeanFactory-oBHX69.png" alt="DefaultListableBeanFactory UML"></p><p>虽然说 Spring 的 <code>BeanFactory</code> 定义了容器的基础概念、接口方法等，但是 <code>DefaultListableBeanFactory</code> 才是一个真正可以 new 出来的具体的容器，当然也可以暂且称之为 bean 工厂。</p><p>下面来看一下 <code>DefaultListableBeanFactory</code> 里面都有什么？</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/oUgw6b-dgE9ZX.png"></p><p>在 <code>DefaultListableBeanFactory</code> 里面会初始化很多参数，其中重点关注的是下面两个参数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Map of bean definition objects, keyed by bean name. */</span></span><br><span class="line"><span class="comment">// BeanDefinition 的存储 Map 其中 key 为 beanName</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** List of bean definition names, in registration order. */</span></span><br><span class="line"><span class="comment">// BeanName 的集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> List&lt;String&gt; beanDefinitionNames = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">256</span>);</span><br></pre></td></tr></table></figure><p>其中 <code>BeanDefinition</code> 描述了一个 bean 实例，该实例具有属性值，构造函数参数值以及具体实现所提供的更多信息。</p><p>对应的 <code>beanDefinitionMap</code> 就是存储的初始化的 beanName 和 BeanDefinition。</p><p>至于 BeanDefinition 具体内容，下一节再做介绍。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过上面的阅读，可以在初始化流程中增加一部分模块，即实例化 <code>DefaultListableBeanFactory</code></p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/m4P5ZW-VrZwt7.png"></p><p>再回顾一下 <code>DefaultListableBeanFactory</code> 的概念。</p><blockquote><p><strong>DefaultListableBeanFactory：</strong></p><p>Spring 的 ConfigurableListableBeanFactory 和 BeanDefinitionRegistry 接口的默认实现：基于bean定义元数据的成熟bean工厂，可通过后处理器进行扩展。<br>重点需要把握的是 DefaultListableBeanFactory 内部定义了 BeanDefinition 的 Map。</p></blockquote><h4 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h4><p>本文从入口开始，进入到构造，主要介绍了 <code>DefaultListableBeanFactory</code> 的创建，及创建时初始化了一堆参数。</p><p>考虑到文章篇幅问题，尽量避免大段大段的贴代码以及注释，有兴趣的小伙伴可以试着自己搭建源码构建环境，然后 Debug 走一走，这样也可以互相探讨，共同学习。</p><p>笔者也是刚开始阅读学习源码，不足之处，希望多多指正。</p><h4 id="相关推荐"><a href="#相关推荐" class="headerlink" title="相关推荐"></a>相关推荐</h4><ul><li><a href="https://mp.weixin.qq.com/s/V7SjmIFKAXyppBF_KHbxXQ">Spring 源码学习 03：创建 IoC 容器的几种方式</a></li><li><a href="https://mp.weixin.qq.com/s/YPDPU7ePtii0vlrynexb_w">Spring 源码学习 02：关于 Spring IoC 和 Bean 的概念</a></li><li><a href="https://mp.weixin.qq.com/s/gDhJMSPSX2vz68p5X3juow">Spring 源码学习 01：源码阅读环境的搭建</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 源码笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 源码学习 03：创建 IoC 容器的几种方式</title>
      <link href="2020/12/01/source-spring-03.html"/>
      <url>2020/12/01/source-spring-03.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/1cc7GX-1iJNvm.png" alt="创建容器"></p><p>在上一篇文章末尾画了一幅简图，现在从简图这入手，先来看看如何创建容器！</p><h3 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h3><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/GenericGroovyApplicationContext-6dwIrF.png"></p><p>在搭建 <a href="https://mp.weixin.qq.com/s/gDhJMSPSX2vz68p5X3juow">Spring 源码阅读环境</a> 时，最后举了一个例子，其实就是创建容器，并从容器中获取 Bean ，来测试环境是否 OK。</p><p>根据元数据的不同，创建容器的方式也不同，下面参考官方文档，简单介绍下创建容器的几种方式：</p><h4 id="Java-配置获取元数据"><a href="#Java-配置获取元数据" class="headerlink" title="Java 配置获取元数据"></a>Java 配置获取元数据</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationConfigApplicationTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line"></span><br><span class="line">context.register(JavaConfig.class);</span><br><span class="line">context.refresh();</span><br><span class="line"></span><br><span class="line">System.out.println(context.getBean(UserComponent.class));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Xml-获取元数据"><a href="#Xml-获取元数据" class="headerlink" title="Xml 获取元数据"></a>Xml 获取元数据</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlConfigApplicationTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;SpringConfig.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(context.getBean(<span class="string">&quot;bookService&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Groovy-获取元数据"><a href="#Groovy-获取元数据" class="headerlink" title="Groovy 获取元数据"></a>Groovy 获取元数据</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroovyConfigApplicationTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">GenericGroovyApplicationContext context = <span class="keyword">new</span> GenericGroovyApplicationContext(<span class="string">&quot;SpringConfig.groovy&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(context.getBean(NotesServiceImpl.class));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="GenericApplicationContext"><a href="#GenericApplicationContext" class="headerlink" title="GenericApplicationContext"></a>GenericApplicationContext</h4><p>也可以直接创建 <code>GenericApplicationContext</code> 然后在加载元数据配置文件。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericApplicationTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">GenericApplicationContext context = <span class="keyword">new</span> GenericApplicationContext();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> XmlBeanDefinitionReader(context).loadBeanDefinitions(<span class="string">&quot;SpringConfig.xml&quot;</span>);</span><br><span class="line"><span class="keyword">new</span> GroovyBeanDefinitionReader(context).loadBeanDefinitions(<span class="string">&quot;SpringConfig.groovy&quot;</span>);</span><br><span class="line"></span><br><span class="line">context.refresh();</span><br><span class="line"></span><br><span class="line">System.out.println(context.getBean(<span class="string">&quot;bookService&quot;</span>));</span><br><span class="line">System.out.println(context.getBean(NotesServiceImpl.class));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/spring03-FyUebg.jpeg"></p><p>本文主要介绍了常用的几种容器的创建，配置文件部分就没有在文章中体现了，如果想了解这部分，可以参考官方文档。</p><h3 id="相关推荐"><a href="#相关推荐" class="headerlink" title="相关推荐"></a>相关推荐</h3><ul><li><a href="https://mp.weixin.qq.com/s/gDhJMSPSX2vz68p5X3juow">Spring 源码学习 01：源码阅读环境的搭建</a></li><li><a href="https://mp.weixin.qq.com/s/YPDPU7ePtii0vlrynexb_w">Spring 源码学习 02：关于 Spring IoC 和 Bean 的概念</a></li><li><a href="https://mp.weixin.qq.com/s/BORxKatt9qs4rDgmAHbv_A">Spring 自调用事务失效，你是怎么解决的？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 源码笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 源码学习 02：关于 Spring IoC 和 Bean 的概念</title>
      <link href="2020/11/30/source-spring-02.html"/>
      <url>2020/11/30/source-spring-02.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在前一篇文章中介绍了如何构建源码阅读环境，既然构建好了源码环境，本地也可以正常运行，那就开始阅读源码吧！</p><p>在阅读源码时，会参考<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#spring-core">官方文档</a>，很多概念在官网都可以得到答案，有兴趣的小伙伴们可以继续阅读，当做复习，写的不足之处，希望多多指导。</p><h3 id="IoC-和-DI"><a href="#IoC-和-DI" class="headerlink" title="IoC 和 DI"></a>IoC 和 DI</h3><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/Cp1dfI-Yg6zuJ.png" alt="IoC 概念"></p><h4 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h4><p>IoC（Inversion of Control），即控制反转。</p><p>之前是在对象内部 new 创建其他对象，然后使用。</p><p>而现在 Spring 中有一个容器可以在创建管理这些对象，并且将对象依赖的其他对象注入到这个对象中，这些对象的创建、销毁都由 Spring 进行管理。</p><p>相比以前来说，不再由自己控制其他对象的生命周期，这个过程就叫做控制反转。而负责统一管理这些类的容器就叫做 IoC 容器。</p><h4 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h4><p><code>IoC is also known as dependency injection (DI).</code> </p><p>是不是感觉奇奇怪怪的，为什么说：<code>IoC 也称为 DI</code>。</p><p>其实 IoC 和 DI 是同一个概念的不同角度描述。</p><p>依赖注入是指组件之间的依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。</p><p>通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。</p><p>Spring 是通过 DI 实现 IoC 的。</p><h3 id="容器和-Bean"><a href="#容器和-Bean" class="headerlink" title="容器和 Bean"></a>容器和 Bean</h3><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/4xZKqx-3YpFD2.png" alt="Spring IoC container and Bean"></p><p><code>Bean 是一个由 Spring IoC 容器实例化，组装和管理的对象。</code></p><p>相信大家都写过或者见过下面的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从容器中获取对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuzhihang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/6 19:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomBeanFactory</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext ctx;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext ac)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ctx = ac;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getBean</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ctx.getBean(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码逻辑很简单，就是从容器中获取到指定名称的 <code>Bean</code>，而其中 <code>ApplicationContext</code> 接口其实就是 Spring IoC 容器。</p><p>当然 <code>ApplicationContext</code> 是一个接口，它有很多实现，而它也继承了 <code>BeanFactory</code>。</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/4PQoiE-WQT8uR.png" alt="BeanFactory or ApplicationContext"></p><p>虽然 <code>BeanFactory</code> 是 IoC 容器的最基本的形式，但是 <code>ApplicationContext</code> 对其进行了很多扩展，并具有 <code>BeanFactory</code> 的所有功能，通常建议优先使用 <code>ApplicationContext</code>。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在通过<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#spring-core">Spring 官网</a> 了解了 IoC 、DI 、容器和 Bean 的概念后，再结合平常的使用基本上可以有个大概流程。</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/0hWvfR-K15LRP.png" alt="流程猜想"></p><p>当然，这只是一个很粗略的猜想，是否正确，还有待后面继续阅读源码，然后去验证。</p><h3 id="相关推荐"><a href="#相关推荐" class="headerlink" title="相关推荐"></a>相关推荐</h3><ul><li><a href="https://mp.weixin.qq.com/s/gDhJMSPSX2vz68p5X3juow">Spring 源码学习 01：源码阅读环境的搭建</a></li><li><a href="https://mp.weixin.qq.com/s/BORxKatt9qs4rDgmAHbv_A">Spring 自调用事务失效，你是怎么解决的？</a></li><li><a href="https://mp.weixin.qq.com/s/ZJB-2WWeJFG7RQxaksNBuA">APP 莫名崩溃，开始以为是 Header 中 name 大小写的锅，最后发现原来是容器的错</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 源码笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 源码学习 01：源码阅读环境的搭建</title>
      <link href="2020/11/26/source-spring-build.html"/>
      <url>2020/11/26/source-spring-build.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>前言</strong></p><p>本文记录了 Spring 源码环境的搭建方式，以及踩过的那些坑！​ 当前版本：5.3.2-SNAPSHOT。</p></blockquote><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ol><li>Git</li><li>JDK<ol><li>master 分支需要 JDK 11</li><li>5.2.x 分支， JDK8 即可</li></ol></li><li>Gradle 6.5.1</li><li>IDEA 最新 （2020.2.3）</li></ol><p>Spring 源码仓库地址：<a href="https://github.com/spring-projects/spring-framework">https://github.com/spring-projects/spring-framework</a></p><h3 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h3><ol><li>clone 源码</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span>  https://github.com/spring-projects/spring-framework.git</span><br></pre></td></tr></table></figure><ol start="2"><li><p>使用 IDEA 打开</p><ol><li><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/nN2jwC-B9crax.png"></li><li><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/SmFKEX-Rikm9z.png"></li><li>等待 IDEA 加载完成即可。</li></ol></li></ol><p>注： 也可以指定 clone 的分支</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b 5.2.x  https://github.com/spring-projects/spring-framework.git</span><br></pre></td></tr></table></figure><p>或者先 fork 到自己的仓库，然后再 clone。</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/larIO8-qFY4Fo.png"></p><p>这里我是 fork 到我的仓库，然后再 clone 的。</p><p>当前 master 分支代表的版本为 5.3.2-SNAPSHOT。</p><h3 id="执行测试"><a href="#执行测试" class="headerlink" title="执行测试"></a>执行测试</h3><ul><li>在项目右键创建 <code>module</code></li></ul><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/qkYNup-hSgF5s.png"></p><ul><li>选择 <code>Gradle</code> <code>Java</code></li></ul><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/v9YDiM-0D64W2.png"></p><ul><li>创建 module</li></ul><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/iYepMg-WRomfs.png"></p><ul><li>在 build.gradle 中添加配置</li></ul><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">compile(project(&quot;:spring-context&quot;))</span><br></pre></td></tr></table></figure><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/SUhEs6-2JKywY.png"></p><ul><li>创建测试类并测试</li></ul><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/O55vLL-XSueLY.png"></p><p>其中 <code>UserComponent</code> 添加了 <code>@Component</code> 注解， 程序正常执行则一切 OK。可以开始愉快的调试代码了。</p><h3 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h3><h4 id="编译失败"><a href="#编译失败" class="headerlink" title="编译失败"></a>编译失败</h4><p>有小伙伴直接下载 zip 包，可能遇到以下问题：(非常不建议直接下载 zip 包构建，想知道原因可以继续看，最后我也没有构建成功，而是直接通过 clone 构建的。)</p><ol><li>报错如下：</li></ol><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">fatal: not a git repository (or any of the parent directories): .git</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL in 14s</span><br><span class="line">Build scan background action failed.</span><br><span class="line">org.gradle.process.internal.ExecException: Process &#x27;command &#x27;git&#x27;&#x27; finished with non-zero exit value 128</span><br><span class="line">    ... 其他省略</span><br></pre></td></tr></table></figure><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/4mqrY9-o9NJO6.png"></p><p>看意思是没有 git 配置，那就添加上吧！</p><ol start="2"><li>这时候想着添加 git</li></ol><p><code>VCS</code> -&gt; <code>Enable Version Control Integration...</code> -&gt; 右上角 <code>Reload All Gradle Projects</code></p><p>依然报错</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">fatal: Needed a single revision</span><br></pre></td></tr></table></figure><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/zLWbqb-rkJFw4.png"></p><ol start="3"><li>查询问题</li></ol><p>issues 地址：<a href="https://github.com/spring-projects/spring-framework/issues/24467">https://github.com/spring-projects/spring-framework/issues/24467</a></p><p>建议使用</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@github.com:spring-projects/spring-framework.git</span><br></pre></td></tr></table></figure><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/siVXre-hle4kw.png"></p><p>意思就是 zip 发行版主要是用来共享源代码，但不一定用于构建它。</p><ol start="4"><li>最后我选择了使用 clone 的方式，直接 clone 下来，然后 build 通过。</li></ol><h4 id="缺少-cglib-和-objenesis-包"><a href="#缺少-cglib-和-objenesis-包" class="headerlink" title="缺少 cglib 和 objenesis 包"></a>缺少 cglib 和 objenesis 包</h4><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Kotlin: warnings found and -Weeror specified</span><br></pre></td></tr></table></figure><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/Xnip-2020-11-24-06-DhRwoS.png"></p><p>没有 <code>spring-cglib-repack</code> 和 <code>spring-objenesis-repack</code> 包</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/2fNVjI-71xWmS.png"></p><p>执行这两个即可。</p><h4 id="找不到包-jdk-jfr"><a href="#找不到包-jdk-jfr" class="headerlink" title="找不到包 jdk.jfr"></a>找不到包 jdk.jfr</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jdk.jfr.Category;</span><br><span class="line"><span class="keyword">import</span> jdk.jfr.Description;</span><br><span class="line"><span class="keyword">import</span> jdk.jfr.Event;</span><br><span class="line"><span class="keyword">import</span> jdk.jfr.Label;</span><br></pre></td></tr></table></figure><p>JDK 升级为 11。因为我本地使用的是 JDK8，发现报错，jfr 包需要升级 JDK 11 才有。</p><p>如果不生效，可以通过：</p><p>IDEA -&gt; <code>File</code> -&gt; <code>Project Structure</code> -&gt; <code>Project</code> 检查下是否修改为 JDK 11</p><p>快捷键：<code>⌘ + ;</code></p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/ost9dI-pTohuz.png"></p><h4 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h4><ol><li>Spring 仓库：<a href="https://github.com/spring-projects/spring-framework">https://github.com/spring-projects/spring-framework</a></li><li>Spring 构建文档：<a href="https://github.com/spring-projects/spring-framework/wiki/Build-from-Source">https://github.com/spring-projects/spring-framework/wiki/Build-from-Source</a></li></ol><h4 id="历史文章"><a href="#历史文章" class="headerlink" title="历史文章"></a>历史文章</h4><ul><li><a href="https://mp.weixin.qq.com/s/_z4KaFip3qz2fynviMYiRQ">ReentrantLock 源码、画图一起看一看！</a></li><li><a href="https://mp.weixin.qq.com/s/yIzAe3kb0HCphzm1Evv-Tw">ReentrantReadWriteLock 的原理！</a></li><li><a href="https://mp.weixin.qq.com/s/BORxKatt9qs4rDgmAHbv_A">Spring 自调用事务失效，你是怎么解决的？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 源码笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【工具册】- DocView 现在支持自定义 Markdown 模版了！</title>
      <link href="2020/11/23/doc-view-template.html"/>
      <url>2020/11/23/doc-view-template.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>前言</strong></p><p>有小伙伴反馈说希望可以自定义 Markdown 模版，这样就可以导出自己想要的样式了！这个功能可以有，毕竟大家不可能都生成一模一样的文档。现在来一起看看如何实现自定义模版吧！</p></blockquote><h4 id="设置模版"><a href="#设置模版" class="headerlink" title="设置模版"></a>设置模版</h4><p><code>Settings</code> -&gt; <code>Other Settings</code> -&gt; <code>Doc View</code> -&gt; <code>Markdown Template</code></p><p>打开之后内容如下：</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/Xnip-2020-11-23-59-asNWSp.png" alt="Xnip-2020-11-23-59-asNWSp"></p><p>模版这里分两个 <code>Tab</code> 分别是 <code>Spring</code> 、 <code>Dubbo</code> 。</p><p>这两个模版内容就稍微有些区别，如果自定义模版，直接修改保存即可。</p><h4 id="模版变量"><a href="#模版变量" class="headerlink" title="模版变量"></a>模版变量</h4><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/d3VlSJ-Hxz8Tj.png"></p><p>关于模版变量，这里使用的是 <code>velocity</code> 将变量替换为文本，如果有其他方式，或者说是 <code>IDEA</code> 用的那种方式，希望可以告诉我。最好可以提供源码。 </p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>非常感谢 <a href="https://github.com/lvgocc">lvgo</a> 小伙伴的参与。</p><p>如果小伙伴们在使用过程中发现一些 bug 或者有好的意见建议，可以在 GitHub 提交 Issues 留言指出来。</p><p>Doc View GitHub：<a href="https://github.com/liuzhihang/doc-view">https://github.com/liuzhihang/doc-view</a></p><p>最后，记得要 <code>一键三连</code>， 来个 <code>【分享、点赞、在看】</code>！</p><h4 id="推荐文章"><a href="#推荐文章" class="headerlink" title="推荐文章"></a>推荐文章</h4><ul><li><a href="https://mp.weixin.qq.com/s/rOTm9Kv02xLZZVFzQXf7IA">Dubbo 生成文档，导出 Markdown，这些功能 DocView 现在都有了！</a></li><li><a href="https://mp.weixin.qq.com/s/VgOHLQ_f4E8UlV9sQhyFpQ">头大！写文档太麻烦了！快来试试这款 IDEA 插件啊！爽到飞起~</a></li><li><a href="https://mp.weixin.qq.com/s/G8h5lg-d8SHZ2_ILBE04sQ">小伙伴想写个 IDEA 插件么？这些 API 了解一下！</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具册 </category>
          
          <category> Doc View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具册 </tag>
            
            <tag> Doc View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【工具册】- Dubbo 接口，导出 Markdown ，这些功能 DocView 现在都有了！</title>
      <link href="2020/11/19/doc-view-dubbo.html"/>
      <url>2020/11/19/doc-view-dubbo.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>前言</strong></p><br><p>自从 DocView 发布了简陋的第一版之后，就不断地有小伙伴提建议意见等等，希望扩展各种功能。这不，时隔两周，DocView 又发布了新版本，本次的更新主要涉及到支持 Dubbo，以及支持导出单个文档为 Markdown 文件。来一起看看新功能吧！</p></blockquote><h4 id="支持导出-Markdown-文件"><a href="#支持导出-Markdown-文件" class="headerlink" title="支持导出 Markdown 文件"></a>支持导出 Markdown 文件</h4><p>DocView 原版本已经支持复制到剪贴板的功能。</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/uRAtpo-AJ2kyV.png" alt="原版本"></p><p>而在新版本中增加了 <code>Export</code> 按钮，可以将单个文档导出为 Markdown 文件。</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/KLmzHE-Sxlxc6.png" alt="新版本"></p><p>来一张动图，大家看看效果：</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/1111-l7NaTW.gif" alt="1111-l7NaTW"></p><p>导出的 Markdown 文本内容如下：</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/DJCp6X-saP6nE.png" alt="DJCp6X-saP6nE"></p><h4 id="支持-Dubbo-接口"><a href="#支持-Dubbo-接口" class="headerlink" title="支持 Dubbo 接口"></a>支持 Dubbo 接口</h4><p>之前的版本是不支持 Dubbo 接口的，而现在的版本可以在 Dubbo 接口里面使用。</p><p>当然这里并没有校验接口是否为 Dubbo 接口，只是校验了下是否为接口。所以说即使其他接口也是可以生成的。</p><p><strong>这块还是需要完善的!</strong></p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/S8M4fB-3ecWbP.png" alt="S8M4fB-3ecWbP"></p><h4 id="DocView-文档地址"><a href="#DocView-文档地址" class="headerlink" title="DocView 文档地址"></a>DocView 文档地址</h4><p>在面板左下角的 <code>help</code> 按钮修改了跳转地址为：<a href="http://docview.liuzhihang.com/">http://docview.liuzhihang.com/</a></p><p>只是粗略搭建了一个 DocView 的说明文档网站，小伙伴们可以发现这个网站连 logo 都没有。</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/IQNatL-uWWCqO.png" alt="IQNatL-uWWCqO"></p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>当然也有一些其他的小改动，比如设置页面（依然不支持自定义设置）。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/MJjOX4-pRQhfK.png" alt="MJjOX4-pRQhfK"></p><p>DocView 虽然支持了一部分功能，但是距离小伙伴们期望中的文档插件还有很多很多需要迭代的功能。</p><p>比如：</p><ul><li>批量生成（当前仅支持单个类或者方法）</li><li>批量导出</li><li>面板支持查看 Markdown 源文本</li><li>支持从 Swagger 注解获取字段相关信息</li><li>支持 Setting 设置</li><li>支持自定义模版</li><li>支持上传的 YApi</li><li>支持导出其他类型</li><li>…</li></ul><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/cx5PxU-gVxBmM.jpg" alt="cx5PxU-gVxBmM"></p><p>嗯~ 可能大概也许应该会需要迭代很久……</p><p>也确实是个人能力和精力有限，如果小伙伴们有兴趣，可以提交 PR。</p><p>当然如果小伙伴们发现一些 bug 或者有好的意见建议，也可以留言指出来。</p><p>留言推荐大家在 GitHub 提 Issues。</p><p>最后如果小伙伴们觉得插件不错，可以推荐给周围的朋友同事，也记得 <code>一键三连</code>， 来个 <code>【分享、点赞、再看】</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 工具册 </category>
          
          <category> Doc View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具册 </tag>
            
            <tag> Doc View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Warning: Calling `brew list` to only list formulae is deprecated! Use `brew list --formula` instead.</title>
      <link href="2020/11/15/brew-list-warning.html"/>
      <url>2020/11/15/brew-list-warning.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>最近终端总是弹出这么一句话，咱也不懂怎么解决。</p><p>Google baidu 也查不到问题。</p><p>小伙伴帮忙看一下。</p><p>每次新打开终端都会有这个 Warning 。</p><pre><code>Warning: Calling `brew list` to only list formulae is deprecated! Use `brew list --formula` instead.</code></pre><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/5eDhZb-ptj6gr.png" alt="5eDhZb-ptj6gr"></p><p>最后被逼无奈，在 V 站 发帖求助小伙伴， 结果还真找到了答案</p><h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/HvJSlT-Q0oUVr.png" alt="HvJSlT-Q0oUVr"></p><p>最后找到问题所在，是因为按照网上的教程安装的 <code>Coreutils</code></p><p><code>~/.zshrc </code>里改一下即可。</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/hAFz8B-HWsVNg.png" alt="hAFz8B-HWsVNg"></p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>写到这里，很多小伙伴应该已经知道问题所在了，可能有的小伙伴还不知道怎么解决：</p><ol><li><code>vim ~/.zshrc</code></li><li>找到使用 <code>brew list</code> 的地方</li><li>将 <code>brew list</code> 改为 <code>brew list --formula</code></li></ol><p>如果还不知道怎么弄，那可以用编辑工具打开<code> .zshrc</code> 文件，然后搜索找到 <code>brew list</code> ，然后替换。</p>]]></content>
      
      
      <categories>
          
          <category> issue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> issue </tag>
            
            <tag> mac </tag>
            
            <tag> brew </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【工作笔记】- Spring 自调用事务失效，你是怎么解决的？</title>
      <link href="2020/11/08/spring-self-call.html"/>
      <url>2020/11/08/spring-self-call.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>前言</strong></p><br><p>相信大家都遇到一种事务失效场景，那就是 Spring 自调用，就是在 Service 方法内，调用另一个加 <code>@Transactional</code> 注解的方法，发现事务失效，这时候你是怎么解决的呢？</p></blockquote><h3 id="事情回顾"><a href="#事情回顾" class="headerlink" title="事情回顾"></a>事情回顾</h3><p>那是一个我忘了天气咋样的下午，突然蹦出一个小红点，嗯~ 挺着急的小红点。</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/3E8q0W-3Cg65u.png" alt="3E8q0W-3Cg65u"></p><p>原来是事务失效了！</p><p>莫慌！莫慌！</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/kRoqUW-MKbcBj.png" alt="kRoqUW-MKbcBj"></p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/KVdtlZ-F3jW3p.png" alt="KVdtlZ-F3jW3p"></p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/T4poZK-qyiLEV.png" alt="T4poZK-qyiLEV"></p><p>最后小伙伴选择了抽走，是我的工具类不香了么？</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/zVf6LC-tLzseS.png" alt="zVf6LC-tLzseS"></p><p>当然故事的结果是完美的，问题解决了。</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/v3W8tg-VJEgZS.jpg" alt="v3W8tg-VJEgZS"></p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>在开发中涉及到同时操作多个表的时候，要保证两个操作要么一起成功，要么一起失败，这时候就需要用到事务。</p><p>现在一般使用的都是基于 <code>@Transactional</code> 注解的<strong>声明式事务</strong>。</p><p>而事务使用过程中有以下几个注意事项：</p><ol><li>事务只能应用到 public 方法上才会有效；</li><li>事务需要从外部调用，Spring 自调用会失效；</li><li>建议事务注解 @Transactional 一般添加在实现类上。</li></ol><p>当然这几句话不是说我的，人家官方文档可是明确说明的！</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/IlNXVn-uemNYF.png" alt="IlNXVn-uemNYF"></p><p>这里可是说明了<code>应仅将 @Transactional 注解应用于具有公开可见性的方法。如果对受 protected, private o或 package-visible 修饰的方法使用，则不会引发任何错误，但是被注解的方法不会显示已配置的事务设置。</code></p><p>说白了，就是你用了，不会报错，但是不生效！</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/M5XTck-YnrPiu.png" alt="M5XTck-YnrPiu"></p><p>至于建议加在实现类上，这个只是建议，不过如果加在接口类或接口方法上时，只有配置基于接口的代理才会生效。所以这块还是老老实实的<code>加在实现类或实现类方法上</code>吧。</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/P28Ciu-4YvetS.png" alt="P28Ciu-4YvetS"></p><p>因为代理模式只拦截通过代理传入的外部方法调用，所以自调用事务是不生效的。</p><p>官方的解释还是比较简单明了的，虽然我看不懂，但是不影响我截图。</p><p>那我还是再截一个吧……</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/sBkeIz-80K1UE.png" alt="sBkeIz-80K1UE"></p><h3 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h3><p>但是在开发中，小伙伴们往往会遇到这种情况！</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/g1BG6s-BgQfOw.png" alt="g1BG6s-BgQfOw"></p><p>本来<strong>自己写的</strong>代码就一坨坨的又臭又长，里面有各种验签、验参、查询、验证等等，就想着来个事务，让事务包裹的范围最小，仅仅在同时更新的时候加上事务吧！</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/38SYyX-gEXV58.png" alt="38SYyX-gEXV58"></p><p>这么写，咦~ IDEA 报错了，好像不能 <code>private</code> 修饰，那我改成 <code>public</code>。</p><p>很显然事务是不生效的。</p><p>把更新的代码放到<code>又臭又长</code>的代码里面，让它变得更臭更长，然后用 <code>@Transactional</code> 注解一加。完美解决！</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/9r8ioC-W6kSbv.jpg" alt="9r8ioC-W6kSbv"></p><p>请放过那坨代码吧！来看看下面的办法。</p><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案 1"></a>解决方案 1</h4><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/08fPAy-ee1X6A.png" alt="08fPAy-ee1X6A"></p><p>那我改成外部调用不就行了么？</p><p>再声明一个 Service，把更新表的逻辑放过去。</p><p>我一般就喜欢使用这个办法。</p><h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案 2"></a>解决方案 2</h4><p>使用<code>编程式事务</code>，前面说了，使用<code>声明式事务</code>时，又这又那，我换一种总可以吧！</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/yuJKad-LGJuVt.png" alt="yuJKad-LGJuVt"></p><p>你看，我还把方法改成 <code>private</code> 修饰了，事务也生效。完美解决！</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/8orQs4-tgtQts.jpg" alt="8orQs4-tgtQts"></p><p>其实这个方法也很不错哦！</p><h4 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案 3"></a>解决方案 3</h4><p>又想用注解，又想自调用怎么办？</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/MBSeHo-E5RDuC.jpg" alt="MBSeHo-E5RDuC"></p><p>不过… 麻烦一点还是可以的。</p><p>咱们可以参考<code>编程式事务</code>的方式，不就是不让自调用么，我调外部方法，然后外部方法再给我调回来不就可以了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionalComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cell</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED, rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">required</span><span class="params">(Cell cell)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        cell.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话不就可以通过 <code>TransactionalComponent</code> 调用了么，并且还可以使用 <code>lambda</code> 表达式。</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/y5bnw5-TMtjKN.png" alt="y5bnw5-TMtjKN"></p><p>当然基于这个版本也可以做一个迭代，就是使用静态方法调用，不用每次都用 <code>@Autowired</code> 注入一次。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionalUtils</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> TransactionalComponent transactionalComponent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> TransactionalComponent <span class="title">getTransactionalComponent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (transactionalComponent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 从容器中获取 transactionalComponent</span></span><br><span class="line">            transactionalComponent = ApplicationContextUtils.getBean(TransactionalComponent.class);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> transactionalComponent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">required</span><span class="params">(TransactionalComponent.Cell cell)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        getTransactionalComponent().required(cell);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/awzH4i-JjJNp4.png" alt="awzH4i-JjJNp4"></p><p>这样通过工具类 <code>TransactionalUtils</code> 便可以直接调用静态方法的方式执行事务操作。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h4><p>本文主要介绍为什么会遇到事务失效，以及事务失效的避免方式，同时提供了三种方式来解决自调用事务失效的问题。不足之处，欢迎指正。</p><h4 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h4><ol><li>Spring 文档：<a href="https://docs.spring.io/spring-framework/docs/5.3.0/reference/html/data-access.html#transaction-declarative-annotations">https://docs.spring.io/spring-framework/docs/5.3.0/reference/html/data-access.html#transaction-declarative-annotations</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【工具册】- 写文档太麻烦，试试这款 IDEA 插件吧！</title>
      <link href="2020/11/01/doc-view.html"/>
      <url>2020/11/01/doc-view.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>前言</strong></p><br><p>每次开发完新项目或者新接口功能等，第一件事就是提供接口文档。说到接口文档，当然是用 Markdown 了。各种复制粘贴字段，必填非必填，字段备注，请求返回示例等等。简直是浪费时间哇。所以想到了开发一款插件来解决重复复制文档的问题。下面来看我介绍介绍这款插件。</p><p>PS：插件比较简陋，还需要不断迭代。</p></blockquote><h2 id="为什么开发插件"><a href="#为什么开发插件" class="headerlink" title="为什么开发插件"></a>为什么开发插件</h2><p>每次在对外提供接口时都要写文档，各种麻烦，并且文档耗费了很大一部分时间。也使用了一些文档工具，在线写作工具，最终还是比较喜欢自己手写文档。</p><h3 id="使用过的生成工具"><a href="#使用过的生成工具" class="headerlink" title="使用过的生成工具"></a>使用过的生成工具</h3><ol><li>Swagger ： 添加依赖，配置类及描述信息，然后在方法及实体上添加注解，启动项目便可以通过访问 <code>xxxx/swagger-ui.html</code> 查看接口文档；</li><li>API Doc ：添加配置文件及注释，安装 <code>npm</code> 并通过执行命令生成文档；</li><li>SmartDoc ：添加依赖及注释后执行测试类生成文档；</li><li>API2DOC ：添加依赖，开启注解，通过注解配置生成文档。</li></ol><p>上面四种方法，无疑都需要添加依赖，使用注解等方式，可以说有一定的代码侵入性。</p><h3 id="使用过的接口文档工具"><a href="#使用过的接口文档工具" class="headerlink" title="使用过的接口文档工具"></a>使用过的接口文档工具</h3><ol><li>ShowDoc ：曾经一段时间很喜欢用这个， Markdown 语法，方便直观。不过就是要自己手写；</li><li>YApi ：现在在使用 YApi，可以通过 Swagger 导入；</li><li>VS Code 写 Markdown ：直接离线写 Markdown ，可以导出 PDF、Word、Html。</li></ol><p>自己写文档比较重复，繁琐，不过个人比较喜欢 Markdown 格式。简洁直观。并且配合着我之前写的 IDEA 插件 <code>copy-as-json</code> 和 <code>Tookit</code> 将实体复制为 json 字符串，用来快速生成请求样例和返回样例，还是可以减少一定的工作量的。</p><h3 id="其他使用方式"><a href="#其他使用方式" class="headerlink" title="其他使用方式"></a>其他使用方式</h3><p>使用各种在线协作工具，腾讯文档、语雀、石墨文档。使用离线版本 PDF、Word、Excel 等等。也有一些其他的文档工具，不过自己都没有使用过或者调研过了。</p><p>基本上这些文档工具要么通过代码侵入的方式生成文档，要么自己手撸文档。总体来说各有千秋。</p><h3 id="个人手写更方便"><a href="#个人手写更方便" class="headerlink" title="个人手写更方便"></a>个人手写更方便</h3><p><strong>个人比较喜欢的就是手写 Markdown 。</strong></p><p>下面是两幅图：</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/fWC7q0-bt3RuN.png" alt="ShowDoc 官方样例"></p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/Yh68js-evYsQS.png" alt="VS Code 手写文档"></p><p>有时候文档比较多的时候，就写的累了。尤其是最近使用了 <code>YApi</code> ， 个人感觉使用 <code>Swagger</code> 然后导入到 <code>YApi</code> 里面还是挺方便的，省时省力。</p><p>后来就想，既然 <code>YApi</code> 提供接口，那我是不是可以自己生成，然后传到 <code>YApi</code> 中呢？</p><p>所以就开始着手这个插件的开发。</p><h2 id="使用及功能"><a href="#使用及功能" class="headerlink" title="使用及功能"></a>使用及功能</h2><p>既然已经开发好最基础版本了，当然也得介绍下，首先看图：</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/B9FzFw-9M24Py.png" alt="Doc View 样例"></p><p>通过图简单介绍下使用以及功能：</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>使用方式很简单，直接在 <code>Controller</code> 类或者 <code>Controller</code> 类的公共非静态方法内右键唤出菜单，单机 <code>Doc View</code> 即可。</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/Gq0gn6-XnAfto.png"></p><p>只能在 <code>Controller</code> 类或者 <code>Controller</code> 类的公共非静态方法内使用。至于两者的区别，后续会介绍。</p><p>这里可能会有小伙伴们发出疑问：Dubbo 接口也要写文档，难道不可以么？</p><p>嗯~ 可以！但是现在不支持~</p><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>基本功能就是截图展示的那样。</p><ol><li>左侧显示接口名及列表，右侧展示接口信息；</li><li>点击 <code>Copy 按钮</code> 就会将展示的信息原本对应的 Markdown 文本复制到剪贴板；</li><li>在 Class 内部点击，生成的如图所示的列表，而在方法内右键生成的是只有本方法的。</li></ol><h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><p>Dubbo 接口，当前版本不支持，所以下面介绍的全都是在 Class 上的使用：</p><h4 id="要生成文档，需要满足什么条件？"><a href="#要生成文档，需要满足什么条件？" class="headerlink" title="要生成文档，需要满足什么条件？"></a>要生成文档，需要满足什么条件？</h4><ol><li>目标类内部有方法；</li><li>类必须有相关 <code>Spring</code> 注解。<ol><li><code>org.springframework.stereotype.Controller</code> </li><li><code>org.springframework.web.bind.annotation.RestController</code></li></ol></li></ol><h4 id="生成文档，接口方法需要满足什么条件？"><a href="#生成文档，接口方法需要满足什么条件？" class="headerlink" title="生成文档，接口方法需要满足什么条件？"></a>生成文档，接口方法需要满足什么条件？</h4><p>文档的方法：<code>Public</code> 修饰且非静态方法（<code>static</code> 修饰），方法上包含以下注解：</p><ol><li><code>org.springframework.web.bind.annotation.GetMapping</code></li><li><code>org.springframework.web.bind.annotation.PostMapping</code></li><li><code>org.springframework.web.bind.annotation.GetMapping</code></li><li><code>org.springframework.web.bind.annotation.DeleteMapping</code></li><li><code>org.springframework.web.bind.annotation.PatchMapping</code></li><li><code>org.springframework.web.bind.annotation.RequestMapping</code></li></ol><h4 id="文档模版是否可以设置？"><a href="#文档模版是否可以设置？" class="headerlink" title="文档模版是否可以设置？"></a>文档模版是否可以设置？</h4><p>当前版本文档模版只有展示的这个，不支持自定义模版。</p><h4 id="接口名称是如何设置的？"><a href="#接口名称是如何设置的？" class="headerlink" title="接口名称是如何设置的？"></a>接口名称是如何设置的？</h4><ol><li><p>接口名称默认取值如图截图所示 <code>类名#方法名</code>；</p><p> <img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/7LRtm9-LzXotO.png" alt="7LRtm9-LzXotO"></p></li><li><p>支持在注释上使用 <code>@name</code> 设置接口名。</p><p> <img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/zdw5TG-QtZFyB.png" alt="zdw5TG-QtZFyB"></p></li></ol><h4 id="接口描述是从哪里获取的？"><a href="#接口描述是从哪里获取的？" class="headerlink" title="接口描述是从哪里获取的？"></a>接口描述是从哪里获取的？</h4><ol><li><p>接口描述直接取的方法注释；</p></li><li><p>如果有 <code>@description</code> 标签，则会优先使用标签对应的描述。</p><p> <img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/pcZB5V-Tn33bX.png" alt="pcZB5V-Tn33bX"></p></li></ol><h4 id="请求路径是如何生成的？"><a href="#请求路径是如何生成的？" class="headerlink" title="请求路径是如何生成的？"></a>请求路径是如何生成的？</h4><p>取 <code>Class</code> 和  <code>Method</code> 上的 path 进行拼装组成。</p><h4 id="请求方式如何设置？"><a href="#请求方式如何设置？" class="headerlink" title="请求方式如何设置？"></a>请求方式如何设置？</h4><p>根据 <code>Method</code> 上的注解生成。</p><h4 id="请求参数及请求示例的需要设置什么？"><a href="#请求参数及请求示例的需要设置什么？" class="headerlink" title="请求参数及请求示例的需要设置什么？"></a>请求参数及请求示例的需要设置什么？</h4><ol><li><p>根据是否有 <code>@RequestBody</code> 注解，生成请求 Header 是否为 json 还是 form。同时会检测请求参数中是否有 <code>@RequestHeader</code> 注解；</p><p> <img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/pQHnXo-C4oPfT.png" alt="Header"></p></li><li><p>对象生成列表；</p></li><li><p>根据请求是 json 还是 form 生成对应的请求示例。</p></li></ol><h4 id="返回参数及返回示例怎么生成？"><a href="#返回参数及返回示例怎么生成？" class="headerlink" title="返回参数及返回示例怎么生成？"></a>返回参数及返回示例怎么生成？</h4><p>支持对象，返回空，返回带泛型方式。这里的泛型仅支持单个泛型且名称为 <code>T</code>。</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/9ML932-RbqIqV.png" alt="返回带泛型"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><p><strong>Q: <code>Doc View</code> 插件去哪里下载？</strong></p><p><strong>A:</strong> </p><ol><li>可以直接通过 IDEA 插件仓库，直接搜索名称即可；</li><li>在 GitHub 通过 Releases 下载；</li><li>关注公众号并发送 <code>Doc View</code> 相关关键字（doc/doc view）获取。</li></ol><p><strong>Q: <code>Doc View</code> 是否开源？</strong></p><p><strong>A:</strong> 是的。开源地址为：<a href="https://github.com/liuzhihang/doc-view">https://github.com/liuzhihang/doc-view</a>，有兴趣的小伙伴，可以给个 Star ，如果想增加一些功能，也可以提 PR。</p><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>插件开发从最开始开发到今天发布第一版，中间经历了很长一段时间，毕竟只是业余时间开发，就断断续续的写，不过现在最简单版本已经可以使用了。</p><p>目前来看，只有一个 <code>Copy</code> 功能，不过基本上可以满足使用。至于其他的需求，比如：自定义模版、支持 Dubbo 接口、预览导出等功能就需要后续不断迭代了。</p><p>个人开发精力有限，小伙伴在使用过程中遇到肯定会遇到 bug，或者是有其他的功能及使用建议，都可以通过以下方式反馈：</p><ol><li>关注公众号：『 刘志航 』 通过读者讨论进行留言；</li><li>在 GitHub 上提 Issues；</li><li>在插件帮助页面留言；</li><li>文章结尾留言；</li></ol><p>最后，感谢小伙伴们的支持。欢迎下载体验，并提出相关建议及意见。</p>]]></content>
      
      
      <categories>
          
          <category> 工具册 </category>
          
          <category> Doc View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具册 </tag>
            
            <tag> Doc View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JDK源码笔记】- 写时复制集合 —— CopyOnWriteArrayList</title>
      <link href="2020/10/31/copyonwritearraylist.html"/>
      <url>2020/10/31/copyonwritearraylist.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>前言</strong></p><br><p>JUC 下面还有一个系列的类，都是 CopyOnWriteXXX ，意思是写时复制，这个究竟是怎么回事？那就以 CopyOnWriteArrayList 为切入点，一起了解写时复制是怎么回事？</p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>ArrayList 的一个线程安全的变体，其中所有可变操作（add、set 等等）都是通过对底层数组进行一次新的复制来实现的。</p><p>像名字一样，每次进行操作的时候，都会进行一次复制，当然会有很大的性能消耗，但是在某些使用场景下，又会提高性能。具体是怎么操作的，那就一步一步阅读源码，然后再做总结归纳。</p><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayListTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        CopyOnWriteArrayList&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加元素</span></span><br><span class="line">        list.add(<span class="string">&quot;liuzhihang&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移除元素</span></span><br><span class="line">        list.remove(<span class="string">&quot;liuzhihang&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查看元素</span></span><br><span class="line">        String value0 = list.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            String next = iterator.next();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="问题疑问"><a href="#问题疑问" class="headerlink" title="问题疑问"></a>问题疑问</h4><ol><li>为什么要叫写时复制集合？</li><li>CopyOnWriteArrayList 实现原理是什么？</li><li>CopyOnWriteArrayList 和 ArrayList 有什么区别？</li><li>CopyOnWriteArrayList 复制是怎么进行复制的？</li></ol><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/PRT4mY-DDwfkF.png" alt="PRT4mY-DDwfkF"></p><h4 id="参数介绍"><a href="#参数介绍" class="headerlink" title="参数介绍"></a>参数介绍</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8673264195747942595L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 数据有变动时使用 */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 数组 只能通过 getArray/setArray 访问 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将数组指向传入的新数组</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">        array = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过参数可以了解到以下内容：</p><ol><li>基于数组实现；</li><li>使用了 ReentrantLock 互斥锁。</li></ol><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setArray(<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在初始化 CopyOnWriteArrayList 时，就是创建了一个 Object 的数组。</p><h4 id="add"><a href="#add" class="headerlink" title="add"></a>add</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前数组</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">// 创建一个新数组，并将原数组数据复制到新数组</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 添加的新元素到数组尾部</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="comment">// 将数组指向新数组</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>add 方法逻辑很简单：</p><ol><li>通过加互斥锁（ReentrantLock）从而保证在写的时候只有一个线程可以写。</li><li>新增元素时，先使用 <code>Arrays.copyOf(elements, len + 1)</code> 复制出一个长度 +1 的新数组。</li><li>添加元素到新数组。</li><li>然后再将原数组对象指向新数组。</li></ol><p>画图如下：</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/KCTNMP-kLOtFP.png" alt="KCTNMP-kLOtFP"></p><h4 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 原数组</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">// 移除的值</span></span><br><span class="line">        E oldValue = get(elements, index);</span><br><span class="line">        <span class="keyword">int</span> numMoved = len - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 如果移除最后一个元素</span></span><br><span class="line">            <span class="comment">// 直接复制前面的元素即可</span></span><br><span class="line">            setArray(Arrays.copyOf(elements, len - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 移除中间的元素，进行两次复制</span></span><br><span class="line">            Object[] newElements = <span class="keyword">new</span> Object[len - <span class="number">1</span>];</span><br><span class="line">            System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">            System.arraycopy(elements, index + <span class="number">1</span>, newElements, index,</span><br><span class="line">                                numMoved);</span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>remove 方法相对多了一些判断：</p><ol><li>通过加互斥锁（ReentrantLock）从而保证在写的时候只有一个线程可以移除元素。</li><li>如果移除的是最后一个元素，则直接复制前面的元素到新数组，并指向新数组即可。</li><li>如果移除的是中间的元素，则需要进行两次复制，然后指向新数组。</li></ol><p>画图如下：</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/q3iE0c-AGgXfP.png" alt="q3iE0c-AGgXfP"></p><h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get 方法可以看出：</p><ol><li>获取元素并没有进行加锁。</li><li>从原数组获取的元素。</li></ol><p>所以并发情况下，并不能保证很及时的读取的刚插入或者移除的元素。</p><h4 id="数组复制"><a href="#数组复制" class="headerlink" title="数组复制"></a>数组复制</h4><p>通过阅读 add 和 remove 相关代码，可以看到在数组复制时使用了 <code>Arrays.copyOf</code> 和 <code>System.arraycopy</code>，这相当于一个优化方面吧。</p><p>毕竟数组复制总不能把原数组遍历一遍，挨着赋值到新数组里面吧。</p><p>那接下来看一下内部是如何实现的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Arrays</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 其他方法省略 ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * original 要复制的数组</span></span><br><span class="line"><span class="comment">     * newLength 新数组的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] copyOf(T[] original, <span class="keyword">int</span> newLength) &#123;</span><br><span class="line">        <span class="keyword">return</span> (T[]) copyOf(original, newLength, original.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * original 要复制的数组</span></span><br><span class="line"><span class="comment">     * newLength 新数组的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class="keyword">int</span> newLength, Class&lt;? extends T[]&gt; newType) &#123;</span><br><span class="line">        <span class="comment">// 创建一个新数组，长度是指定的长度</span></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        T[] copy = ((Object)newType == (Object)Object[].class)</span><br><span class="line">            ? (T[]) <span class="keyword">new</span> Object[newLength]</span><br><span class="line">            <span class="comment">// 创建具有指定的组件类型和长度的新数组</span></span><br><span class="line">            : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用 System.arraycopy 复制数组</span></span><br><span class="line">        System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line">                         Math.min(original.length, newLength));</span><br><span class="line">        <span class="keyword">return</span> copy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过阅读 <code>Arrays.copyOf</code> 相关源码，发现其实 <code>Arrays.copyOf</code> 底层也是调用的 <code>System.arraycopy</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">System</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他方法省略 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * src 源数组</span></span><br><span class="line"><span class="comment">     * srcPos 源数组起始位置</span></span><br><span class="line"><span class="comment">     * dest 目标数组</span></span><br><span class="line"><span class="comment">     * destPos 目标数组的起始位置</span></span><br><span class="line"><span class="comment">     * length 要复制的元素数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,  <span class="keyword">int</span>  srcPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        Object dest, <span class="keyword">int</span> destPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">int</span> length)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 <code>System.arraycopy</code> 是一个 <code>native</code> 方法，这个是 JVM 内部实现的，具体可以阅读相关资料。而使用这种方式要比 <code>for</code> 循环和 <code>clone</code> 要高效很多。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h4><p><strong>Q: 为什么要叫写时复制集合？</strong></p><p><strong>A:</strong> 因为在 add、remove 操作时会复制出来一个新数组。</p><p><strong>Q: CopyOnWriteArrayList 实现原理是什么？</strong></p><p><strong>A:</strong> 在 add、remove 操作时会进行加锁，然后复制出来一个新数组，操作的都是新数组，而此时原数组是可以提供查询的。当操作结束之后，会将对象指针指向新数组。</p><p><strong>Q: CopyOnWriteArrayList 和 ArrayList 有什么区别？</strong></p><p><strong>A:</strong> CopyOnWriteArrayList 在读多写少的场景下可以提高效率，而 ArrayList 只是普通数组集合，并不适用于并发场景，而如果对 ArrayList 加锁，则会影响一部分性能。</p><p>同样对 CopyOnWriteArrayList 而言，仅能保证最终一致性。因为刚写入的数据，是写到的复制的数组中，此时并不能立即查询到。如果要保证实时性可以尝试使用 <code>Collections.synchronizedList</code> 或者加锁等方式。</p><p><strong>Q: CopyOnWriteArrayList 复制是怎么进行复制的？</strong></p><p><strong>A:</strong> 内部使用的是本地方法 <code>System.arraycopy</code> 进行数组的复制。</p><h4 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h4><p>通过阅读 CopyOnWriteArrayList 源码，了解到写时复制是的原理。同时了解到可以使用 <code>System.arraycopy</code> 的方式提高数组复制的效率。</p><p>同样 CopyOnWriteArrayList 适合读多写少的场景，满足最终一致性，但是并不能保证数据修改及时查询到。</p>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码笔记 </tag>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JDK源码笔记】- 非阻塞的无界线程安全队列 —— ConcurrentLinkedQueue</title>
      <link href="2020/10/25/source-code-concurrentlinkedqueue.html"/>
      <url>2020/10/25/source-code-concurrentlinkedqueue.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>前言</strong></p><br><p>JUC 下面的相关源码继续往下阅读，这就看到了非阻塞的无界线程安全队列 —— ConcurrentLinkedQueue，来一起看看吧。</p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>基于链接节点的无界线程安全队列，对元素FIFO（先进先出）进行排序。 队列的头部是队列中最长时间的元素，队列的尾部是队列中最短时间的元素。 在队列的尾部插入新元素，队列检索操作获取队列头部的元素。</p><p>当许多线程共享对公共集合的访问 ConcurrentLinkedQueue 是一个合适的选择。 与大多数其他并发集合实现一样，此类不允许使用null元素。</p><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentLinkedQueueTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ConcurrentLinkedQueue&lt;String&gt; queue = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将指定元素插入此队列的尾部。</span></span><br><span class="line">        queue.add(<span class="string">&quot;liuzhihang&quot;</span>);</span><br><span class="line">        <span class="comment">// 将指定元素插入此队列的尾部。</span></span><br><span class="line">        queue.offer(<span class="string">&quot;liuzhihang&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取但不移除此队列的头，队列为空返回 null。</span></span><br><span class="line">        queue.peek();</span><br><span class="line">        <span class="comment">// 获取并移除此队列的头，此队列为空返回 null。</span></span><br><span class="line">        queue.poll();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/LNKjGH-iwlqrt.png" alt="LNKjGH-iwlqrt"></p><h4 id="参数介绍"><a href="#参数介绍" class="headerlink" title="参数介绍"></a>参数介绍</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点中的元素</span></span><br><span class="line">    <span class="keyword">volatile</span> E item;</span><br><span class="line">    <span class="comment">// 下一个节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(E item) &#123;</span><br><span class="line">        UNSAFE.putObject(<span class="keyword">this</span>, itemOffset, item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// CAS 的方式设置节点元素</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">casItem</span><span class="params">(E cmp, E val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, itemOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置下一个节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lazySetNext</span><span class="params">(Node&lt;E&gt; val)</span> </span>&#123;</span><br><span class="line">        UNSAFE.putOrderedObject(<span class="keyword">this</span>, nextOffset, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CAS 的方式设置下一个节点</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">casNext</span><span class="params">(Node&lt;E&gt; cmp, Node&lt;E&gt; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, nextOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略 ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 ConcurrentLinkedQueue 内部含有一个内部类 Node，如上所示，这个内部类用来标识链表中的一个节点，通过代码可以看出，在 ConcurrentLinkedQueue 中的链表为<code>单向链表</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentLinkedQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 其他省略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头结点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; head;      </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尾节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>头尾节点使用 <code>volatile</code> 修饰，保证内存可见性。</p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentLinkedQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    head = tail = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当创建对象时，头尾节点都是指向一个空节点。</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/ZzpJTa-lOE9g4.png" alt="ZzpJTa-lOE9g4"></p><h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> offer(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 验证是否为空</span></span><br><span class="line">    checkNotNull(e);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环入队列</span></span><br><span class="line">    <span class="comment">// t 是当前尾节点，p 初始为 t</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; t = tail, p = t;;) &#123;</span><br><span class="line">        <span class="comment">// q 为尾节点的下一个节点</span></span><br><span class="line">        Node&lt;E&gt; q = p.next;</span><br><span class="line">        <span class="keyword">if</span> (q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 为空，说明后面没有节点，则 CAS 设置尾节点</span></span><br><span class="line">            <span class="keyword">if</span> (p.casNext(<span class="keyword">null</span>, newNode)) &#123;</span><br><span class="line">                <span class="comment">// 此时 p.next 是 newNode</span></span><br><span class="line">                <span class="comment">// 如果 p ！= t 说明有并发</span></span><br><span class="line">                <span class="keyword">if</span> (p != t) </span><br><span class="line">                    <span class="comment">// 其他线程已经更新了 tail</span></span><br><span class="line">                    <span class="comment">// q = p.next 所以 q == null 不正确了</span></span><br><span class="line">                    <span class="comment">// q 取到了 t.next</span></span><br><span class="line">                    <span class="comment">// 此时将 tail 更新为 新节点</span></span><br><span class="line">                    casTail(t, newNode);  <span class="comment">// Failure is OK.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Lost CAS race to another thread; re-read next</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 多线程情况下， poll ，操作移除元素，可能会导致 p == q </span></span><br><span class="line">        <span class="comment">// 此时要重新查找</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            p = (t != (t = tail)) ? t : head;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 检查 tail 并更新</span></span><br><span class="line">            p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>画图说明：</p><ul><li>单线程情况下：</li></ul><ol><li>当执行到 <code>Node&lt;E&gt; q = p.next;</code> 时，当前情况如图所示：</li></ol><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/QJ5fjB-QtmN7F.png" alt="QJ5fjB-QtmN7F"></p><ol start="2"><li>判断 <code>q == null</code>，满足条件，此时便会执行 <code>p.casNext(null, newNode)</code> 使用 CAS 设置 p.next。</li><li>设置成功之后，<code>p == t</code> 没有变动，所以程序退出。</li></ol><ul><li>多线程情况下：</li></ul><ol><li>当执行到 <code>Node&lt;E&gt; q = p.next;</code> 时，当前情况如图所示：</li></ol><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/QJ5fjB-QtmN7F.png" alt="QJ5fjB-QtmN7F"></p><ol start="2"><li>多个线程执行 <code>p.casNext(null, newNode)</code> 使用 CAS 设置 p.next。</li><li>A 线程 CAS 设置成功：</li></ol><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/u4O6mX-yQeaI6.png" alt="u4O6mX-yQeaI6"></p><ol start="4"><li>B 线程 CAS 执行失败， 重新循环，会执行到 <code>p = (p != t &amp;&amp; t != (t = tail)) ? t : q</code>。</li></ol><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/vkP5tp-jaUZOc.png" alt="vkP5tp-jaUZOc"></p><ol start="5"><li>再次循环就可以成功设置上了。</li></ol><h4 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    restartFromHead:</span><br><span class="line">    <span class="comment">// 无限循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;;) &#123;</span><br><span class="line">            <span class="comment">// 头结点的 iterm</span></span><br><span class="line">            E item = p.item;</span><br><span class="line">            <span class="comment">// 当前节点如果不为 null CAS 设置为 null</span></span><br><span class="line">            <span class="keyword">if</span> (item != <span class="keyword">null</span> &amp;&amp; p.casItem(item, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="comment">// CAS 成功 则标记移除</span></span><br><span class="line">                <span class="keyword">if</span> (p != h) <span class="comment">// hop two nodes at a time</span></span><br><span class="line">                    updateHead(h, ((q = p.next) != <span class="keyword">null</span>) ? q : p);</span><br><span class="line">                <span class="keyword">return</span> item;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前队列未空 返回 null</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((q = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                updateHead(h, p);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 自引用了， 重新进行循环</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">                <span class="keyword">continue</span> restartFromHead;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p = q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>画图过程如下：</p><ol><li>在执行内层循环时，如果队列为空：<code>E item = p.item;</code> 此时，iterm 为 null，会 <code>updateHead(h, p)</code> 并返回 null。</li><li>假设同时有并发插入操作，添加了一个元素，此时如图所示：</li></ol><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/zGeE4p-Udb3x0.png" alt="zGeE4p-Udb3x0"></p><p>这时会执行最后的 else 将 <code>p = q</code></p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/KkcsgS-8RvW4W.png" alt="KkcsgS-8RvW4W"></p><ol start="3"><li>继续循环获取 item，并执行 <code>p.casItem(item, null)</code> ， 然后判断 <code>p != h</code>，更新 head 并返回 item。</li></ol><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/mBNd6o-RS2hU0.png" alt="mBNd6o-RS2hU0"></p><p>这里的情况比较复杂，这里只是列举一种，如果需要可以自己多列举几种。</p><p>而查看元素的代码和获取元素代码类似就不多介绍了。</p><h4 id="size-操作"><a href="#size-操作" class="headerlink" title="size 操作"></a>size 操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; p = first(); p != <span class="keyword">null</span>; p = succ(p))</span><br><span class="line">        <span class="keyword">if</span> (p.item != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// Collection.size() spec says to max out</span></span><br><span class="line">            <span class="keyword">if</span> (++count == Integer.MAX_VALUE)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CAS 没有加锁，所以 size 是不准确的。并且 size 会遍历一遍列表，比较耗费性能。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>ConcurrentLinkedQueue 在工作中使用的相对较少，所以阅读相关源码的时候也只是大概看了一下，了解常用 API，以及底层原理。</p><p>简单总结就是使用<strong>单向链表</strong>来保存队列元素，内部使用非阻塞的 CAS 算法，没有加锁。所以计算 size 时可能不准确，同样 size 会遍历链表，所以并不建议使用。</p>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码笔记 </tag>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【工作笔记】- APP 莫名崩溃，开始以为是 Header 中 name 大小写的锅，最后发现原来是容器的错！</title>
      <link href="2020/10/19/header-name-case.html"/>
      <url>2020/10/19/header-name-case.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>前言</strong></p><br><p>部署测试，部署预发布，一切测试就绪，上生产。</p><p>发布生产</p><p>闪退</p><p>What？？？</p><p>马上回滚</p><p>开始排查</p><p>后端一模一样的代码，不是 APP 端的问题吧。可 APP 端没有发版啊。</p><p>…… 一番排查</p><p>原来是 APP 端打包，测试和预发布包 Header 传的都是 <code>Authorization</code> ，生产传的是 <code>authorization</code> 。就是大小写问题，那赶紧改。</p></blockquote><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>首页接口只有登录才可以进入，因为首页要展示获取用户账户的一些信息。这里使用的是统一拦截，从 Header 中获取 token 后，使用 token 获取用户信息。</p><p>而现在要改为用户未登录也可以查看首页信息中的宣传文案等等，只不过账户信息不显示。</p><h4 id="原流程"><a href="#原流程" class="headerlink" title="原流程"></a>原流程</h4><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/FiwOie-8ZLjgv.png" alt="FiwOie-8ZLjgv"></p><p>整个过程代码在 <a href="https://mp.weixin.qq.com/s/8qY94y3w0Q2RRhkG7iUfOg">ThreadLocal底层原理</a> 里面有所介绍。这里省略一部分代码。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception arg3)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        LocalUserUtils.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 请求方法是否存在注解</span></span><br><span class="line">        <span class="keyword">boolean</span> assignableFrom = handler.getClass().isAssignableFrom(HandlerMethod.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!assignableFrom) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        CheckToken checkToken = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> HandlerMethod) &#123;</span><br><span class="line">            checkToken = ((HandlerMethod) handler).getMethodAnnotation(CheckToken.class);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有加注解 直接放过</span></span><br><span class="line">        <span class="keyword">if</span> (checkToken == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从Header中获取Authorization</span></span><br><span class="line">        String authorization = request.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;header authorization : &#123;&#125;&quot;</span>, authorization);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(authorization)) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;从Header中获取Authorization失败&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> CustomExceptionEnum.NOT_HAVE_TOKEN.throwCustomException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 其他代码省略</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看出这里大概过程如下：</p><ol><li>是使用拦截器拦截请求</li><li>如果方法没有 CheckToken 注解直接放过</li><li>有 CheckToken 注解，则从 request 的 header 中获取 Authorization</li></ol><h4 id="新需求"><a href="#新需求" class="headerlink" title="新需求"></a>新需求</h4><p>这里想到只需要把注解去掉，然后从请求参数中获取 token 即可。获取到走原逻辑，获取不到则只返回宣传文案等信息。</p><h3 id="从-Header-中获取信息"><a href="#从-Header-中获取信息" class="headerlink" title="从 Header 中获取信息"></a>从 Header 中获取信息</h3><h4 id="直接获取请求头某一个-headerName"><a href="#直接获取请求头某一个-headerName" class="headerlink" title="直接获取请求头某一个 headerName"></a>直接获取请求头某一个 headerName</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/getAuthorizationByKey&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getAuthorizationByKey</span><span class="params">(<span class="meta">@RequestHeader(&quot;Authorization&quot;)</span> String authorization)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;获取 Authorization ---&gt;&#123;&#125;&quot;</span>, authorization);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> authorization;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用-Map-获取所有请求头"><a href="#使用-Map-获取所有请求头" class="headerlink" title="使用 Map 获取所有请求头"></a>使用 Map 获取所有请求头</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/getAuthorizationByMap&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getAuthorizationByMap</span><span class="params">(<span class="meta">@RequestHeader</span> Map&lt;String, String&gt; map)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String authorization = map.get(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;获取 Authorization ---&gt;&#123;&#125;&quot;</span>, authorization);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> authorization;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用-MultiValueMap-获取请求头"><a href="#使用-MultiValueMap-获取请求头" class="headerlink" title="使用 MultiValueMap 获取请求头"></a>使用 MultiValueMap 获取请求头</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/getAuthorizationByMultiValueMap&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getAuthorizationByMultiValueMap</span><span class="params">(<span class="meta">@RequestHeader</span> MultiValueMap&lt;String, String&gt; map)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; authorization = map.get(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;获取 Authorization ---&gt;&#123;&#125;&quot;</span>, authorization);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;SUCCESS&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用-HttpHeaders-获取请求头"><a href="#使用-HttpHeaders-获取请求头" class="headerlink" title="使用 HttpHeaders 获取请求头"></a>使用 HttpHeaders 获取请求头</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/getAuthorizationByHeaders&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getAuthorizationByHeaders</span><span class="params">(<span class="meta">@RequestHeader</span> HttpHeaders headers)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; authorization = headers.get(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;获取 Authorization ---&gt;&#123;&#125;&quot;</span>, authorization);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;SUCCESS&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用-HttpServletRequest-获取"><a href="#使用-HttpServletRequest-获取" class="headerlink" title="使用 HttpServletRequest 获取"></a>使用 HttpServletRequest 获取</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/getAuthorizationByServlet&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getAuthorizationByServlet</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String authorization = request.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;获取 Authorization ---&gt;&#123;&#125;&quot;</span>, authorization);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> authorization;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试文件"><a href="#测试文件" class="headerlink" title="测试文件"></a>测试文件</h4><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/dqAEES-LSudFy.png" alt="dqAEES-LSudFy"></p><p>经过测试这些都是可以的，最终选择使用 Map 接收 Header ，然后从 Map 中获取 Authorization。</p><blockquote><p>PS: 可能有小伙伴测试不过，发现接受的 header 里的 name 全都是小写了，可以继续阅读。<br>源码在文末，也可以关注公众号，发送 headerName/4 获取。</p></blockquote><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/rXC2fS-cVftVR.jpg" alt="rXC2fS-cVftVR"></p><p>你以为事情如果到这里就结束了，那真是太天真了。</p><p>这不，出现了文章开头的描述的场景，赶紧回滚，然后排查问题，最后定位到是 Header 的 name 大小写问题。</p><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><ol><li>之前 APP 端也是这么传的，那为什么使用拦截器是正常的呢？</li><li>上面的那几种方式是不是都是这样？</li><li>不排除 tomcat 发现原来都会转换为小写，又是为什么？</li></ol><h3 id="模拟排查"><a href="#模拟排查" class="headerlink" title="模拟排查"></a>模拟排查</h3><h4 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h4><p>模拟生产首先使用相同的容器配置，这里排除了内置的 tomcat 容器，并且使用 undertow 容器。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Exclude the Tomcat dependency --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-undertow<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="使用拦截器传小写为什么没有问题"><a href="#使用拦截器传小写为什么没有问题" class="headerlink" title="使用拦截器传小写为什么没有问题"></a>使用拦截器传小写为什么没有问题</h4><ul><li>修改使用小写 <code>authorization</code></li></ul><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/BnwZnf-7AvYYg.png" alt="BnwZnf-7AvYYg"></p><ul><li>debug 断点</li></ul><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/OOjOyV-54K6Na.png" alt="OOjOyV-54K6Na"></p><p>神奇的一幕出现了，收到的确实是小写，但是 <strong>request.getHeader(“Authorization”);</strong> 却可以获取到 <code>authorization</code></p><ul><li>F7 继续往里跟</li></ul><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/JwgnFS-cW3pJY.png" alt="JwgnFS-cW3pJY"></p><p><code>io.undertow.servlet.spec.HttpServletRequestImpl#getHeader</code> 第 190 行，从 HeaderMap 中获取第一个元素</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/DnRSum-crs0Mb.png" alt="DnRSum-crs0Mb"></p><p><code>io.undertow.util.HeaderMap#getFirst</code> 第 297 行， 通过 getEntry 方法获取 header</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/C8lSGw-XxKDPW.png" alt="C8lSGw-XxKDPW"></p><p>继续追踪，发现在 <code>io.undertow.util.HeaderMap#getEntry(java.lang.String)</code> 方法 77~79 行的时候获取到了 header 信息。那就看一下这块的源码吧。</p><p>在仔细看一下发现是 77 行 <code>final int hc = HttpString.hashCodeOf(headerName);</code> 在获取 name 的 hashCode 时，这里无论大小写，都是同一个 hashCode。这块代码如下</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/3v1FVJ-MuPXUA.png" alt="3v1FVJ-MuPXUA"></p><p>higher 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">higher</span><span class="params">(<span class="keyword">byte</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &amp; (b &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; b &lt;= <span class="string">&#x27;z&#x27;</span> ? <span class="number">0xDF</span> : <span class="number">0xFF</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这块的含义</p><ol><li>如果 b 是小写字符则 <code>b &amp; 0xDF</code></li><li>如果 b 是大写字符则 <code>b &amp; 0xFF</code></li></ol><p>对照 ASCII 表，大小写字母相差 32 而 0xFF(255) 和 0xDF(223) 同样相差 32，所以问题定位到了。header 的 name 无论是大写还是小写，都会查出同一个值。</p><p>当然你也可以这么传</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/VOOF8k-LoGjAf.png" alt="VOOF8k-LoGjAf"></p><p>这样的话谁在上面，Header 中使用的 name 就是那个。</p><h4 id="使用-Map-为什么会区分大小写"><a href="#使用-Map-为什么会区分大小写" class="headerlink" title="使用 Map 为什么会区分大小写"></a>使用 Map 为什么会区分大小写</h4><p>传入的是大写</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">HttpServlet </span><br><span class="line">-&gt; DispatcherServlet#doDispatch </span><br><span class="line">-&gt; AbstractHandlerMethodAdapter#handle </span><br><span class="line">-&gt; RequestMappingHandlerAdapter#handleInternal </span><br><span class="line">-&gt; RequestMappingHandlerAdapter#invokeHandlerMethod </span><br><span class="line">-&gt; ServletInvocableHandlerMethod#invokeAndHandle</span><br><span class="line">-&gt; InvocableHandlerMethod#invokeForRequest (解析参数值)</span><br><span class="line">-&gt; InvocableHandlerMethod#getMethodArgumentValues</span><br><span class="line">-&gt; RequestHeaderMapMethodArgumentResolver#resolveArgument</span><br></pre></td></tr></table></figure><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/dqAEES-LSudFy.png" alt="dqAEES-LSudFy"></p><p>如图所示 <code>String headerName = iterator.next();</code> name 被区分大小写放到了 LinkedHashMap 中，后续会反射调用对应的 Controller 方法。</p><p>所以也就出现了我所遇到的问题。 </p><p>当然理论上 APP 客户端不应该测试和预发布使用大写，而生产使用小写。</p><p>上面阅读的源码只是 Spring 对 Header 的处理，Spring 在 <code>HttpServlet</code> 收到请求时，Spring 没有对请求 Header 的 name 大小写进行转换，只是在获取对应 value 的时候，没有区分大小写进行获取。</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/mpl3PK-m7dKAb.jpg"></p><h3 id="容器对-header-的处理"><a href="#容器对-header-的处理" class="headerlink" title="容器对 header 的处理"></a>容器对 header 的处理</h3><h5 id="undertow-容器的处理"><a href="#undertow-容器的处理" class="headerlink" title="undertow 容器的处理"></a>undertow 容器的处理</h5><ul><li>请求参数的处理</li></ul><p>这里发现 undertow 并没有对请求参数进行大小写转换处理操作。</p><ul><li>从 HttpServletRequest 获取 header</li></ul><p>debug 发现调用的是 <code>io.undertow.servlet.spec.HttpServletRequestImpl#getHeader</code>，这个过程就是上面的排查过程。</p><ul><li>从 Headers 中获取 header</li></ul><p>通过 debug 发现 jetty 调用的是 <code>org.springframework.http.HttpHeaders#get</code>，然后调用 <code>org.springframework.util.MultiValueMapAdapter#get</code>，然后调用 <code>org.springframework.util.LinkedCaseInsensitiveMap#get</code></p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/nRw6xN-GkUqAN.png" alt="nRw6xN-GkUqAN"></p><p>这里会不区分大小写</p><ul><li>从 MultiValueMap 获取 header</li></ul><p>这块 debug 发现是直接从 <code>LinkedHashMap</code> 获取的，所以区分了大小写。</p><h4 id="tomcat-容器的处理"><a href="#tomcat-容器的处理" class="headerlink" title="tomcat 容器的处理"></a>tomcat 容器的处理</h4><ul><li>请求参数的处理</li></ul><p>而如果没有排除的话，即使用内嵌的 tomcat 容器无论传递大写还是小写，接收到的全部都是小写，又是怎么个情况呢？</p><p>通过 debug 发现没有排除 tomcat 使用的是，在接收请求时使用的是 <code>org.apache.coyote.http11.Http11Processor</code>。</p><p>在 <code>Http11Processor#service</code> 方法中</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/303mmp-6TczCR.png" alt="303mmp-6TczCR"></p><p>类 284 行负责处理解析 header </p><p>进入 <code>org.apache.coyote.http11.Http11InputBuffer#parseHeaders</code> 方法</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/cqHTEZ-1E9mH7.png" alt="cqHTEZ-1E9mH7"></p><p>第 589 行 （Download Sources 后），阅读 <code>parseHeader</code> 方法</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/oEEbej-rMulR7.png" alt="oEEbej-rMulR7"></p><p>发现会将请求 header 的 name 转换为小写</p><ul><li>从 HttpServletRequest 获取 header</li></ul><p>当使用 tomcat 容器时，调用 <code>org.apache.catalina.connector.RequestFacade#getHeader</code>， <code>org.apache.catalina.connector.Request#getHeader</code>， <code>org.apache.coyote.Request#getHeader</code> <code>org.apache.tomcat.util.http.MimeHeaders#getHeader</code> 最后调用 <code>org.apache.tomcat.util.http.MimeHeaders#getValue</code> 获取 header </p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/qDJXXn-z6hTjZ.png" alt="qDJXXn-z6hTjZ"></p><p>这里也会忽略大小写判断</p><ul><li>从 Headers 获取 header</li></ul><p>通过 debug 发现 tomcat 容器下调用的是 <code>org.springframework.http.HttpHeaders#get</code>，然后调用 <code>org.springframework.util.MultiValueMapAdapter#get</code>，然后调用 <code>org.springframework.util.LinkedCaseInsensitiveMap#get</code></p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/nRw6xN-GkUqAN.png" alt="nRw6xN-GkUqAN"></p><p>这里会不区分大小写</p><ul><li>从 MultiValueMap 获取 header</li></ul><p>这块 debug 发现是直接从 <code>LinkedHashMap</code> 获取的，所以区分了大小写。</p><h4 id="jetty-容器的处理"><a href="#jetty-容器的处理" class="headerlink" title="jetty 容器的处理"></a>jetty 容器的处理</h4><ul><li>请求参数的处理</li></ul><p>如果换成 jetty 容器的话</p><p>在 <code>org.eclipse.jetty.server.HttpConnection</code> 中又会发现无论传入大写还是小写都会被转换为驼峰。</p><p>源码可以阅读 <code>org.eclipse.jetty.http.HttpParser#parseFields</code></p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/Q9KjmT-HSRusz.png" alt="Q9KjmT-HSRusz"></p><p>会转换为驼峰命名法。</p><ul><li>从 HttpServletRequest 获取 header</li></ul><p>通过 debug 发现 jetty 调用的是 <code>org.eclipse.jetty.server.Request#getHeader</code></p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/H9onCc-uyaMMn.png" alt="H9onCc-uyaMMn"></p><p>jetty 在获取 header 时，会调用 <code>org.eclipse.jetty.http.HttpFields#get</code></p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/BOkxFw-op6ZIV.png" alt="BOkxFw-op6ZIV"></p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/ioe7pS-uNuRU6.png" alt="ioe7pS-uNuRU6"></p><p>原来在获取的时候忽略了大小写</p><ul><li>从 Headers 获取 header</li></ul><p>通过 debug 发现 jetty 容器下调用的是 <code>org.springframework.http.HttpHeaders#get</code>，然后调用 <code>org.springframework.util.MultiValueMapAdapter#get</code>，然后调用 <code>org.springframework.util.LinkedCaseInsensitiveMap#get</code></p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/nRw6xN-GkUqAN.png" alt="nRw6xN-GkUqAN"></p><p>这里会不区分大小写</p><ul><li>从 MultiValueMap 获取</li></ul><p>也是调用的 <code>org.springframework.util.MultiValueMapAdapter#get</code> 然后不区分大小写。和从 Headers 中获取相同。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h4><p><strong>Q: 为什么拦截器获取 Authorization 可以不区分大小写？</strong></p><p><strong>A:</strong> 从拦截器获取 Authorization 其实就是从 <code>HttpServletRequest</code> 中获取，这里无论使用 tomcat 还是使用 undertow 或者 jetty 获取 Header 是都是忽略 headerName 的大小写的。具体可以阅读上面的源码分析。</p><p><strong>Q: 这么多获取 Header 的方式有什么区别？</strong><br><strong>A:</strong></p><p>不同的容器下实现方式不同，这里列表说明</p><table><thead><tr><th align="center"></th><th align="center">undertow</th><th align="center">tomcat</th><th align="center">jetty</th></tr></thead><tbody><tr><td align="center">请求参数大小写转换</td><td align="center">不变</td><td align="center">小写</td><td align="center">驼峰</td></tr><tr><td align="center">直接获取请求头某一个 headerName</td><td align="center">忽略大小写，不能为空</td><td align="center">忽略大小写，不能为空</td><td align="center">忽略大小写，不能为空</td></tr><tr><td align="center">使用 Map 获取所有请求头</td><td align="center">Map 的 key 和传入 headerName 大小写的一致，保持一致可获取到</td><td align="center">Map 的 key 全是小写，需要使用小写headerName 获取</td><td align="center">Map 的 key 是驼峰命名法，要使用驼峰命名才可以获取到</td></tr><tr><td align="center">使用 MultiValueMap 获取请求头</td><td align="center">实际是从 LinkedHashMap 中获取，区分大小写</td><td align="center">实际是从 LinkedHashMap 中获取，区分大小写</td><td align="center">从 LinkedCaseInsensitiveMap 获取，不区分大小写</td></tr><tr><td align="center">使用 HttpHeaders 获取请求头</td><td align="center">从 LinkedCaseInsensitiveMap 获取，不区分大小写</td><td align="center">从 LinkedCaseInsensitiveMap 获取，不区分大小写</td><td align="center">从 LinkedCaseInsensitiveMap 获取，不区分大小写</td></tr><tr><td align="center">使用 HttpServletRequest 获取</td><td align="center">使用 HttpString.hashCodeOf(headerName) 忽略了大小写</td><td align="center">调用 MimeHeaders#getValue 忽略了大小写</td><td align="center">HttpFields#get 忽略了大小写</td></tr></tbody></table><p>通过表格发现，即使是不同的容器在使用 HttpHeaders 获取请求头是都是调用了 Spring 的 <code>LinkedCaseInsensitiveMap</code> 获取 header，并且内部忽略了大小写，这里比较推荐使用。</p><p>同样使用 HttpServletRequest 的方式获取也比较推荐。</p><h4 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h4><p>本文主要是分析生产遇到的一个问题，然后开始探究原因，开始的时候发现是 Spring 的原因，因为使用 Map 接收时， headerName 什么格式就是什么格式。</p><p>在自己写 demo 时又发现，原来和 Spring 的关系并不大，是容器的原因。不同的容器处理方式不同。所以总结出来相关文章，供大家参考，不足之处，欢迎指正。</p><h4 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h4><ol><li>本文源码地址：<a href="https://github.com/liuzhihang/header-demo">https://github.com/liuzhihang/header-demo</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【工作笔记】- 几行代码轻松实现跨系统传递 traceId，再也不用担心对不上日志了！</title>
      <link href="2020/10/18/log-trace-id.html"/>
      <url>2020/10/18/log-trace-id.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>前言</strong></p><br><p>新项目查日志太麻烦，多台机器之间查来查去，还不知道是不是同一个请求的。打印日志时使用 MDC 在日志上添加一个 traceId，那这个 traceId 如何跨系统传递呢？</p></blockquote><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>同样是新项目开发的笔记，因为使用的是分布式架构，涉及到各个系统之间的交互</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/hHJYwn-b0KzBU.png" alt="hHJYwn-b0KzBU"></p><p>这时候就会遇到一个很常见的问题：</p><ol><li>单个系统是集群部署，日志分布在多台服务器上；</li><li>多个系统的日志在多台机器，但是一次请求，查日志更是难上加难。</li></ol><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/53_b91a8fc194febf0f3d3edf032e6cf78d-dSqBDj.jpg" alt="53_b91a8fc194febf0f3d3edf032e6cf78d-dSqBDj"></p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ol><li>使用 SkyWalking traceid 进行链路追踪；</li><li>使用 Elastic APM 的 trace.id 进行链路追踪；</li><li>自己生成 traceId 并 put 到 MDC 里面。</li></ol><h3 id="MDC"><a href="#MDC" class="headerlink" title="MDC"></a>MDC</h3><p>MDC（Mapped Diagnostic Context）是一个映射，用于存储运行上下文的特定线程的上下文数据。因此，如果使用log4j进行日志记录，则每个线程都可以拥有自己的MDC，该MDC对整个线程是全局的。属于该线程的任何代码都可以轻松访问线程的MDC中存在的值。</p><h4 id="如何使用-MDC"><a href="#如何使用-MDC" class="headerlink" title="如何使用 MDC"></a>如何使用 MDC</h4><ol><li>在 <strong>log4j2-spring.xml</strong> 的日志格式中添加 <code>%X&#123;traceId&#125;</code> 配置。</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">&quot;LOG_PATTERN&quot;</span>&gt;</span></span><br><span class="line">    [%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;]-[%t]-[%X&#123;traceId&#125;]-[%-5level]-[%c&#123;36&#125;:%L]-[%m]%n</span><br><span class="line"><span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">&quot;LOG_PATTERN_ERROR&quot;</span>&gt;</span></span><br><span class="line">    [%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;]-[%t]-[%X&#123;traceId&#125;]-[%-5level]-[%l:%M]-[%m]%n</span><br><span class="line"><span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 省略 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--这个输出控制台的配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">&quot;Console&quot;</span> <span class="attr">target</span>=<span class="string">&quot;SYSTEM_OUT&quot;</span> <span class="attr">follow</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--输出日志的格式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>  <span class="attr">pattern</span>=<span class="string">&quot;$&#123;LOG_PATTERN&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>新增拦截器</li></ol><p>拦截所有请求，从 header 中获取 traceId 然后放到 MDC 中，如果没有获取到，则直接用 UUID 生成一个。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TRACE_ID = <span class="string">&quot;traceId&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception arg3)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView arg3)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        String traceId = request.getHeader(TRACE_ID);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(traceId)) &#123;</span><br><span class="line">            MDC.put(TRACE_ID, UUID.randomUUID().toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            MDC.put(TRACE_ID, traceId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>配置拦截器</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> LogInterceptor logInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(logInterceptor)</span><br><span class="line">                .addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="跨服务之间如何传递-traceId"><a href="#跨服务之间如何传递-traceId" class="headerlink" title="跨服务之间如何传递 traceId"></a>跨服务之间如何传递 traceId</h4><ul><li>FeignClient</li></ul><p>因为这边使用的是 FeignClient 进行服务之间的调用，只需要新增请求拦截器即可</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignInterceptor</span> <span class="keyword">implements</span> <span class="title">RequestInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TRACE_ID = <span class="string">&quot;traceId&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(RequestTemplate requestTemplate)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        requestTemplate.header(TRACE_ID, MDC.get(TRACE_ID));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Dubbo</li></ul><p>如果是 Dubbo 可以通过扩展 Filter 的方式传递 traceId</p><ol><li>编写 filter</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Activate(group = &#123;&quot;provider&quot;, &quot;consumer&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TraceIdFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        RpcContext rpcContext = RpcContext.getContext();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String traceId;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rpcContext.isConsumerSide()) &#123;</span><br><span class="line"></span><br><span class="line">            traceId = MDC.get(<span class="string">&quot;traceId&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (traceId == <span class="keyword">null</span>) &#123;</span><br><span class="line">                traceId = UUID.randomUUID().toString();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            rpcContext.setAttachment(<span class="string">&quot;traceId&quot;</span>, traceId);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rpcContext.isProviderSide()) &#123;</span><br><span class="line">            traceId = rpcContext.getAttachment(<span class="string">&quot;traceId&quot;</span>);</span><br><span class="line">            MDC.put(<span class="string">&quot;traceId&quot;</span>, traceId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> invoker.invoke(invocation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>指定 filter</li></ol><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line"> |-main</span><br><span class="line">    |-java</span><br><span class="line">        |-com</span><br><span class="line">            |-xxx</span><br><span class="line">                |-XxxFilter.java (实现Filter接口)</span><br><span class="line">    |-resources</span><br><span class="line">        |-META-INF</span><br><span class="line">            |-dubbo</span><br><span class="line">                |-org.apache.dubbo.rpc.Filter (纯文本文件，内容为：xxx=com.xxx.XxxFilter)</span><br></pre></td></tr></table></figure><p>截图如下：</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/STZ8hr-q8AmQ6.png" alt="STZ8hr-q8AmQ6"></p><p>测试结果如下：</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/FKroew-oE1qSz.png" alt="FKroew-oE1qSz"></p><blockquote><p>dubbo filter 相关源码地址在文末<br>也可以关注公众号，发送 traceid 获取</p></blockquote><h4 id="其他方式"><a href="#其他方式" class="headerlink" title="其他方式"></a>其他方式</h4><p>当然如果小伙伴们有使用 SkyWalking 或者 Elastic APM 也可以通过以下方式进行注入：</p><ol><li>SkyWalking</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.skywalking<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>apm-toolkit-log4j-2.x<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>&#123;project.release.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span></span></span><br></pre></td></tr></table></figure><p>然后将 <code>[%traceId]</code> 配置在 log4j2.xml 文件的 pattern 中即可</p><ol start="2"><li><p>Elastic APM</p><ol><li>在启动时指定 enable_log_correlation 为 true</li><li>将 <code>%X&#123;trace.id&#125;</code> 配置在 log4j2.xml 文件的 pattern 中</li></ol></li></ol><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><h4 id="统一日志采集"><a href="#统一日志采集" class="headerlink" title="统一日志采集"></a>统一日志采集</h4><p>虽然有了 traceId 可以进行全链路追踪查询日志，但是毕竟也是在多台服务器上，为了提高查询效率，可以考虑将日志汇总到一起。</p><p>常用的使用方法就是基于 ELK 的日志系统：</p><ol><li>使用 filebeat 采集日志报送到 logstash</li><li>logstash 进行分词过滤等处理，输出到 Elasticsearch</li><li>使用 Kinbana 或者自己开发的可视化工具从 Elasticsearch 查询日志</li></ol><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/aBn5LF-utuTLx.png" alt="aBn5LF-utuTLx"></p><h4 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h4><p>本文主要记录近期开发过程中的遇到的一点问题，希望对小伙伴也有所帮助。不足之处，欢迎指正。如果小伙伴有其他的建议或者观点欢迎留言讨论，共同进步。</p><h4 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h4><ol><li>Log4j 2 API：<a href="https://logging.apache.org/log4j/2.x/manual/thread-context.html">https://logging.apache.org/log4j/2.x/manual/thread-context.html</a></li><li>SkyWalking：<a href="https://github.com/apache/skywalking/tree/master/docs/en/setup/service-agent/java-agent">https://github.com/apache/skywalking/tree/master/docs/en/setup/service-agent/java-agent</a></li><li>Elastic APM：<a href="https://www.elastic.co/guide/en/apm/agent/java/current/log-correlation.html">https://www.elastic.co/guide/en/apm/agent/java/current/log-correlation.html</a></li><li>Dubbo filter：<a href="http://dubbo.apache.org/zh-cn/docs/dev/impls/filter.html">http://dubbo.apache.org/zh-cn/docs/dev/impls/filter.html</a></li><li>本文 Dubbo filter demo：<a href="https://github.com/liuzhihang/trace">https://github.com/liuzhihang/trace</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
          <category> 链路追踪 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作笔记 </tag>
            
            <tag> 链路追踪 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【工作笔记】- 老大问我：“建表为啥还设置个自增 id ？用流水号当主键不正好么？”</title>
      <link href="2020/10/11/work-trans-why-table-id.html"/>
      <url>2020/10/11/work-trans-why-table-id.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>又要开始新项目了，一顿操作猛如虎，梳理流程加画图。这不，开始对流程及表结构了。<br><br><br>我：吧啦吧啦吧啦 ……<br>老大：这个建表为啥还设置个自增 id ？直接用流水号（用户号/产品号）当主键不就行了？<br>我：这个是 DBA 规定的，创建表 id、create_time、update_time 这三个字段都要有。《Java 开发规范》也是这么规定的。<br>小伙伴：（附和）是的，规定的是这样的！<br>老大：流水号在你这是唯一索引吧？设置成主键，这样就不用 id 了，还减少一次回表查询？<br>我：…… （说的好像很有道理，咱也不敢说话。）<br>老大：既然他们规定了，那你回去查一下为什么要设计个自增 id ？<br>我：掏出小本本（回去查资料~）。</p></blockquote><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/why-id-8ZFv04.jpg" alt="why-id-8ZFv04"></p><h3 id="建表规约"><a href="#建表规约" class="headerlink" title="建表规约"></a>建表规约</h3><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/create-db-id-Gv58zQ.png" alt="Java 开发手册-嵩山版"></p><p>在工作中，创建表的时候，DBA 也会审核一下建表 SQL，检查是否符合规范以及常用字段是否设置索引。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`xxxx`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">&#x27;自增主键&#x27;</span>,</span><br><span class="line">  <span class="string">`create_time`</span> datetime(<span class="number">3</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">current_timestamp</span>(<span class="number">3</span>) <span class="keyword">COMMENT</span> <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  <span class="string">`update_time`</span> datetime(<span class="number">3</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">current_timestamp</span>(<span class="number">3</span>) <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">current_timestamp</span>(<span class="number">3</span>) <span class="keyword">COMMENT</span> <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_create_time`</span> (<span class="string">`create_time`</span>) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_update_time`</span> (<span class="string">`update_time`</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">5</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COMMENT</span>=<span class="string">&#x27;表注释&#x27;</span>;</span><br></pre></td></tr></table></figure><p>所以在我使用的过程中，流水号都是单独设置了一个字段，比如叫 trans_no，但是这次就遇到了疑问：trans_no 既然是唯一的，那为什么不直接用 trans_no 当做 id 呢？</p><p>下面开始通过查阅相关资料，一步一步的了解是为什么？</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/why-id-2-pMeutc.jpg" alt="why-id-2-pMeutc"></p><h3 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h3><h4 id="什么是主键"><a href="#什么是主键" class="headerlink" title="什么是主键"></a>什么是主键</h4><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/MySQL-primary-key-z64UFB.png" alt="MySQL-primary-key-z64UFB"></p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_primary_key">https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_primary_key</a></p><p>这段定义咱们主要关注最后一句：</p><blockquote><p>When choosing primary key values, consider using arbitrary values (a <strong>synthetic key</strong>) rather than relying on values derived from some other source (a <strong>natural key</strong>).</p></blockquote><p>意思是创建主键的时候尽量使用 MySQL 自增主键而不是使用业务生成的值当做主键。</p><h4 id="主键的特征"><a href="#主键的特征" class="headerlink" title="主键的特征"></a>主键的特征</h4><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/MySQL-primary-key-1-QDuU4H.png" alt="MySQL-primary-key-1-QDuU4H"></p><p>简而言之：</p><p>非空、唯一、少更改或不更改 。</p><h4 id="如何添加主键"><a href="#如何添加主键" class="headerlink" title="如何添加主键"></a>如何添加主键</h4><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/hfPeDL-r5M5YU.png" alt="hfPeDL-r5M5YU"></p><p>可以在 create 创建表的时候指定，也可以使用 alter 语句后面添加主键，不过官方建议在创建表时就指定。</p><h4 id="为什么要添加主键"><a href="#为什么要添加主键" class="headerlink" title="为什么要添加主键"></a>为什么要添加主键</h4><ol><li>主键可以唯一标识这一行数据，从而保证在删除更新操作时，只是操作这一行数据。</li><li>索引需要，每个 InnoDB 表又有一个特殊的索引，即聚簇索引，用来存储行数据。通常，聚簇索引和主键同义。<ol><li>声明主键，InnoDB 会将主键作为聚簇索引。</li><li>未声明时，会在 UNIQUE 所有键列所在位置找到第一个索引，NOT NULL 并将其作为聚簇索引</li><li>未声明且找不到合适的 UNIQUE 索引，则内部生成一个隐藏的聚簇索引 GEN_CLUST_INDEX，这个隐藏的行 ID 是 6 字节且单调增加。</li></ol></li></ol><p>图 -&gt; 那什么是索引</p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>这里仅介绍 InnoDB 引擎，具体可以参考官方文档，并且介绍的相对比较简单。</p><h4 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h4><ol><li>聚簇索引：表存储是根据主键列的值组织的，以加快涉及主键列的查询和排序。在介绍主键时也对聚簇索引进行了介绍。</li><li>二级索引：也可以叫辅助索引，在辅助索引中会记录对应的主键列以及辅助索引列。根据辅助索引进行搜索的时候，会先根据辅助索引获取到对应的主键列，然后再根据主键去聚簇索引里面搜索。<strong>一般不建议主键很长，因为主键很长辅助索引就会使用更多的空间。</strong></li></ol><blockquote><p><strong>补充：</strong></p><p>回表：先在二级索引查询到对应的主键值，然后根据主键再去聚簇索引里面取查询。<br>索引覆盖：二级索引记录了主键列和二级索引列，如果我只查询主键列的值和二级索引列的值，那就不需要回表了。</p></blockquote><h4 id="索引的物理结构"><a href="#索引的物理结构" class="headerlink" title="索引的物理结构"></a>索引的物理结构</h4><p>InnoDB 使用的 B+ 数数据结构，根据聚簇索引值（主键/UNQIUE/或者自己生成）构建一颗 B+ 树，叶子节点中存放行记录数据，所以每个叶子节点也可以叫数据页。每个数据页大小默认为 16k，支持自定义。</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/B+Tree-UgFQjS.png" alt="B+Tree-UgFQjS"></p><h4 id="数据的插入"><a href="#数据的插入" class="headerlink" title="数据的插入"></a>数据的插入</h4><p>当数据插入时，InnoDB 会使页面 1/16 空闲，以备将来插入和更新索引记录。</p><ol><li>顺序插入（升序或降序）：会将索引页剩余的大约 15/16 装满</li><li>随机插入：只会使用容量的 1/2 到 15/16</li></ol><p>在随机插入中，会频繁的移动、分页，从而造成大量的碎片，并且使索引树不够紧凑。而使用顺序插入的方式，则数据比较紧凑，有更高的空间利用率。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h4><p><strong>Q: 什么是回表和索引覆盖？</strong></p><p><strong>A:</strong></p><ol><li>回表：先在二级索引查询到对应的主键值，然后根据主键再去聚簇索引里面取查询。</li><li>索引覆盖：二级索引记录了主键列和二级索引列，如果我只查询主键列的值和二级索引列的值，那就不需要回表了。</li></ol><p><strong>Q: 为什么要设置自增主键 id ？</strong></p><p><strong>A:</strong></p><ol><li>可以唯一标识一行数据，在 InnoDB 构建索引树的时候会使用主键。</li><li>自增 id 是顺序的，可以保证索引树上的数据比较紧凑，有更高的空间利用率以及减少数据页的分裂合并等操作，提高效率。</li><li>一般使用手机号、身份证号作为主键等并不能保证顺序性。</li><li>流水号一般相对较长，比如 28 位，32 位等，过长的话会二级索引占用空间较多。同时为了业务需求，流水号具有一定的随机性。</li></ol><h4 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h4><p>本文主要通过查阅资料，了解为什么要设置一个和业务无关的自增 id 用来当做主键，很多内容比较浅显，比如 InnoDB 的 B+ 树，页分裂及页合并，插入过程等都没有进行深入研究，有兴趣的小伙伴可以更深入的研究下。</p><p>同时在建表时除了要设置一个自增 id 用来当做主键，小伙伴们在业务开发过程中是否也会遇到一种情况：用户的注销，数据的删除等都是进行的逻辑删除，而不是物理删除。</p><p>本篇文章介绍比较简陋，不足之处，希望大家多多指正。</p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JDK源码笔记】- 基于链表的有界阻塞队列 —— LinkedBlockingQueue</title>
      <link href="2020/10/04/source-code-linkedblockingqueue.html"/>
      <url>2020/10/04/source-code-linkedblockingqueue.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>前言</strong></p><br><p>上一节看了基于数据的有界阻塞队列 ArrayBlockingQueue 的源码，通过阅读源码了解到在 ArrayBlockingQueue 中入队列和出队列操作都是用了 ReentrantLock 来保证线程安全。下面咱们看另一种有界阻塞队列：LinkedBlockingQueue。</p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>一个基于链接节点的，可选绑定的 BlockingQueue 阻塞队列。</p><p>对元素 FIFO（先进先出）进行排序。队列的头部是已在队列中停留最长时间的元素。队列的尾部是最短时间出现在队列中的元素。将新元素插入队列的尾部，并检索队列操作获取队列开头的元素。</p><p>基于连表的队列通常具有比基于数组的队列有更高的吞吐量，但是大多数并发应用程序中的可预测性较差。</p><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedBlockingQueueTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> LinkedBlockingQueue&lt;String&gt; QUEUE = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 入队列</span></span><br><span class="line">        QUEUE.put(<span class="string">&quot;put 入队列, 队列满则会阻塞等待&quot;</span>);</span><br><span class="line"></span><br><span class="line">        QUEUE.add(<span class="string">&quot;add 入队列, 队列满则会抛出异常&quot;</span>);</span><br><span class="line"></span><br><span class="line">        QUEUE.offer(<span class="string">&quot;offer 入队列, 队列满会返回 false&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 出队列</span></span><br><span class="line">        <span class="comment">// 队列空返回 null</span></span><br><span class="line">        String poll = QUEUE.poll();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 队列空会阻塞等待</span></span><br><span class="line">        String take = QUEUE.take();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 仅仅看一下最早入队列的元素</span></span><br><span class="line">        String peek = QUEUE.peek();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="问题疑问"><a href="#问题疑问" class="headerlink" title="问题疑问"></a>问题疑问</h4><ol><li>LinkedBlockingQueue 的实现原理是什么？</li><li>LinkedBlockingQueue 和 ArrayBlockingQueue 的区别是什么？</li></ol><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/LinkedBlockingQueue-uml-Ma14n3.png" alt="LinkedBlockingQueue-uml-Ma14n3"></p><h4 id="参数介绍"><a href="#参数介绍" class="headerlink" title="参数介绍"></a>参数介绍</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    E item;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * One of:</span></span><br><span class="line"><span class="comment">    * - 真正的后继节点</span></span><br><span class="line"><span class="comment">    * - 有值，表示后继者是head.next</span></span><br><span class="line"><span class="comment">    * - null，表示没有后继（这是最后一个节点）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(E x) &#123; item = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先在 LinkedBlockingQueue 中有一个静态内部类 Node<E> 支持泛型，下面看下其他字段：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 初始容量，如果没有，则为Integer.MAX_VALUE */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 当前元素数 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 链表头</span></span><br><span class="line"><span class="comment">* 不变的是: head.item == null</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 链表尾</span></span><br><span class="line"><span class="comment">* 不变的是: last.next == null</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 执行 take, poll 等操作需要获取到 takeLock */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 等待执行 take 操作的线程，会放入这个条件队列 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 执行 put, offer 等操作需要获取到 putLock */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 等待执行 put 操作的线程，会被放入这个条件队列 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建时指定容量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    last = head = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过构造函数可以看出，在初始化 LinkedBlockingQueue 时，如果不传入容量则会默认指定 Integer.MAX_VALUE。</p><h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><p>add 方法是直接调用的父类 AbstractQueue 的方法，内部调用的 LinkedBlockingQueue 自己实现的 offer 方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (offer(e))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Queue full&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要阅读的还是 LinkedBlockingQueue 的 put 和 offer 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 插入元</span></span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// Note: 所有put / take / etc中的约定是预设本地变量</span></span><br><span class="line">    <span class="comment">// 保持计数为负表示失败，除非置位。</span></span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 如果已经到最大容量，则等待 </span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">        enqueue(node);</span><br><span class="line">        <span class="comment">// 总数进行增加， 返回的是先前的容量</span></span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        <span class="comment">// 判断是否需要唤醒入队列阻塞的线程</span></span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 唤醒因调用 notEmpty 的 await 方法而被阻塞的线程</span></span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 为空抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="comment">// 如果已经到最大容量，返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (count.get() == capacity)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    putLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count.get() &lt; capacity) &#123;</span><br><span class="line">            enqueue(node);</span><br><span class="line">            c = count.getAndIncrement();</span><br><span class="line">            <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">                notFull.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">    <span class="keyword">return</span> c &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面两段代码可以看出 put 和 offer 的最大区别在于是否阻塞。 put 方法当队列达到指定容量时，会阻塞，等待有元素出队列。而 offer 方法会直接返回 false。</p><p>同时两个方法操作元素入队列都是调用的 enqueue(node) 方法，下面一起看下 enqueue 方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert putLock.isHeldByCurrentThread();</span></span><br><span class="line">    <span class="comment">// assert last.next == null;</span></span><br><span class="line">    last = last.next = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 enqueue 方法中，直接指定当前尾节点的 next 为传入的元素即可。</p><h4 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="comment">// 队列为空返回 null</span></span><br><span class="line">    <span class="keyword">if</span> (count.get() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    E x = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count.get() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = dequeue();</span><br><span class="line">            <span class="comment">// 减少队列元素计数，返回的是旧值</span></span><br><span class="line">            c = count.getAndDecrement();</span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">            <span class="comment">// 旧值大于 1 ，就是当前大于 0</span></span><br><span class="line">            <span class="comment">// 唤醒调用 notEmpty.await 等待的线程</span></span><br><span class="line">                notEmpty.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        <span class="comment">// 如果旧值等于 capacity 说明当前空了一个位置</span></span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E x;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 阻塞等待</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        &#125;</span><br><span class="line">        x = dequeue();</span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面代码可以看出 poll 和 take 方法逻辑大致相同。区别就是在当前队列为空时的处理逻辑。poll 在当前队列为空时返回 null，take 会阻塞等待，知道当前队列中有元素。</p><p>poll 和 take 都试用 dequeue() 方法从队列中获取元素。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert takeLock.isHeldByCurrentThread();</span></span><br><span class="line">    <span class="comment">// assert head.item == null;</span></span><br><span class="line">    Node&lt;E&gt; h = head;</span><br><span class="line">    Node&lt;E&gt; first = h.next;</span><br><span class="line">    h.next = h; <span class="comment">// help GC</span></span><br><span class="line">    head = first;</span><br><span class="line">    E x = first.item;</span><br><span class="line">    first.item = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dequeue() 方法逻辑就是获取头节点，并将 head 指向下一个节点。</p><h4 id="查看元素"><a href="#查看元素" class="headerlink" title="查看元素"></a>查看元素</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count.get() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Node&lt;E&gt; first = head.next;</span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> first.item;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>peek() 方法比较简单，直接获取 head 的元素值即可。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h4><p><strong>Q: LinkedBlockingQueue 的实现原理？</strong></p><p><strong>A:</strong> LinkedBlockingQueue 是基于链表实现的，内部使用 ReentrantLock 互斥锁，防止并发放置元素或者取出元素的冲突问题。</p><ol><li>take、poll、peek 等从队列中获取元素的操作共用 takeLock 锁。</li><li>add、put、offer 等向队列中添加元素的操作共同 putLock 锁。</li><li>notEmpty 和 notFull 是 Condition 类型，在 take 和 put 操作时，如果如果队列为空或者队列已满，会调用相应的 await 将线程放入条件队列。</li></ol><p><strong>Q: 入队列和出队列方法之间的区别是什么？</strong></p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>add</td><td>添加元素，队列满了，添加失败抛出遗产</td></tr><tr><td>offer</td><td>添加元素， 队列满了，添加失败，返回 false</td></tr><tr><td>put</td><td>添加元素，队列满了，阻塞等待</td></tr><tr><td></td><td></td></tr><tr><td>poll</td><td>弹出元素，队列为空则返回 null</td></tr><tr><td>take</td><td>弹出元素，队列为空则等待队列中有元素</td></tr><tr><td></td><td></td></tr><tr><td>peek</td><td>查看队列中放入最早的一个元素</td></tr></tbody></table><h4 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h4><p>LinkedBlockingQueue 使用和 ArrayBlockingQueue 并没有什么区别，内部实现都是使用的 ReentrantLock，可以对照着阅读。同时 Condition 这块也需要着重了解一下。</p>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码笔记 </tag>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JDK源码笔记】- AQS 都看完了，Condition 原理可不能少！</title>
      <link href="2020/10/01/source-code-condition.html"/>
      <url>2020/10/01/source-code-condition.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>前言</strong></p><br><p>在介绍 AQS 时，其中有一个内部类叫做 ConditionObject，当时并没有进行介绍，并且在后续阅读源码时，会发现很多地方用到了 Condition ，这时就会很诧异，这个 Condition 到底有什么作用？那今天就通过阅读 Condition 源码，从而弄清楚 Condition 到底是做什么的？当然阅读这篇文章的时候希望你已经阅读了 AQS、ReentrantLock 以及 LockSupport 的相关文章或者有一定的了解（<del>当然小伙伴也可以直接跳到文末看总结</del>）。</p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Object 的监视器方法：wait、notify、notifyAll 应该都不陌生，在多线程使用场景下，必须先使用 synchronized 获取到锁，然后才可以调用 Object 的 wait、notify。</p><p>Condition 的使用，相当于用 Lock 替换了 synchronized，然后用 Condition 替换 Object 的监视器方法。</p><p>Conditions（也称为条件队列或条件变量）为一种线程提供了一种暂停执行（等待），直到另一线程通知被阻塞的线程，某些状态条件现在可能为真。</p><p>因为访问到此共享状态信息发生在不同的线程中，因此必须对其进行保护，所以会使用某种形式的锁。等待条件提供的关键属性是它以原子地释放了关联的锁，并且挂起当前线程，就像 Object.wait 一样。</p><p>Condition 实例本质上要绑定到锁。 为了获得 Condition 实例，一般使用 Lock 实例的 newCondition() 方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">Condition con = lock.newCondition();</span><br></pre></td></tr></table></figure><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">// condition 实例依赖于 lock 实例</span></span><br><span class="line">    <span class="keyword">final</span> Condition notFull = lock.newCondition();</span><br><span class="line">    <span class="keyword">final</span> Condition notEmpty = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">new</span> Object[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> putPtr, takePtr, count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//  put 时判断是否已经满了</span></span><br><span class="line">            <span class="comment">// 则线程在 notFull 条件上排队阻塞</span></span><br><span class="line">            <span class="keyword">while</span> (count == items.length) &#123;</span><br><span class="line">                notFull.await();</span><br><span class="line">            &#125;</span><br><span class="line">            items[putPtr] = x;</span><br><span class="line">            <span class="keyword">if</span> (++putPtr == items.length) &#123;</span><br><span class="line">                putPtr = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++count;</span><br><span class="line">            <span class="comment">// put 成功之后，队列中有元素</span></span><br><span class="line">            <span class="comment">// 唤醒在 notEmpty 条件上排队阻塞的线程</span></span><br><span class="line">            notEmpty.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// take 时，发现为空</span></span><br><span class="line">            <span class="comment">// 则线程在 notEmpty 的条件上排队阻塞</span></span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            Object x = items[takePtr];</span><br><span class="line">            <span class="keyword">if</span> (++takePtr == items.length) &#123;</span><br><span class="line">                takePtr = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            --count;</span><br><span class="line">            <span class="comment">// take 成功，队列不可能是满的</span></span><br><span class="line">            <span class="comment">// 唤醒在 notFull 条件上排队阻塞的线程</span></span><br><span class="line">            notFull.signal();</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是官方文档的一个例子，实现了一个简单的 BlockingQueue ，看懂这里，会发现在<strong>同步队列</strong>中很多地方都是用的这个逻辑。必要的代码说明都已经在代码中进行注释。</p><h4 id="问题疑问"><a href="#问题疑问" class="headerlink" title="问题疑问"></a>问题疑问</h4><ol><li>Condition 和 AQS 有什么关系？</li><li>Condition 的实现原理是什么？</li><li>Condition 的等待队列和 AQS 的同步队列有什么区别和联系？</li></ol><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/condition-uml-rMKuf3.png" alt="condition-uml-rMKuf3"></p><p>通过 UML 可以看出，Condition 只是一个抽象类，它的主要实现逻辑是在 AQS 的内部类 ConditionObject 实现的。下面主要从 await 和 signal 两个方法入手，从源码了解 ConditionObject。</p><h4 id="创建-Condition"><a href="#创建-Condition" class="headerlink" title="创建 Condition"></a>创建 Condition</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">Condition con = lock.newCondition();</span><br></pre></td></tr></table></figure><p>一般使用 lock.newCondition() 创建条件变量。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Sync 集成 AQS</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">final</span> ConditionObject <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用的是 ReentrantLock 的源码，里面调用的 sync.newCondition()，Sync 继承 AQS，其实就是创建了一个 AQS 内部类的 ConditionObject 的实例。</p><p>这里需要注意的是 lock 每调用一次 <code>lock.newCondition()</code> 都会有一个新的 ConditionObject 实例生成，就是说一个 lock 可以创建多个 Condition 实例。</p><h4 id="Condition-参数"><a href="#Condition-参数" class="headerlink" title="Condition 参数"></a>Condition 参数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 条件队列的第一个节点 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line"><span class="comment">/** 条件队列的最后一个节点 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br></pre></td></tr></table></figure><h4 id="await-方法"><a href="#await-方法" class="headerlink" title="await 方法"></a>await 方法</h4><p>await 方法，会造成当前线程在等待，直到收到信号或被中断。</p><p>与此 Condition 相关联的锁被原子释放，并且出于线程调度目的，当前线程被禁用，并且处于休眠状态，直到发生以下四种情况之一：</p><ol><li>其他一些线程调用此 Condition 的 signal 方法，而当前线程恰好被选择为要唤醒的线程；</li><li>其他一些线程调用此 Condition 的 signalAll 方法；</li><li>其他一些线程中断当前线程，并支持中断线程挂起；</li><li>发生虚假唤醒。</li></ol><p>在所有情况下，在此方法可以返回之前，当前线程必须重新获取与此条件关联的锁。当线程返回时，可以保证保持此锁。</p><p>现在来看 AQS 内部的实现逻辑：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 响应中断</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">// 添加到条件队列尾部（等待队列）</span></span><br><span class="line">    <span class="comment">// 内部会创建 Node.CONDITION 类型的 Node</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="comment">// 释放当前线程获取的锁（通过操作 state 的值）</span></span><br><span class="line">    <span class="comment">// 释放了锁就会被阻塞挂起</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 节点已经不在同步队列中，则调用 park 让其在等待队列中挂着</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="comment">// 调用 park 阻塞挂起当前线程</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 说明 signal 被调用了或者线程被中断，校验下唤醒原因</span></span><br><span class="line">        <span class="comment">// 如果因为终端被唤醒，则跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// while 循环结束， 线程开始抢锁</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="comment">// 统一处理中断的</span></span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>await 方法步骤如下：</p><ol><li>创建 Node.CONDITION 类型的 Node 并添加到条件队列（ConditionQueue）的尾部；</li><li>释放当前线程获取的锁（通过操作 state 的值）</li><li>判断当前线程是否在同步队列（SyncQueue）中，不在的话会使用 park 挂起。</li><li>循环结束之后，说明已经已经在同步队列（SyncQueue）中了，后面等待获取到锁，继续执行即可。</li></ol><p>在这里一定要把条件队列和同步队列进行区分清楚！！</p><p>条件队列/等待队列：即 Condition 的队列<br>同步队列：AQS 的队列。</p><p>下面对 await 里面重要方法进行阅读：</p><ul><li>addConditionWaiter() 方法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = lastWaiter;</span><br><span class="line">    <span class="comment">// If lastWaiter is cancelled, clean out.</span></span><br><span class="line">    <span class="comment">// 判断尾节点状态，如果被取消，则清除所有被取消的节点</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建新节点，类型为 Node.CONDITION</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    <span class="comment">// 将新节点放到等待队列尾部</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>addConditionWaiter 方法可以看出，只是创建一个类型为 Node.CONDITION 的节点并放到条件队列尾部。同时通过这段代码还可以得出其他结论：</p><ol><li>条件队列内部的 Node，只用到了 thread、waitStatus、nextWaiter 属性；</li><li>条件队列是单向队列。</li></ol><p>作为对比，这里把条件队列和同步队列做出对比：</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/condition-node-7yUQjE.png" alt="condition-node-7yUQjE"></p><p><a href="https://mp.weixin.qq.com/s/u-0aRcTTsQNzkkMhoJP0lQ">AQS</a> 同步队列如下：</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/condition-aqs-n5Fs85.png" alt="condition-aqs-n5Fs85"></p><p>再来看下 Condition 的条件队列</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/condition-condition-A97bUS.png" alt="condition-condition-A97bUS"></p><p>waitStatus 在 AQS 中已经进行了介绍：</p><blockquote><ol><li>默认状态为 0；</li><li>waitStatus &gt; 0 (CANCELLED 1) 说明该节点超时或者中断了，需要从队列中移除；</li><li>waitStatus = -1 SIGNAL 当前线程的前一个节点的状态为 SIGNAL，则当前线程需要阻塞（unpark）；</li><li>waitStatus = -2 CONDITION -2 ：该节点目前在条件队列；</li><li>waitStatus = -3 PROPAGATE -3 ：releaseShared 应该被传播到其他节点，在共享锁模式下使用。</li></ol></blockquote><ul><li>fullyRelease 方法 （AQS）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前节点的 state</span></span><br><span class="line">        <span class="keyword">int</span> savedState = getState();</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">            failed = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> savedState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            node.waitStatus = Node.CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fullyRelease 方法是由 AQS 提供的，首先获取当前的 state，然后调用 release 方法进行释放锁。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>release 方法在 <a href="https://mp.weixin.qq.com/s/u-0aRcTTsQNzkkMhoJP0lQ">AQS</a> 中做了详细的介绍。它的主要作用就是释放锁，并且需要注意的是：</p><ol><li>fullyRelease 会一次性释放所有的锁，所以说不管重入多少次，在这里都会全部释放的。</li><li>这里会抛出异常，主要是在释放锁失败时，这时就会在 finally 里面将节点状态置为 Node.CANCELLED。</li></ol><ul><li>isOnSyncQueue(node)</li></ul><p>通过上面的流程，节点已经放到了<strong>条件队列</strong>并且释放了持有的<strong>锁</strong>，而后就会挂起阻塞，直到 signal 唤醒。但是在挂起时要保证节点已经不在同步队列（SyncQueue）中了才可以挂起。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOnSyncQueue</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前节点是条件队列节点，或者上一个节点是空</span></span><br><span class="line">    <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="keyword">null</span>) <span class="comment">// If has successor, it must be on queue</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从尾部开始遍历</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">findNodeFromTail</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    Node t = tail;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t == node)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        t = t.prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个节点（总是一个最初放置在条件队列中的节点）现在正等待在同步队列上重新获取，则返回true。</p><p>这段代码的主要作用判断节点是不是在同步队列中，如果不在同步队列中，后面才会调用 park 进行阻塞当前线程。这里就会有一个疑问：AQS 的同步队列和 Condition 的条件队列应该是无关的，这里为什么会要保证节点不在同步队列之后才可以进行阻塞？因为 signal 或者 signalAll 唤醒节点之后，节点就会被放到同步队列中。</p><p>线程到这里已经被阻塞了，当有其他线程调用 signal 或者 signalAll 时，会唤醒当前线程。</p><p>而后会验证是否因中断唤醒当前线程，这里假设没有发生中断。那 while 循环的 isOnSyncQueue(Node node) 必然会返回 true ，表示当前节点已经在同步队列中了。</p><p>后续会调用 <strong>acquireQueued(node, savedState)</strong> 进行获取锁。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否拿到资源</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 中断状态</span></span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 无限循环</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 当前节点之前的节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 前一个节点是头节点， 说明当前节点是 头节点的 next 即真实的第一个数据节点 （因为 head 是虚拟节点）</span></span><br><span class="line">            <span class="comment">// 然后再尝试获取资源</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">// 获取成功之后 将头指针指向当前节点</span></span><br><span class="line">                setHead(node); </span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// p 不是头节点， 或者 头节点未能获取到资源 （非公平情况下被别的节点抢占） </span></span><br><span class="line">            <span class="comment">// 判断 node 是否要被阻塞，获取不到锁就会一直阻塞</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是 AQS 的逻辑了，同样可以阅读 <a href="https://mp.weixin.qq.com/s/u-0aRcTTsQNzkkMhoJP0lQ">AQS</a> 的相关介绍。</p><blockquote><ol><li>不断获取本节点的上一个节点是否为 head，因为 head 是虚拟节点，如果当前节点的上一个节点是 head 节点，则当前节点为 <code>第一个数据节点&gt;</code>；</li><li>第一个数据节点不断的去获取资源，获取成功，则将 head 指向当前节点；</li><li>当前节点不是头节点，或者 <code>tryAcquire(arg)</code> 失败（失败可能是非公平锁）。这时候需要判断前一个节点状态决定<code>当前节点是否要被阻塞</code>（前一个节点状态是否为 SIGNAL）。</li></ol></blockquote><p>值得注意的是，当节点放到 AQS 的同步队列时，也是进行争抢资源，同时设置 <code>savedState</code> 的值，这个值则是代表当初释放锁的时候释放了多少重入次数。</p><p>总体流程画图如下：</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/condition-await-q4EBQx.png" alt="condition-await-q4EBQx"></p><h4 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否为当前持有线程</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// firstWaiter 头节点指向条件队列头的下一个节点</span></span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">            lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 将原来的头节点和同步队列断开</span></span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">                (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 判断节点是否已经在之前被取消了</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 enq 添加到 同步队列的尾部</span></span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">    <span class="comment">// node 的上一个节点 修改为 SIGNAL 这样后续就可以唤醒自己了</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>enq 同样可以阅读 <a href="https://mp.weixin.qq.com/s/u-0aRcTTsQNzkkMhoJP0lQ">AQS</a> 的代码 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="comment">// 尾节点为空 需要初始化头节点，此时头尾节点是一个</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不为空 循环赋值</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 enq 方法将节点放到 AQS 的同步队列之后，要将 node 的前一个节点的 waitStatus 设置为 Node.SIGNAL。signalAll 的代码也是类似。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h4><p><strong>Q: Condition 和 AQS 有什么关系？</strong></p><p><strong>A:</strong> Condition 是基于 AQS 实现的，Condition 的实现类 ConditionObject 是 AQS 的一个内部类，在里面共用了一部分 AQS 的逻辑。</p><p><strong>Q: Condition 的实现原理是什么？</strong></p><p><strong>A:</strong> Condition 内部维护一个条件队列，在获取锁的情况下，线程调用 await，线程会被放置在条件队列中并被阻塞。直到调用 signal、signalAll 唤醒线程，此后线程唤醒，会放入到 AQS 的同步队列，参与争抢锁资源。</p><p><strong>Q: Condition 的等待队列和 AQS 的同步队列有什么区别和联系？</strong><br><strong>A:</strong> Condition 的等待队列是单向链表，AQS 的是双向链表。二者之间并没有什么明确的联系。仅仅在节点从阻塞状态被唤醒后，会从等待队列挪到同步队列中。</p><h4 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h4><p>本文主要是阅读 Condition 的相关代码，不过省略了线程中断等逻辑。有兴趣的小伙伴。可以更深入的研究相关的源码。</p>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码笔记 </tag>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JDK源码笔记】- 基于数组的有界阻塞队列 —— ArrayBlockingQueue</title>
      <link href="2020/09/27/source-code-arrayblockingqueue.html"/>
      <url>2020/09/27/source-code-arrayblockingqueue.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>前言</strong></p><br><p>在阅读完和 AQS 相关的锁以及同步辅助器之后，来一起阅读 JUC 下的和队列相关的源码。先从第一个开始：ArrayBlockingQueue。</p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>由数组支持的有界BlockingQueue阻塞队列。</p><p>这个队列的命令元素FIFO（先入先出）。 队列的头是元素一直在队列中时间最长。 队列的尾部是该元素已经在队列中的时间最短。 新元素插入到队列的尾部，并且队列检索操作获取在队列的头部元素。</p><p>这是一个典型的“有界缓冲区”，在其中一个固定大小的数组保持由生产者插入并受到消费者的提取的元素。 一旦创建，容量不能改变。 试图put 一个元素到一个满的队列将导致操作阻塞; 试图 take 从空队列一个元素将类似地阻塞。</p><p>此类支持订购等待生产者和消费者线程可选的公平政策。 默认情况下，这个顺序不能保证。 然而，队列公平设置为构建 true 保证线程以FIFO的顺序进行访问。 公平性通常会降低吞吐量，但减少了可变性和避免饥饿。</p><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueueTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ArrayBlockingQueue&lt;String&gt; QUEUE = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CountDownLatch LATCH = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">2</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">1024</span>),</span><br><span class="line">                <span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(<span class="string">&quot;Thread-pool-%d&quot;</span>).build(),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        pool.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line"></span><br><span class="line">                    QUEUE.put(<span class="string">&quot;鸡蛋&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                    System.out.println(<span class="string">&quot;put 放入元素&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            LATCH.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        pool.submit(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500L</span>);</span><br><span class="line"></span><br><span class="line">                    String take = QUEUE.take();</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">&quot;take = &quot;</span> + take);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            LATCH.countDown();</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            LATCH.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>demo 只是临时写的一个，很简单的版本。</p><h4 id="问题疑问"><a href="#问题疑问" class="headerlink" title="问题疑问"></a>问题疑问</h4><ol><li>ArrayBlockingQueue 的实现原理是什么？</li><li>入队列和出队列方法之间的区别是什么？</li></ol><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/ArrayBlockingQueue-uml-37BHBp.png" alt="ArrayBlockingQueue-uml-37BHBp"></p><h4 id="参数介绍"><a href="#参数介绍" class="headerlink" title="参数介绍"></a>参数介绍</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** 数组 - 存储队列中的元素 */</span></span><br><span class="line"><span class="keyword">final</span> Object[] items;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 下一个 take, poll, peek or remove 的索引 */</span></span><br><span class="line"><span class="keyword">int</span> takeIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 下一个 put, offer, or add 的索引 */</span></span><br><span class="line"><span class="keyword">int</span> putIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 队列中的元素数 */</span></span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Main lock guarding all access */</span></span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** take 操作时是否等待 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** put 操作时是否等待 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(capacity, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定容量，及是否公平</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化的时候放入元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair,</span></span></span><br><span class="line"><span class="function"><span class="params">                            Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(capacity, fair);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock(); <span class="comment">// Lock only for visibility, not mutual exclusion</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (E e : c) &#123;</span><br><span class="line">                checkNotNull(e);</span><br><span class="line">                items[i++] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        count = i;</span><br><span class="line">        putIndex = (i == capacity) ? <span class="number">0</span> : i;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.add(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类的方法，其实调用的也是 offer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (offer(e))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Queue full&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == items.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            enqueue(e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 放入元素， 如果队列满了，则等待</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            notFull.await();</span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>add 方法：调用的是父类 AbstractQueue 的 add 方法，内部调用的是 offer 方法，如果 offer 返回 false，则抛出异常。</li><li>offer 方法：校验元素非空，加互斥锁，如果队列满了，则返回 false，如果队列未满，则调用 enqueue 方法，添加元素。</li><li>put 方法：校验元素非空，加互斥锁，如果队列满了，则一直自旋等待，队列未满则调用 enqueue 方法，添加元素。</li></ol><p>所以下面还是需要看一下 enqueue 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只有在获取锁的时候才可以调用</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="comment">// putIndex 下一个 put, offer, or add 的索引</span></span><br><span class="line">    <span class="comment">// 对其进行赋值，然后进行 ++putIndex 操作</span></span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    <span class="comment">// 如果等于长度，则指定为开始</span></span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">        putIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 对元素数进行 ++</span></span><br><span class="line">    count++;</span><br><span class="line">    <span class="comment">// 有元素入队列，唤醒在等待获取元素的线程</span></span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="keyword">null</span> : dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过源码可以看出：</p><ol><li>pool 和 take 都是从队列中获取元素，二者不同的是，当队列中没有元素时，poll 方法返回 null，而 take 方法会一直阻塞等待，直到从队列中获取到元素。</li><li>poll 和 take 方法获取元素都是调用的 dequeue 方法。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[takeIndex] != null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="comment">// 获取元素并将元素置为 null</span></span><br><span class="line">    E x = (E) items[takeIndex];</span><br><span class="line">    items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// takeIndex 下一个 take, poll, peek or remove 的索引</span></span><br><span class="line">    <span class="comment">// 指向下一个元素，并且 元素数减少</span></span><br><span class="line">    <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">        takeIndex = <span class="number">0</span>;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="comment">// 更新迭代器状态</span></span><br><span class="line">    <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line">    <span class="comment">// 唤醒等待放入元素的线程</span></span><br><span class="line">    notFull.signal();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查看元素"><a href="#查看元素" class="headerlink" title="查看元素"></a>查看元素</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> itemAt(takeIndex); <span class="comment">// null when queue is empty</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h4><p><strong>Q: ArrayBlockingQueue 的实现原理？</strong></p><p><strong>A:</strong> ArrayBlockingQueue 是基于数组实现的，内部使用 ReentrantLock 互斥锁，防止并发放置元素或者取出元素的冲突问题。</p><p><strong>Q: 入队列和出队列方法之间的区别是什么？</strong></p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>add</td><td>添加元素，队列满了，添加失败抛出遗产</td></tr><tr><td>offer</td><td>添加元素， 队列满了，添加失败，返回 false</td></tr><tr><td>put</td><td>添加元素，队列满了，阻塞等待</td></tr><tr><td></td><td></td></tr><tr><td>poll</td><td>弹出元素，队列为空则返回 null</td></tr><tr><td>take</td><td>弹出元素，队列为空则等待队列中有元素</td></tr><tr><td></td><td></td></tr><tr><td>peek</td><td>查看队列中放入最早的一个元素</td></tr></tbody></table><h4 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h4><p>ArrayBlockingQueue 中使用了 ReentrantLock 互斥锁，在元素入队列和出队列的时候都进行了加锁，所以同时只会有一个线程进行入队列或者出队列，从而保证线程安全。</p>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码笔记 </tag>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JDK源码笔记】- 使用递增计数器的线程同步工具 —— 信号量，它的原理是什么样子的？</title>
      <link href="2020/09/21/source-code-semaphore.html"/>
      <url>2020/09/21/source-code-semaphore.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>前言</strong></p><br><p>在 JUC 中线程同步器除了 CountDownLatch 和 CycleBarrier ，还有一个叫做 Semaphore （信号量），同样是基于 AQS 实现的。下面来看看信号量的内部原理。</p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>一个计数信号量。 从概念上讲，信号量维护了一组许可。 如果有必要，在许可可用之前调用 acquire 方法会被阻塞，直到许可证可用。 调用 release 方法会增加了一个许可证，从而释放被阻塞的线程。 </p><ol><li>声明时指定初始许可数量。</li><li>调用 acquire(int permits) 方法，指定目标许可数量。</li><li>调用 release(int permits) 方法，发布指定的许可数量。</li></ol><p>在许可数量没有到达指定目标数量时，调用 acquire 方法的线程会被阻塞。</p><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Semaphore SEMAPHORE = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">5</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">1024</span>),</span><br><span class="line">                <span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(<span class="string">&quot;Thread-pool-%d&quot;</span>).build(),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            pool.submit(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span> + <span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;当前线程: &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; 发布一个许可&quot;</span>);</span><br><span class="line">                SEMAPHORE.release(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----&gt; 这里是主线程&quot;</span>);</span><br><span class="line"></span><br><span class="line">        SEMAPHORE.acquire(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----&gt; 主线程执行完毕&quot;</span>);</span><br><span class="line"></span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-----&gt; 这里是主线程</span><br><span class="line">当前线程: Thread-pool-2 发布一个许可</span><br><span class="line">当前线程: Thread-pool-4 发布一个许可</span><br><span class="line">当前线程: Thread-pool-1 发布一个许可</span><br><span class="line">当前线程: Thread-pool-0 发布一个许可</span><br><span class="line">当前线程: Thread-pool-3 发布一个许可</span><br><span class="line">-----&gt; 主线程执行完毕</span><br></pre></td></tr></table></figure><p>上面这个方法也是模拟了类似 CountDownLatch 的用法， 在子线程执行完毕之后，主线程继续执行。只不过 Semaphore 和 CountDownLatch 区别最大的是：</p><p>Semaphore 是从指定数值开始增加，直到到达许可数量，然后被阻塞线程开始继续执行。</p><p>CountDownLatch 是从指定数量的线程开始减少，直到为 0 时，被阻塞的线程开始继续执行。</p><p>当然这只是最简单的用法，除此让主线程等待，同样也可以让其他线程等待，然后再开始执行。</p><h4 id="问题疑问"><a href="#问题疑问" class="headerlink" title="问题疑问"></a>问题疑问</h4><ol><li>Semaphore 和 AQS 有什么关系？</li><li>Semaphore 和 CountDownLatch 有什么区别？</li></ol><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/Semaphore-cover-iGaTzJ.png" alt="Semaphore-cover-iGaTzJ"></p><p>通过类图可以看出在 Semaphore 里面有一个静态内部类 Sync 继承了 AQS，同时为了区分公平和非公平的情况，Sync 分别有两个子类：NonfairSync 、FairSync。</p><p>下面根据案例分别从构造函数、acquire()、release() 入手，从而了解内部实现原理。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化默认非公平锁， 同时需要传入指定许可数， 可以看到这块代码是调用的 AQS 的 setState(permits) 方法。代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2694183684443567898L</span>;</span><br><span class="line"></span><br><span class="line">    NonfairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        <span class="keyword">super</span>(permits);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1192457210091910933L</span>;</span><br><span class="line"></span><br><span class="line">        Sync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">            setState(permits);</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>setState 方法其实就是对 AQS 的 state 进行赋值。</p><blockquote><p>补充</p><ol><li>在 ReentrantLock 中 state 代表加锁状态，0 没有线程获得锁，大于等于 1 已经有线程获得锁，大于 1 说明该获得锁的线程多次重入。</li><li>在 ReentrantReadWriteLock 中 state 代表锁的状态。state 为 0 ，没有线程持有锁，state 的高 16 为代表读锁状态，低 16 为代表写锁状态。通过位运算可以获取读写锁的实际值。</li><li>而在这里 （CountDownLatch）则代表门闩或者说计数的值。</li></ol></blockquote><p>如果对 state 有所遗忘，可以阅读前面的 AQS 、CAS 相关代码。 state 在这里代表的是信号量的许可数量。</p><h4 id="acquire"><a href="#acquire" class="headerlink" title="acquire()"></a>acquire()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> permits)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    sync.acquireSharedInterruptibly(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>acquire() 和 acquire(int permits) 调用的都是 sync.acquireSharedInterruptibly(permits) 方法，只不过一个支持传递参数，一个默认为 1。</p><p>acquireSharedInterruptibly 方法，其实就是 Sync 继承自 AQS 的。</p><p>这块可以阅读 AQS 的文章，这里简单介绍下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在失败后会使用 <code>doAcquireSharedInterruptibly(arg);</code> 不断获取资源；</li><li><code>final Node node = addWaiter(Node.SHARED);</code> 会创建节点以共享模式放到队列里；</li><li>在循环中不断判断前一个节点，如果是 head，则尝试获取共享资源；</li><li>在共享模式下获取到资源后会使用 <code>setHeadAndPropagate(node, r);</code> 设置头节点，同时唤醒后续节点。</li></ol><p>tryAcquireShared 是需要子类实现，也就是在 Semaphore.Sync 的实现类中实现了，这里以 FairSync 做讲解：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2014338818796000944L</span>;</span><br><span class="line"></span><br><span class="line">    FairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        <span class="keyword">super</span>(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 如果前面有节点，则直接返回 -1 表示失败</span></span><br><span class="line">            <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 获取当前信号量</span></span><br><span class="line">            <span class="keyword">int</span> available = getState();</span><br><span class="line">            <span class="comment">// 获取当前剩余量</span></span><br><span class="line">            <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">            <span class="comment">// 如果小于 0 或者 CAS 设置信号量成功 则直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                compareAndSetState(available, remaining))</span><br><span class="line">                <span class="keyword">return</span> remaining;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">而这段代码的含义：</span><br><span class="line"><span class="number">1.</span> 如果前面有节点，则直接阻塞；</span><br><span class="line"><span class="number">2.</span> 如果当前剩余信号量小于 <span class="number">0</span> ，则返回负值，直接阻塞；</span><br><span class="line"><span class="number">3.</span> 如果当前剩余量大于等于 <span class="number">0</span> ，会 CAS 更新信号量，并返回非负数。</span><br><span class="line"></span><br><span class="line">&gt;这块数值的含义，在 AQS 中定义了，含义如下：</span><br><span class="line"></span><br><span class="line">&gt;<span class="number">1.</span> 小于 <span class="number">0</span>: 表示失败；</span><br><span class="line">&gt;<span class="number">2.</span> 等于 <span class="number">0</span>: 表示共享模式获取资源成功，但后续的节点不能以共享模式获取成功; </span><br><span class="line">&gt;<span class="number">3.</span> 大于 <span class="number">0</span>: 表示共享模式获取资源成功，后续节点在共享模式获取也可能会成功，在这种情况下，后续等待线程必须检查可用性。</span><br><span class="line"></span><br><span class="line">#### release()</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    sync.releaseShared(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发布许可证的给定数量，该数量增加可用的许可数量。 看其内部调用的是 Sync 的 releaseShared， 其实就是 AQS 的对应方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果实现tryReleaseShared返回true，以共享模式释放资源。 其中的 tryReleaseShared 部分由 Semaphore.Sync 中实现，逻辑如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 获取当前 state</span></span><br><span class="line">        <span class="keyword">int</span> current = getState();</span><br><span class="line">        <span class="comment">// 对 state 进行增加</span></span><br><span class="line">        <span class="keyword">int</span> next = current + releases;</span><br><span class="line">        <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum permit count exceeded&quot;</span>);</span><br><span class="line">        <span class="comment">// 使用 CAS 赋值</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面代码可以看出，在 Semaphore 的 release 方法中主要就是对 state 进行增加，增加成功后会调用 AQS 的 doReleaseShared 方法唤醒头节点。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h4><p><strong>Q: 既然 Semaphore 也是基于 AQS， 那在 Semaphore 中 state 的含义代表什么？</strong><br><strong>A:</strong> 在 Semaphore 中 state 代表许可数量，acquire 方法当许可小于指定数量会阻塞线程，release 方法增加许可当许可增加成功则唤醒阻塞节点。</p><p><strong>Q: Semaphore 基于 AQS 具体是怎么实现的呢？</strong><br><strong>A:</strong> </p><ol><li>初始设置 state 的初始值，即初始许可数量。</li><li>acquire 方法设置目标数量，当目标数量大于当前数量时，会阻塞线程并将其放到阻塞队列中。此处基于 AQS 实现。</li><li>release 对 state 进行增加，成功后会调用 AQS 的 doReleaseShared 唤醒头结点。同样是基于 AQS 实现。</li></ol><p><strong>Q: Semaphore 和 CountDownLatch 有什么区别？</strong><br><strong>A:</strong> Semaphore 的计数器是递加的，而 CountDownLatch 是递减的。相同点就是计数器都不可以重置。</p><h4 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h4><p>在阅读 Semaphore 源码过程中，发现其主要功能都是基于 AQS 实现的，可以回顾阅读 AQS 的相关笔记。同样 Semaphore 也支持公平和非公平模式，这块就需要小伙伴自己去阅读啦。</p>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码笔记 </tag>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【工作笔记】- 你有没有想过为什么交易和退款要拆开不同的表？</title>
      <link href="2020/09/19/work-trans-refund-table.html"/>
      <url>2020/09/19/work-trans-refund-table.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>前言</strong></p><br><p>近期做新项目，在设计表结构的时候，突然想起来之前面试的时候遇到的一个问题，那时候也是初出茅庐，对很多东西一知半解（当然现在也是），当时那个小哥哥问我为什么交易和退款要拆成两个表？是基于什么考虑？有什么好处和优点么？</p></blockquote><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>那是一个风和日丽的下午，当然，风和日丽的下午应该配点其他的形容词，实在是我才疏学浅，只能用这个词充当了下开头…… （此处省略小五千字）</p><p>赶紧进入正文！</p><p>因为之前一直做<strong>聚合支付</strong>，而在使用过程中，也是支付和退款表拆开的，一直这么用，并没有觉得不妥。</p><p>比如一个交易表基本就是这样的：</p><table><thead><tr><th>字段</th><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>id</td><td>bigint</td><td>主键 id</td></tr><tr><td>trans_id</td><td>varchar</td><td>交易订单号</td></tr><tr><td>trans_amount</td><td>bigint</td><td>订单金额</td></tr><tr><td>trans_status</td><td>tinyint</td><td>交易状态</td></tr><tr><td>……</td><td>……</td><td>……</td></tr><tr><td>create_time</td><td>datetime</td><td>创建时间</td></tr><tr><td>update_time</td><td>datetime</td><td>更新时间</td></tr></tbody></table><p>退款表是这样子的：</p><table><thead><tr><th>字段</th><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>id</td><td>bigint</td><td>主键 id</td></tr><tr><td>refund_id</td><td>varchar</td><td>退款订单号</td></tr><tr><td>origin_trans_id</td><td>varchar</td><td>原始交易订单号</td></tr><tr><td>refund_status</td><td>tinyint</td><td>退款状态</td></tr><tr><td>refund_amount</td><td>bigint</td><td>退款金额</td></tr><tr><td>……</td><td>……</td><td>……</td></tr><tr><td>create_time</td><td>datetime</td><td>创建时间</td></tr><tr><td>update_time</td><td>datetime</td><td>更新时间</td></tr></tbody></table><p>大概两个表就是这样子的吧！像一些其他字段就先省略了，平常用着也觉得没什么。</p><p>但是恰好那次那个小哥哥就问了这个问题，支付和退款为什么要分开记录？</p><p>当时也是确实是实力不允许，我只是说了就是这么用的，把正向流程和逆向流程拆开，分开实现逻辑，比较方便。</p><h3 id="个人见解"><a href="#个人见解" class="headerlink" title="个人见解"></a>个人见解</h3><p>这里说的不仅仅是交易和退款，同时泛指正向交易和逆向交易，比如充值和消费，借款和贷款，账户出账入账等等，下面仅说说个人见解，<strong>只做讨论</strong>，如果小伙伴有更好的说法，希望可以留言指出，共同学习。</p><h4 id="对账需要"><a href="#对账需要" class="headerlink" title="对账需要"></a>对账需要</h4><p>对账户而言，出款表和入款表最后两方的金额是能对的上的，也就是说<strong>收支平衡</strong>。</p><p>当然这个记在一个表里也是完全可以的。毕竟对出入账只是流水没有状态变化，比如出账中，入账中，等等，流水表完全可以记在一个里面，然后用字段进行标识是出账还是入账。</p><h4 id="拆表需要"><a href="#拆表需要" class="headerlink" title="拆表需要"></a>拆表需要</h4><p>在网上看资料经常会说<strong>分库分表</strong>，而像订单这种（交易/退款）完全两种业务，使用两张表相对而言比较合适，毕竟<strong>交易</strong>的订单相比退款订单要多的多。</p><h4 id="字段设计"><a href="#字段设计" class="headerlink" title="字段设计"></a>字段设计</h4><p>交易和退款是完全不同的两种业务，不像账户流水就是资金记录。</p><p>交易除了订单状态还有一些交易信息比如商户号、优惠金额、实付金额、交易渠道、商品 id 名称、备注等各种信息。</p><p>退款则是根据原单进行退款，需要记录原始订单号、退款金额（部分退款）、退款信息等。</p><p>虽然交易和退款总体上都包含 订单号、状态、金额等，但是如果强行放在一个表，就会导致以下问题：</p><ol><li>很多字段为空的情况，比如交易不需要原始订单号，退款需要存储原始订单号。本来可以设置索引来提高查询效率的字段也不太合适设置了。</li><li>状态也不一定可以完全兼容，像交易状态和退款状态就很难互相兼容。</li></ol><h4 id="开发效率"><a href="#开发效率" class="headerlink" title="开发效率"></a>开发效率</h4><p>交易和退款分开之后，两个人负责不同的业务进行开发，包括业务逻辑和查询展示。如果放在一起，就很多字段不能保证别人知道有还是没有，是存储还是不存储，毕竟表里设置的都可以为空。这种情况下需要很多沟通，或者干脆一个人进行开发。</p><h4 id="设计模式及原则"><a href="#设计模式及原则" class="headerlink" title="设计模式及原则"></a>设计模式及原则</h4><p>其他从设计模式及原则的角度上来说，可以说是职责单一，当然再高大上偏理论的我这就扯不出来了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h4><p><strong>Q: 那前端要将两种甚至多种在一个列表展示该如何处理？</strong></p><p><strong>A:</strong> 在很多 APP 中大家看到的多种订单都是在一个列表里面展示出来的，比如：支付宝的账单页面。</p><p>当然，如果前端分 tab 页，分开展示不同的业务，那对后端来说简直不要太友好。不过实际往往不是这样，这时候就需要将订单统一存储。</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/LDZJYc-IFUqcP.png" alt="LDZJYc-IFUqcP"></p><p>在订单成功的时候存储到一个公共存储中，可以通过 MQ 等，将数据保送到另一张表/库，或者 ES 中用来存储。这样订单查询还可以和业务逻辑的表/库分开。也可以通过 binlog 进行处理，这里的方案只做参考。</p><h4 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h4><p>之所以写这篇文章，也是为了总结一下最近工作中遇到的问题，以及处理方法。同时一瞬间想起来了很久前遇到的相同的问题。</p><p>如果小伙伴们还有别的看法，欢迎留言，发表自己的意见及看法，共同讨论。</p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JDK源码笔记】- CyclicBarrier 不就是比 CountDownLatch 多了个回环么？</title>
      <link href="2020/09/13/source-code-cyclicbarrier.html"/>
      <url>2020/09/13/source-code-cyclicbarrier.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>前言</strong></p><br><p>看完 CountDownLatch 正准备表示一番，突然看到了一个 CyclicBarrier —— 回环屏障。沃特？回环还屏障？说比 CountDownLatch 要多一个回环，那咱可得瞧一瞧，看一看了！</p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>一个同步辅助，它允许一组线程的所有等待彼此达成共同屏障点。 </p><p>CyclicBarrier 在涉及固定线程数且必须等待彼此的程序非常有用。 </p><p>该屏障被称为回环屏障 ，因为它在等待的线程被释放后可以被重新利用。</p><p>CyclicBarrier 支持一个可选的 Runnable 命令，该命令在障碍中的最后一个线程到达之后，但在释放任何线程之前，每个屏障点运行一次。</p><p>此屏障操作对于在任何一方继续之前更新共享状态很有用。</p><p>通过上面的源码注释基本可以得出以下结论：</p><ol><li>CyclicBarrier 和 CountDownLatch 类似，但它是一组线程等待，直到在其他线程中执行的一组操作完成为止。</li><li>CountDownLatch 是计数递减，结束后再调用 await 或者 countdown 都会立即返回，但是 CyclicBarrier 可以重置屏障。</li><li>CyclicBarrier 还可以传入参数 Runnable ，Runnable 会在释放线程之前执行。</li></ol><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>既然上面总结了三个结论，下面当然从三个方面演示如何使用的：</p><p><strong>- 屏障功能</strong> </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CyclicBarrier CYCLIC_BARRIER = <span class="keyword">new</span> CyclicBarrier(<span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> BrokenBarrierException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">10</span>, <span class="number">10</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">1024</span>),</span><br><span class="line">                <span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(<span class="string">&quot;Thread-pool-%d&quot;</span>).build(),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            pool.submit(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 开始执行&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行结束，准备调用 await&quot;</span>);</span><br><span class="line">                    CYCLIC_BARRIER.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程执行 —————————————— &gt;&gt;&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        CYCLIC_BARRIER.await();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程继续执行 —————————————— &gt;&gt;&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        pool.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面代码其实模拟了个类似 CountDownLatch 的功能，让所有线程等待，直到都调用 await 之后，各个线程继续执行，同时主线程也继续往下执行。</p><p>不过相对 CountDownLatch 的指定一个线程或多个等待，直到其他线程执行结束，等待的线程才继续执行来说，CyclicBarrier 相对来说还是逊色。</p><p>差别总结如下：</p><ol><li>CountDownLatch 是指定等待的线程，其他线程进行 countDown，等计数为 0 时，等待的线程继续执行。</li><li>CyclicBarrier 是一组线程调用 await 进行等待，当所有的都进入等待的时候，这一组就会一起冲破屏障继续执行。</li></ol><p><strong>- 回环功能</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CyclicBarrier CYCLIC_BARRIER = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> BrokenBarrierException, InterruptedException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ExecutorService pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">5</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">1024</span>),</span><br><span class="line">                <span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(<span class="string">&quot;Thread-pool-%d&quot;</span>).build(),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            pool.submit(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 开始执行&quot;</span>);</span><br><span class="line">                    CYCLIC_BARRIER.await();</span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 冲破屏障 &gt;&gt;&gt; 1&quot;</span>);</span><br><span class="line">                    CYCLIC_BARRIER.await();</span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 冲破屏障 &gt;&gt;&gt;&gt;&gt; 2&quot;</span>);</span><br><span class="line">                    CYCLIC_BARRIER.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://liuzhihang.com/oss/pic/article/carbon-gzpBD4.png" alt="carbon-gzpBD4"></p><p>上面演示的回环的用法。</p><p><strong>- 回环 Runnable</strong></p><p>这块只需要在声明的 CyclicBarrier 修改为以下即可：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CyclicBarrier CYCLIC_BARRIER = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行一次 Runnable &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>打印结果如下：</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://liuzhihang.com/oss/pic/article/carbon1-lHnKnA.png" alt="carbon1-lHnKnA"></p><p>可以看出只是在下一个计数开始之前，先执行 Runnable 。至于是不是在释放屏障之前，那很容易，直接 Debug 走一遭就知道了！专门录制了个视频：</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://liuzhihang.com/oss/pic/article/cyclicBarrier-vl-5Bz3Xa.mov" alt="cyclicBarrier-vl-5Bz3Xa"></p><p>通过 debug 可以看出<strong>Runnable 会在释放线程之前执行</strong>。</p><h4 id="问题疑问？"><a href="#问题疑问？" class="headerlink" title="问题疑问？"></a>问题疑问？</h4><ol><li>CyclicBarrier 和 AQS 有什么关系？</li><li>CyclicBarrier 的实现原理是什么？</li><li>CyclicBarrier 是如何实现回环的？</li></ol><p>下面就带着疑问去源码阅读，一探究竟！</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://liuzhihang.com/oss/pic/article/CleanShot-2020-09-12-KFzaCR0G@2x-seVhre.png" alt="CleanShot-2020-09-12-KFzaCR0G@2x-seVhre"></p><p>通过 UML 乍一看，CyclicBarrier 和 AQS 并无什么关系，那下面开始从<strong>参数</strong>、<strong>构造器</strong>、<strong>await()方法</strong>分别看源码。</p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrier</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 屏障的每次使用都表示为一个生成实例。</span></span><br><span class="line"><span class="comment">     * broken 表示屏障是否被打破。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generation</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> broken = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 锁 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">/** 条件等待，直到屏障 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition();</span><br><span class="line">    <span class="comment">/** 等待计数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parties;</span><br><span class="line">    <span class="comment">/* The command to run when tripped */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;</span><br><span class="line">    <span class="comment">/** 当前 generation 新创建的*/</span></span><br><span class="line">    <span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation();</span><br><span class="line">    <span class="comment">/** 仍在等待的 parties 数量，递减 为 0 会重置 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过上面可以看出：</p><p>内部使用了一个静态类 Generation ，它有什么功能呢？通过注释了解到，每次使用屏障的时候都会生成，具体有什么用，其实就是用来标示屏障是否被打破。</p><p>内部还有一个 parties 表示等待计数，count 表示仍在等待的计数。</p><p>那就继续往下看吧！</p><h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="keyword">this</span>.count = parties;</span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的入参有两个：</p><ul><li>parties（等待计数）：记录多少个线程调用 await 之后，才会一起打破屏障。</li><li>barrierAction：冲破屏障前执行的行为。</li><li>但是会同时对 parties 和 count 赋值为传入的 parties。</li></ul><p>单参数构造，其实就是将 barrierAction 赋值为 null。</p><h4 id="await-方法"><a href="#await-方法" class="headerlink" title="await() 方法"></a>await() 方法</h4><p>在示例中用的 <strong>await()</strong> 方法， 那就从 <strong>await()</strong> 方法入手：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>await() 才是重头戏， 先来根据源码注释，了解是干嘛的，看看作者怎么讲：</p><ol><li>等到所有各方都在此障碍上调用await。</li><li>如果当前线程不是最后到达的线程，则出于线程调度目的将其禁用，并使其处于休眠状态，直到发生以下情况之一：<ol><li>最后一个线程到达；</li><li>其他一些线程中断当前线程；</li><li>其他一些线程中断其他正在等待的线程之一；</li><li>等待屏障的时候其他线程超时；</li><li>其他一些线程在此屏障上调用 reset。</li></ol></li></ol><p>看到这些，咱们最想看的当然是 2.1 ，等待最后一个线程到达屏障，之后所有的线程一起继续执行。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">            TimeoutException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在这里用到了这个代</span></span><br><span class="line">        <span class="keyword">final</span> Generation g = generation;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (g.broken)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line">        <span class="comment">// 线程终中断标示</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对计数进行递减</span></span><br><span class="line">        <span class="keyword">int</span> index = --count;</span><br><span class="line">        <span class="comment">// 如果是 0 则</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">            <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                <span class="comment">// 不是 null 先执行行为</span></span><br><span class="line">                <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">// 这里不是新开线程</span></span><br><span class="line">                    command.run();</span><br><span class="line">                ranAction = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 下一代</span></span><br><span class="line">                nextGeneration();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 任务未成功时，即 ranAction 还是 false 打破屏障</span></span><br><span class="line">                <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">        <span class="comment">// 自旋</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 没有设置超时时间</span></span><br><span class="line">                <span class="keyword">if</span> (!timed)</span><br><span class="line">                <span class="comment">// 进入等待</span></span><br><span class="line">                    trip.await();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line">            <span class="comment">// 已经下一代了</span></span><br><span class="line">            <span class="keyword">if</span> (g != generation)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一大坨代码，完全没有看的欲望，直接划过去吧！</p><p>所以…… 直接看到了这里吧。</p><p>代码还是要阅读的，分开来看（异常流程省略）：</p><ol><li>使用了 ReentrantLock 互斥锁，因此对 count、broken 的修改是原子性的。</li><li>对 count 进行 –count 操作，这样就理解为什么说 count 是仍在等待的计数，或者说还有多少才能到达屏障点。</li><li>当 count 为 0 ，表示到达屏障点了<ol><li><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://liuzhihang.com/oss/pic/article/cyclicbarrier-amQMu4.png" alt="cyclicbarrier-amQMu4"></li><li>command 不为 null，会先执行 **command.run()**， 值得注意的是这里并不是新开了个线程。</li><li>**nextGeneration()**开始新的下一代，即重置 count 为 parties。</li><li>在 finally 里面使用 <strong>breakBarrier()</strong> 打破屏障。</li></ol></li><li>当 count 不是 0<ol><li>自旋，直到是 0.</li></ol></li></ol><p>这后面还有两个方法不能少：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 唤醒线程</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">    <span class="comment">// 更新 count 为 parties</span></span><br><span class="line">    count = parties;</span><br><span class="line">    <span class="comment">// 更新 Generation</span></span><br><span class="line">    generation = <span class="keyword">new</span> Generation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打破屏障，并唤醒全部</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">breakBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    generation.broken = <span class="keyword">true</span>;</span><br><span class="line">    count = parties;</span><br><span class="line">    trip.signalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="reset"><a href="#reset" class="headerlink" title="reset()"></a>reset()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        breakBarrier();   <span class="comment">// break the current generation</span></span><br><span class="line">        nextGeneration(); <span class="comment">// start a new generation</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将屏障重置为其初始状态，reset() 方法其实还是调用的 breakBarrier() 和 nextGeneration()，前者时打破当前代，后者是开始新的一轮。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>Q: CyclicBarrier 和 AQS 有什么关系？</strong><br><strong>A:</strong> 通过阅读源码，其实发现是使用了 ReentrantLock 互斥锁 以及 Condition 的等待唤醒功能。</p><p><strong>Q: CyclicBarrier 的实现原理是什么？</strong><br><strong>A:</strong> 内部含有两个计数，分别是 parties 和 count ，初始是二者相等，当有线程调用 await() 时，count 递减，只要 count 不为 0 ， 就会阻塞线程，直到 count 递减为 0 时，此时会所有线程一起释放，同时将 count 重置为 parties。</p><p><strong>Q: CyclicBarrier 是如何实现回环的？</strong><br><strong>A:</strong> 使用两个计数，count 递减，当 count 为 0 时，会重置为 parties，从而达到回环效果。</p><p><strong>Q: 为什么 count 的 –count 操作没有使用 CAS？</strong><br><strong>A:</strong> 因为已经 lock.lock() 了，使用了 ReentrantLock 锁能够保证 count 的原子性。</p><h4 id="CyclicBarrier-和-CountDownLatch-的区别"><a href="#CyclicBarrier-和-CountDownLatch-的区别" class="headerlink" title="CyclicBarrier 和 CountDownLatch 的区别"></a>CyclicBarrier 和 CountDownLatch 的区别</h4><ol><li>回环：CyclicBarrier 可以回环，重新计数。CountDownLatch 只能一轮。</li><li>计数器：CyclicBarrier 的计数器自己维护递减， CountDownLatch 的计数器维护则是交给使用者。</li><li>阻塞线程：CyclicBarrier 阻塞的是自身，当到达屏障后，所有被阻塞的线程一起释放。CountDownLatch 可以指定阻塞线程。</li></ol><h4 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h4><p>本文主要介绍了 CyclicBarrier 的常用方式，通过源码方式，分析如何达到屏障以及回环的效果。不对之处，请多指正。</p>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码笔记 </tag>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【工具册】- 给大家介绍下，这是我的流程图软件 —— draw.io</title>
      <link href="2020/09/06/source-tool-drawio.html"/>
      <url>2020/09/06/source-tool-drawio.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>前言</strong></p><br><p>之前推了一篇文章《<a href="https://mp.weixin.qq.com/s/Ktjcc_7XCPx6fU4Zn8Tmlg">十张图带大家看懂 ES 原理 ！明白为什么说：ES 是准实时的！</a>》，很多小伙伴都比较好奇在文章中的图是用的什么画图软件？看那么明显的手绘风格，当然是手画的啦！（开玩笑），其实我用的是 draw.io ，下面分享我的画图软件 —— draw.io 。</p></blockquote><h3 id="为什么需要画图？"><a href="#为什么需要画图？" class="headerlink" title="为什么需要画图？"></a>为什么需要画图？</h3><p>俗话说：“一图顶百字！”，好吧！这是我现想的俗话。</p><p>在新项目开发，技术分享，阅读代码笔记，或者面试的时候，画个流程图，架构图等等，比较直观，便于理解等。优点啥的就不多介绍了，这里主要介绍我的画图软件。</p><h4 id="基本要求"><a href="#基本要求" class="headerlink" title="基本要求"></a>基本要求</h4><ol><li>免费</li><li>使用方便</li><li>支持离线使用</li></ol><h4 id="用过的其他软件"><a href="#用过的其他软件" class="headerlink" title="用过的其他软件"></a>用过的其他软件</h4><ol><li>Visio：使用方便，在最开始的时候就是使用 Visio，不过只能在 Win 系统上使用。</li><li>ProcessOn：在线版，使用方便，很简洁。个人免费，不过限制文件数量。</li><li>OmniGraffle：Mac 客户端，收费，有很多功能，不过对我来说有点玩不熟练。</li><li>语雀：语雀也支持画简单的流程图。</li><li>其他一些，暂时没想起来的。</li></ol><p>体验了很多画图软件，最后还是（暂时）选择了 draw.io 。 原因很简单，支持多平台（网页/Win/Mac/Linux），开源免费，文件存储在本地，也可以选择存储位置。</p><p>下面简单介绍下 draw.io</p><h3 id="draw-io"><a href="#draw-io" class="headerlink" title="draw.io"></a>draw.io</h3><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>在线版可以直接访问 <a href="https://draw.io/">https://draw.io</a> 或者 <a href="https://app.diagrams.net/">https://app.diagrams.net/</a> 使用，进去之后如下所示：</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/draw-web-FlEHBo.png" alt="draw-web-FlEHBo"></p><p>可以选择存储，当然也有离线版本，即 drawio-desktop ，下载地址：<a href="https://github.com/jgraph/drawio-desktop">https://github.com/jgraph/drawio-desktop</a></p><p>选择对应的平台下载安装即可：</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/drawio-desktop-nj8Mpy.png" alt="drawio-desktop-nj8Mpy"></p><h4 id="设置语言"><a href="#设置语言" class="headerlink" title="设置语言"></a>设置语言</h4><p>打开 app 或者 进入 app 之后可以设置语言，如下：</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/drawio-desktop-1-sIyT2d.png" alt="drawio-desktop-1-sIyT2d"></p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/drawio-desktop-2-qmJ3XA.png" alt="drawio-desktop-2-qmJ3XA"></p><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p>都已经到这里了，就不用说怎么使用的了吧！下面展示之前画的图：</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/draw-1-slJldy.png" alt="draw-1-slJldy"></p><h4 id="手绘风格"><a href="#手绘风格" class="headerlink" title="手绘风格"></a>手绘风格</h4><p>那手绘风格是怎么画的呢？</p><p>秘籍就在右侧工具栏，选中 Sketch 选项，之后图片就会变为手绘风格的了！</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/draw-2-smWIKE.png" alt="draw-2-smWIKE"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本篇文章主要分享我常用的画图软件，有兴趣的小伙伴可以使用试一下。软件万万千，自己用的顺手的才是最重要的。不过 draw.io 还是比较推荐的。</p><p>后续我也会分享一些其他软件工具等，有兴趣的小伙伴可以关注以下。如果有什么比较有趣或生产力软件都可以给推荐下。</p>]]></content>
      
      
      <categories>
          
          <category> 工具册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具册 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JDK源码笔记】- 快来看看！AQS 和  CountDownLatch 有怎么样的关系？</title>
      <link href="2020/09/06/source-code-countdownlatch.html"/>
      <url>2020/09/06/source-code-countdownlatch.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>前言</strong></p><br><p>CountDownLatch 一个同步辅助工具，同样是基于 AQS 实现，本篇文件主要是介绍 CountDownLatch 的使用，以及源码。</p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>一个同步辅助工具，允许一个或多个线程等待，直到在其他线程中执行的一组操作完成为止</p><p>一个 CountDownLatch 初始化为给定计数。 在 await 方法阻塞，调用 countDown 方法会减少计数直到达到零，此后所有等待的线程被释放，任何后续调用 await 都会立即返回。 这是一次性的现象 - 计数不能复位。 如果你需要一个版本重置计数，请考虑使用CyclicBarrier 。</p><p>CountDownLatch 是一种通用的同步工具，可用于多种用途。 </p><ol><li>用作一个简单的开/关锁存器，或者门：所有线程调用await在门口等待，直到被调用 countDown 的线程打开。 </li><li>初始化计数为 N ，用一个线程等待，直到 N 个线程完成某项操作，或某些动作已经完成 N 次。</li></ol><p>CountDownLatch 一个有用的属性是，它不要求调用 countDown 线程等待计数到达零之前继续，它只是阻止任何线程通过await ，直到所有线程可以通过。</p><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>在我之前 CAS 那篇文章《<a href="https://mp.weixin.qq.com/s/nSZW-bZ_snQ0ZYyzeEBJiw">从JUC源码看CAS，我做了个笔记 ……</a>》中介绍 CAS 举例时使用了 CountDownLatch，其代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CasTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CountDownLatch LATCH = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> NUM_I = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> NUM_J = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger NUM_K = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                        NUM_I++;</span><br><span class="line">                        NUM_J++;</span><br><span class="line">                        NUM_K.incrementAndGet();</span><br><span class="line">                    &#125;</span><br><span class="line">                    LATCH.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        LATCH.await();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;NUM_I = &quot;</span> + NUM_I);</span><br><span class="line">        System.out.println(<span class="string">&quot;NUM_J = &quot;</span> + NUM_J);</span><br><span class="line">        System.out.println(<span class="string">&quot;NUM_K = &quot;</span> + NUM_K.get());</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单介绍下这段代码的主要逻辑及功能：</p><ol><li>CountDownLatch 初始化计数为 10 。</li><li>开 10 个线程去处理业务逻辑，业务逻辑结束会调用 LATCH.countDown() 对计数进行 -1 操作。</li><li>在 LATCH.await() 处会阻塞等待，直到 LATCH 的值为 0 ，即 10 个线程业务都处理结束。</li><li>然后主线程继续执行。</li></ol><h4 id="问题疑问"><a href="#问题疑问" class="headerlink" title="问题疑问"></a>问题疑问</h4><ol><li>CountDownLatch 和 AQS 有什么关系？</li><li>CountDownLatch 的实现原理是什么？</li></ol><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/uml-VAGlMb.png" alt="uml-VAGlMb"></p><p>通过类图可以看出，CountDownLatch 内部存在一个静态类 Sync，而 Sync 继承了 AbstractQueuedSynchronizer。具体内部是如何实现的，则下面通过源码和画图一步一步的进行介绍。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;count &lt; 0&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过初始化构造器可以看出，在 new 创建对象时必须传递一个 int 类型的非负数。实现逻辑可以看出，是创建了一个 Sync 对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4982264981922014374L</span>;</span><br><span class="line"></span><br><span class="line">    Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">        setState(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>之前在介绍 AQS 源码中已经介绍了 state 的含义，state 在不同子类中代表不同的含义。</p><ol><li>在 ReentrantLock 中 state 代表加锁状态，0 没有线程获得锁，大于等于 1 已经有线程获得锁，大于 1 说明该获得锁的线程多次重入。</li><li>在 ReentrantReadWriteLock 中 state 代表锁的状态。state 为 0 ，没有线程持有锁，state 的高 16 为代表读锁状态，低 16 为代表写锁状态。通过位运算可以获取读写锁的实际值。</li><li>而在这里 （CountDownLatch）则代表门闩或者说计数的值。</li></ol><h4 id="countDown"><a href="#countDown" class="headerlink" title="countDown"></a>countDown</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递减锁存器的计数：</p><ul><li>如果当前计数大于零，则递减。 </li><li>如果计数到达零，则释放所有等待的线程。</li><li>如果那么当前计数等于零没有任何反应。</li></ul><p>此处调用的是 AQS 的 releaseShard() 方法，释放共享资源。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AQS 代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 AQS 释放共享资源方法中 <strong>tryReleaseShared(arg)</strong> 部分是在 CountDownLatch 的内部类 Sync 中实现的，代码部分如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递减更新 state ，如果 state 为 0 则返回 false，否则返回 true 。</p><p>此时再对照上面 AQS 代码，发现：如果 tryReleaseShared 返回 true ，则会唤醒后续节点开始执行操作。所以也就是说，如果 state 不为 0，则不会唤醒后续节点，直到 state 为 0 。</p><h4 id="await"><a href="#await" class="headerlink" title="await"></a>await</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>导致当前线程等待，直到锁存器倒计数至零，除非线程被中断。</p><ul><li><p>如果当前计数为零，则此方法立即返回。</p></li><li><p>如果当前计数大于零，则当前线程用于线程调度目的，禁用并一直处于休眠状态的两件事情之一发生：</p><ul><li>因调用countDown方法使计数达到0; </li><li>其他某些线程中断当前线程。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AQS 定义了 tryAcquireShared 返回值分为 3 种：</p><ol><li>小于 0: 表示失败；</li><li>等于 0: 表示共享模式获取资源成功，但后续的节点不能以共享模式获取成功; </li><li>大于 0: 表示共享模式获取资源成功，后续节点在共享模式获取也可能会成功，在这种情况下，后续等待线程必须检查可用性。</li></ol><p>其中 tryAcquireShared 同样由 CountDownLatch 的内部类 Sync 中实现，内部逻辑主要是判断 state 的值，进行返回。</p><p>在内部实现中返回的值只有 1 和 -1 ，说明在 state == 0 时，返回 1 ，即唤醒后续节点。不等于 0 时，会阻塞。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>Q: CountDownLatch 和 AQS 有什么关系？</strong></p><p><strong>A:</strong> CountDownLatch 是基于 AQS 的共享模式实现的。</p><p><strong>Q: CountDownLatch 的实现原理是什么？</strong></p><p><strong>A:</strong> 可以参考上面的源码解析，进行总结介绍。 CountDownLatch 是基于 AQS 共享模式实现的，在初始化时必须传入计数，该计数实际上是 AQS 的 state 值。在 countDown 时对 state 进行递减，在 当 state 为 0 时 会唤醒 AQS 队列中的所有等待的节点 （因为是共享模式）。而 await 方法是判断 state 的值，如果不是 0 ，则所有线程在队列中阻塞，等待唤醒。</p><p><strong>Q: state 在代表的含义是什么？</strong><br><strong>A:</strong> </p><ol><li>在 ReentrantLock 中 state 代表加锁状态，0 没有线程获得锁，大于等于 1 已经有线程获得锁，大于 1 说明该获得锁的线程多次重入。</li><li>在 ReentrantReadWriteLock 中 state 代表锁的状态。state 为 0 ，没有线程持有锁，state 的高 16 为代表读锁状态，低 16 为代表写锁状态。通过位运算可以获取读写锁的实际值。</li><li>而在这里 （CountDownLatch）则代表门闩或者说计数的值。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码笔记 </tag>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Elasticsearch 技术分享】—— 十张图带大家看懂 ES 原理 ！明白为什么说：ES 是准实时的！</title>
      <link href="2020/08/29/technology-sharing-es-5.html"/>
      <url>2020/08/29/technology-sharing-es-5.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>前言</strong></p><br><p>说到 Elasticsearch ，其中最明显的一个特点就是 <em>near real-time</em> 准实时 —— 当文档存储在Elasticsearch中时，将在1秒内以几乎实时的方式对其进行索引和完全搜索。那为什么说 ES 是准实时的呢？</p></blockquote><h3 id="Lucene-和-ES"><a href="#Lucene-和-ES" class="headerlink" title="Lucene 和 ES"></a>Lucene 和 ES</h3><h4 id="Lucene"><a href="#Lucene" class="headerlink" title="Lucene"></a>Lucene</h4><p>Lucene 是 Elasticsearch所基于的 Java 库，它引入了按段搜索的概念。</p><p>Segment： 也叫段，类似于倒排索引，相当于一个数据集。</p><p>Commit point：提交点，记录着所有已知的段。</p><p>Lucene index： “a collection of segments plus a commit point”。由一堆 Segment 的集合加上一个提交点组成。</p><p>对于一个 Lucene index 的组成，如下图所示。</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/lucene-woYwZZ.png" alt="lucene-woYwZZ"></p><h4 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h4><p>一个 Elasticsearch Index 由一个或者多个 shard （分片） 组成。</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/es-shard-TjHfGE.png" alt="es-shard-TjHfGE"></p><p>而 Lucene 中的 Lucene index 相当于 ES 的一个 shard。</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/es-shard-lucene-5CpsYR.png" alt="es-shard-lucene-5CpsYR"></p><h3 id="写入过程"><a href="#写入过程" class="headerlink" title="写入过程"></a>写入过程</h3><h4 id="写入过程-1-0-（不完善）"><a href="#写入过程-1-0-（不完善）" class="headerlink" title="写入过程 1.0 （不完善）"></a>写入过程 1.0 （不完善）</h4><ol><li>不断将 Document 写入到 In-memory buffer （内存缓冲区）。</li><li>当满足一定条件后内存缓冲区中的 Documents 刷新到磁盘。</li><li>生成新的 segment 以及一个 Commit point 提交点。</li><li>这个 segment 就可以像其他 segment 一样被读取了。</li></ol><p>画图如下：</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/es-write-1-L60ip2.png" alt="es-write-1-L60ip2"></p><p>将文件刷新到磁盘是非常耗费资源的，而且在内存缓冲区和磁盘中间存在一个高速缓存（cache），一旦文件进入到 cache 就可以像磁盘上的 segment 一样被读取了。</p><h4 id="写入过程-2-0"><a href="#写入过程-2-0" class="headerlink" title="写入过程 2.0"></a>写入过程 2.0</h4><ol><li>不断将 Document 写入到 In-memory buffer （内存缓冲区）。</li><li>当满足一定条件后内存缓冲区中的 Documents 刷新到 高速缓存（<strong>cache</strong>）。</li><li>生成新的 segment ，这个 segment 还在 cache 中。</li><li>这时候还没有 commit ，但是已经可以被读取了。</li></ol><p>画图如下：</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/es-write-2-CW97xV.png" alt="es-write-2-CW97xV"></p><p>数据从 buffer 到 cache 的过程是定期每秒刷新一次。所以新写入的 Document 最慢 1 秒就可以在 cache 中被搜索到。</p><p>而 Document 从 buffer 到 cache 的过程叫做 <strong>?refresh</strong> 。一般是 1 秒刷新一次，不需要进行额外修改。当然，如果有修改的需要，可以参考文末的相关资料。这也就是为什么说 Elasticsearch 是<strong>准实时</strong>的。</p><p>使文档立即可见：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /test/_doc/1?refresh</span><br><span class="line">&#123;<span class="attr">&quot;test&quot;</span>: <span class="string">&quot;test&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">PUT /test/_doc/2?refresh=true</span><br><span class="line">&#123;<span class="attr">&quot;test&quot;</span>: <span class="string">&quot;test&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="Translog-事务日志"><a href="#Translog-事务日志" class="headerlink" title="Translog 事务日志"></a>Translog 事务日志</h4><p>此处可以联想 Mysql 的 binlog， ES 中也存在一个 translog 用来失败恢复。</p><ol><li>Document 不断写入到 In-memory buffer，此时也会追加 translog。</li><li>当 buffer 中的数据每秒 refresh 到 cache 中时，translog 并没有进入到刷新到磁盘，是持续追加的。</li><li>translog 每隔 5s 会 fsync 到磁盘。</li><li>translog 会继续累加变得越来越大，当 translog 大到一定程度或者每隔一段时间，会执行 flush。</li></ol><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/es-write-translog-1-L8RWwm.png" alt="es-write-translog-1-L8RWwm"></p><p>flush 操作会分为以下几步执行：</p><ol><li>buffer 被清空。</li><li>记录 commit point。</li><li>cache 内的 segment 被 fsync 刷新到磁盘。</li><li>translog 被删除。</li></ol><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/es-write-translog-2-BWnz3P.png" alt="es-write-translog-2-BWnz3P"></p><p>值得注意的是：</p><ol><li>translog 每 5s 刷新一次磁盘，所以故障重启，可能会丢失 5s 的数据。</li><li>translog 执行 flush 操作，默认 30 分钟一次，或者 translog 太大 也会执行。</li></ol><p>手动执行flush：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">POST /my-index-000001/_flush</span><br></pre></td></tr></table></figure><h3 id="删除和更新"><a href="#删除和更新" class="headerlink" title="删除和更新"></a>删除和更新</h3><p>segment 不可改变，所以 docment 并不能从之前的 segment 中移除或更新。</p><p>所以每次 commit， 生成 commit point 时，会有一个 .del 文件，里面会列出被删除的 document（逻辑删除）。<br>而查询时，获取到的结果在返回前会经过 .del 过滤。</p><p>更新时，也会标记旧的 docment 被删除，写入到 .del 文件，同时会写入一个新的文件。此时查询会查询到两个版本的数据，但在返回前会被移除掉一个。</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/es-del-1-nc0mKK.png" alt="es-del-1-nc0mKK"></p><h3 id="segment-合并"><a href="#segment-合并" class="headerlink" title="segment 合并"></a>segment 合并</h3><p>每 1s 执行一次 refresh 都会将内存中的数据创建一个 segment。</p><p>segment 数目太多会带来较大的麻烦。 每一个 segment 都会消耗文件句柄、内存和cpu运行周期。更重要的是，每个搜索请求都必须轮流检查每个 segment ；所以 segment 越多，搜索也就越慢。</p><p>在 ES 后台会有一个线程进行 segment 合并。</p><ol><li>refresh操作会创建新的 segment 并打开以供搜索使用。</li><li>合并进程选择一小部分大小相似的 segment，并且在后台将它们合并到更大的 segment 中。这并不会中断索引和搜索。</li><li>当合并结束，老的 segment 被删除 说明合并完成时的活动：<ol><li>新的 segment 被刷新（flush）到了磁盘。  写入一个包含新 segment 且排除旧的和较小的 segment的新 commit point。</li><li>新的 segment 被打开用来搜索。</li><li>老的 segment 被删除。</li></ol></li></ol><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/segment-merge-55A1b6.png" alt="segment-merge-55A1b6"></p><p>物理删除：</p><p>在 segment merge 这块，那些被逻辑删除的 document 才会被真正的物理删除。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>主要介绍了内部写入和删除的过程，需要了解 refresh、fsync、flush、.del、segment merge 等名词的具体含义。</p><p>完整画图如下：</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/all-FMAPTS.png" alt="all-FMAPTS"></p><p>以上就是个人分享的 ES 相关的内容，主要目的是组内技术分享，进行扫盲。不对之处，希望大家留言指正。</p><h4 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h4><ol><li>准实时搜索： <a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.9/near-real-time.html">https://www.elastic.co/guide/en/elasticsearch/reference/7.9/near-real-time.html</a></li><li>Refresh API：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.9/indices-refresh.html">https://www.elastic.co/guide/en/elasticsearch/reference/7.9/indices-refresh.html</a></li><li>Flush API：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.9/indices-flush.html">https://www.elastic.co/guide/en/elasticsearch/reference/7.9/indices-flush.html</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
          <category> ELK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作笔记 </tag>
            
            <tag> ELK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Elasticsearch 技术分享】—— ES 查询检索数据的过程，是什么样子的？</title>
      <link href="2020/08/26/technology-sharing-es-4.html"/>
      <url>2020/08/26/technology-sharing-es-4.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>前言</strong></p><br><p>ES 使用过程中常用的就是查询以及检索，那查询和检索的过程，什么样的呢？</p></blockquote><h3 id="查询流程"><a href="#查询流程" class="headerlink" title="查询流程"></a>查询流程</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET my-index/_doc/0</span><br></pre></td></tr></table></figure><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/fJmmvi-T7hz9J.png" alt="fJmmvi-T7hz9J"></p><ol><li>Client 将请求发送到任意节点 node，此时 node 节点就是<strong>协调节点</strong>（coordinating node）。</li><li>协调节点对 id 进行路由，从而判断该数据在哪个shard。</li><li>在 primary shard 和 replica shard 之间 随机选择一个，请求获取 doc。</li><li>接收请求的节点会将数据返回给<strong>协调节点</strong>，协调节点会将数据返回给Client。</li></ol><p>可以通过 preference 参数指定执行操作的节点或分片。默认为随机。</p><h3 id="检索流程"><a href="#检索流程" class="headerlink" title="检索流程"></a>检索流程</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /my-index/_search </span><br></pre></td></tr></table></figure><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/w1lGEZ-TgHyvN.png" alt="w1lGEZ-TgHyvN"></p><ol><li>Client 将请求发送到任意节点 node，此时 node 节点就是<strong>协调节点</strong>（coordinating node）</li><li>协调节点进行分词等操作后，去查询所有的 shard （primary shard 和 replica shard 选择一个）</li><li>所有 shard 将满足条件的数据 id 排序字段 等信息返回给路由节点</li><li>路由节点重新进行排序，截取数据后，获取到真正需要返回的数据的 id</li><li>路由节点再次请求对应的 shard （此时有 id 了，可以直接定位到对应shard）</li><li>获取到全量数据，返回给 Client</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>主要介绍了 ES 查询以及检索的流程，不足及错误之处欢迎指正。</p><h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><ol><li>协调节点：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.9/modules-node.html#coordinating-node">https://www.elastic.co/guide/en/elasticsearch/reference/7.9/modules-node.html#coordinating-node</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
          <category> ELK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作笔记 </tag>
            
            <tag> ELK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Elasticsearch 技术分享】—— Elasticsearch 存储一条数据， put 过程是什么样子的？</title>
      <link href="2020/08/26/technology-sharing-es-3.html"/>
      <url>2020/08/26/technology-sharing-es-3.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>前言</strong></p><br><p>在前面已经介绍了 ES 中常用的一些名词，知道了数据是存储在 shard 中的，而 index 会映射一个或者多个 shard 。那这时候我要存储一条数据到某个索引下，这条数据是在哪个 index 下的呢？</p></blockquote><h3 id="ES-演示"><a href="#ES-演示" class="headerlink" title="ES 演示"></a>ES 演示</h3><p>一切按照官方教程使用 三条命令，在本机启动三个节点组装成伪集群。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~  % &gt; ./elasticsearch</span><br><span class="line"></span><br><span class="line">~  % &gt; ./elasticsearch -Epath.data=data2 -Epath.logs=log2</span><br><span class="line"></span><br><span class="line">~  % &gt; ./elasticsearch -Epath.data=data3 -Epath.logs=log3</span><br></pre></td></tr></table></figure><h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X PUT <span class="string">&quot;localhost:9200/my-index-000001?pretty&quot;</span> -H <span class="string">&#x27;Content-Type: application/json&#x27;</span> -d<span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;settings&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;index&quot;: &#123;</span></span><br><span class="line"><span class="string">      &quot;number_of_shards&quot;: 3,  </span></span><br><span class="line"><span class="string">      &quot;number_of_replicas&quot;: 2 </span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#x27;</span></span><br></pre></td></tr></table></figure><p>当前版本 7.9</p><p>文档地址：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-create-index.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-create-index.html</a></p><p>ES 默认 number_of_shards 为 1<br>默认 number_of_replicas 为 1，即一个分片只有一个副本</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/put-index-0-dyP7ph.png" alt="put-index-0-dyP7ph"></p><p>下面命令可以查看索引信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X GET <span class="string">&quot;localhost:9200/_cat/indices/my-index-000001?v&amp;s=index&amp;pretty&quot;</span></span><br></pre></td></tr></table></figure><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/put-index-1-VKKT73.png" alt="put-index-1-VKKT73"></p><h4 id="存放数据"><a href="#存放数据" class="headerlink" title="存放数据"></a>存放数据</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X PUT <span class="string">&quot;localhost:9200/my-index-000001/_doc/0825?pretty&quot;</span> -H <span class="string">&#x27;Content-Type: application/json&#x27;</span> -d<span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;name&quot;: &quot;liuzhihang&quot;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#x27;</span></span><br></pre></td></tr></table></figure><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/put-1-vJVlLn.png" alt="put-1-vJVlLn"></p><h4 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X GET <span class="string">&quot;localhost:9200/my-index-000001/_doc/0825?pretty&quot;</span></span><br></pre></td></tr></table></figure><p>文档地址：<br><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-get.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-get.html</a></p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/put-2-JwDffk.png" alt="put-2-JwDffk"></p><h3 id="一条数据该存放在哪个-shard"><a href="#一条数据该存放在哪个-shard" class="headerlink" title="一条数据该存放在哪个 shard"></a>一条数据该存放在哪个 shard</h3><p>通过命令可以看出：在存放数据时并没有指定到哪个 shard，那数据是存在哪里的呢？</p><p>当一条数据进来，会默认会根据 id 做路由</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shard &#x3D; hash(routing) % number_of_primary_shards</span><br></pre></td></tr></table></figure><p>从而确定存放在哪个 shard。 routing 默认是 _id， 也可以设置其他。</p><p>这个 id 可以自己指定也可以系统给生成, 如果不指定则会系统自动生成。</p><h3 id="put-一条数据的过程是什么样的？"><a href="#put-一条数据的过程是什么样的？" class="headerlink" title="put 一条数据的过程是什么样的？"></a>put 一条数据的过程是什么样的？</h3><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/OxOQ9V-S0Wt6P.png" alt="OxOQ9V-S0Wt6P"></p><p>写入过程主要分为三个阶段</p><ol><li>协调阶段：Client 客户端选择一个 node 发送 put 请求，此时当前节点就是<strong>协调节点</strong>（coordinating node）。协调节点根据 document 的 id 进行路由，将请求转发给对应的 node。这个 node 上的是 primary shard 。</li><li>主要阶段：对应的 primary shard 处理请求，写入数据 ，然后将数据同步到 replica shard。<ol><li>primary shard 会验证传入的数据结构</li><li>本地执行相关操作</li><li>将操作转发给 replica shard</li><li>当数据写入 primary shard 和 replica shard 成功后，路由节点返回响应给 Client。</li></ol></li><li>副本阶段：每个 replica shard 在转发后，会进行本地操作。</li></ol><p>在写操作时，默认情况下，只需要 primary shard 处于活跃状态即可进行操作。</p><p>在索引设置时可以设置这个属性</p><p>index.write.wait_for_active_shards</p><p>默认是 1，即 primary shard 写入成功即可返回。 </p><p>如果设置为 all 则相当于 number_of_replicas+1  就是 primary shard 数量 + replica shard 数量。 就是需要等待 primary shard 和 replica shard 都写入成功才算成功。</p><p>可以通过索引设置动态覆盖此默认设置。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="如何查看数据在哪个-shard-上呢？"><a href="#如何查看数据在哪个-shard-上呢？" class="headerlink" title="如何查看数据在哪个 shard 上呢？"></a>如何查看数据在哪个 shard 上呢？</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X GET <span class="string">&quot;localhost:9200/my-index-000001/_search_shards?routing=0825&amp;pretty&quot;</span></span><br></pre></td></tr></table></figure><p>通过上面命令可以查到数据 0825 的所在 shard。</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/put-index-3-JIP0zD.png" alt="put-index-3-JIP0zD"></p><h4 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h4><ol><li>ES 创建索引：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-create-index.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-create-index.html</a></li><li>ES 查询数据：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-get.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-get.html</a></li><li>ES 检索 shard：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-shards.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/search-shards.html</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
          <category> ELK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作笔记 </tag>
            
            <tag> ELK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Elasticsearch 技术分享】—— ES 常用名词及结构</title>
      <link href="2020/08/23/technology-sharing-es-2.html"/>
      <url>2020/08/23/technology-sharing-es-2.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>前言</strong></p><br><p>看完什么是 Elasticsearch 以及了解到了倒排索引的概念，下面就熟悉下 ES 中常用的一些名词。</p></blockquote><h3 id="常用术语"><a href="#常用术语" class="headerlink" title="常用术语"></a>常用术语</h3><table><thead><tr><th><strong>名词</strong></th><th><strong>解释</strong></th></tr></thead><tbody><tr><td><strong>cluster</strong></td><td>一个或者多个 node 指定相同的 cluster name，则它们会组成集群，并且自动选举 master，以及在故障时自动选举。</td></tr><tr><td><strong>node</strong></td><td>节点是属于集群的Elasticsearch的运行实例 。在启动时，节点将使用单播来发现具有相同集群名称的现有集群，并将尝试加入该集群。</td></tr><tr><td><strong>index</strong></td><td>类似关系数据库的表，映射一个或者多个主分片，同时拥有零个或多个副本分片。</td></tr><tr><td><strong>index alias</strong></td><td>索引别名是用于引用一个或多个现有索引的辅助名称。大多数Elasticsearch API接受索引别名代替索引名称。</td></tr><tr><td><strong>mapping</strong></td><td>每个 index 都有一个 mapping ，定义一个 type 以及许多索引范围的设置。mapping 可以明确定义，也可以在为文档建立索引后自动生成。</td></tr><tr><td><strong>shard</strong></td><td>分片是单个Lucene实例。最小的工作单位，由Elasticsearch自动管理。索引是指向主分片和副本分片的逻辑命名空间。</td></tr><tr><td><strong>primary shard</strong></td><td>每个文档都存储在一个主分片中。当您为文档建立索引时，将首先在主 shard 上建立索引，然后在主 shard 的所有副本上建立索引。默认情况下，索引具有一个主分片。您可以指定更多的主要分片来扩展 索引可以处理的文档数量。创建索引后，您将无法更改索引中的主要分片数量。但是，可以使用split API将索引拆分为新索引 。</td></tr><tr><td><strong>replica shard</strong></td><td>每个主分片可以具有零个或多个副本。副本是 primary shard 的副本。</td></tr><tr><td><strong>document</strong></td><td>document 是存储在 Elasticsearch 中的 JSON 文档。每个 document 都存储在索引中，并且有 type 和 id。被索引的 JSON 文档 将存储在 _source 字段中，该字段在获取或搜索文档时默认返回。</td></tr><tr><td><strong>id</strong></td><td>每个 document 都有不同的 id，没有指定的话，会自动生成。</td></tr><tr><td><strong>field</strong></td><td>一个 document 包含字段或键值对的列表。字段类似于关系数据库中表中的列。</td></tr><tr><td><strong>source field</strong></td><td>默认情况下，索引的JSON文档存储在 _source 字段中，并且将由所有 get 和 search 请求返回。这样，可以直接从搜索结果中访问原始对象，而无需执行第二步来从 ID 中检索对象。</td></tr></tbody></table><p>画图出来就是下面这个样子</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/CWbmcX-mPCKR6.png" alt="CWbmcX-mPCKR6"></p><h3 id="replica-shard-有什么用？"><a href="#replica-shard-有什么用？" class="headerlink" title="replica shard 有什么用？"></a>replica shard 有什么用？</h3><ol><li><p>增加故障转移：如果主副本发生故障，副本副本可以提升为主副本</p></li><li><p>提高性能：获取和搜索请求可以由主或副本分片处理。</p><p> 默认情况下，每个主分片都有一个副本，但是可以在现有索引上动态更改副本的数量。副本分片永远不会与其主分片在同一节点上启动。</p></li></ol><p>除了定义索引应具有的主分片和副本分片的数量外，您无需直接引用分片。相反，您的代码应仅处理索引。</p><p>Elasticsearch 在 集群中的所有节点之间分配分片，并且在节点发生故障或添加新节点的情况下，可以自动将分片从一个节点移动到另一个节点。</p><p>分片 默认是 5个，副本默认为 1个。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这篇文章简单介绍了 ES 的常用名词，因为只有了解到这些名词，在小伙伴讨论 ES 的时候，才不会一脸懵逼。</p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
          <category> ELK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作笔记 </tag>
            
            <tag> ELK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Elasticsearch 技术分享】—— Elasticsearch ？倒排索引？这都是什么？</title>
      <link href="2020/08/18/technology-sharing-es-1.html"/>
      <url>2020/08/18/technology-sharing-es-1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>前言</strong></p><br><p>革命同志是块砖，哪里需要哪里搬！这不，老大发话，要我在组内做一个 Elasticsearch 技术分享。这不话题一转，开始看起来 ES 了。虽然很久之前用过 ELK 做过日志监控系统，但是毕竟时隔已久，还是得从头看起。当然手头的活也不能停，话不多说，开始分享。先看看什么是 ES？</p></blockquote><h3 id="什么是ES"><a href="#什么是ES" class="headerlink" title="什么是ES"></a>什么是ES</h3><p>Elasticsearch 是分布式搜索和分析引擎。</p><p>Elasticsearch 为所有类型的数据提供<strong>近实时（near real-time）</strong>的搜索和分析。</p><p>常用场景：</p><ol><li>网站搜索</li><li>ELK 日志采集，存储，分析</li><li>地理信息系统分析</li></ol><p>像下图中使用的设计：</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/HiP4n4-mnRdVv.png" alt="HiP4n4-mnRdVv"></p><p>特点：</p><ol><li>ES是一个分布式文档存储，存储的数据都是序列化为 JSON documents 。</li><li>使用<strong>倒排索引</strong>存储数据，倒排索引比较适合全文本搜索。</li><li>基于<strong>Apache Lucene</strong>搜索引擎库，可以存储，检索文档及元数据。</li><li>支持 JSON 样式的查询语言——Query DSL，也支持 SQL 样式的查询。</li><li>集群部署，易于扩展。节点（node）分片（shard），将新的 node 添加到集群时，ES 会自动迁移 shard 到新 node 上，重新平衡集群。<ol><li>shard 分为两种 主分片（primary shard）和 副本分片 （replica shard）</li><li>replica shard 存放的是 primary shard 的冗余副本 —— 可以防止集群故障，数据丢失，同时可以提高搜索或检索速度。</li><li>在创建索引时 primary shard 数量是固定的，而replica shard 数量是可以更改的。</li><li>分片由索引配置，分片越多，维护索引则开销则越大，分片大小越大，则 ES 在增减节点重新平衡集群时，分片移动时间越长。</li></ol></li><li>集群恢复： 跨集群复制 （CCR），可以自动将索引从主集群同步到热备份的辅助远程集群。</li></ol><h3 id="什么是倒排索引？"><a href="#什么是倒排索引？" class="headerlink" title="什么是倒排索引？"></a>什么是倒排索引？</h3><p>倒排索引也可以成为反向索引。</p><p>作为开发咱们经常接触到的就是 MySql，假设有一堆技术书籍，并且已经编上号。</p><ol><li>Java 并发编程之美</li><li>Java 开发手册</li><li>深入分布式缓存</li><li>Java 并发程序设计</li><li>算法</li><li>数据结构与算法</li></ol><ul><li>如果放在 MySql 里面就是这样</li></ul><table><thead><tr><th>id</th><th>book_name</th></tr></thead><tbody><tr><td>1</td><td>Java 并发编程之美</td></tr><tr><td>2</td><td>Java 开发手册</td></tr><tr><td>3</td><td>深入分布式缓存</td></tr><tr><td>4</td><td>Java 并发程序设计</td></tr><tr><td>5</td><td>算法</td></tr><tr><td>6</td><td>数据结构与算法</td></tr></tbody></table><p>此时我想查询所有关于 <strong>并发</strong> 的书籍。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_book <span class="keyword">where</span> book_name <span class="keyword">like</span> %并发%;</span><br></pre></td></tr></table></figure><p>然后会开始遍历表格，查找到 1和4两条记录。</p><ul><li>如果是倒排索引处理的话</li></ul><p>首先会将每个名称进行分词，比如 <code>Java 并发编程之美</code> 会被分为 <code>Java</code> <code>并发</code> <code>编程</code> <code>之</code> <code>美</code>。<br>分词结束之后按照词关联书籍的编号。</p><table><thead><tr><th>term</th><th>ids</th></tr></thead><tbody><tr><td>Java</td><td>1、2、4</td></tr><tr><td>并发</td><td>1、4</td></tr><tr><td>编程</td><td>1</td></tr><tr><td>算法</td><td>5、6</td></tr><tr><td>分布式</td><td>3</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><p>在倒排索引中搜索<strong>并发</strong>，然后进行检索，就很容易定位到关于<strong>并发</strong>书籍的编号。</p><h3 id="那什么是-Lucene？"><a href="#那什么是-Lucene？" class="headerlink" title="那什么是 Lucene？"></a>那什么是 Lucene？</h3><p>Lucene 可以理解为一个开源的、高性能、可伸缩的信息搜索库。使用 Java 开发，封装了各种倒排索引和搜索的API。相当于一个组件。</p><p>而 ES 就是在 Lucene 之上进行的开发，从而可以<strong>高可用</strong>、<strong>集群部署</strong>、<strong>故障迁移</strong>、<strong>备份容灾</strong>等。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>就这么多，先知道个 ES 是干嘛的。后续再慢慢看、慢慢总结。</p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
          <category> ELK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作笔记 </tag>
            
            <tag> ELK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JDK源码笔记】- 除了读写锁，JUC 下面还有个 StampedLock！还不过来了解一下么？</title>
      <link href="2020/08/09/source-code-stamped-lock.html"/>
      <url>2020/08/09/source-code-stamped-lock.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>前言</strong></p><br><p>在了解完 ReentrantLock 和 ReentrantReadWriteLock 之后，惊奇的发现 JUC 下还有一个 StampedLock 。 查阅资料发现是 JDK8 新增的一个锁。现在已经 JDK15 了，原谅我的孤陋寡闻，实在是业务开发中用的太少。那行吧，赶紧来看一下 StampedLock 到底是什么？为什么有了 ReentrantLock 和 ReentrantReadWriteLock 之后还要设计一个 StampedLock ？</p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><h4 id="往期回顾"><a href="#往期回顾" class="headerlink" title="往期回顾"></a>往期回顾</h4><p>在介绍 StampedLock 之前还是先看一下 ReentrantLock 和 ReentrantReadWriteLock。</p><p>ReentrantLock：互斥锁，同时只有一个线程可以持有。支持锁重入。</p><p>ReentrantReadWriteLock：读写锁，分为读锁和写锁，支持重入。其中读读共享，写写独占，读写互斥，写读互斥。支持锁降级，线程获取写锁后可以降级为读锁。适合读多写少的场景。</p><p>那为什么要设计 StampedLock 呢？先来看一下源码上的注释：</p><h4 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h4><p>基于功能的锁，具有三种模式来控制读/写访问。StampedLock的状态由版本和模式组成。锁获取方法返回一个 stamp 用来表示并控制锁状态的访问；这些方法的“try”版本可能会返回特殊值零，以表示无法获取访问权限。<br>锁的释放和转换方法需要使用 stamp 作为参数，如果它们与锁的状态不匹配，则会失败。</p><p>三种模式是：写锁、读锁、乐观读锁。</p><p>并且具有以下特征：</p><ol><li>获取锁的时候（无论读锁还是写锁或者乐观读锁）都会返回一个 stamp，在释放锁的时候需要使用这个 stamp；</li><li>支持三种模式转换；</li><li>不是可重入的，所以获得锁的时候，不要尝试再次获取。</li></ol><h4 id="使用样例"><a href="#使用样例" class="headerlink" title="使用样例"></a>使用样例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuzhihang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/8/6 15:27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Count</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StampedLock stampedLock = <span class="keyword">new</span> StampedLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用写锁，在对 num 进行写入的时候加锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = stampedLock.writeLock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            num += x;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            stampedLock.unlockWrite(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 乐观读</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取乐观读锁；返回 stamp</span></span><br><span class="line">        <span class="keyword">long</span> stamp = stampedLock.tryOptimisticRead();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// validate 验证是否被写锁持有</span></span><br><span class="line">            <span class="comment">// 没有被写锁持有，可以直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (!stampedLock.validate(stamp)) &#123;</span><br><span class="line">                <span class="comment">// 被写锁持有，那只能获取读锁</span></span><br><span class="line">                stamp = stampedLock.readLock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            stampedLock.unlockRead(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">convertWrite</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 读</span></span><br><span class="line">        <span class="keyword">long</span> stamp = stampedLock.readLock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (num == x) &#123;</span><br><span class="line">                <span class="comment">// 满足条件，转换为写锁</span></span><br><span class="line">                <span class="keyword">long</span> ws = stampedLock.tryConvertToWriteLock(stamp);</span><br><span class="line">                <span class="comment">// 转为写锁成功</span></span><br><span class="line">                <span class="keyword">if</span> (ws != <span class="number">0L</span>) &#123;</span><br><span class="line">                    stamp = ws;</span><br><span class="line">                    num = x;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 转换失败，释放读锁</span></span><br><span class="line">                    stampedLock.unlockRead(stamp);</span><br><span class="line">                    <span class="comment">// 再次获取写锁</span></span><br><span class="line">                    stamp = stampedLock.writeLock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            stampedLock.unlock(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>写锁使用方法一样；</li><li>乐观读，可以先去读数据，发现没有改变可以返回，发现改变了，则重新获取读锁，然后再返回；</li><li>读锁可以升级为写锁，通过 tryConvertToWriteLock 方法。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h4><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/StampedLock-uml-Wq0Jz2.png" alt="StampedLock-uml-Wq0Jz2"></p><p>通过 UML 可以看出 StampedLock 和 AQS 并无任何关系。</p><h4 id="StampedLock-和-ReentrantReadWriteLock-的区别？"><a href="#StampedLock-和-ReentrantReadWriteLock-的区别？" class="headerlink" title="StampedLock 和 ReentrantReadWriteLock 的区别？"></a>StampedLock 和 ReentrantReadWriteLock 的区别？</h4><ol><li>StampedLock 也是读写锁，但是和 AQS 没有关系</li><li>StampedLock 除了 读锁和写锁，还有一个乐观读。</li><li>StampedLock 的读锁可以升级为写锁。</li><li>StampedLock 不支持锁重入。</li></ol><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>本文主要介绍 StampedLock 的相关使用及和 ReentrantReadWriteLock 的区别。</p><p>因为工作确实很少使用，阅读源码，内部自旋逻辑等有很多。如果介绍的话会篇幅特别长，这里就省略了。有兴趣的小伙伴可以自己阅读源码。</p><p>因为 StampedLock 提供的乐观读锁支持，所以在多线程多读情况下，性能比 ReentrantReadWriteLock 要更好，但是需要注意的是 StampedLock 是不支持锁重入的。</p><p>另一个需要记住的就是 StampedLock 和 AQS 并没有什么关系，它是在自己内部维护了一个双向阻塞队列。</p>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码笔记 </tag>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA插件开发常用API</title>
      <link href="2020/08/01/idea-plugin-development-common-api.html"/>
      <url>2020/08/01/idea-plugin-development-common-api.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>在开发Toolkit过程中查阅相关资料和阅读其他开源项目总结的一些常用API.<br>整体内容来源于网络, 以及自己使用开发Toolkit过程中使用到的.<br>总结的不到位的地方欢迎指正.</p></blockquote><h3 id="AnAction操作"><a href="#AnAction操作" class="headerlink" title="AnAction操作"></a>AnAction操作</h3><ol><li>创建Action集成<code>AnAction</code>并实现其<code>actionPerformed</code>方法. 在方法中可以获取到<code>AnActionEvent</code>对象. 代码如下:</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonFormatAction</span> <span class="keyword">extends</span> <span class="title">AnAction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(AnActionEvent event)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前project对象</span></span><br><span class="line">        Project project = event.getData(PlatformDataKeys.PROJECT);</span><br><span class="line">        <span class="comment">// 获取当前编辑的文件, 可以进而获取 PsiClass, PsiField 对象</span></span><br><span class="line">        PsiFile psiFile = event.getData(CommonDataKeys.PSI_FILE);</span><br><span class="line">        Editor editor = event.getData(CommonDataKeys.EDITOR);</span><br><span class="line">        <span class="comment">// 获取Java类或者接口</span></span><br><span class="line">        PsiClass psiClass = getTargetClass(editor, psiFile);</span><br><span class="line">        <span class="comment">// 创建并调起 DialogWrapper</span></span><br><span class="line">        DialogWrapper dialog = <span class="keyword">new</span> JsonFormat(project, psiFile, editor, psiClass);</span><br><span class="line">        dialog.show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>其他方式</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取project. 内部调用 getData(CommonDataKeys.PROJECT) = getDataContext().getData(CommonDataKeys.PROJECT)</span></span><br><span class="line">Project project = e.getProject();</span><br><span class="line"><span class="comment">// 获取数据上下文</span></span><br><span class="line">DataContext dataContext = e.getDataContext();</span><br><span class="line"><span class="comment">// context可以也获取到其他信息, 入参为 PlatformDataKeys 定义的字段</span></span><br><span class="line">Project project1 = dataContext.getData(PlatformDataKeys.PROJECT);</span><br><span class="line">Editor editor = dataContext.getData(PlatformDataKeys.EDITOR);</span><br><span class="line">PsiFile psiFile = dataContext.getData(PlatformDataKeys.PSI_FILE);</span><br><span class="line">PsiElement psiElement = dataContext.getData(PlatformDataKeys.PSI_ELEMENT);</span><br><span class="line"><span class="comment">// 虚拟文件</span></span><br><span class="line">VirtualFile virtualFile = dataContext.getData(PlatformDataKeys.VIRTUAL_FILE);</span><br></pre></td></tr></table></figure><h3 id="获取PsiClass"><a href="#获取PsiClass" class="headerlink" title="获取PsiClass"></a>获取PsiClass</h3><p>PsiClass为java类或者接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> PsiClass <span class="title">getTargetClass</span><span class="params">(Editor editor, PsiFile file)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> offset = editor.getCaretModel().getOffset();</span><br><span class="line">    PsiElement element = file.findElementAt(offset);</span><br><span class="line">    <span class="keyword">if</span> (element == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        PsiClass target = PsiTreeUtil.getParentOfType(element, PsiClass.class);</span><br><span class="line">        <span class="keyword">return</span> target <span class="keyword">instanceof</span> SyntheticElement ? <span class="keyword">null</span> : target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Psixxx操作"><a href="#Psixxx操作" class="headerlink" title="Psixxx操作"></a>Psixxx操作</h3><h4 id="PsiClass操作API"><a href="#PsiClass操作API" class="headerlink" title="PsiClass操作API"></a>PsiClass操作API</h4><p>源码有注释且比较清楚, 此处仅记录我用到的一部分</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取全类名</span></span><br><span class="line">String qualifiedName = aClass.getQualifiedName();</span><br><span class="line"><span class="comment">// 获取所有字段</span></span><br><span class="line">PsiField[] fields = aClass.getFields();</span><br></pre></td></tr></table></figure><h4 id="PsiField操作"><a href="#PsiField操作" class="headerlink" title="PsiField操作"></a>PsiField操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取字段名</span></span><br><span class="line">String name = psiField.getName()</span><br></pre></td></tr></table></figure><h4 id="PsiElement操作"><a href="#PsiElement操作" class="headerlink" title="PsiElement操作"></a>PsiElement操作</h4><p>PsiClass和PsiField都实现了PsiElement</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除</span></span><br><span class="line">element.delete()</span><br><span class="line"><span class="comment">// 添加元素, 向一个类中添加方法, 字段等, 也可以调用 addBefore, addAfter</span></span><br><span class="line">add(PsiElement element)</span><br></pre></td></tr></table></figure><h4 id="PsiType操作"><a href="#PsiType操作" class="headerlink" title="PsiType操作"></a>PsiType操作</h4><p>PsiType支持常用基本类型, 但是当创建对象时则不支持.需要自己创建</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PsiElementFactory psiElementFactory = JavaPsiFacade.getElementFactory(project);</span><br><span class="line"><span class="comment">// String 类型</span></span><br><span class="line">PsiType stringPsiType = psiElementFactory.createTypeFromText(<span class="string">&quot;java.lang.String&quot;</span>, <span class="keyword">null</span>)</span><br><span class="line"><span class="comment">// list</span></span><br><span class="line">PsiType listPsiType = psiElementFactory.createTypeFromText(<span class="string">&quot;java.util.List&lt;String&gt;&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// 自定义list</span></span><br><span class="line">PsiType typeFromText = psiElementFactory.createTypeFromText(<span class="string">&quot;java.util.List&lt;&quot;</span> + className + <span class="string">&quot;&gt;&quot;</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><h3 id="其他API"><a href="#其他API" class="headerlink" title="其他API"></a>其他API</h3><h4 id="XML-文件操作"><a href="#XML-文件操作" class="headerlink" title="XML 文件操作"></a>XML 文件操作</h4><p>参考地址：<a href="https://jetbrains.org/intellij/sdk/docs/reference_guide/frameworks_and_external_apis/xml_dom_api.html">https://jetbrains.org/intellij/sdk/docs/reference_guide/frameworks_and_external_apis/xml_dom_api.html</a></p><p>以 Mapper.xml 举例声明接口，继承 DomElement，并配合 @Attribute、@SubTag 、@SubTagsList 注解定义一个 xml model，其中需要注意 @SubTagsList 方法要使用复数形式。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Mapper</span> <span class="keyword">extends</span> <span class="title">DomElement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * namespace</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Attribute(&quot;namespace&quot;)</span></span><br><span class="line">    <span class="function">GenericAttributeValue&lt;String&gt; <span class="title">getNamespace</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 增删改查对应的节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SubTagsList(&#123;&quot;select&quot;, &quot;insert&quot;, &quot;update&quot;, &quot;delete&quot;&#125;)</span></span><br><span class="line">    <span class="function">List&lt;Statement&gt; <span class="title">getStatements</span><span class="params">()</span></span>;</span><br><span class="line">​</span><br><span class="line">    <span class="meta">@SubTagList(&quot;select&quot;)</span></span><br><span class="line">    <span class="function">List&lt;Select&gt; <span class="title">getSelects</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SubTagList(&quot;insert&quot;)</span></span><br><span class="line">    <span class="function">List&lt;Insert&gt; <span class="title">getInserts</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SubTagList(&quot;update&quot;)</span></span><br><span class="line">    <span class="function">List&lt;Update&gt; <span class="title">getUpdates</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SubTagList(&quot;delete&quot;)</span></span><br><span class="line">    <span class="function">List&lt;Delete&gt; <span class="title">getDeletes</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="搜索文件"><a href="#搜索文件" class="headerlink" title="搜索文件"></a>搜索文件</h4><p>比如想搜索项目中的所有 xml 文件，上面使用 Mapper 接口定义了 Mapper.xml 的结构，就可以利用 DomService 搜索所有的 Mapper.xml：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前项目的所有元素 mapper, 分别填入类型, 作用域 GlobalSearchScope</span></span><br><span class="line">List&lt;DomFileElement&lt;Mapper&gt;&gt; fileElements = DomService.getInstance().getFileElements(Mapper.class, project, GlobalSearchScope.allScope(project));</span><br></pre></td></tr></table></figure><h3 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h3><p>需要调用<code>WriteCommandAction</code>进行异步写入.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WriteCommandAction.runWriteCommandAction(project, () -&gt; &#123;</span><br><span class="line">    doGenerate(psiClass, jsonObject);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h3><p>在操作成功之后，在 IDEA 右下角通知用户，使用 NotificationGroup 类即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 静态属性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> NotificationGroup NOTIFICATION_GROUP = <span class="keyword">new</span> NotificationGroup(<span class="string">&quot;Java2Json.NotificationGroup&quot;</span>, NotificationDisplayType.BALLOON, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(<span class="meta">@NotNull</span> AnActionEvent e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在方法中调用</span></span><br><span class="line">    Notification success = NOTIFICATION_GROUP.createNotification(message, NotificationType.INFORMATION);</span><br><span class="line">    Notifications.Bus.notify(success, project);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以定义为工具类，如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 进行消息通知工具类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuzhihang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/2/28 18:52</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotificationUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> NotificationGroup notificationGroup = <span class="keyword">new</span> NotificationGroup(<span class="string">&quot;ApiDoc.NotificationGroup&quot;</span>, NotificationDisplayType.BALLOON, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">warnNotify</span><span class="params">(String message, Project project)</span> </span>&#123;</span><br><span class="line">        Notifications.Bus.notify(notificationGroup.createNotification(message, NotificationType.WARNING), project);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">infoNotify</span><span class="params">(String message, Project project)</span> </span>&#123;</span><br><span class="line">        Notifications.Bus.notify(notificationGroup.createNotification(message, NotificationType.INFORMATION), project);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">errorNotify</span><span class="params">(String message, Project project)</span> </span>&#123;</span><br><span class="line">        Notifications.Bus.notify(notificationGroup.createNotification(message, NotificationType.ERROR), project);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>基本上常用的就是这些了，也可以查找官方文档，官方文档现在还是比较全面的，地址在相关资料中。也可以 Clone Toolkit 这个插件源码，源码中有一些注释。在其他优秀的插件中，同样可有相关使用方法。</p><h4 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h4><ul><li>Toolkit: <a href="https://github.com/liuzhihang/toolkit">https://github.com/liuzhihang/toolkit</a></li><li>copy-as-json: <a href="https://github.com/liuzhihang/copy-as-json">https://github.com/liuzhihang/copy-as-json</a></li><li>IntelliJ Platform SDK: <a href="https://jetbrains.org/intellij/sdk/docs/intro/welcome.html">https://jetbrains.org/intellij/sdk/docs/intro/welcome.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> IDEA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> plugin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【工具册】- IDEA 插件找不到？看这里！那就自己敲一个！</title>
      <link href="2020/07/29/tool-book-copy-as-json.html"/>
      <url>2020/07/29/tool-book-copy-as-json.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>前言</strong></p><br><p>大家都经常使用 IDEA 进行开发，肯定会使用一些 IDEA 插件，我之前也写过两个插件，不过已经很久没有更新了，就让它先放着吧！</p><p>那小伙伴你是否想亲手写一个插件，或者你是否有一些插件的想法，但是找不到插件。那就自己实现一个吧！</p></blockquote><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><h4 id="使用-Gradle-创建"><a href="#使用-Gradle-创建" class="headerlink" title="使用 Gradle 创建"></a>使用 Gradle 创建</h4><p>写插件，先从创建项目开始：</p><p><code>File</code> -&gt; <code>New</code> -&gt; <code>Project...</code></p><ul><li>这里使用 Gradle，其中 Java 已经默认选中，咱们再额外选择 <strong>IntelliJ Platform Plugin</strong>。</li></ul><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/create-CS5lN3.png" alt="create-CS5lN3"></p><ul><li>点击 <strong>Next</strong> ，然后填写项目名称，路径等选项。</li></ul><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/create2-rBTM8z.png" alt="create2-rBTM8z"></p><ul><li>项目结构</li></ul><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/structure-oKmDur.png" alt="structure-oKmDur"></p><p><strong>build.gradle</strong> 为项目配置文件。<br><strong>resources/META-INF/plugin.xml</strong> 为插件配置文件。</p><h4 id="使用-GitHub-模版"><a href="#使用-GitHub-模版" class="headerlink" title="使用 GitHub 模版"></a>使用 GitHub 模版</h4><ol><li>访问 <a href="https://github.com/JetBrains/intellij-platform-plugin-template">https://github.com/JetBrains/intellij-platform-plugin-template</a></li><li>点击 <strong>Use this template</strong> 创建模版。<img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/use-this-template-Z9tfjX.png" alt="use-this-template-Z9tfjX"></li><li>Clone 项目到自己本地。</li></ol><p>注：模版生成的项目是使用的 <strong>Kotlin</strong>，所以这里使用的第一种方式创建。</p><h3 id="开始开发"><a href="#开始开发" class="headerlink" title="开始开发"></a>开始开发</h3><h4 id="修改-build-gradle-配置文件"><a href="#修改-build-gradle-配置文件" class="headerlink" title="修改 build.gradle 配置文件"></a>修改 build.gradle 配置文件</h4><p>原内容如下：</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/build-gradle-K0gj4a.png" alt="build-gradle-K0gj4a"></p><p>修改后：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;java&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;org.jetbrains.intellij&#x27;</span> version <span class="string">&#x27;0.4.15&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group <span class="string">&#x27;com.liuzhihang.toolkit&#x27;</span></span><br><span class="line">version <span class="string">&#x27;1.0.2&#x27;</span></span><br><span class="line"></span><br><span class="line">sourceCompatibility = <span class="number">1.8</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenLocal()</span><br><span class="line">    maven &#123; url <span class="string">&quot;https://maven.aliyun.com/repository/public&quot;</span> &#125;</span><br><span class="line">    mavenCentral()</span><br><span class="line">    jcenter()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    testCompile group: <span class="string">&#x27;junit&#x27;</span>, name: <span class="string">&#x27;junit&#x27;</span>, version: <span class="string">&#x27;4.12&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// See https://github.com/JetBrains/gradle-intellij-plugin/</span></span><br><span class="line">intellij &#123;</span><br><span class="line">    version <span class="string">&#x27;2019.1.1&#x27;</span></span><br><span class="line">    pluginName <span class="string">&#x27;Copy as Json&#x27;</span></span><br><span class="line">    updateSinceUntilBuild <span class="keyword">false</span></span><br><span class="line">    sameSinceUntilBuild <span class="keyword">false</span></span><br><span class="line">&#125;</span><br><span class="line">patchPluginXml &#123;</span><br><span class="line">    pluginDescription(file(descriptionFile).text)</span><br><span class="line">    changeNotes(file(changesFile).text)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>修改 <strong>repositories</strong> 使用阿里云</li><li>修改 <strong>patchPluginXml</strong> 使用外置文件</li><li>在<strong>根目录</strong>下创建 parts 路径，并创建 <strong>changeNotes.html</strong>、<strong>pluginDescription.html</strong></li></ol><h4 id="修改-resources-META-INF-plugin-xml-插件信息"><a href="#修改-resources-META-INF-plugin-xml-插件信息" class="headerlink" title="修改 resources/META-INF/plugin.xml 插件信息"></a>修改 resources/META-INF/plugin.xml 插件信息</h4><p>原内容如下：</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/plugin-xml-AuzOSc.png" alt="plugin-xml-AuzOSc"></p><p>修改后：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">idea-plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>com.liuzhihang.toolkit.copyasjson<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Copy as Json<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">vendor</span> <span class="attr">email</span>=<span class="string">&quot;liuzhihangs@qq.com&quot;</span> <span class="attr">url</span>=<span class="string">&quot;https://liuzhihang.com&quot;</span>&gt;</span>Liu ZhiHang<span class="tag">&lt;/<span class="name">vendor</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>&lt;![CDATA[ Description will be added by gradle build]]&gt;<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- please see http://www.jetbrains.org/intellij/sdk/docs/basics/getting_started/plugin_compatibility.html</span></span><br><span class="line"><span class="comment">         on how to target different products --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">depends</span>&gt;</span>com.intellij.modules.java<span class="tag">&lt;/<span class="name">depends</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">idea-version</span> <span class="attr">since-build</span>=<span class="string">&quot;181.00&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">extensions</span> <span class="attr">defaultExtensionNs</span>=<span class="string">&quot;com.intellij&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Add your extensions here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">actions</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">actions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">idea-plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>plugin.xml 说明：<a href="https://jetbrains.org/intellij/sdk/docs/basics/plugin_structure/plugin_configuration_file.html">https://jetbrains.org/intellij/sdk/docs/basics/plugin_structure/plugin_configuration_file.html</a></p><h4 id="创建-Action"><a href="#创建-Action" class="headerlink" title="创建 Action"></a>创建 Action</h4><ol><li><p>先在 main 下 创建 java 目录，及包路径。</p></li><li><p><code>New</code> -&gt; <code>Plugin DevKit</code> -&gt; <code>Action</code>  <img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/new-action-Pbv61Y.png" alt="new-action-Pbv61Y"></p></li><li><p>设置 Action 的 <strong>id</strong> 、<strong>Class Name</strong> 、 <strong>description</strong> 、 <strong>group</strong> 及<strong>快捷键</strong>等<img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/create-action-5rIhur.png" alt="create-action-5rIhur"></p></li><li><p>这时候会发现在 plugin.xml 也插入了 <strong>action</strong>。</p></li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">actions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">id</span>=<span class="string">&quot;Toolkit.Json.CopyAsJsonAction&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.liuzhihang.toolkit.action.CopyAsJsonAction&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">text</span>=<span class="string">&quot;CopyAsJsonAction&quot;</span> <span class="attr">description</span>=<span class="string">&quot;Copy As Json&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">add-to-group</span> <span class="attr">group-id</span>=<span class="string">&quot;EditorTabsGroup&quot;</span> <span class="attr">anchor</span>=<span class="string">&quot;first&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">keyboard-shortcut</span> <span class="attr">keymap</span>=<span class="string">&quot;$default&quot;</span> <span class="attr">first-keystroke</span>=<span class="string">&quot;shift meta J&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">actions</span>&gt;</span></span><br></pre></td></tr></table></figure><p>到这里已经结构完全创建完毕了，下面将演示插件 <strong>copy-as-json</strong> 的内部逻辑。当然这块也可以直接跳过，阅读源码即可。</p><p>源码地址：文末相关资料或公众号发送 <strong>copy-as-json</strong> 获取。</p><p>插件效果：将 JavaBean 复制为 Json 字符串。</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/demo-gNnhR9.gif" alt="demo-gNnhR9"></p><h4 id="开发笔记"><a href="#开发笔记" class="headerlink" title="开发笔记"></a>开发笔记</h4><p>首先需要知道一些常用的 API，常用 API 可以阅读官方文档或者关注公众号后面会推送，这里仅介绍一些在这里用到的。</p><ul><li>打开 <strong>CopyAsJsonAction</strong> </li></ul><p>该类继承并需要实现 <strong>actionPerformed</strong> 方法。在 <strong>actionPerformed</strong> 方法中可以通过以下三个方法获取到项目相关信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取项目</span></span><br><span class="line">Project project = e.getData(PlatformDataKeys.PROJECT);</span><br><span class="line"><span class="comment">// 获取Psi文件</span></span><br><span class="line">PsiFile psiFile = e.getData(CommonDataKeys.PSI_FILE);</span><br><span class="line"><span class="comment">// 获取当前编辑的文件</span></span><br><span class="line">Editor editor = e.getData(CommonDataKeys.EDITOR);</span><br></pre></td></tr></table></figure><ul><li>获取到当前编辑的文件</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PsiClass <span class="title">getTargetClass</span><span class="params">(<span class="meta">@NotNull</span> Editor editor, <span class="meta">@NotNull</span> PsiFile file)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> offset = editor.getCaretModel().getOffset();</span><br><span class="line">    PsiElement element = file.findElementAt(offset);</span><br><span class="line">    <span class="keyword">if</span> (element != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前类</span></span><br><span class="line">        PsiClass target = PsiTreeUtil.getParentOfType(element, PsiClass.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> target <span class="keyword">instanceof</span> SyntheticElement ? <span class="keyword">null</span> : target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>从当前编辑的文件里面获取到字段</li></ul><p>将当前编辑的 JavaBean 中的字段提取，并转换为 Map。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Object&gt; fieldsMap = getFields(selectedClass);</span><br></pre></td></tr></table></figure><p>getFields 方法篇幅较长，请参考源码。</p><ul><li>将字段转化成 Json 字符串，并格式化</li></ul><p>使用 Gson 将 Map 转换为 Json 字符串，并格式化。其中格式化自定义了缩进。</p><p>见代码：<code>com.liuzhihang.toolkit.utils.GsonFormatUtil</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Gson gson = <span class="keyword">new</span> GsonBuilder().create();</span><br><span class="line">String json = GsonFormatUtil.gsonFormat(gson, fieldsMap);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用自定义缩进格式 String json = new GsonBuilder().setPrettyPrinting().create().toJson(fieldsMap);</span></span><br><span class="line">StringSelection selection = <span class="keyword">new</span> StringSelection(json);</span><br></pre></td></tr></table></figure><ul><li>将 Json 字符串拷贝到剪贴板</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringSelection selection = <span class="keyword">new</span> StringSelection(json);</span><br><span class="line">Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();</span><br><span class="line">clipboard.setContents(selection, selection);</span><br></pre></td></tr></table></figure><ul><li>发出提示 success</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String message = <span class="string">&quot;Convert &quot;</span> + selectedClass.getName() + <span class="string">&quot; to JSON success, copied to clipboard.&quot;</span>;</span><br><span class="line">Notification success = NOTIFICATION_GROUP.createNotification(message, NotificationType.INFORMATION);</span><br><span class="line">Notifications.Bus.notify(success, project);</span><br></pre></td></tr></table></figure><h4 id="测试运行"><a href="#测试运行" class="headerlink" title="测试运行"></a>测试运行</h4><p>右侧 <code>Gradle</code> -&gt; <code>选择 intellij</code> -&gt; <code>点击 runlde</code></p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/run-GfscZn.png" alt="run-GfscZn"></p><h4 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h4><p>右侧 <code>Gradle</code> -&gt; 选择 <code>intellij</code> -&gt; <code>点击 buildPlugin</code></p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/build-epNxlA.png" alt="build-epNxlA"></p><p>此时在项目路径下会生成插件，把这个插件包发给小兄弟安装使用就行了。</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/build-1-2aX8za.png" alt="build-1-2aX8za"></p><h4 id="上传到-IDEA-插件库"><a href="#上传到-IDEA-插件库" class="headerlink" title="上传到 IDEA 插件库"></a>上传到 IDEA 插件库</h4><p>访问 <a href="https://plugins.jetbrains.com/">https://plugins.jetbrains.com/</a> 创建账号，将插件包上传到仓库即可。当然也有其他的方式，这块就没有研究了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过上面的方式已经简单开发一个插件了，要问这个插件有什么用？</p><p>其实就是在写文档，或者接口调用的时候，直接将 Java Bean 复制为 Json 串，省过一个一个敲，然后手写 Json 了。</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/postman-7trAcJ.gif" alt="postman-7trAcJ"></p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/req111-JvWo5q.gif" alt="req111-JvWo5q"></p><h4 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h4><p>[1] IntelliJ Platform SDK DevGuide：<a href="https://jetbrains.org/intellij/sdk/docs/intro/intellij_platform.html">https://jetbrains.org/intellij/sdk/docs/intro/intellij_platform.html</a><br>[2] JetBrains Plugins Repository：<a href="https://plugins.jetbrains.com/">https://plugins.jetbrains.com/</a><br>[3] Toolkit： <a href="https://github.com/liuzhihang/toolkit">https://github.com/liuzhihang/toolkit</a><br>[4] copy-as-json：<a href="https://github.com/liuzhihang/copy-as-json">https://github.com/liuzhihang/copy-as-json</a><br>[5] copy-as-json 插件地址：<a href="https://plugins.jetbrains.com/plugin/13606-copy-as-json">https://plugins.jetbrains.com/plugin/13606-copy-as-json</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具册 </category>
          
          <category> IDEA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具册 </tag>
            
            <tag> IDEA </tag>
            
            <tag> plugin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JDK源码笔记】- 快进来！花几分钟看一下 ReentrantReadWriteLock 的原理！</title>
      <link href="2020/07/27/source-code-reentrant-read-write-lock.html"/>
      <url>2020/07/27/source-code-reentrant-read-write-lock.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>前言</strong></p><br><p>在看完 ReentrantLock 之后，在高并发场景下 ReentrantLock 已经足够使用，但是因为 ReentrantLock 是独占锁，同时只有一个线程可以获取该锁，而很多应用场景都是读多写少，这时候使用 ReentrantLock 就不太合适了。读多写少的场景该如何使用？在 JUC 包下同样提供了读写锁 ReentrantReadWriteLock 来应对读多写少的场景。</p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>支持类似 ReentrantLock 语义的 ReadWriteLock 的实现。</p><p>具有以下属性：</p><ul><li><strong>获取顺序</strong></li></ul><p>此类不会将读取优先或写入优先强加给锁访问的排序。但是，它确实支持可选的<em>公平</em> 策略。</p><p>支持<strong>公平模式</strong>和<strong>非公平模式</strong>，默认为<strong>非公平模式</strong>。</p><ul><li><strong>重入</strong></li></ul><p>允许 reader 和 writer 按照 <code>ReentrantLock</code> 的样式重新获取读锁或写锁。在写线程释放持有的所有写锁后，reader 才允许重入使用它们。此外，writer 可以获取读锁，但反过来则不成立。</p><ul><li><strong>锁降级</strong></li></ul><p>重入还允许从写锁降级为读锁，通过先获取写锁，然后获取读锁，最后释放写锁的方式降级。但是，从读锁升级到写锁是<strong>不可能的</strong>。</p><ul><li><strong>锁获取的中断</strong></li></ul><p>读锁和写锁都支持锁获取期间的中断。</p><ul><li><strong><code>Condition</code> 支持</strong></li></ul><p>写锁提供了一个 <code>Condition</code> 实现，对于写锁来说，该实现的方式与 <code>ReentrantLock.newCondition()</code> 提供的 <code>Condition</code> 实现对 <code>ReentrantLock</code> 所做的行为相同。当然，此 <code>Condition</code> 只能用于写锁。读锁不支持 <code>Condition</code>。</p><ul><li><strong>监测</strong></li></ul><p>此类支持一些确定是保持锁还是争用锁的方法。这些方法设计用于监视系统状态，而不是同步控制。</p><p>锁最多支持 65535 个递归写锁和 65535 个读锁</p><p>以上为 <em>Java Api 官方文档</em><sup>[1]</sup> 的解释，总结一下内容如下：</p><ol><li>支持非公平和公平模式，默认为非公平模式。</li><li>支持重入，读锁可以重入获取读锁，写锁可以重入获取写锁，写锁可以获取读锁，读锁不可以获取写锁。</li><li>锁可以降级，从写锁降级为读锁，但是不可能从读锁升级到写锁。</li></ol><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CachedData</span> </span>&#123;</span><br><span class="line">    Object data;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> cacheValid;</span><br><span class="line">    <span class="keyword">final</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">processCachedData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 读锁加锁</span></span><br><span class="line">        rwl.readLock().lock();</span><br><span class="line">        <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">            <span class="comment">// 获取写锁之前必须释放读锁</span></span><br><span class="line">            rwl.readLock().unlock();</span><br><span class="line">            <span class="comment">// 写锁加锁</span></span><br><span class="line">            rwl.writeLock().lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 重新检查状态，因为另一个线程可能</span></span><br><span class="line">                <span class="comment">// 在执行操作之前获取了写锁定并更改了状态</span></span><br><span class="line">                <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">                    data = ...</span><br><span class="line">                    cacheValid = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 通过在释放写锁之前获取读锁来降级</span></span><br><span class="line">                rwl.readLock().lock();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                rwl.writeLock().unlock(); <span class="comment">// Unlock write, still hold read</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            use(data);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwl.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面只是官方文档提供的一个 demo。</p><h4 id="问题疑问"><a href="#问题疑问" class="headerlink" title="问题疑问"></a>问题疑问</h4><ol><li>在 ReentrantReadWriteLock 中 state 代表什么？</li><li>线程获取锁的流程是怎么样的？</li><li>读锁和写锁的可重入性是如何实现的？</li><li>当前线程获取锁失败，被阻塞的后续操作是什么？</li><li>锁降级是怎么降级的？</li></ol><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h4><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/ReentrantReadWriteLock-uml-SQCZqu.png" alt="ReentrantReadWriteLock-uml-SQCZqu"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantReadWriteLock</span> <span class="keyword">implements</span> <span class="title">ReadWriteLock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6992448646407690164L</span>;</span><br><span class="line">    <span class="comment">/** 提供读锁的内部类 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;</span><br><span class="line">    <span class="comment">/** 提供写锁的内部类 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;</span><br><span class="line">    <span class="comment">/** 执行所有同步机制 */</span></span><br><span class="line">    <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="state"><a href="#state" class="headerlink" title="state"></a>state</h4><p>之前在阅读 ReentrantLock 源码的时候 state 代表了锁的状态，0 表示没有线程持有锁，大于 1 表示已经有线程持有锁及其重入的次数。而在 ReentrantReadWriteLock 是读写锁，那就需要保存<strong>读锁</strong>和<strong>写锁</strong>两种状态的，那是怎么样表示的呢？</p><p>在 ReentrantReadWriteLock 中同样存在一个 Sync 继承了 AbstractQueuedSynchronizer，也是 FairSync、NonfairSync 的父类。内部定义了 state 的一些操作。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6317671515068378041L</span>;</span><br><span class="line">    <span class="comment">// 移位数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;</span><br><span class="line">    <span class="comment">// 单位</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_UNIT    = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line">    <span class="comment">// 最大数量 1 &lt;&lt; 16 -&gt; 65536</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT      = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 计算独占数使用 1 &lt;&lt; 16 -&gt; 65536</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回共享保留数</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span>    </span>&#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line">    <span class="comment">// 返回独占保留数 </span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 AQS 中定义 state 为 int 类型，而在 ReentrantReadWriteLock 中，将 state 的 高 16 位和低 16 位拆开表示读写锁。其中高 16 位表示读锁，低 16 位表示写锁。分别使用 sharedCount 和 exclusiveCount 方法获取读锁和写锁的当前状态。</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/ReentrantReadWriteLock-state-JusW2l.png" alt="ReentrantReadWriteLock-state-JusW2l"></p><p>下面分别从读锁和写锁的角度来看如何进行加锁和释放锁的？</p><h4 id="ReadLock-lock"><a href="#ReadLock-lock" class="headerlink" title="ReadLock.lock"></a>ReadLock.lock</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadLock</span> </span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取读取锁。</span></span><br><span class="line"><span class="comment">     * 如果写锁没有被另一个线程持有，则获取读锁并立即返回。</span></span><br><span class="line"><span class="comment">     * 如果写锁由另一个线程持有，则出于线程调度目的，</span></span><br><span class="line"><span class="comment">     * 当前线程将被禁用，并处于休眠状态，直到获取读锁为止。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用 AQS 获取共享资源</span></span><br><span class="line">        sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/ReentrantReadWriteLock-AQS-Share-gTrD2e.png" alt="ReentrantReadWriteLock-AQS-Share-gTrD2e"></p><p>获取共享资源，这块使用的 AQS 的逻辑，其中 tryAcquireShared(arg) 是在 ReentrantReadWriteLock.Sync 中实现的。并且 AQS 中有规定，tryAcquireShared 分为三种返回值：</p><ol><li>小于 0: 表示失败；</li><li>等于 0: 表示共享模式获取资源成功，但后续的节点不能以共享模式获取成功; </li><li>大于 0: 表示共享模式获取资源成功，后续节点在共享模式获取也可能会成功，在这种情况下，后续等待线程必须检查可用性。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="comment">// 获取 state 值</span></span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">// 独占计数不为 0 且 不是当前线程， 说明已经有写锁</span></span><br><span class="line">        <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp; getExclusiveOwnerThread() != current)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 获取共享计数（读锁计数）</span></span><br><span class="line">        <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">        <span class="comment">// 不需要阻塞读锁 &amp;&amp; 共享计数小于最大值 &amp;&amp; state 更新成功</span></span><br><span class="line">        <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp; r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">            compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 当前读锁计数为 0</span></span><br><span class="line">                <span class="comment">// firstReader是获得读锁的第一个线程</span></span><br><span class="line">                <span class="comment">// firstReaderHoldCount是firstReader的保持计数</span></span><br><span class="line">                firstReader = current;</span><br><span class="line">                firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                <span class="comment">// 读锁重入</span></span><br><span class="line">                firstReaderHoldCount++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 当前缓存计数</span></span><br><span class="line">                HoldCounter rh = cachedHoldCounter;</span><br><span class="line">                <span class="comment">// 当前线程没有计数 或者 没有创建计数器</span></span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                    <span class="comment">// 创建计数，基于 ThreadLocal</span></span><br><span class="line">                    cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>) </span><br><span class="line">                    readHolds.set(rh);</span><br><span class="line">                <span class="comment">// 计数累加</span></span><br><span class="line">                rh.count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 完整地获取共享锁方法，作为tryAcquireShared方法因CAS获取锁失败后的处理。</span></span><br><span class="line">        <span class="comment">// 因为前面可能失败 CAS 失败， 队列策略失败等原因。</span></span><br><span class="line">        <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>先获取 state ，通过 exclusiveCount 方法获取到写锁的计数值，不为 0 且 不是当前线程， 说明已经有写锁。返回 -1 失败。</li><li>通过 sharedCount 获取读锁计数，判断是否需要阻塞以及是否超过上限后，使用 CAS 更新 读锁计数。</li><li>设置或更新 firstReader、firstReaderHoldCount、 cachedHoldCounter。</li><li>最后会进行完整的获取共享锁方法，作为之前获取失败的后续处理方法。</li></ol><p>firstReader：firstReader是获得读锁的第一个线程；<br>firstReaderHoldCount：firstReaderHoldCount是firstReader的保持计数。即获得读锁的第一个线程的重入次数。<br>cachedHoldCounter：最后一个获得读锁的线程获得读锁的重入次数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullTryAcquireShared</span><span class="params">(Thread current)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    HoldCounter rh = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 无限循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">// 是否有写锁</span></span><br><span class="line">        <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 有写锁，但是不是当前线程，直接返回失败</span></span><br><span class="line">            <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;</span><br><span class="line">            <span class="comment">// 需要阻塞</span></span><br><span class="line">            <span class="comment">// 没有写锁，确保没有重新获取读锁</span></span><br><span class="line">            <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 当前线程的读锁计数 ThreadLocal 中</span></span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current)) &#123;</span><br><span class="line">                        rh = readHolds.get();</span><br><span class="line">                        <span class="comment">// 计数结束，remove 掉</span></span><br><span class="line">                        <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                            readHolds.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 为 0 直接失败</span></span><br><span class="line">                <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 到达上限 抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        <span class="comment">// CAS 设置读锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) &#123;</span><br><span class="line">                firstReader = current;</span><br><span class="line">                firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                firstReaderHoldCount++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span>)</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                    rh = readHolds.get();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    readHolds.set(rh);</span><br><span class="line">                rh.count++;</span><br><span class="line">                cachedHoldCounter = rh; <span class="comment">// cache for release</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先会一直循环</li><li>有写锁，但是不是当前线程，直接返回失败。<strong>但是，有写锁，如果是当前线程，是会继续执行的。</strong></li><li>设置或更新 firstReader、firstReaderHoldCount、 cachedHoldCounter。</li></ol><p>当存在写锁（独占锁）时，方法会返回 -1 失败，后续会调用 AQS 的 doAcquireShared 方法，循环获取资源。doAcquireShared 方法会不断循环，尝试获取读锁，一旦获取到读锁，当前节点会立即唤醒后续节点，后续节点开始尝试获取读锁，依次传播。</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/ReentrantReadWriteLock-1-rl0DjC.png" alt="ReentrantReadWriteLock-1-rl0DjC"></p><h4 id="ReadLock-unlock"><a href="#ReadLock-unlock" class="headerlink" title="ReadLock.unlock"></a>ReadLock.unlock</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadLock</span> </span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 AQS 的 releaseShared 释放共享资源方法。</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/ReadLock-unlock-LE7vUH.png" alt="ReadLock-unlock-LE7vUH"></p><p>其中 tryReleaseShared 有 ReadLock 实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">        <span class="comment">// 第一个线程是当前线程</span></span><br><span class="line">        <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">            firstReader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            firstReaderHoldCount--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 第一个线程不是当前线程，更新自己的 ThreadLocal 里面的计数</span></span><br><span class="line">        HoldCounter rh = cachedHoldCounter;</span><br><span class="line">        <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">            rh = readHolds.get();</span><br><span class="line">        <span class="keyword">int</span> count = rh.count;</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            readHolds.remove();</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">        &#125;</span><br><span class="line">        --rh.count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line">        <span class="comment">// 使用 CAS 更新 state</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="comment">// 但是如果现在读和写锁都已释放，</span></span><br><span class="line">            <span class="comment">// 它可能允许等待的写程序继续进行。</span></span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果是第一个线程，直接更新技术，不是则更新自己 ThreadLocal 里面保存的计数。</li><li>循环，使用 CAS 更新 state 的值。</li><li>如果 state 更新后的值为 0，说明没有线程持有读锁或者写锁了。</li><li>当 state 为 0，此时会调用 AQS 的 doReleaseShared 方法。此时队列如果有写锁，那就会被写锁获取的锁。</li></ol><h4 id="WriteLock-lock"><a href="#WriteLock-lock" class="headerlink" title="WriteLock.lock"></a>WriteLock.lock</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteLock</span> </span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取写入锁。</span></span><br><span class="line"><span class="comment">     * 如果没有其他线程持有读锁或写锁，会直接返回，并将写锁计数设置为1。</span></span><br><span class="line"><span class="comment">     * 如果当前线程持有写锁，则将写锁计数 +1，然后返回。</span></span><br><span class="line"><span class="comment">     * 如果锁正在被其他线程持有，则当前线程用于线程调度目的，</span></span><br><span class="line"><span class="comment">     * 当前线程将被禁用，并处于休眠状态，直到获取读锁并将写锁计数设置为1。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/WriteLock.lock-wBuvUA.png" alt="WriteLock.lock-wBuvUA"></p><p>tryAcquire 方法由 Write 自己实现，方式和 ReentrantLock 类似。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果读锁计数为非零或写锁计数为非零，并且所有者是另一个线程，则失败。</span></span><br><span class="line">    <span class="comment">// 如果计数饱和，则失败。只有在count不为零时，才可能发生这种情况。</span></span><br><span class="line">    <span class="comment">// 否则，如果该线程是可重入获取或队列策略允许的话，则有资格进行锁定。</span></span><br><span class="line">    <span class="comment">// 如果是这样，请更新状态并设置所有者。</span></span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 写锁计数</span></span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">    <span class="comment">// c ！= 0 说明有有线程获取锁了</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line">        <span class="comment">// 判断是不是自己，不是自己 返回 false</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 判断有没有超过上限</span></span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        <span class="comment">// 重入</span></span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不需要阻塞，或者 CAS 更新 state 失败</span></span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() || !compareAndSetState(c, c + acquires))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>获取 state ， 如果 state 不为 0 则判断是否为当前线程重入获取。</li><li>state 为 0 ，则当前线程 CAS 更新 state，获取锁。</li><li>更新成功之后绑定当前线程。</li><li>如果失败会继续调用 AQS 的 acquireQueued，将当前阻塞放在 AQS 队列中。AQS 会不断循环，等待上一个锁释放后，尝试获得锁。</li></ol><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/ReentrantReadWriteLock-2-mQAgGL.png" alt="ReentrantReadWriteLock-2-mQAgGL"></p><h4 id="WriteLock-unlock"><a href="#WriteLock-unlock" class="headerlink" title="WriteLock.unlock"></a>WriteLock.unlock</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteLock</span> </span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前线程是此锁的持有者，则保持计数递减。 </span></span><br><span class="line">    <span class="comment">// 如果保持现在的计数为零，则解除锁定。 </span></span><br><span class="line">    <span class="comment">// 如果当前线程不是此锁的持有者则IllegalMonitorStateException异常。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/Write-unlock-bwHAcw.png" alt="Write-unlock-bwHAcw"></p><p>同样这块代码是使用 AQS 的逻辑，tryRelease 部分由 WriteLock 自己实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">int</span> nextc = getState() - releases;</span><br><span class="line">    <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (free)</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    setState(nextc);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果是当前线程重入，扣减重入次数。</li><li>扣减后如果为 0，则设置锁持有线程为 null，更新 state 值。AQS 会唤醒后续节点获取锁。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p><strong>Q：</strong>在 ReentrantReadWriteLock 中 state 代表什么？</p><p><strong>A：</strong>state 代表锁的状态。state 为 0 ，没有线程持有锁，state 的高 16 为代表读锁状态，低 16 为代表写锁状态。通过位运算可以获取读写锁的实际值。</p><p><strong>Q：</strong>线程获取锁的流程是怎么样的？</p><p><strong>A：</strong>可以参考上面的源码笔记，以及后面的流程图。</p><p><strong>Q：</strong>读锁和写锁的可重入性是如何实现的？</p><p><strong>A：</strong>在加锁的时候，判断是否为当前线程，如果是当前线程，则直接累加计数。值得注意的是：读锁重入计数使用的 ThreadLocal 在线程中缓存计数，而写锁则直接用的 state 进行累加（其实和 state 低 16 位进行累加一样）。</p><p><strong>Q：</strong>当前线程获取锁失败，被阻塞的后续操作是什么？</p><p><strong>A：</strong>获取失败，会放到 AQS 等待队列中，在队列中不断循环，监视前一个节点是否为 head ，是的话，会重新尝试获取锁。</p><p><strong>Q：</strong>锁降级是怎么降级的？</p><p><strong>A：</strong> <img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/write-to-read-koAuqm.png" alt="write-to-read-koAuqm"><br>如图，在圈出部分 fullTryAcquireShared 代码中，可以看出来，在获取读锁的时候，如果当前线程持有写锁，是可以获取读锁的。这块就是指锁降级，比如线程 A 获取到了写锁，当线程 A 执行完毕时，它需要获取当前数据，假设不支持锁降级，就会导致 A 释放写锁，然后再次请求读锁。而在这中间是有可能被其他阻塞的线程获取到写锁的。从而导致线程 A 在一次执行过程中数据不一致。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li>ReentrantReadWriteLock 读写锁，内部实现是 ReadLock 读锁 和 WriteLock 写锁。读锁，允许共享；写锁，是独占锁。</li><li>读写锁都支持重入，读锁的重入次数记录在线程维护的 ThreadLocal 中，写锁维护在 state 上（低 16 位）。</li><li>支持锁降级，从写锁降级为读锁，防止脏读。</li><li>ReadLock 和 WriteLock 都是通过 AQS 来实现的。获取锁失败后会放到 AQS 等待队列中，后续不断尝试获取锁。区别在读锁只有存在写锁的时候才放到等待队列，而写锁是只要存在非当前线程锁（无论写锁还是读锁）都会放到等待队列。<img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/read-write-different-gzNdCo.png" alt="read-write-different-gzNdCo"></li><li>通过源码分析，可以得出读写锁适合在<strong>读多写少</strong>的场景中使用。</li></ol><h4 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h4><p>[1] Java Api：<a href="https://docs.oracle.com/javase/8/docs/api/overview-summary.html">https://docs.oracle.com/javase/8/docs/api/overview-summary.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码笔记 </tag>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JDK源码笔记】- 不能再被问住了！ReentrantLock 源码、画图一起看一看！</title>
      <link href="2020/07/25/source-code-reentrant-lock.html"/>
      <url>2020/07/25/source-code-reentrant-lock.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>在阅读完 JUC 包下的 AQS 源码之后，其中有很多疑问，最大的疑问就是 state 究竟是什么含义？并且 AQS 主要定义了队列的出入，但是获取资源、释放资源都是交给子类实现的，那子类是怎么实现的呢？下面开始了解 ReentrantLock。 </p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>一个可重入的互斥锁与隐式监视器锁synchronized具有相同的基本行为和语义，但功能更强大。</p><p>具有以下特征：</p><ol><li>互斥性：同时只有一个线程可以获取到该锁，此时其他线程请求获取锁，会被阻塞，然后被放到该锁内部维护的一个 AQS 阻塞队列中。</li><li>可重入性：维护 state 变量，初始为 0，当一个线程获取到锁时，state 使用 cas 更新为 1，本线程再次申请获取锁，会对 state 进行 CAS 递增，重复获取次数即 state，最多为 2147483647 。试图超出此限制会从锁定方法抛出 Error。</li><li>公平/非公平性：在初始化时，可以通过构造器传参，指定是否为公平锁，还是非公平锁。当设置为 true 时，为公平锁，线程争用锁时，会倾向于等待时间最长的线程。</li></ol><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();  <span class="comment">// block until condition holds</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ... method body</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock()</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="问题疑问？"><a href="#问题疑问？" class="headerlink" title="问题疑问？"></a>问题疑问？</h4><p>首先在阅读本文时，对 AQS 有了一定的了解，如果不了解的话，可以看以下之前的文章。<a href="">图文讲解 AQS</a></p><ol><li>在 AQS 中介绍 state 时，说 state 含义由子类进行定义，那在 ReentrantLock 中 state 代表什么？</li><li>ReentrantLock 和 AQS 有什么关系？</li><li>线程是如何获取到锁的？</li><li>锁的可重入性是如何实现的？</li><li>当前线程获取锁失败，被阻塞的后续操作是什么？</li><li>公平锁和非公平锁是如何体现的？</li><li>锁是如何释放的？</li></ol><p>将通过源码及画图的方式，围绕上面几个问题，展开阅读和分析。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/ReentrantLock-uml-DDnlDW.png" alt="ReentrantLock-uml-DDnlDW"></p><p>基本结构如图所示，ReentrantLock 类实现了接口 Lock，在接口 Lock 中定义了使用锁时的方法，方法及含义如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取锁，如果没有获取到，会阻塞。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取锁，如果没有获取到，会阻塞。响应中断。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获取锁，如果获取到，返回 true，没有获取到 返回 false</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获取锁，没有有获取到，会等待指定时间，响应中断。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 ReentrantLock 也只是实现了 Lock 接口，并实现了这些方法，那 ReentrantLock 和 AQS 到底有什么关系呢？这就需要看内部具体如何实现的了。</p><p>通过上面类图可以看出，在 ReentrantLock 中含有两个内部类，分别是 NonfairSync FairSync 而它俩又实现了 抽象类 Sync，抽象类 Sync 继承了 AbstractQueuedSynchronizer 即 AQS。具体代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁的同步控制基础类。 子类具体到公平和非公平的版本。 使用AQS状态来表示持有该锁的数量。</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123; </span><br><span class="line">        <span class="comment">// 省略 ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123; </span><br><span class="line">        <span class="comment">// 非公平锁逻辑 省略 ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123; </span><br><span class="line">        <span class="comment">// 公平锁逻辑 省略 ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 默认非公平锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据传参指定公平锁还是非公平锁，true 公平锁，false 非公平锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过上面代码可以看出：</p><ol><li>锁的基本控制是由 NonfairSync 和 FairSync 进行控制的，而它俩的父类 Sync 继承了 AQS (AbstractQueuedSynchronizer)，这也就是说明 ReentrantLock 的实现和 AQS 是有关的。</li><li>NonfairSync 代表非公平锁实现逻辑，FairSync 代表公平锁实现逻辑。</li><li>构造器传参可以看出，初始化时，默认为 NonfairSync 非公平锁。也可以指定声明为公平锁或非公平锁，传参 true 为 公平锁，false 为非公平锁。</li></ol><p>具体 ReentrantLock 和 AQS 的关系是怎样的，就需要通过加锁的过程来分析了。</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/878c841a671f102ddc2cdeae35faa4cc-pKLxAS.gif" alt="878c841a671f102ddc2cdeae35faa4cc-pKLxAS"></p><h4 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h4><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/ReentrantLock-lock-4apftk.png" alt="ReentrantLock-lock-4apftk"></p><p>如图所示，默认声明非公平锁，lock 方法内部调用 <code>sync.lock();</code> 此时应该是使用的非公平锁内部的 lock 加锁操作。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过 CAS 设置 state 值 0 -&gt; 1</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        <span class="comment">// 设置成功当前线程获取到了锁</span></span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 设置失败，则调用 AQS 的方法，尝试获取锁。</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先会 使用 CAS 更新 state 的值， 此时就会发现， state 在这里代表的锁的状态。 0 未加锁，1 加锁。</li><li>设置失败，会调用 AQS 的 acquire(1); 方法。</li></ol><p>再看下 AQS 的 acquire 代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// tryAcquire 尝试获取 state，获取失败则会加入到队列</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在之前分析 AQS 源码时，已经介绍 tryAcquire 是尝试获取 state 的值，AQS 中并不提供可用的方法，此处是由子类实现的。所以这块代码还是在 NonfairSync 类中自己实现的业务逻辑。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">// NonfairSync 实现</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用父类的方法</span></span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// NonfairSync 的父类 Sync 中有实现</span></span><br><span class="line">    <span class="comment">// state 传参是 1</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前线程</span></span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="comment">// 获取 state</span></span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">// 如果 c 是 0 </span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 使用 cas 更新为 1</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                <span class="comment">// 设置持有线程为当前</span></span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="comment">// 如果是当前线程持有</span></span><br><span class="line">            <span class="comment">// 对 state 进行累加</span></span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="comment">// 不允许超过 int 的最大值 2147483647 + 1 = -2147483648</span></span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            <span class="comment">// 设置 state 的值</span></span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>当前线程加锁，直接使用 CAS 方式对 state 从 0 更新为 1，更新成功，则获得锁，更新失败，则获取失败。</li><li>更新失败后会调用 AQS 的 <code>acquire(1);</code> 方法， 此处传参为 1。</li><li>tryAcquire 再次尝试获取锁。<ol><li>state 是 0，尝试获取。获取成功返回 true；</li><li>state 不是 0，判断是否为当前线程持有，是当前线程持有则对 state 进行累加。</li></ol></li><li>tryAcquire 获取锁失败，则走 AQS 的 acquireQueued 逻辑，创建节点，并加入到等待队列中。</li></ol><p>流程画图如下：</p><ul><li>初始为单个线程</li></ul><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/ReentrantLock-1-1ozuSU.png" alt="ReentrantLock-1-1ozuSU"></p><ul><li>此时其他线程来请求获取锁</li></ul><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/ReentrantLock-2-zO9REa.png" alt="ReentrantLock-2-zO9REa"></p><ul><li>加锁流程图</li></ul><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/ReentrantLock-nonfair-LcRGc7.png" alt="ReentrantLock-nonfair-LcRGc7"></p><h4 id="再来看下公平锁是如何体现的？"><a href="#再来看下公平锁是如何体现的？" class="headerlink" title="再来看下公平锁是如何体现的？"></a>再来看下公平锁是如何体现的？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断有无节点排队</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拉出来代码比较一下：</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/compare-UFOHD0.png" alt="compare-UFOHD0"></p><p>可以看出在公平锁（FairSync）中多了一个判断条件</p><p><strong><code>!hasQueuedPredecessors()</code></strong></p><p>hasQueuedPredecessors 方法在 AQS 中，如果有当前线程前面的线程排队返回true，如果当前线程是在队列的头部或队列为空，返回false。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Node t = tail; </span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp; ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果当前加锁时已经有节点在排队，那就去节点尾部排队，否则才会去抢占锁。</p><p>到这里基本上已经知道公平锁和非公平锁的区别了：</p><p>非公平锁：不管有没有节点在排队，都会试图去获取锁，如果获取失败，进入 acquire 方法，还是会试图获取一次，之后才会进入队列中。<br>公平锁：已经有节点在排队，那就自己去节点后面排队。</p><h4 id="tryLock"><a href="#tryLock" class="headerlink" title="tryLock"></a>tryLock</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.nonfairTryAcquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接调用的 Sync 中的 nonfairTryAcquire， 尝试获取锁，获取失败，就返回 false，获取到锁或者是当前线程持有锁则对 state 累加后都返回 true。</p><h4 id="unlock"><a href="#unlock" class="headerlink" title="unlock"></a>unlock</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现 unlock 直接调用的 AQS 的 release 方法，进行释放资源。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这块在 AQS 中有介绍，也说明 tryRelease 由子类进行实现，现在在 ReentrantLock 重点关注 tryRelease 的实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 释放资源，传入值为 1</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>获取当前的 state 进行 -1 操作；</li><li>判断了下当前线程是否为持有线程；</li><li>如果释放完之后 state 为 0 ，则设置持有线程为 null；</li><li>更新并返回 state 的值。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过上面的源码及画图，基本上对开始的问题已经有了答案：</p><p><strong>Q</strong>：在 AQS 中介绍 state 时，说 state 含义由子类进行定义，那在 ReentrantLock 中 state 代表什么？<br><strong>A</strong>：在 ReentrantLock 中 state 代表加锁状态，0 没有线程获得锁，大于等于 1 已经有线程获得锁，大于 1 说明该获得锁的线程多次重入。</p><p><strong>Q</strong>：ReentrantLock 和 AQS 有什么关系？<br><strong>A</strong>：ReentrantLock 内部基于 AQS 实现，无论是锁状态，还是进入等待队列，锁释放等都是基于 AQS 实现。ReentrantLock 的公平锁和非公平锁都是 NonfairSync、FairSync 来实现的，而他们的父类 Sync 继承了 AQS。</p><p><strong>Q</strong>：线程是如何获取到锁的？<br><strong>A</strong>：线程通过修改 state 字段的状态来获取到锁。</p><p><strong>Q</strong>：锁的可重入性是如何实现的？<br><strong>A</strong>：当前线程发现 state 不是 0 ，则说明有锁已经被获取了，此时会判断当前获取到锁的线程是不是自己，如果是，则对 state 进行累加。</p><p><strong>Q</strong>：当前线程获取锁失败，被阻塞的后续操作是什么？<br><strong>A</strong>：获取失败，会放到 AQS 等待队列中，在队列中不断循环，监视前一个节点是否为 head ，是的话，会重新尝试获取锁。</p><p><strong>Q</strong>：公平锁和非公平锁是如何体现的？<br><strong>A</strong>：公平锁主要体现在如果当前队列中已经有排队的线程了，则自己直接排在后面。非公平锁是不管当前队列都没有线程排队，都会直接尝试修改 state 获取锁。</p><p><strong>Q</strong>：锁是如何释放的？<br><strong>A</strong>：锁释放资源，即将 state 进行 -1 操作，如果 -1 后 state 为 0，则释放节点，后续节点尝试获取锁。此处可以看 AQS 相关逻辑。</p>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码笔记 </tag>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【工作笔记】- 老大说新项目的结构和 xxx 项目一样就可以了，我 ……</title>
      <link href="2020/07/18/work-archetype.html"/>
      <url>2020/07/18/work-archetype.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>又要开发新项目了，还是创建新项目，怎么办？老大说按照 xxx 项目的结构创建一个新项目就可以了。</p></blockquote><p>在工作中经常有新项目需要创建，此时就会有三种常用的方式</p><p><strong>CC 大法</strong> 新建项目，然后找到之前的各种工具类，复制粘贴进来，此时还不一定能跑起来，然后再进行各种调试。</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/archetype-cc-45VBU1.png" alt="archetype-cc-45VBU1"></p><p><strong>CD 大法</strong> 复制老项目，然后改 module 名字，依赖名字，删除老代码，当然也不一定能跑起来，此时再进行各种调试。</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/archetype-cc1-SPx1ct.png" alt="archetype-cc1-SPx1ct"></p><p>当然，这里肯定不是使用这两种办法，下面咱们介绍一种更简洁的方式，使用 maven archetype 生成项目模版，一键创建项目。</p><p>Action！！！</p><h3 id="什么是-Archetype-？"><a href="#什么是-Archetype-？" class="headerlink" title="什么是 Archetype ？"></a>什么是 Archetype ？</h3><p>简而言之，Archetype 是 Maven 项目模板工具箱。</p><p><em>An archetype is defined as an original pattern or model from which all other things of the same kind are made.</em> </p><p>原型被定义为原始样式或模型，从中可以制成所有其他同类项目。</p><p>官方解释，简洁明了，就是使用已有的项目，生成一个模版。以后使用这个模版就可以快速生成结构相同的项目了。在团队开发中很有用。</p><p>其实就是官方解释，地址贴上来：<a href="http://maven.apache.org/archetype/maven-archetype-plugin/index.html">http://maven.apache.org/archetype/maven-archetype-plugin/index.html</a></p><p>下面使用 IDEA 作为演示工具，一步一步开始介绍。</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/8e83e6d78b16698fb19762806acadd1c-ZXYM5I.jpg" alt="8e83e6d78b16698fb19762806acadd1c-ZXYM5I"></p><h3 id="准备模版项目"><a href="#准备模版项目" class="headerlink" title="准备模版项目"></a>准备模版项目</h3><p>这里还是要有一个模版项目，比如这样：</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/archetype1-lZkrqX.png" alt="archetype1-lZkrqX"></p><p>这是一个多 module 项目，一个简单的 demo</p><ol><li>使用了 nacos 作为注册中心；</li><li>fegin 作为调用工具；</li><li>有通用校验 token 工具类；</li><li>假设里面也有一些公司的公共配置（MQ，链路监控，统一日志等）。</li></ol><p>当然这个项目是可以跑起来的。新创建的项目也是这个模版。</p><h3 id="进入主题"><a href="#进入主题" class="headerlink" title="进入主题"></a>进入主题</h3><h4 id="使用命令"><a href="#使用命令" class="headerlink" title="使用命令"></a>使用命令</h4><p>**archetype:generate **</p><p>这样是基于当前项目生成，你也可以使用官网的用法分别指定参数</p><ol><li><strong>mvn archetype:generate</strong> 然后一步一步按照提示输入；</li><li>一次性输入，其中 <code>DarchetypeGroupId</code> <code>、DarchetypeArtifactId</code> <code>、DarchetypeVersion</code> 为生成的 Archetype 项目的组织版本。</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn archetype:generate                                  \</span><br><span class="line">  -DarchetypeGroupId=&lt;archetype-groupId&gt;                \</span><br><span class="line">  -DarchetypeArtifactId=&lt;archetype-artifactId&gt;          \</span><br><span class="line">  -DarchetypeVersion=&lt;archetype-version&gt;                \</span><br><span class="line">  -DgroupId=&lt;my.groupid&gt;                                \</span><br><span class="line">  -DartifactId=&lt;my-artifactId&gt;</span><br></pre></td></tr></table></figure><p>高级用法 <strong>mvn clean archetype:create-from-project</strong></p><p>执行图示如下：</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/archetype-iterm-GONbvt.png" alt="archetype-iterm-GONbvt"></p><p>执行后返回 IDEA 查看项目，在 <code>target/generated-sources</code> 目录下的 <code>archetype</code> 即生成的项目模版。</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/archetype-afer-term-vP3Tz3.png" alt="archetype-afer-term-vP3Tz3"></p><p>结构如图所示：</p><ol><li>main/resources/archetype-resources：项目的模版，生成新项目，就是根据这块的代码进行生成的。<ol><li>.idea 无用，删除掉。</li><li>__rootArtifactId__xxx 项目的各个 module</li></ol></li><li>main/resources/META-INF/maven/archetype-metadata.xml：模版工程的元数据配置。</li></ol><p>可以把 archetype 拷出去，这是一个单独的工程模版，拷出去之后，使用 IDEA 打开。</p><p>下面开始介绍 archetype 里面都有什么。</p><h3 id="archetype-模版项目介绍"><a href="#archetype-模版项目介绍" class="headerlink" title="archetype 模版项目介绍"></a>archetype 模版项目介绍</h3><p>使用 IDEA 打开之后发现，还是一个 Maven 项目。</p><h4 id="archetype-resources"><a href="#archetype-resources" class="headerlink" title="archetype-resources"></a>archetype-resources</h4><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/archetype-structure-xUdYE2.png" alt="archetype-structure-xUdYE2"></p><p>打开 pom 文件，可以看到里面 <code>$&#123;groupId&#125;</code> 、 <code>$&#123;artifactId&#125;</code> 、<code>$&#123;version&#125;</code> 使用占位符指定的组织版本，这些就是新创建项目时指定的。</p><h4 id="archetype-metadata-xml"><a href="#archetype-metadata-xml" class="headerlink" title="archetype-metadata.xml"></a>archetype-metadata.xml</h4><p>archetype-metadata.xml 里面为元数据配置。</p><ul><li>fileSet：用来生成一些项目中的文件。如果文件或目录名称包含 <code>__property__</code> 模式，则将其替换为相应的属性值。</li></ul><table><thead><tr><th>属性</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>filtered</td><td>boolean</td><td>过滤文集，将指定文件直接复制不需要修改。<strong>默认值为：false。</strong></td></tr><tr><td>packaged</td><td>boolean</td><td>打包文件，指定文件将在package属性之前的目录结构中生成/复制。它们可以是非打包的，这意味着所选文件将在没有该前缀的情况下生成/复制。<strong>默认值为：false。</strong></td></tr><tr><td>encoding</td><td>String</td><td>过滤内容时使用的编码。</td></tr></tbody></table><p>fileSet 包含以下元素：</p><table><thead><tr><th>元素</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>directory</td><td>String</td><td>生成项目文件的目录</td></tr><tr><td>includes/include*</td><td>List<String></td><td>包含文件</td></tr><tr><td>excludes/exclude*</td><td>List<String></td><td>排除文件</td></tr></tbody></table><p>因为生成项目不需要 .idea *.iml 文件，所以直接删除：</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/archetype-metadata1-iVIvLq.png" alt="archetype-metadata1-iVIvLq"></p><ul><li>module 就是要生成的项目一共几个 module</li></ul><table><thead><tr><th>属性</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>String</td><td>The module’s artifactId.</td></tr><tr><td>dir</td><td>String</td><td>The module’s directory.</td></tr><tr><td>name</td><td>String</td><td>The module’s name.</td></tr></tbody></table><table><thead><tr><th>元素</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>fileSets/fileSet*</td><td>List<FileSet></td><td>文件</td></tr><tr><td>modules/module*</td><td>List<ModuleDescriptor></td><td>模块</td></tr></tbody></table><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/archetype-metadata2-HCnJqd.png" alt="archetype-metadata2-HCnJqd"></p><p>可以看出里面就是自己的项目模版。</p><p><code>__rootArtifactId__-controller</code> 在生成的时候，就会根据传入的 artifactId 生成指定的 module 名字。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol><li>clean install </li></ol><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/archetype-clean-install-zbua0z.png" alt="archetype-clean-install-zbua0z"></p><ol start="2"><li>IDEA Add Archetype</li></ol><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/archetype-maven-b3sZ6a.png" alt="archetype-maven-b3sZ6a"></p><ol start="3"><li>选择使用 Archetype 生成新项目</li></ol><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/archetype-maven2-HDnFc4.png" alt="archetype-maven2-HDnFc4"></p><ol start="4"><li>填写新生成项目的名字等</li></ol><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/archetype-maven3-sbJlI1.png" alt="archetype-maven3-sbJlI1"></p><ol start="5"><li>生成新项目</li></ol><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/archetype-generate-5GUrpu.png" alt="archetype-generate-5GUrpu"></p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p><strong>Q:</strong> 如何自定义包路径？</p><p><strong>A:</strong> 可以使用 <code>requiredProperties</code> 自定义参数。通过传入自定义的参数，来生成自定的包路径。</p><p>比如发现新生成项目的包路径都是 <code>com.liuzhihang.archetype</code>，这样肯定是不行的，每个项目有每个项目自己的包路径。只需要做以下修改：</p><ol><li>将 <code>requiredProperties</code> 添加到项目中，然后添加新变量 <code>middlePackage</code>。</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">requiredProperties</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--使用archetype时候必须要求输入的参数--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">requiredProperty</span> <span class="attr">key</span>=<span class="string">&quot;groupId&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--可以设置默认值，使用archetype会使用默认值--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">defaultValue</span>&gt;</span>com.liuzhihang<span class="tag">&lt;/<span class="name">defaultValue</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">requiredProperty</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">requiredProperty</span> <span class="attr">key</span>=<span class="string">&quot;package&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">defaultValue</span>&gt;</span>com.liuzhihang<span class="tag">&lt;/<span class="name">defaultValue</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">requiredProperty</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">requiredProperty</span> <span class="attr">key</span>=<span class="string">&quot;middlePackage&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">defaultValue</span>&gt;</span>$&#123;rootArtifactId&#125;<span class="tag">&lt;/<span class="name">defaultValue</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">requiredProperty</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">requiredProperties</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>修改模版的文件名</li></ol><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/archetype-middle-mH0Gzf.png" alt="archetype-middle-mH0Gzf"></p><p>如果文件或目录名称包含 <code>__property__</code> 模式，则将其替换为相应的属性值。到这里还不行，因为生成的包名还没改。</p><ol start="3"><li>修改内部文件的包路径。包括 <strong>.java</strong> 、** .xml** 、** .properties** 等。</li></ol><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/archetype-change-middle-3C0Msb.png" alt="archetype-change-middle-3C0Msb"></p><ol start="4"><li>重新 clean install</li></ol><p>注：此时可能会报错，需要在 <code>src/test/resources/projects/basic/archetype.properties</code> 下添加 <code>middlePackage=basic</code> 再重新尝试下。</p><p>在生成时注意指定 <code>middlePackage</code> 属性。</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/archetype-middle-1-r8qOco.png" alt="archetype-middle-1-r8qOco"></p><p><strong>Q:</strong> 我想自定义 Application 的名字怎么弄？</p><p><strong>A:</strong> 同样使用 <code>requiredProperties</code> 自定义参数。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">requiredProperty</span> <span class="attr">key</span>=<span class="string">&quot;appName&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">requiredProperty</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/archetype-app-name-Vt9Xj3.png" alt="archetype-app-name-Vt9Xj3"></p><p>当然也可以起一个通用的名字。</p><p><strong>Q:</strong> 别的小伙伴怎么用？</p><p><strong>A:</strong> 当然是 deploy 到私服了， 在 pom 里面添加如下配置，指定自己公司的私服。deploy ，这样就可以和小伙伴一起愉快的使用啦。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 远程仓库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus Release Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://liuzhihang.com:xxxx/repository/maven-releases/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus Snapshot Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://liuzhihang.com:xxxx/repository/maven-snapshots/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>Q:</strong> 我要怎么从 IDEA 删除 Archetype ​？</p><p><strong>A:</strong> 这么好用怎么舍得删除​呢？只要找到以下路径</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">liuzhihang % &gt; <span class="built_in">pwd</span></span><br><span class="line">/Users/liuzhihang/Library/Caches/JetBrains/IntelliJIdea2020.1/Maven/Indices</span><br></pre></td></tr></table></figure><p>里面有一个 <code>UserArchetypes.xml​</code>， 打开，删除掉里面的 archetype 就行。</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/archetype-delete-ZyQULu.png" alt="archetype-delete-ZyQULu"></p><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>Maven Archetype 文档：<a href="http://maven.apache.org/archetype/maven-archetype-plugin/index.html">http://maven.apache.org/archetype/maven-archetype-plugin/index.html</a></p><p>代码地址：<a href="https://github.com/liuzhihang/archetype-demo">https://github.com/liuzhihang/archetype-demo</a></p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
          <category> Archetype </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作笔记 </tag>
            
            <tag> Archetype </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JDK源码笔记】- 别走！这里有个笔记：图文讲解 AQS ，一起看看 AQS 的源码……(图文较长)</title>
      <link href="2020/07/12/source-code-aqs.html"/>
      <url>2020/07/12/source-code-aqs.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>AbstractQueuedSynchronizer 抽象队列同步器，简称 AQS 。是在 JUC 包下面一个非常重要的基础组件，JUC 包下面的并发锁 <code>ReentrantLock</code> <code>CountDownLatch</code> 等都是基于 AQS 实现的。所以想进一步研究锁的底层原理，非常有必要先了解 AQS 的原理。</p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>先看下 AQS 的类图结构，以及源码注释，有一定的大概了解之后再从源码入手，一步一步研究它的底层原理。</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/aqs.png" alt="aqs"></p><p>“ 源码注释</p><p>提供了实现阻塞锁和相关同步器依靠先入先出（FIFO）等待队列（信号量，事件等）的框架。 此类中设计了一个对大多数基于 AQS 的同步器有用的原子变量来表示状态（state）。 子类必须定义 protected 方法来修改这个 state，并且定义 state 值在对象中的具体含义是 acquired 或 released。 考虑到这些，在这个类中的其他方法可以实现所有排队和阻塞机制。 子类可以保持其他状态字段，但只能使用方法 getState 、setState 和 compareAndSetState 以原子方式更新 state 。</p><p>子类应被定义为用于实现其封闭类的同步性能的非公共内部辅助类。 类AbstractQueuedSynchronizer没有实现任何同步接口。 相反，它定义了一些方法，如 acquireInterruptibly 可以通过具体的锁和相关同步器来调用适当履行其公共方法。</p><p>此类支持独占模式和共享模式。 在独占模式下，其他线程不能获取成功，共享模式下可以（但不一定）获取成功。 此类不“理解”，在机械意义上这些不同的是，当共享模式获取成功，则下一个等待的线程（如果存在）也必须确定它是否能够获取。 线程在不同模式下的等待共享相同的FIFO队列。 通常情况下，实现子类只支持其中一种模式，但同时使用两种模式也可以，例如ReadWriteLock 。 仅共享模式不需要定义支持未使用的模式的方法的子类。</p><p>这个类中定义了嵌套类 AbstractQueuedSynchronizer.ConditionObject ，可用于作为一个 Condition 由子类实现，并使用 isHeldExclusively 方法说明当前线程是否以独占方式进行，release()、 getState() acquire() 方法用于操作 state 原子变量。</p><p>此类提供检查和监视内部队列的方法，以及类似方法的条件对象。 根据需要进使用以用于它们的同步机制。</p><p>要使用这个类用作同步的基础上，需要重新定义以下方法，如使用，通过检查和或修改 getState 、setState 或 compareAndSetState 方法：</p><p>tryAcquire<br>tryRelease<br>tryAcquireShared<br>tryReleaseShared<br>isHeldExclusively</p><p>“</p><p>通过上面的注释可以得出大概的印象：</p><ol><li>内部依靠先入先出（FIFO） 等待队列。</li><li>存在 state 表示状态信息。state 值只能用 getState 、setState 和 compareAndSetState 方法以原子方式更新。</li><li>支持独占模式和共享模式，但具体需要子类实现具体支持哪种模式。</li><li>嵌套 AbstractQueuedSynchronizer.ConditionObject 可以作为 Condition 由子类实现。</li><li>子类需要重新定义  tryAcquire、tryRelease、tryAcquireShared、tryReleaseShared、isHeldExclusively 方法。</li></ol><h3 id="队列节点-Node"><a href="#队列节点-Node" class="headerlink" title="队列节点 Node"></a>队列节点 Node</h3><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/node-1P32mR.png" alt="node-1P32mR"></p><p>Node节点，包含以下元素：</p><table><thead><tr><th>元素</th><th>含义</th></tr></thead><tbody><tr><td>prev</td><td>上一个节点</td></tr><tr><td>next</td><td>下一个节点</td></tr><tr><td>thread</td><td>持有线程</td></tr><tr><td>waitStatus</td><td>节点状态</td></tr><tr><td>nextWaiter</td><td>下一个处于 CONDITION 状态的节点</td></tr></tbody></table><p>组合成等待队列则如下：</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/node-fifo.png" alt="node-fifo"></p><p>下面是等待队列节点的 Node 属性：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 节点正在共享模式下等待的标记</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="comment">// 指示节点正在以独占模式等待的标记</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指示线程已取消</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 指示后续线程需要唤醒</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 指示线程正在等待条件</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 指示下一次acquireShared应该无条件传播</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 状态字段，仅使用以下值</span></span><br><span class="line"><span class="comment">     * SIGNAL -1 ：当前节点释放或者取消时，必须 unpark 他的后续节点。</span></span><br><span class="line"><span class="comment">     * CANCELLED 1 ：由于超时（timeout）或中断（interrupt），该节点被取消。节点永远不会离开此状态。特别是，具有取消节点的线程永远不会再次阻塞。</span></span><br><span class="line"><span class="comment">     * CONDITION -2 ：该节点目前在条件队列。 但它不会被用作同步队列节点，直到转移，转移时的状态将被设置为 0 。</span></span><br><span class="line"><span class="comment">     * PROPAGATE -3 ：releaseShared 应该被传播到其他节点。 </span></span><br><span class="line"><span class="comment">     * 0：都不是</span></span><br><span class="line"><span class="comment">     * 值以数字表示以简化使用，大多数时候可以检查符号（是否大于0）以简化使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上一个节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下一个节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点持有线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链接下一个等待条件节点，或特殊值共享</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点是否处于 共享状态 是， 返回 true</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回前一个节点， 使用时 前一个节点不能为空</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">        Node p = prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">        <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">        <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Node 节点中需要重点关注 waitStatus</p><ol><li>默认状态为 0；</li><li>waitStatus &gt; 0 (CANCELLED 1) 说明该节点超时或者中断了，需要从队列中移除；</li><li>waitStatus = -1 SIGNAL 当前线程的前一个节点的状态为 SIGNAL，则当前线程需要阻塞（unpark）；</li><li>waitStatus = -2 CONDITION -2 ：该节点目前在条件队列；</li><li>waitStatus = -3 PROPAGATE -3 ：releaseShared 应该被传播到其他节点，在共享锁模式下使用。</li></ol><p>了解完 Node 的结构之后，再了解下 AQS 结构，并从常用方法入手，逐步了解具体实现逻辑。</p><h3 id="AbstractQueuedSynchronizer"><a href="#AbstractQueuedSynchronizer" class="headerlink" title="AbstractQueuedSynchronizer"></a>AbstractQueuedSynchronizer</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待队列的头，延迟初始化。 除了初始化，它是仅经由方法setHead修改。 注意：如果头存在，其waitStatus保证不会是 CANCELLED 状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待队列的尾部，延迟初始化。 仅在修改通过方法ENQ添加新节点等待。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步状态 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取状态</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置状态值</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">        state = newState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原子更新状态值</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 AQS 中主要参数为：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>head</td><td>等待队列头</td></tr><tr><td>tail</td><td>等待队列尾</td></tr><tr><td>state</td><td>同步状态</td></tr></tbody></table><p>通过注释了解到，在 AQS 里主要分为两种操作模式，分别是：独占模式、共享模式，下面分别从两个不同的角度去分析源码。</p><table><thead><tr><th>操作</th><th>含义</th></tr></thead><tbody><tr><td>acquire</td><td>以独占模式获取，忽略中断。 通过调用至少一次实施tryAcquire ，在成功时返回。 否则，线程排队，可能重复查封和解封，调用tryAcquire直到成功为止。 这种方法可以用来实现方法Lock.lock 。</td></tr><tr><td>release</td><td>以独占模式释放。 通过疏通一个或多个线程，如果实现tryRelease返回true。 这种方法可以用来实现方法Lock.unlock 。</td></tr><tr><td>acquireShared</td><td>获取在共享模式下，忽略中断。 通过至少一次第一调用实现tryAcquireShared ，在成功时返回。 否则，线程排队，可能重复查封和解封，调用tryAcquireShared直到成功为止。</td></tr><tr><td>releaseShared</td><td>以共享模式释放。 通过疏通一个或多个线程，如果实现tryReleaseShared返回true。</td></tr></tbody></table><p>无论是共享模式还是独占模式在这里面都会用到 addWaiter 方法，将当前线程及模式创建排队节点。</p><h4 id="独占模式"><a href="#独占模式" class="headerlink" title="独占模式"></a>独占模式</h4><h5 id="获取独占资源-acquire"><a href="#获取独占资源-acquire" class="headerlink" title="获取独占资源 acquire"></a>获取独占资源 acquire</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// tryAcquire 尝试获取 state，获取失败则会加入到队列</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在独占模式下会尝试获取 state，当获取失败时会调用 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)。</p><ol><li>tryAcquire(arg)，尝试获取 state 这块由子类自己实现，不同的子类逻辑不同，这块在介绍子类代码时会说明。</li><li>获取 state 失败后，会进行 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)，这块代码可以拆分为两块：addWaiter(Node.EXCLUSIVE)，acquireQueued(node, arg)。</li><li>addWaiter(Node.EXCLUSIVE) 返回的是当前新创建的节点。</li><li>acquireQueued(node, arg) 线程获取锁失败，使用 addWaiter(Node.EXCLUSIVE) 放入等待队列，而 acquireQueued(node, arg) 使用循环，不断的为队列中的节点去尝试获取资源，直到获取成功或者被中断。</li></ol><p>总结获取资源主要分为三步：</p><ol><li>尝试获取资源</li><li>入队列</li><li>出队列</li></ol><p>尝试获取资源 <code>tryAcquire(arg)</code>，由子类实现，那下面则着手分别分析 <code>入队列</code>、<code>出队列</code>。</p><h6 id="入队列：addWaiter-Node-EXCLUSIVE"><a href="#入队列：addWaiter-Node-EXCLUSIVE" class="headerlink" title="入队列：addWaiter(Node.EXCLUSIVE)"></a>入队列：addWaiter(Node.EXCLUSIVE)</h6><p>使用 <code>addWaiter(Node.EXCLUSIVE)</code> 方法将节点插入到队列中，步骤如下：</p><ol><li>根据传入的模式创建节点</li><li>判断尾节点是否存在，不存在则需要使用 <code>enq(node)</code> 方法初始化节点，存在则直接<code>尝试</code>插入尾部。</li><li><code>尝试</code>插入尾部时使用 CAS 插入，防止并发情况，如果插入失败，会调用 <code>enq(node)</code> 自旋直到插入。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// 定位到队列末尾的 node</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 新节点的上一个节点 指向尾节点</span></span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">// 使用 CAS 设置尾节点，tail 如果等于 pred 则更新为 node</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            <span class="comment">// 更新成功则将 pred 的下一个节点指向 node</span></span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尾节点没有初始化，或竞争失败，自旋</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * tailOffset 也就是成员变量 tail 的值</span></span><br><span class="line"><span class="comment"> * 此处相当于：比较 tail 的值和 expect 的值是否相等， 相等则更新为 update</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetTail</span><span class="params">(Node expect, Node update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, tailOffset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetHead</span><span class="params">(Node update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, headOffset, <span class="keyword">null</span>, update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="comment">// 尾节点为空 需要初始化头节点，此时头尾节点是一个</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不为空 循环赋值</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看完代码和注释肯定还是有点模糊，现在用图一步一步进行说明。</p><p>因为根据<code>初始尾节点是否为空</code>分为两种情况，这里使用两幅图：</p><ol><li>第一幅为第一次添加节点，此时 head 会延迟初始化；</li><li>第二幅图为已经存在队列，进行插入节点；</li><li>注意看代码，enq 方法返回的是<code>之前的尾节点</code>；</li><li>addWaiter 方法 返回的是<code>当前插入的新创建的节点</code>。</li></ol><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/aqs-addwaiter-1.png" alt="aqs-addwaiter-1"></p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/cas-add-waiter-02.png" alt="cas-add-waiter-02"></p><p>节点添加到队列之后，返回当前节点，而下一步则需要调用方法 <code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</code> 不断的去获取资源。</p><h6 id="出队列：acquireQueued-addWaiter-Node-EXCLUSIVE-arg"><a href="#出队列：acquireQueued-addWaiter-Node-EXCLUSIVE-arg" class="headerlink" title="出队列：acquireQueued(addWaiter(Node.EXCLUSIVE), arg)"></a>出队列：acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</h6><p>方法会通过循环不断尝试获取拿到资源，直到成功。代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否拿到资源</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 中断状态</span></span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 无限循环</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 当前节点之前的节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 前一个节点是头节点， 说明当前节点是 头节点的 next 即真实的第一个数据节点 （因为 head 是虚拟节点）</span></span><br><span class="line">            <span class="comment">// 然后再尝试获取资源</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">// 获取成功之后 将头指针指向当前节点</span></span><br><span class="line">                setHead(node); </span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// p 不是头节点， 或者 头节点未能获取到资源 （非公平情况下被别的节点抢占） </span></span><br><span class="line">            <span class="comment">// 判断 node 是否要被阻塞，</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>不断获取本节点的上一个节点是否为 head，因为 head 是虚拟节点，如果当前节点的上一个节点是 head 节点，则当前节点为 <code>第一个数据节点</code>；</li><li>第一个数据节点不断的去获取资源，获取成功，则将 head 指向当前节点；</li><li>当前节点不是头节点，或者 <code>tryAcquire(arg)</code> 失败（失败可能是非公平锁）。这时候需要判断前一个节点状态决定<code>当前节点是否要被阻塞</code>（前一个节点状态是否为 SIGNAL）。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据上一个节点的状态，判断当前线程是否应该被阻塞</span></span><br><span class="line"><span class="comment"> * SIGNAL -1 ：当前节点释放或者取消时，必须 unpark 他的后续节点。</span></span><br><span class="line"><span class="comment"> * CANCELLED 1 ：由于超时（timeout）或中断（interrupt），该节点被取消。节点永远不会离开此状态。特别是，具有取消节点的线程永远不会再次阻塞。</span></span><br><span class="line"><span class="comment"> * CONDITION -2 ：该节点目前在条件队列。 但它不会被用作同步队列节点，直到转移，转移时的状态将被设置为 0 。</span></span><br><span class="line"><span class="comment"> * PROPAGATE -3 ：releaseShared 应该被传播到其他节点。 </span></span><br><span class="line"><span class="comment"> * 0：都不是</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 前一个节点的等待状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="comment">// 前一个节点需要 unpark 后续节点</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 当前节点处于取消状态</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 将取消的节点从队列中移除</span></span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 设置前一个节点为 SIGNAL 状态</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>shouldParkAfterFailedAcquire</code> 方法中，会判断前一个节点的状态，同时取消在队列中当前节点前面无效的节点。</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/aqs-acquire.png" alt="aqs-acquire"></p><p>再继续阅读 出队列 acquireQueued 方法，发现有一个 finally 会判断状态后执行 <code>cancelAcquire(node);</code> ，也就是上面流程图中下面的红色方块。</p><h6 id="cancelAcquire-Node-node"><a href="#cancelAcquire-Node-node" class="headerlink" title="cancelAcquire(Node node)"></a>cancelAcquire(Node node)</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否拿到资源</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 省略</span></span><br><span class="line">        <span class="comment">// 在 finally 会将当前节点置为取消状态</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 节点不存在 直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消节点关联线程</span></span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//跳过已经取消的节点，获取当前节点之前的有效节点</span></span><br><span class="line">    Node pred = node.prev;</span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前节点之前的有效节点的下一个节点</span></span><br><span class="line">    Node predNext = pred.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前节点设置为取消</span></span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前节点如果是尾节点，则将最后一个有效节点设置为尾节点，并将 predNext 设置为空</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> ws;</span><br><span class="line">        <span class="comment">// pred 不是头节点(node 的上一个有效节点 不是 head) &amp;&amp; （ pred的状态是 SIGNAL ||  pred 的状态设置为 SIGNAL 成功 ） &amp;&amp; pred 的绑定线程不为空</span></span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp; </span><br><span class="line">        ((ws = pred.waitStatus) == Node.SIGNAL || (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp; </span><br><span class="line">        pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 当前节点的后继节点</span></span><br><span class="line">            Node next = node.next;</span><br><span class="line">            <span class="comment">// 后继节点不为空 且 状态有效 将 pred 的 后继节点设置为 当前节点的后继节点</span></span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// node 的上一个有效节点 是 head， 或者其他情况 唤醒当前节点的下一个有效节点</span></span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前节点状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 将节点状态更新为 0 </span></span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下一个节点， 一般是下一个节点应该就是需要唤醒的节点，即颁发证书。</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">// 大于 0  CANCELLED ： 线程已取消</span></span><br><span class="line">    <span class="comment">// 但是有可能 后继节点 为空或者被取消了。</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 从尾节点开始遍历，直到定位到 t.waitStatus &lt;= 0 的节点</span></span><br><span class="line">        <span class="comment">// 定位到后并不会停止，会继续执行，相当于找到最开始的那个需要唤醒的节点</span></span><br><span class="line">        <span class="comment">// t.waitStatus &lt;= 0 ： SIGNAL（ -1 后续线程需要释放） </span></span><br><span class="line">        <span class="comment">//                     CONDITION （ -2 线程正在等待条件） </span></span><br><span class="line">        <span class="comment">//                     PROPAGATE （ -3 releaseShared 应该被传播到其他节点）</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定位到需要唤醒的节点后 进行 unpark</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>流程分析：</p><ol><li>找到当前节点的前一个非无效节点 pred；</li><li>当前节点如果是尾节点，则将最后一个有效节点设置为尾节点，并将 predNext 设置为空；</li><li>pred 不是头节点 &amp;&amp; （ pred的状态是 SIGNAL ||  pred 的状态设置为 SIGNAL 成功 ） &amp;&amp; pred 的绑定线程不为空；</li><li>其他情况。</li></ol><p>下面分别画图：</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/1-RD0LEx.png" alt="1-RD0LEx"></p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/2-PHY9bi.png" alt="2-PHY9bi"></p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/3-rOnnvu.png" alt="3-rOnnvu"></p><p><strong>Q: 通过图可以看出来，只操作了 next 指针，但是没有操作 prev 指针，这是为什么呢？</strong></p><p><strong>A:</strong> 在 <code>出队列：acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</code> 方法中，<code>shouldParkAfterFailedAcquire</code> 方法会判断前一个节点的状态，同时取消在队列中当前节点前面无效的节点。这时候会移除之前的无效节点，此处也是为了防止指向一个已经被移除的节点。同时保证 prev 的稳定，有利于从 tail 开始遍历列表，这块在 <code>unparkSuccessor(node);</code> 中也可以看到是从后往前表里列表。</p><p><strong>Q: unparkSuccessor(Node node) 为什么从后往前遍历？</strong></p><p><strong>A:</strong></p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/AQS-8IDBPX.png" alt="AQS-8IDBPX"></p><p>在 <code>addWaiter(Node.EXCLUSIVE)</code> 插入新节点时，使用的是 <code>尾插法</code>，看红框部分，此时有可能还未指向next。</p><p><strong>Q: node.next = node; 这块导致 head不是指向最新节点，链表不就断了么？</strong><br><strong>A：</strong> acquireQueued 方法介绍中，里面有个循环，会不断尝试获取资源，成功之后会设置为 head。并且在 shouldParkAfterFailedAcquire 中也会清除当前节点前的无效节点。</p><h5 id="释放独占资源-release"><a href="#释放独占资源-release" class="headerlink" title="释放独占资源 release"></a>释放独占资源 release</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以独占模式释放。 通过释放一个或多个线程，如果实现tryRelease返回true。 这种方法可以用来实现方法Lock.unlock 。</p><ol><li>tryRelease(arg) 操作释放资源，同样是由子类实现，后面介绍子类时会进行说明。返回 true 说明资源现在已经没有线程持有了，其他节点可以尝试获取；</li><li>释放成功，且 head != null &amp;&amp; h.waitStatus != 0, 会继续执行 unparkSuccessor(h)；</li><li>这块会看到 只要 tryRelease(arg) 操作释放资源成功， 后面无论执行是否成功，都会返回 true，unparkSuccessor(h) 相当于只是附加操作。</li></ol><h4 id="共享模式"><a href="#共享模式" class="headerlink" title="共享模式"></a>共享模式</h4><h5 id="获取共享资源-acquireShared"><a href="#获取共享资源-acquireShared" class="headerlink" title="获取共享资源 acquireShared"></a>获取共享资源 acquireShared</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 小于 0 表示获取资源失败</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 添加到节点 此处是共享节点</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="comment">// 根据是否拿到资源 判断是否需要取消</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 返回前一个节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">// 再次尝试获取共享资源</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="comment">// 表示获取成功</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 设置当前节点为头节点 并尝试唤醒后续节点</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    <span class="comment">// 释放头节点 GC 会回收</span></span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>tryAcquireShared(arg)，尝试获取资源，这块由子类实现；</li><li>返回值分为 3 种：<ol><li>小于 0: 表示失败；</li><li>等于 0: 表示共享模式获取资源成功，但后续的节点不能以共享模式获取成功; </li><li>大于 0: 表示共享模式获取资源成功，后续节点在共享模式获取也可能会成功，在这种情况下，后续等待线程必须检查可用性。</li></ol></li><li>在失败后会使用 <code>doAcquireShared(arg);</code> 不断获取资源；</li><li><code>final Node node = addWaiter(Node.SHARED);</code> 同样会创建节点；</li><li>在循环中不断判断前一个节点如果是 head，则尝试获取资源；</li><li>在共享模式下获取到资源后会使用 <code>setHeadAndPropagate(node, r);</code> 设置头节点，同时唤醒后续节点。</li></ol><h6 id="设置头节点，并传播唤醒后续节点"><a href="#设置头节点，并传播唤醒后续节点" class="headerlink" title="设置头节点，并传播唤醒后续节点"></a>设置头节点，并传播唤醒后续节点</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// node 是当前节点</span></span><br><span class="line"><span class="comment">// propagate 是 前一步 tryAcquireShared 的返回值 进来时 &gt;=0</span></span><br><span class="line"><span class="comment">// 大于 0: 表示共享模式获取资源成功，后续节点在共享模式获取也可能会成功，在这种情况下，后续等待线程必须检查可用性。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录下当前头节点</span></span><br><span class="line">    Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">    <span class="comment">// 设置传入 node 为头节点</span></span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="comment">// 判断条件，唤醒后续节点</span></span><br><span class="line">    <span class="comment">// propagate &gt; 0 有后续资源</span></span><br><span class="line">    <span class="comment">// h == null 旧的头节点 因为前面 addWaiter， 肯定不会为空，应该是防止 h.waitStatus &lt; 0 空指针的写法</span></span><br><span class="line">    <span class="comment">// (h = head) == null 当前的 头节点，再判断状态</span></span><br><span class="line">    <span class="comment">// waitStatus &lt; 0 后续节点就需要被唤醒</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="comment">// 后续节点为共享，则需要唤醒</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="doReleaseShared-释放共享资源"><a href="#doReleaseShared-释放共享资源" class="headerlink" title="doReleaseShared() 释放共享资源"></a>doReleaseShared() 释放共享资源</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 从头开始</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">// 判断队列是否为空，就是刚初始化</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="comment">// SIGNAL（ -1 后续线程需要释放）</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="comment">// 将等待状态更新为 0 如果失败，会循环</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                <span class="comment">// 唤醒后续节点， 同时将当前节点设置为 取消</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果状态是 0 则会更新状态为 PROPAGATE</span></span><br><span class="line">            <span class="comment">// PROPAGATE （ -3 releaseShared 应该被传播到其他节点）</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp; !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断头节点有没有变化，有变化 是因为竞争，别的线程获取到了锁，会继续循环</span></span><br><span class="line">        <span class="comment">// 没有变化直接结束</span></span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>从头节点开始进行，如果 h != null &amp;&amp; h != tail 说明队列不是空或者刚初始化；</li><li>节点状态为 SIGNAL（ -1 ）说明后续线程需要释放；</li><li>会更改当前节点状态，成功后唤醒后续节点，失败则继续循环；</li><li>节点状态如果是 0 则更新为 PROPAGATE，会将状态传播。</li></ol><h5 id="释放共享资源-releaseShared"><a href="#释放共享资源-releaseShared" class="headerlink" title="释放共享资源 releaseShared"></a>释放共享资源 releaseShared</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        <span class="comment">// 释放共享资源</span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以共享模式释放。 通过释放一个或多个线程，如果实现tryReleaseShared返回true。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>Q: AQS 到底是什么？</strong><br><strong>A:</strong> AQS 内部提供了一个先入先出（FIFO）双向等待队列，内部依靠 Node 实现，并提供了在<code>独占模式</code>和<code>共享模式</code>下的出入队列的公共方法。而关于状态信息 state 的定义是由子类实现。tryAcquire、tryRelease、tryAcquireShared、tryReleaseShared等尝试获取资源操作都是由子类进行定义和实现的。而 AQS 中提供了子类获取资源之后的相关操作，包括节点 Node 的出入队列，自旋获取资源等等。</p><p><strong>Q: AQS 获取资源失败后会如何操作？</strong><br><strong>A:</strong> 线程获取资源失败后，会放到等待队列中，在队列中会不断尝试获取资源（自旋），说明线程只是进入等待状态，后面还是可以再次获取资源的。</p><p><strong>Q: AQS 等待队列的数据结构是什么？</strong><br><strong>A:</strong> CLH变体的先入先出（FIFO）双向等待队列。（CLH锁是一个自旋锁。能确保无饥饿性。提供先来先服务的公平性。是一种基于链表的可扩展、高性能、公平的自旋锁，申请线程仅仅在本地变量上自旋，它不断轮询前驱的状态，如果发现前驱释放了锁就结束自旋。）</p><p><strong>Q: AQS 等待队列中的节点如何获取获取和释放资源的？</strong><br><strong>A:</strong> 可以看下<code>独占模式</code>中的讲述过程，通过代码梳理。</p><p>本文分别从 <code>独占模式</code> 和 <code>共享模式</code>介绍的 AQS 基本逻辑，并通过源码和作图理解基本思路。但是并没有对需要子类实现的业务逻辑做介绍。这块会在后面介绍 <code>ReentrantLock</code>、<code>CountDownLatch</code> 等子类的时候做介绍。</p>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码笔记 </tag>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JDK源码笔记】- JUC 包下工具类，它的名字叫 LockSupport ！你造么？</title>
      <link href="2020/07/05/source-code-locksupport.html"/>
      <url>2020/07/05/source-code-locksupport.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>LockSupport 是 JUC 中常用的一个工具类，主要作用是挂起和唤醒线程。在阅读 JUC 源码中经常看到，所以很有必要了解一下。</p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote><p>基本线程阻塞原语创建锁和其他同步类。Basic thread blocking primitives for creating locks and other synchronization classes.</p></blockquote><blockquote><p>LockSupport 类每个使用它的线程关联一个许可（在意义上的Semaphore类）。 如果许可可用，调用 park 将立即返回，并在此过程中消费它; 否则可能阻塞。如果许可不是可用，可以调用 unpark 使得许可可用。（但与Semaphore不同，许可不能累积。最多有一个。）</p><p>方法 park 和 unpark 提供了阻塞的有效手段和解锁线程不会遇到死锁问题，而 Thread.suspend 和 Thread.resume 是不能用于这种目的：因为许可的存在，一个线程调用 park 和另一个线程试图 unpark 它之间的竞争将保持活性。 此外，如果调用者线程被中断，park 将返回，并且支持设置超时。 该 park 方法也可能返回在其他任何时间，“毫无理由”，因此通常必须在一个循环中调用的返回后重新检查条件。 在这个意义上park作为“忙碌等待”不会浪费太多的时间自旋的优化，但必须以配对 unpark 使用。</p><p>这三种形式的 park 还支持 blocker 对象参数。而线程被阻塞时是允许使用监测和诊断工具，以确定线程被阻塞的原因。（诊断工具可以使用getBlocker(Thread) 方法 。）同时推荐使用带有 blocker 参数的 park方法，通常做法是 blocker 被设置为 this 。</p></blockquote><p>上面的意思总结下来个人理解是：</p><ol><li>许可（permit）的上限是1，也就是说只有 0 或 1 。</li><li>park: 没有许可的时候，permit 为 0 ，调用 park 会阻塞；有许可的时候，permit 为 1 ， 调用 park 会扣除一个许可，然后返回。</li><li>unpark：没有许可的时候，permit 为 0 ，调用 unpark 会增加一个许可，因为许可上限是 1 ， 所以调用多次也只会为 1 个。</li><li>线程初始的时候是没有许可的。</li><li>park 的当前线程如果被中断，会立即返回，并不会抛出中断异常。</li><li>park 方法的调用一般要放在一个循环判断体里面。</li></ol><p>大概如图所示：</p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/rGm1AX.png" align=center /><p>下面是源码注释中的案例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * FIFO 独占锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FIFOMutex</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean locked = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Thread&gt; waiters = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;Thread&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">boolean</span> wasInterrupted = <span class="keyword">false</span>;</span><br><span class="line">     Thread current = Thread.currentThread();</span><br><span class="line">     waiters.add(current);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Block while not first in queue or cannot acquire lock</span></span><br><span class="line">     <span class="comment">// 不在队列头，或者锁被占用，则阻塞， 就是只有队列头的可以获得锁</span></span><br><span class="line">     <span class="keyword">while</span> (waiters.peek() != current || !locked.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">       LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">       <span class="keyword">if</span> (Thread.interrupted()) <span class="comment">// ignore interrupts while waiting</span></span><br><span class="line">         wasInterrupted = <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     waiters.remove();</span><br><span class="line">     <span class="keyword">if</span> (wasInterrupted)          <span class="comment">// reassert interrupt status on exit</span></span><br><span class="line">       current.interrupt();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     locked.set(<span class="keyword">false</span>);</span><br><span class="line">     LockSupport.unpark(waiters.peek());</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><h4 id="线程初始有没有许可？"><a href="#线程初始有没有许可？" class="headerlink" title="线程初始有没有许可？"></a>线程初始有没有许可？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSupportTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;开始执行……&quot;</span>);</span><br><span class="line"></span><br><span class="line">        LockSupport.park();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;LockSupport park 之后……&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>执行后会发现，代码在 park 处阻塞。说明，线程初始是没有许可的。</li></ol><h4 id="添加许可并消耗许可"><a href="#添加许可并消耗许可" class="headerlink" title="添加许可并消耗许可"></a>添加许可并消耗许可</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSupportTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;开始执行……&quot;</span>);</span><br><span class="line"></span><br><span class="line">        LockSupport.unpark(Thread.currentThread());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;执行 - park&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        LockSupport.park();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;LockSupport park 之后……&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSupportTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程 &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;开始执行 park&quot;</span>);</span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;线程 &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;执行 park 结束&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="comment">// 保证 上面线程先执行，然后再主线程</span></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;开始执行 unpark(thread)&quot;</span>);</span><br><span class="line">        LockSupport.unpark(thread);</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;执行 unpark(thread) 结束&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过上面示例可以看出：</p><ol><li>执行 unpark 可以进行给予指定线程一个证书。</li><li>线程当前被 park 阻塞，此时给予证书之后， park 会消耗证书，然后继续执行。</li></ol><h4 id="许可上限为-1"><a href="#许可上限为-1" class="headerlink" title="许可上限为 1"></a>许可上限为 1</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSupportTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;unpark 1次&quot;</span>);</span><br><span class="line">        LockSupport.unpark(Thread.currentThread());</span><br><span class="line">        System.out.println(<span class="string">&quot;unpark 2次&quot;</span>);</span><br><span class="line">        LockSupport.unpark(Thread.currentThread());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;执行 - park 1 次&quot;</span>);</span><br><span class="line">        LockSupport.park();</span><br><span class="line">        System.out.println(<span class="string">&quot;执行 - park 2 次&quot;</span>);</span><br><span class="line">        LockSupport.park();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;LockSupport park 之后……&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>线程阻塞，可以看出 permit 只能有一个</li></ol><h4 id="中断可以使-park-继续执行并不会抛出异常"><a href="#中断可以使-park-继续执行并不会抛出异常" class="headerlink" title="中断可以使 park 继续执行并不会抛出异常"></a>中断可以使 park 继续执行并不会抛出异常</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSupportTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程 &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;开始执行 park&quot;</span>);</span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;线程 &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;执行 park 结束&quot;</span>);</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;线程 &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;开始执行 park 第二次&quot;</span>);</span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;线程 &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;执行 park 第二次 结束&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            thread.start();</span><br><span class="line">            <span class="comment">// 保证 上面线程先执行，然后再主线程</span></span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;开始执行 unpark(thread)&quot;</span>);</span><br><span class="line">            <span class="comment">// LockSupport.unpark(thread);</span></span><br><span class="line">            thread.interrupt();</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;执行 unpark(thread) 结束&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_221.jdk/Contents/Home/bin/java ...</span><br><span class="line">线程 Thread-0开始执行 park</span><br><span class="line">开始执行 unpark(thread)</span><br><span class="line">线程 Thread-0执行 park 结束</span><br><span class="line">线程 Thread-0开始执行 park 第二次</span><br><span class="line">线程 Thread-0执行 park 第二次 结束</span><br><span class="line">执行 unpark(thread) 结束</span><br></pre></td></tr></table></figure><ol><li>可以看出线程中断，park 会继续执行，并且没有抛出异常。</li><li>thread.interrupt(); 调用之后， 设置线程中断标示，unpark 没有清除中断标示，第二个 park 也会继续执行。</li></ol><h4 id="使用诊断工具"><a href="#使用诊断工具" class="headerlink" title="使用诊断工具"></a>使用诊断工具</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">liuzhihang % &gt; jps</span><br><span class="line">76690 LockSupportTest</span><br><span class="line">77130 Jps</span><br><span class="line">liuzhihang % &gt; jstack 77265</span><br><span class="line">...</span><br><span class="line"><span class="string">&quot;main&quot;</span> <span class="comment">#1 prio=5 os_prio=31 tid=0x00007f7f3e80a000 nid=0xe03 waiting on condition [0x000070000dfcd000]</span></span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">        at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:304)</span><br><span class="line">        at com.liuzhihang.source.LockSupportTest.main(LockSupportTest.java:14)</span><br></pre></td></tr></table></figure><ol><li>中间省略部分，但是可以看出线程进入 <code>WAITING</code> 状态</li></ol><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为线程 thread 设置一个许可</span></span><br><span class="line"><span class="comment">     * 无许可，则添加一个许可，有许可，则不添加</span></span><br><span class="line"><span class="comment">     * 如果线程因为 park 被阻塞， 添加许可之后，会解除阻塞状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (thread != <span class="keyword">null</span>)</span><br><span class="line">            UNSAFE.unpark(thread);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有许可，则使用该许可</span></span><br><span class="line"><span class="comment">     * 没有许可，阻塞线程，直到获得许可</span></span><br><span class="line"><span class="comment">     * 传递 blocker 是为了方便使用诊断工具</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(Object blocker)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        setBlocker(t, blocker);</span><br><span class="line">        UNSAFE.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">        setBlocker(t, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置线程的 blocker 属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setBlocker</span><span class="params">(Thread t, Object arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Even though volatile, hotspot doesn&#x27;t need a write barrier here.</span></span><br><span class="line">        UNSAFE.putObject(t, parkBlockerOffset, arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LockSupport 的 park unpark 方法，实际调用的是底层 Unsafe 类的 native 方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Unsafe</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Object var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(<span class="keyword">boolean</span> var1, <span class="keyword">long</span> var2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然调用了 Unsafe 到此处肯定不能善罢甘休。</p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/ffecad2c8644bab7d152be118c31722d.jpg" align=center /><h4 id="hotspot-源码"><a href="#hotspot-源码" class="headerlink" title="hotspot 源码"></a>hotspot 源码</h4><p>这块是下载的官方包中的源码，阅读并查阅资料了解的大概逻辑，不清楚之处，希望指导出来。</p><p>也可以直接跳过直接看结论。</p><p>查看jdk源码<br><a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/5a83b7215107/src/share/vm/runtime/park.hpp">http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/5a83b7215107/src/share/vm/runtime/park.hpp</a></p><p>这块在以 os_linux 代码为例<br><a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/5a83b7215107/src/os/linux/vm/os_linux.cpp">http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/5a83b7215107/src/os/linux/vm/os_linux.cpp</a></p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/c-parker.png" align=center /><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/c-park.png" align=center /><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/c-unpark.png" align=center /><ol><li>在底层维护了一个 <code>_counter</code> 通过更新 <code>_counter</code> 的值来标示是否有证明。</li><li>在 park 时，判断 <code>_counter</code> 为 0，则阻塞等待，为 1 则获得更新为 0 并返回。</li><li>在 unpark 时，判断 <code>_counter</code> 为 0，则给予凭证，并唤醒线程，为 1 则直接返回。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结也是和预想的是相同的。</p><ol><li>许可（permit）的上限是1，也就是说只有 0 或 1 。</li><li>park: 没有许可的时候，permit 为 0 ，调用 park 会阻塞；有许可的时候，permit 为 1 ， 调用 park 会扣除一个许可，然后返回。</li><li>unpark：没有许可的时候，permit 为 0 ，调用 unpark 会增加一个许可，因为许可上限是 1 ， 所以调用多次也只会为 1 个。</li><li>线程初始的时候是没有许可的。</li><li>park 的当前线程如果被中断，会立即返回，并不会抛出中断异常。</li></ol><h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><ul><li>park/unpark 和 wait/notify 区别</li></ul><ol><li>park 阻塞当前线程，unpark 唤醒指定线程。</li><li>wait() 需要结合锁使用，并释放锁资源，如果没有设置超时时间，则需要 notify() 唤醒。而 notify() 是随机唤醒线程。 </li></ol>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码笔记 </tag>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JDK源码笔记】- JDK 8 新增的 LongAdder，得过来看一下！</title>
      <link href="2020/06/28/source-code-longadder.html"/>
      <url>2020/06/28/source-code-longadder.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>在介绍 AtomicInteger 时，已经说明在高并发下大量线程去竞争更新同一个原子变量时，因为只有一个线程能够更新成功，其他的线程在竞争失败后，只能一直循环，不断的进行 CAS 尝试，从而浪费了 CPU 资源。而在 JDK 8 中新增了 LongAdder 用来解决高并发下变量的原子操作。下面同样通过阅读源码来了解 LongAdder 。</p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>一个或多个变量共同维持初值为 0 总和。 当跨线程竞争更新时，变量集可以动态增长以减少竞争。 方法 sum 返回当前变量集的总和。</p><p>当多个线程更新时，这个类是通常优选 AtomicLong ，比如用于收集统计信息，不用于细粒度同步控制的共同总和。 在低更新竞争，这两个类具有相似的特征。 但在高更新竞争时，使用 LongAdder 性能要高于 AtomicLong，同样要消耗更高的空间为代价。</p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/longadder-uml.png" align=center /><p>LongAdder 继承了 Striped64，内部维护一个 Cells 数组，相当于多个 Cell 变量， 每个 Cell 里面都有一个初始值为 0 的 long 型变量。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="Cell-类"><a href="#Cell-类" class="headerlink" title="Cell 类"></a>Cell 类</h4><p>Cell 类 是 Striped64 的静态内部类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Cell</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> value;</span><br><span class="line">    Cell(<span class="keyword">long</span> x) &#123; value = x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">cas</span><span class="params">(<span class="keyword">long</span> cmp, <span class="keyword">long</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, valueOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unsafe mechanics</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; ak = Cell.class;</span><br><span class="line">            valueOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (ak.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>Cell 使用 @sun.misc.Contended 注解。</li><li>内部维护一个被 volatile 修饰的 long 型 value 。</li><li>提供 cas 方法，更新value。</li></ol><p>其中 @sun.misc.Contended 注解作用是为了减少缓存争用。什么是缓存争用，这里只做下简要介绍。</p><blockquote><p>伪共享<br>CPU 存在多级缓存，其中最小存储单元是 Cache Line，每个 Cache Line 能存储 64 个字节的数据。<br>在多线程场景下，A B 两个线程数据如果被存储到同一个 Cache Line 上，此时 A B 更新各自的数据，就会发生缓存争用，导致多个线程之间相互牵制，变成了串行程序，降低了并发。<br>@sun.misc.Contended 注解，则可以保证该变量独占一个 Cache Line。<br>详细可参考：<a href="http://openjdk.java.net/jeps/142">http://openjdk.java.net/jeps/142</a></p></blockquote><h4 id="Striped64-核心属性"><a href="#Striped64-核心属性" class="headerlink" title="Striped64 核心属性"></a>Striped64 核心属性</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Striped64</span> <span class="keyword">extends</span> <span class="title">Number</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** CPU 的数量，以限制表大小 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * cell 数组，当非空时，大小是 2 的幂。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> Cell[] cells;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Base 值，在无争用时使用，表初始化竞赛期间的后备。使用 CAS 更新 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> base;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调整大小和创建Cells时自旋锁（通过CAS锁定）使用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Striped64 类主要提供以下几个属性：</p><ol><li>NCPU：CPU 的数量，以限制表大小。</li><li>cells：Cell[] cell 数组，当非空时，大小是 2 的幂。</li><li>base：long 型，Base 值，在无争用时使用，表初始化竞赛期间的后备。使用 CAS 更新。</li><li>cellsBusy：调整大小和创建Cells时自旋锁（通过CAS锁定）使用。</li></ol><p>下面看是进入核心逻辑：</p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/uFCfpw.gif" align=center /><h4 id="LongAdder-add"><a href="#LongAdder-add" class="headerlink" title="LongAdder#add"></a>LongAdder#add</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongAdder</span> <span class="keyword">extends</span> <span class="title">Striped64</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">        Cell[] as; <span class="keyword">long</span> b, v; <span class="keyword">int</span> m; Cell a;</span><br><span class="line">        <span class="comment">// cells 是 数组，base 是基础值</span></span><br><span class="line">        <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> || !casBase(b = base, b + x)) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">                (a = as[getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">                !(uncontended = a.cas(v = a.value, v + x)))</span><br><span class="line">                longAccumulate(x, <span class="keyword">null</span>, uncontended);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Striped64</span> <span class="keyword">extends</span> <span class="title">Number</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 CAS 更新 BASE 的值</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">casBase</span><span class="params">(<span class="keyword">long</span> cmp, <span class="keyword">long</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, BASE, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回当前线程的探测值。 由于包装限制，从ThreadLocalRandom复制</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getProbe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.getInt(Thread.currentThread(), PROBE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/longadder-add.png" align=center /><ol><li>首先会对 Base 值进行 CAS 更新，当 Base 发生竞争时， 会更新数组内的 Cell 。</li><li>数组未初始化，Cell 未初始化， Cell 更新失败，即 Cell 也发生竞争时，会调用 Striped64 的 longAccumulate 方法。</li></ol><h4 id="Striped64-longAccumulate"><a href="#Striped64-longAccumulate" class="headerlink" title="Striped64#longAccumulate"></a>Striped64#longAccumulate</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Striped64</span> <span class="keyword">extends</span> <span class="title">Number</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * x 要增加的值</span></span><br><span class="line"><span class="comment">     * wasUncontended 有没有发生竞争 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">longAccumulate</span><span class="params">(<span class="keyword">long</span> x, LongBinaryOperator fn, <span class="keyword">boolean</span> wasUncontended)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="comment">// 当前线程有无初始化线程探测值， 给当前线程生成一个 非 0 探测值</span></span><br><span class="line">        <span class="keyword">if</span> ((h = getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">            ThreadLocalRandom.current(); <span class="comment">// force initialization</span></span><br><span class="line">            h = getProbe();</span><br><span class="line">            wasUncontended = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> collide = <span class="keyword">false</span>;                <span class="comment">// True if last slot nonempty</span></span><br><span class="line">        <span class="comment">// 循环</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Cell[] as; Cell a; <span class="keyword">int</span> n; <span class="keyword">long</span> v;</span><br><span class="line">            <span class="comment">// 数组不为空切数组长度大于 0</span></span><br><span class="line">            <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// (n - 1) &amp; h 获取到索引，索引处 cell 是否为 null， cell未初始化</span></span><br><span class="line">                <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 判断 cellsBusy 是否为 0</span></span><br><span class="line">                    <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;       <span class="comment">// Try to attach new Cell</span></span><br><span class="line">                        Cell r = <span class="keyword">new</span> Cell(x);   <span class="comment">// Optimistically create</span></span><br><span class="line">                        <span class="comment">// cellsBusy == 0 且 使用 casCellsBusy 方法将其更新为 1，失败会继续循环</span></span><br><span class="line">                        <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                            <span class="keyword">boolean</span> created = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">try</span> &#123;               <span class="comment">// Recheck under lock</span></span><br><span class="line">                                Cell[] rs; <span class="keyword">int</span> m, j;</span><br><span class="line">                                <span class="comment">// 重新检查状态 并创建</span></span><br><span class="line">                                <span class="keyword">if</span> ((rs = cells) != <span class="keyword">null</span> &amp;&amp; (m = rs.length) &gt; <span class="number">0</span> &amp;&amp; rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    rs[j] = r;</span><br><span class="line">                                    created = <span class="keyword">true</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                <span class="comment">// 创建完成之后， 改回 cellsBusy 值</span></span><br><span class="line">                                cellsBusy = <span class="number">0</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (created)</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="comment">// 未创建继续循环</span></span><br><span class="line">                            <span class="keyword">continue</span>;           <span class="comment">// Slot is now non-empty</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    collide = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 传入的 wasUncontended 为 false 即发生碰撞了， 修改为未碰撞， 此处会继续循环，走到下一步，相当于会一直循环这个 cell</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)       <span class="comment">// CAS already known to fail</span></span><br><span class="line">                    wasUncontended = <span class="keyword">true</span>;      <span class="comment">// Continue after rehash</span></span><br><span class="line">                <span class="comment">// cas 更新 cell 的 value， 成功则返回</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a.cas(v = a.value, ((fn == <span class="keyword">null</span>) ? v + x : fn.applyAsLong(v, x))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 数组到最大长度 即大于等于 CPU 数量， 或者 cells 数组被改变，</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= NCPU || cells != as)</span><br><span class="line">                    collide = <span class="keyword">false</span>;            <span class="comment">// At max size or stale</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">                    collide = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 乐观锁 进行扩容</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (cells == as) &#123;      <span class="comment">// Expand table unless stale</span></span><br><span class="line">                            Cell[] rs = <span class="keyword">new</span> Cell[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                                rs[i] = as[i];</span><br><span class="line">                            cells = rs;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        cellsBusy = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    collide = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;                   <span class="comment">// Retry with expanded table</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 当前探针值不能操作成功，则重新设置一个进行尝试</span></span><br><span class="line">                h = advanceProbe(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 没有加 cellsBusy 乐观锁 且 没有初始化，且获得锁成功（此时 cellsBusy == 1）</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> init = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;                           <span class="comment">// Initialize table</span></span><br><span class="line">                    <span class="keyword">if</span> (cells == as) &#123;</span><br><span class="line">                        Cell[] rs = <span class="keyword">new</span> Cell[<span class="number">2</span>];</span><br><span class="line">                        rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> Cell(x);</span><br><span class="line">                        cells = rs;</span><br><span class="line">                        init = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    cellsBusy = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (init)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 尝试在base上累加</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (casBase(v = base, ((fn == <span class="keyword">null</span>) ? v + x : fn.applyAsLong(v, x))))</span><br><span class="line">                <span class="keyword">break</span>;                          <span class="comment">// Fall back on using base</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>longAccumulate 方法一共有三种情况</p><ol><li><code>(as = cells) != null &amp;&amp; (n = as.length) &gt; 0</code> 数组不为空且长度大于 0 。<ol><li>获取索引处的 cell ， cell 为空则进行初始化。</li><li>cell 不为空，使用 cas 更新， 成功 <code>break;</code> 跳出循环， 失败则还在循环内，会一直尝试。</li><li>collide 指是否发生冲突，冲突后会进行重试。</li><li>冲突后会尝试获得锁并进行扩容，扩容长度为原来的 2 倍，然后继续重试。</li><li>获得锁失败（说明其他线程在扩容）会重新进行计算探针值。</li></ol></li><li><code>cellsBusy == 0 &amp;&amp; cells == as &amp;&amp; casCellsBusy()</code> 数组为空，获得乐观锁成功。<ol><li>直接初始化数组。</li><li>初始数组长度为 2 。</li></ol></li><li><code>casBase(v = base, ((fn == null) ? v + x : fn.applyAsLong(v, x)))</code> 获得乐观锁失败。<ol><li>说明有其他线程在初始化数组，直接 CAS 更新 base 。</li></ol></li></ol><h4 id="LongAdder-sum"><a href="#LongAdder-sum" class="headerlink" title="LongAdder#sum"></a>LongAdder#sum</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongAdder</span> <span class="keyword">extends</span> <span class="title">Striped64</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Cell[] as = cells; Cell a;</span><br><span class="line">        <span class="keyword">long</span> sum = base;</span><br><span class="line">        <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                    sum += a.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>数组为空，说明没有发生竞争，直接返回 base 。</li><li>数组不为空，说明发生竞争，累加 cell 的 value 和 base 的和进行返回。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h4><ol><li>LongAdder 继承了 Striped64，内部维护一个 Cells 数组，相当于多个 Cell 变量， 每个 Cell 里面都有一个初始值为 0 的 long 型变量。</li><li>未发生竞争时（Cells 数组未初始化），是对 base 变量进行原子操作。</li><li>发生竞争时，每个线程对自己的 Cell 变量的 value 进行原子操作。</li></ol><h4 id="如何确定哪个线程操作哪个-cell？"><a href="#如何确定哪个线程操作哪个-cell？" class="headerlink" title="如何确定哪个线程操作哪个 cell？"></a>如何确定哪个线程操作哪个 cell？</h4><p>通过 <code>getProbe()</code> 方法获取该线程的探测值，然后和数组长度 <code>n - 1</code> 做 <code>&amp;</code> 操作 (n - 1) &amp; h 。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getProbe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> UNSAFE.getInt(Thread.currentThread(), PROBE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Cells-数组初始化及扩容？"><a href="#Cells-数组初始化及扩容？" class="headerlink" title="Cells 数组初始化及扩容？"></a>Cells 数组初始化及扩容？</h4><p>初始化扩容时会判断 <code>cellsBusy</code>， cellsBusy 使用 <code>volatile</code> 修饰，保证线程见可见性，同时使用 CAS 进行更新。 0 表示空闲，1 表示正在初始化或扩容。</p><p>初始化时会创建长度为 2 的 Cell 数组。扩容是创建一个长度是原数组长度 2 倍的新数组，并循环赋值。</p><p>如果线程访问分配的 Cell 元素有冲突后，会使用 <code>advanceProbe()</code> 方法重新获取探测值，再次进行尝试。</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>在高并发情况下，需要相对高的性能，同时数据准确性要求不高，可以考虑使用 LongAdder。</p><p>当要保证线程安全，并允许一定的性能损耗时，并对数据准确性要求较高，优先使用 AtomicLong。</p>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码笔记 </tag>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JDK源码笔记】- 请介绍下你了解的ThreadLocal，它的底层原理！</title>
      <link href="2020/06/21/source-code-threadlocal.html"/>
      <url>2020/06/21/source-code-threadlocal.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>前言</strong></p><p>业务开发中经常使用 ThreadLocal 来存储用户信息等线程私有对象… ThreadLocal 内部构造是什么样子的？为什么可以线程私有？常说的内存泄露又是怎么回事？</p><p>公众号：liuzhihangs ，记录工作学习中的技术、开发及源码笔记；时不时分享一些生活中的见闻感悟。欢迎大佬来指导！</p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote><p>ThreadLocal 类提供了线程局部变量。和正常对象不同的是，每个线程都可以访问 get()、set() 方法，获取独属于自己的副本。 ThreadLocal 实例通常是类中的私有静态字段，并且其状态和线程关联。<br>每个线程都保持对其线程局部变量副本的隐式引用，只要线程是活动的并且 ThreadLocal 实例访问; 一个线程消失之后，所有的线程局部实例的副本都会被垃圾回收（除非存在对这些副本的其他引用）。</p></blockquote><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>有这么一种使用场景，收到 web 请求，先进行 token 验证，而这个 token，可以解析出用户 user 的信息。所以我这边一般是这样使用的：</p><ol><li>自定义注解， <code>@CheckToken</code> ， 标识该方法需要校验 token。</li><li>在 <code>Interceptor</code>（拦截器）中检查，如果方法有 <code>@CheckToken</code> 注解则校验 token。</li><li>从Header中获取 <code>Authorization</code> ，请求第三方或者自己的逻辑校验 token ，并解析成 user。</li><li>将user放到<code>ThreadLocal</code>中。</li><li>controller、service 在后续使用中， 如果需要 user 信息，可以直接从 <code>ThreadLocal</code> 中获取。</li><li>使用结束后进行remove。</li></ol><h4 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalUserUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户信息保存至 ThreadLocal 中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;User&gt; USER_THREAD_LOCAL = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        USER_THREAD_LOCAL.set(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> USER_THREAD_LOCAL.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        USER_THREAD_LOCAL.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 加上注解 CheckToken</span></span><br><span class="line"><span class="comment"> * 只有方法， 类忽略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@CheckToken</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/doXxx&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result&lt;Resp&gt; <span class="title">doXxx</span><span class="params">(<span class="meta">@RequestBody</span> Req req)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Resp resp = xxxService.doXxx(req);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result.success(resp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2. 3. 4.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception arg3)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        LocalUserUtils.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 请求方法是否存在注解</span></span><br><span class="line">        <span class="keyword">boolean</span> assignableFrom = handler.getClass().isAssignableFrom(HandlerMethod.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!assignableFrom) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        CheckToken checkToken = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> HandlerMethod) &#123;</span><br><span class="line">            checkToken = ((HandlerMethod) handler).getMethodAnnotation(CheckToken.class);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有加注解 直接放过</span></span><br><span class="line">        <span class="keyword">if</span> (checkToken == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从Header中获取Authorization</span></span><br><span class="line">        String authorization = request.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;header authorization : &#123;&#125;&quot;</span>, authorization);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(authorization)) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;从Header中获取Authorization失败&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> CustomExceptionEnum.NOT_HAVE_TOKEN.throwCustomException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        User user = xxxUserService.checkAuthorization(authorization);</span><br><span class="line">        <span class="comment">// 放到</span></span><br><span class="line">        LocalUserUtils.set(user);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 5. 使用</span></span><br><span class="line"><span class="comment"> * 只有方法， 类忽略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Resp <span class="title">doXxx</span><span class="params">(Req req)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    User user = LocalUserUtils.get();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// do something ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> resp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/640.jpeg"  div align=center /><h4 id="抛出问题"><a href="#抛出问题" class="headerlink" title="抛出问题"></a>抛出问题</h4><ol><li>为什么可以线程私有？</li><li>为什么建议声明为静态？</li><li>为什么强制使用后必须remove？</li></ol><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/19.png" alt="19"></p><p>图 | 阿里巴巴 - Java开发手册（截图）</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/6.png" alt="6"></p><p>图 | 阿里巴巴 - Java开发手册（截图）</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略 ...</span></span><br><span class="line"></span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">    ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 <code>Thread</code> 对象中声明了 <code>ThreadLocal.ThreadLocalMap</code> 对象，每个线程都有自己的工作内存，每个线程都有自己的 <code>ThreadLocal. ThreadLocalMap</code> 对象，所以在线程之间是互相<code>隔离</code>的。</p><h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><p>ThreadLocal则是一个泛型类，同时提供 <code>set()</code>、<code>get()</code>、<code>remove()</code> 等<code>静态</code>方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程本地hashCode</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取此线程局部变量的当前线程副本中的值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="comment">// 设置当前线程的此线程局部变量的复制到指定的值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="comment">// 删除当前线程的此线程局部变量的值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="comment">// ThreadLocalMap只是用来维持线程本地值的定制Map</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="set-T-value-方法"><a href="#set-T-value-方法" class="headerlink" title="set(T value)方法"></a>set(T value)方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取当前线程的 threadLocals 属性</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 存在则赋值</span></span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 不存在则直接创建</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据线程获取当前线程的ThreadLocalMap</span></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建ThreadLocalMap 并赋值给当前线程的threadLocals字段</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.<code>Thread.currentThread()</code> 先获取到当前线程。<br>2. 获取当前线程的 <code>threadLocals</code> 属性，即 <code>ThreadLocalMap</code>。<br>3. 判断 Map 是否存在，存在则赋值，不存在则创建对象。</p><h5 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取当前线程的 threadLocals 属性</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">// map不为空</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 根据当前ThreadLocal获取的ThreadLocalMap的Entry节点</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取节点的value 并返回</span></span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置初始值并返回 （null）</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1.<code>Thread.currentThread()</code> 先获取到当前线程。<br>2. 获取当前线程的 <code>threadLocals</code> 属性，即 <code>ThreadLocalMap</code> 。<br>3. 判断 Map 不为空，根据当前 <code>ThreadLocal</code> 对象获取 <code>ThreadLocalMap.Entry</code> 节点, 从节点中获取 value。<br>4.<code>ThreadLocalMap</code> 为空或者 <code>ThreadLocalMap.Entry</code> 为空，则初始化 ThreadLocalMap 并返回。</p><h5 id="remove-方法"><a href="#remove-方法" class="headerlink" title="remove()方法"></a>remove()方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程的ThreadLocalMap</span></span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="comment">// 不为空， 从ThreadLocalMap中移除该属性</span></span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">        m.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>阅读 <code>set()</code>、<code>get()</code>、<code>remove()</code> 的源码之后发现后面其实是操作的 <code>ThreadLocalMap</code>, 主要还是操作的 <code>ThreadLocalMap</code> 的 <code>set()</code>、<code>getEntry()</code>、<code>remove()</code> 以及构造函数。下面看是看 ThreadLocalMap 的源码。</p><h4 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Entry节点继承WeakReference是弱引用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/** 与此ThreadLocal关联的值。 */</span></span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始容量-必须是2的幂</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表，根据需要调整大小. table.length必须始终为2的幂.</span></span><br><span class="line">    <span class="keyword">private</span> ThreadLocal.ThreadLocalMap.Entry[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表中的条目数。 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容阈值  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threshold; <span class="comment">// Default to 0</span></span><br><span class="line">    <span class="comment">// 设置阀值为长度的 2/3   </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setThreshold</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        threshold = len * <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据ThreadLocal获取节点Entry</span></span><br><span class="line">    <span class="keyword">private</span> ThreadLocal.ThreadLocalMap.<span class="function">Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set ThreadLocalMap的k-v</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除当前值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>Entry 继承了 <code>WeakReference&lt;ThreadLocal&lt;?&gt;</code> 也就意味着， <code>Entry 节点的 key 是弱引用</code>。</li><li>Entry 对象的key弱引用，指向的是 <code>ThreadLocal</code> 对象。</li><li>线程对象执行完毕，线程对象内实例属性会被回收，此时线程内 <code>ThreadLocal</code> 对象的<code>引用</code>被置为 <code>null</code> ，即 Entry 的 <code>key</code> 为 <code>null</code>, key 会被垃圾回收。</li><li>ThreadLocal 对象通常为私有静态变量， 生命周期不会至少不会随着线程技术而结束。</li><li>ThreadLocal 对象存在，并且 <code>Entry的 key == null &amp;&amp; value != null</code> ，这时就会造成内存泄漏。</li></ol><ul><li>小补充</li></ul><ol><li>强引用、软引用、弱引用、虚引用<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">强引用（StrongReference）：最常见，直接 new Object(); 创建的即为强引用。当内存空间不足，Java虚拟机宁愿抛出 OOM，也不愿意随意回收具有强引用的对象来解决内存不足问题。</span><br><span class="line">软引用（SoftReference）：内存足够，垃圾回收器不会回收软引用对象；内存不足时，垃圾回收器会回收。</span><br><span class="line">弱引用（WeakReference）：垃圾回收器线程，发现就会回收。</span><br><span class="line">虚引用（PhantomReference）：任何时候都有可能被垃圾回收，必须引用队列联合使用。</span><br></pre></td></tr></table></figure></li><li>内存泄露：<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">内存泄漏（Memory leak）是在计算机科学中，由于疏忽或错误造成程序未能释放已经不再使用的内存。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费。</span><br><span class="line">—— 维基百科</span><br></pre></td></tr></table></figure></li></ol><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/SJPSIU.jpg"  div align=center /><h5 id="构造函数及hash计算"><a href="#构造函数及hash计算" class="headerlink" title="构造函数及hash计算"></a>构造函数及hash计算</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    <span class="comment">// 初始化Entry数组， 长度为16</span></span><br><span class="line">    table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">    <span class="comment">// 获取key的hashCode，并计算出在数组中的索引，</span></span><br><span class="line">    <span class="comment">// 长度是 2的幂的情况下，取模 a % b == a &amp; (b - 1)</span></span><br><span class="line">    <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">    table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">    <span class="comment">// 设置数组元素数</span></span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 设置扩容阈值</span></span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>threadLocalHashCode 是 ThreadLocal 的静态属性，通过 nextHashCode 方法获取。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被赋予了接下来的哈希码。 原子更新。 从零开始。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回下一个hash码，通过步长 0x61c88647 累加生成，这块注释说明是最佳哈希值</span></span><br><span class="line">    <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>初始化数组，长度16。</li><li>计算 key 的 hashCode，对2的幂取模。</li><li>设置元素，元素数及扩容阈值。</li></ol><p>hashCode 通过步长 0x61c88647 累加生成， 并且使用了 AtomicInteger，保证原子性。</p><h5 id="set-方法"><a href="#set-方法" class="headerlink" title="set()方法"></a>set()方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="comment">// hashcode取模求数组索引</span></span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数组中对应的位置， 重点关注 e = tab[i = nextIndex(i, len)]</span></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i]; e != <span class="keyword">null</span>; e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="comment">// 获取key</span></span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// key 存在则覆盖</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// key 不存在则赋值</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时 e == null 直接执创建节点</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="comment">// cleanSomeSlots 循环数组 查找全部key==null的Entry</span></span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>获取循环 Entry 数组，获取 tab[i] 处的 e， e != null 继续循环<ol><li>此时发现 e 的 key 不存在，并且不是 null （hash冲突了。）</li><li>那就通过 e = tab[i = nextIndex(i, len)]) 继续获取下一个 i，并获取新的 tab[i] 处的 e。</li><li>赋值替换值结束结束并返回。</li></ol></li><li>e == null 结束循环。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下一个index，如果 i + 1 &lt; len 直接返回下一个位置  </span></span><br><span class="line"><span class="comment">// 如果 i + 1 &gt;= len 则返回 0， 从头开始。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prevIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i - <span class="number">1</span> &gt;= <span class="number">0</span>) ? i - <span class="number">1</span> : len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>这块利用环形设计，如果长度到达数组长度，则从开头开始继续查找。</li><li>int i = key.threadLocalHashCode &amp; (len-1); 求出索引，并不是从0开始的。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * staleSlot 为当前索引位置， 并且当前索引位置的 k == null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value, <span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要清除的 entry 的索引</span></span><br><span class="line">    <span class="keyword">int</span> slotToExpunge = staleSlot;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环获取到上一个 key==null 的节点及其索引，有可能还是自己</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len); (e = tab[i]) != <span class="keyword">null</span>; i = prevIndex(i, len))</span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 继续上一层的循环，查找下一个 k == key 的节点索引</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len); (e = tab[i]) != <span class="keyword">null</span>; i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            <span class="comment">// key 相等 则直接赋值</span></span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="comment">// 并且将 此处的 entry替换为 tab[staleSlot]</span></span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果发现要清除的 entry和传入的在一个位置上， 则直接赋值</span></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 清除掉过期的 expungeStaleEntry(slotToExpunge) 会清除 entry的value，将其设置为null并将其设置为null， 并返回下一个需要清除的entry的索引位置</span></span><br><span class="line">            <span class="comment">// cleanSomeSlots 循环数组 查找全部key==null的Entry</span></span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果向后扫描没有找到，并且已经到第初始传入的索引位置处了</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没找到， 直接将旧值 Entry 设置为 null 并指向新创建的Entry</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结束之后发现要清楚的 key的索引 不等于当前传入的索引， 说明还有其他需要清除。</span></span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>这里存在三个属性 key， value，以及 staleSlot， staleSlot节点的 Entry != null 但是 k == null。</li><li>向前扫描获取到上一个  Entry != null 但是 k == null 的节点及其索引, 赋值给 slotToExpunge， 没有扫描到的话 slotToExpunge 还是等于 staleSlot。</li><li>向后扫描 Entry != null 的节点，因为在 set 方法中， 后面还有一段数组没有遍历。<ol><li>发现 key 相等的Entry节点了， 直接赋值，然后清除其他 Entry != null 但是 k == null 的节点， 并返回。</li><li>没有找到key相等的节点，但是找到了下一个 Entry != null 但是 k == null， 且此时 slotToExpunge 未发生变化，还是指向 staleSlot， 则 i 赋值给 slotToExpunge。</li></ol></li><li>向后扫描没有扫描到，则直接对当前节点（索引值为staleSlot）的节点的value设置为null，并指向新value。</li><li>结束之后发现 slotToExpunge 被改变了， 说明还有其他的要清除。</li></ol><h5 id="getEntry-方法"><a href="#getEntry-方法" class="headerlink" title="getEntry()方法"></a>getEntry()方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// hashcode取模求数组索引</span></span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="comment">// 存在则返回</span></span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 不存在</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// key 已经 == null 了 清除一下 value</span></span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 继续获取下一个</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>hashcode 取模求数组索引。</li><li>索引处获取到 Entry 则直接返回。</li><li>获取不到或者获取到的 Entry key 不相等时，有可能是因为 hash 冲突，被放到别的地方， 调用 getEntryAfterMiss 方法。</li><li>getEntryAfterMiss 方法中。<ol><li>e == null  返回null。</li><li>e != null  判断key， key相等返回 Entry， key == null， 那就需要清除这个节点，然后继续按照 <code>nextIndex(i, len)</code> 方法找下一个节点。</li></ol></li></ol><h4 id="remove-方法-1"><a href="#remove-方法-1" class="headerlink" title="remove()方法"></a>remove()方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="comment">// hashcode 取模求数组索引</span></span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 清除当前节点的value</span></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i]; e != <span class="keyword">null</span>; e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">            <span class="comment">// 清楚对象引用</span></span><br><span class="line">            e.clear();</span><br><span class="line">            <span class="comment">// value 指向 null</span></span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.referent = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>hashcode 取模求数组索引。</li><li>循环查找数组，将当前 key 的 Entry 的引用，将 value 设置为 null， 后面会被垃圾回收掉。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="为什么可以线程私有？"><a href="#为什么可以线程私有？" class="headerlink" title="为什么可以线程私有？"></a>为什么可以线程私有？</h4><p>ThreadLocal 的 get()、set()、remove()方法中都有 <code>Thread t = Thread.currentThread();</code> 操作的其实是本线程，获取本线程的ThreadLocalMap。</p><p>每个线程都有自己的 ThreadLocal，并且是将 value 存放在一个以 ThreadLocal 为 key 的 ThreadLocalMap 中的。所以线程间隔离。</p><h4 id="为什么建议声明为静态？"><a href="#为什么建议声明为静态？" class="headerlink" title="为什么建议声明为静态？"></a>为什么建议声明为静态？</h4><p>Java开发手册已经给出说明，还有就是，如果 ThreadLocal 设置为非静态，那就是某个线程的实例类，这样的话就会失去了线程共享的本质属性。</p><h4 id="为什么强制必须时候后remove-？"><a href="#为什么强制必须时候后remove-？" class="headerlink" title="为什么强制必须时候后remove()？"></a>为什么强制必须时候后remove()？</h4><p>这块可以和内存泄露一块说明， 通过上面的 <code>ThreadLocalMap</code> 处关于弱引用的讲解已经说明会产生内存泄露。至于如何解决也给出了答案：</p><p>1.<code>set()</code> 时清除 Entry != null &amp;&amp; key == null 的节点， 将其 value 设置为 null。<br>2.<code>getEntry()</code> 时清除<code>当前 key 到 nextIndex(i, len)==null 之间的</code> Entry != null &amp;&amp; key == null 的节点， 将其 value 设置为 null。<br>3.<code>remove()</code> 时清除<code>指定key</code>的 Entry != null &amp;&amp; key == null 的节点， 将其 value 设置为 null。</p><p>之所以使用remove()，还是为了解决内存泄露的问题。</p><h4 id="Last"><a href="#Last" class="headerlink" title="Last"></a>Last</h4><ol><li>使用时注意声明为 <code>private static final</code>。</li><li>使用后要 <code>remove()</code>。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码笔记 </tag>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JDK源码笔记】- 从JUC源码看CAS，我做了个笔记 ......</title>
      <link href="2020/06/12/source-code-cas.html"/>
      <url>2020/06/12/source-code-cas.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>前言<br>JUC包下大量使用了CAS，工作和面试中也经常遇到CAS，包括说到乐观锁，也不可避免的想起CAS，那CAS究竟是什么？</p></blockquote><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>说到CAS，基本上都会想到乐观锁、AtomicInteger、Unsafe … </p><p>当然也有可能啥也没想到！</p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/zoi3eG.jpg" div align=center /><p>不管你们怎么想， 我第一印象是乐观锁，毕竟做交易更新交易状态经常用到乐观锁，就自然想到这个SQL：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> trans_order </span><br><span class="line"><span class="keyword">set</span> order_status = <span class="number">1</span> </span><br><span class="line"><span class="keyword">where</span> order_no = <span class="string">&#x27;xxxxxxxxxxx&#x27;</span> <span class="keyword">and</span> order_status = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>其实就是 set和where里面都携带order_status。</p><p>那什么是CAS？</p><p>CAS就是<code>Compare-and-Swap</code>，即比较并替换，在并发算法时常用，并且在JUC（java.util.concurrent）包下很多类都使用了CAS。</p><p>非常常见的问题就是多线程操作i++问题。一般解决办法就是添加 synchronized 关键字修饰，当然也可以使用 AtomicInteger 代码举例如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CasTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CountDownLatch LATCH = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> NUM_I = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> NUM_J = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger NUM_K = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                        NUM_I++;</span><br><span class="line">                        NUM_J++;</span><br><span class="line">                        NUM_K.incrementAndGet();</span><br><span class="line">                    &#125;</span><br><span class="line">                    LATCH.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        LATCH.await();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;NUM_I = &quot;</span> + NUM_I);</span><br><span class="line">        System.out.println(<span class="string">&quot;NUM_J = &quot;</span> + NUM_J);</span><br><span class="line">        System.out.println(<span class="string">&quot;NUM_K = &quot;</span> + NUM_K.get());</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面就从<code>AtomicInteger</code>开始了解CAS。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6214790243416807050L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">decrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, -<span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出里面使用了<code>Unsafe</code>类下的<code>getAndAddInt</code>方法，<code>Unsafe</code>类很多方法是本地（native）方法，主要是硬件级别的<code>原子操作</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> var1 当前对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> var2 当前对象在内存偏移量，Unsafe可以根据内存偏移地址获取数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> var4 操作值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 获取在var1在内存的值</span></span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">        <span class="comment">// 将var1赋值为var5+var4， 赋值时会判断var1是否为var5</span></span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原子操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br></pre></td></tr></table></figure><p>至于 compareAndSwapInt 的分析就忽略了。 </p><p>看完代码过程其实就是：</p><ol><li>比较var1的值是否为var4，是的话将var1更新为var5。</li><li>如果不是的话就一直循环，直到var1是var4。</li></ol><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/3E5FDF0D-875A-4CD0-9B75-61D01ACBCD50_4_5005_c.jpeg"  div align=center /><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/iyLlPP.png"  div align=center /><ol><li>这要是一直获取不到，岂不是一直循环。线程多的情况下，会自旋很长时间，导致浪费资源。</li><li>你更新了， 我又给你更新回去了，你也不知道。ABA问题！比如像这样，A想更新值为a，还未抢到资源，这时候B进行了更新，将对象更新为了b，然后又马上更新回了a， 这时候A是什么都不知道的。</li></ol><p>以乐观锁举例：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 0 -&gt; 1</span></span><br><span class="line"><span class="keyword">update</span> trans_order </span><br><span class="line"><span class="keyword">set</span> order_status = <span class="number">1</span> </span><br><span class="line"><span class="keyword">where</span> order_no = <span class="string">&#x27;xxxxxxxxxxx&#x27;</span> <span class="keyword">and</span> order_status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 1 -&gt; 0</span></span><br><span class="line"><span class="keyword">update</span> trans_order </span><br><span class="line"><span class="keyword">set</span> order_status = <span class="number">1</span> </span><br><span class="line"><span class="keyword">where</span> order_no = <span class="string">&#x27;xxxxxxxxxxx&#x27;</span> <span class="keyword">and</span> order_status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 0 -&gt; 1</span></span><br><span class="line"><span class="keyword">update</span> trans_order </span><br><span class="line"><span class="keyword">set</span> order_status = <span class="number">1</span> </span><br><span class="line"><span class="keyword">where</span> order_no = <span class="string">&#x27;xxxxxxxxxxx&#x27;</span> <span class="keyword">and</span> order_status = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>解决办法可以添加version进行版本号控制。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 0 -&gt; 1</span></span><br><span class="line"><span class="keyword">update</span> trans_order </span><br><span class="line"><span class="keyword">set</span> order_status = <span class="number">1</span> </span><br><span class="line"><span class="keyword">where</span> order_no = <span class="string">&#x27;xxxxxxxxxxx&#x27;</span> <span class="keyword">and</span> order_status = <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">version</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 1 -&gt; 0</span></span><br><span class="line"><span class="keyword">update</span> trans_order </span><br><span class="line"><span class="keyword">set</span> order_status = <span class="number">1</span> </span><br><span class="line"><span class="keyword">where</span> order_no = <span class="string">&#x27;xxxxxxxxxxx&#x27;</span> <span class="keyword">and</span> order_status = <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">version</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 0 -&gt; 1</span></span><br><span class="line"><span class="keyword">update</span> trans_order </span><br><span class="line"><span class="keyword">set</span> order_status = <span class="number">1</span> </span><br><span class="line"><span class="keyword">where</span> order_no = <span class="string">&#x27;xxxxxxxxxxx&#x27;</span> <span class="keyword">and</span> order_status = <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">version</span> = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>代码中可以看 <code>AtomicStampedReference</code> 类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以原子方式设置该引用和标志给定的更新值的值，</span></span><br><span class="line"><span class="comment"> * 如果当前引用==预期的引用，并且当前标志==预期标志。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expectedReference 预期引用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newReference 更新的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expectedStamp 预期标志</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newStamp 更新的标志</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if successful</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V   expectedReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                                V   newReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> expectedStamp,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> newStamp)</span> </span>&#123;</span><br><span class="line">    Pair&lt;V&gt; current = pair;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        expectedReference == current.reference &amp;&amp;</span><br><span class="line">        expectedStamp == current.stamp &amp;&amp;</span><br><span class="line">        ((newReference == current.reference &amp;&amp;</span><br><span class="line">            newStamp == current.stamp) ||</span><br><span class="line">            casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是额外增加一个标志（<code>stamp</code>）来防止ABA的问题， 类似乐观锁的version。</p>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码笔记 </tag>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JDK源码笔记】- HashMap红黑树</title>
      <link href="2020/05/25/source-code-hashmap-red-black-tree.html"/>
      <url>2020/05/25/source-code-hashmap-red-black-tree.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>前言<br>在阅读HashMap源码时，会发现在HashMap中使用了红黑树，所以需要先了解什么是红黑树，以及其原理。从而再进一步阅读HashMap中的链表到红黑树的转换，红黑树的增删节点等。</p></blockquote><blockquote><ol><li>什么是红黑树？</li><li>在HashMap中是怎么应用的？</li></ol></blockquote><h3 id="什么是红黑树？"><a href="#什么是红黑树？" class="headerlink" title="什么是红黑树？"></a>什么是红黑树？</h3><blockquote><p>红黑树（英语：Red–black tree）是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组。它在1972年由鲁道夫·贝尔发明，被称为”对称二叉B树”，它现代的名字源于Leo J. Guibas和Robert Sedgewick于1978年写的一篇论文。红黑树的结构复杂，但它的操作有着良好的最坏情况运行时间，并且在实践中高效：它可以在O(logN)时间内完成查找、插入和删除，这里的n是树中元素的数目。</p></blockquote><h3 id="红黑树的性质"><a href="#红黑树的性质" class="headerlink" title="红黑树的性质"></a>红黑树的性质</h3><p>红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求：</p><ol><li>节点是红色或黑色。</li><li>根是黑色。</li><li>所有叶子都是黑色（叶子是NIL节点）。</li><li>每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）</li><li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。</li></ol><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/red-black-tree001.jpeg" alt="红黑树001"></p><h3 id="红黑树操作"><a href="#红黑树操作" class="headerlink" title="红黑树操作"></a>红黑树操作</h3><h4 id="左旋、右旋"><a href="#左旋、右旋" class="headerlink" title="左旋、右旋"></a>左旋、右旋</h4><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/krck8S.gif" alt="krck8S"></p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/OUd2GL.gif" alt="OUd2GL"></p><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><ol><li>以二叉查找树的方法增加节点</li><li>新插入节点为红色（如果设为黑色，就会导致根到叶子的路径上有一条路上，多一个额外的黑节点，这个是很难调整的。但是设为红色节点后，可能会导致出现两个连续红色节点的冲突，那么可以通过颜色调换（color flips）和树旋转来调整。）</li></ol><p>注意：</p><ol><li>性质1和性质3是永远保持着的。</li><li>性质4只在增加红色节点、重绘黑色节点为红色，或做旋转时受到威胁。</li><li>性质5只在增加黑色节点、重绘红色节点为黑色，或做旋转时受到威胁。</li></ol><p>插入时会遇到以下五种情形：</p><blockquote><p>情形1：插入第一个节点<br>情形2：插入新节点，父节点是黑色<br>情形3：插入新节点，父节点是红色，叔父节点是红色<br>情形4：插入新节点，父节点是红色，叔父节点是黑色或缺省，新节点是右子节点，父节点又是其父节点的左子节点<br>情形5：插入新节点，父节点是红色，叔父节点是黑色或缺省，新节点是左子节点，父节点又是其父节点的左子节点。</p></blockquote><ul><li>情形1：</li></ul><p>操作：插入第一个节点<br>违反性质2：” 根是黑色。 “<br>情形：直接插入红色节点，然后进行染色为黑色</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/red-black-tree1.gif" alt="红黑树1"></p><ul><li>情形2：</li></ul><p>操作：插入新节点，父节点是黑色<br>未违反性质<br>情形：直接插入</p><ul><li>情形3：</li></ul><p>操作：插入新节点，父节点是红色，叔父节点是红色<br>违反性质4：” 每个红色节点必须有两个黑色的子节点。 “<br>情形：将祖父节点染色，祖父节点染色后再进行重新判断进行染色或旋转</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/red-black-tree3.gif" alt="红黑树3"></p><ul><li>情形4：</li></ul><p>操作：插入新节点，父节点是红色，叔父节点是黑色或缺省，新节点是右子节点，父节点又是其父节点的左子节点<br>违反性质4：” 每个红色节点必须有两个黑色的子节点。 “<br>情形：进行左旋，旋转后父节点变成左子节点，新节点变成父节点，然后重新判断进行染色或旋转</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/red-black-tree4.gif" alt="红黑树4"></p><ul><li>情形5：</li></ul><p>操作：插入新节点，父节点是红色，叔父节点是黑色或缺省，新节点是左子节点，父节点又是其父节点的左子节点。<br>违反性质4：” 每个红色节点必须有两个黑色的子节点。 “<br>情形：父节点染色为黑色，进行右旋，祖父节点变为右子节点，然后重新判断进行染色或旋转</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/red-black-tree5.gif" alt="红黑树5"></p><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line">    <span class="comment">// ... 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三个参数"><a href="#三个参数" class="headerlink" title="三个参数"></a>三个参数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链表转为树阈值。 </span></span><br><span class="line"><span class="comment"> * 大于等于8时，会转换为树。 </span></span><br><span class="line"><span class="comment"> * 8 是综合性能考虑确定的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从树转换为链表的阈值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最小树形化容量，只有哈希表元素数到达64才会进行树转换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br></pre></td></tr></table></figure><h4 id="链表转红黑树-treeifyBin"><a href="#链表转红黑树-treeifyBin" class="headerlink" title="链表转红黑树-treeifyBin"></a>链表转红黑树-treeifyBin</h4><ol><li>数组（哈希表）长度到达64</li><li>当链表长度大于等于8是会将链表转换为红黑树</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 数组为null或者数组长度小于MIN_TREEIFY_CAPACITY（64）时，进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 头尾节点 hd-头 tl-尾</span></span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 创建树节点 Node -&gt; TreeNode</span></span><br><span class="line">            <span class="comment">// 循环执行完之后得到的是双向链表</span></span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 此时得到的仅仅是双向链表</span></span><br><span class="line">        <span class="comment">// 指针指向链表头</span></span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 将双向链表转换为树</span></span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; root = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">        x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 情形1：插入第一个节点</span></span><br><span class="line">            x.parent = <span class="keyword">null</span>;</span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            root = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当前节点的 key 和 hash</span></span><br><span class="line">            K k = x.key;</span><br><span class="line">            <span class="keyword">int</span> h = x.hash;</span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 再次循环</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> dir, ph;</span><br><span class="line">                <span class="comment">// 内层循环的key</span></span><br><span class="line">                K pk = p.key;</span><br><span class="line">                <span class="comment">// 当前节点的hash和内层循环的hash值作比较</span></span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    <span class="comment">// &lt; 0 left查找</span></span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    <span class="comment">// &gt; 0 right 查找</span></span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                            (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                            (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">// 比较对象</span></span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line"></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                <span class="comment">// dir &lt;= 0 则走 left查找 &gt; 0 则走 right查找</span></span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    x.parent = xp;</span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    <span class="comment">// 正式转换为红黑树</span></span><br><span class="line">                    root = balanceInsertion(root, x);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    moveRootToFront(tab, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// root 根节点</span></span><br><span class="line"><span class="comment">// x 要操作的节点</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认节点为红色</span></span><br><span class="line">    x.red = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// xp：x的父节点</span></span><br><span class="line">    <span class="comment">// xpp：x的祖父节点</span></span><br><span class="line">    <span class="comment">// xppl：x祖父节点的左子节点</span></span><br><span class="line">    <span class="comment">// xppr：x祖父节点的右子节点</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 情形1： 父节点为null， 直接置为根</span></span><br><span class="line">        <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 父节点黑色 或者 祖父节点为空，直接返回</span></span><br><span class="line">        <span class="comment">// 情形2：插入新节点，父节点是黑色</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 父节点是祖父节点的左子节点</span></span><br><span class="line">        <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;</span><br><span class="line">            <span class="comment">// 祖父节点的右子节点不为空且是红色</span></span><br><span class="line">            <span class="comment">// 情形3：插入新节点，父节点是红色，叔父节点是红色</span></span><br><span class="line">            <span class="keyword">if</span> ((xppr = xpp.right) != <span class="keyword">null</span> &amp;&amp; xppr.red) &#123;</span><br><span class="line">                xppr.red = <span class="keyword">false</span>; <span class="comment">//祖父节点的右子节点设置为黑色</span></span><br><span class="line">                xp.red = <span class="keyword">false</span>; <span class="comment">// 父节点设置为黑色</span></span><br><span class="line">                xpp.red = <span class="keyword">true</span>; <span class="comment">// 祖父节点设置为红色</span></span><br><span class="line">                x = xpp; <span class="comment">// 继续操作祖父节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 旋转</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 新插入的是右子节点</span></span><br><span class="line">                <span class="keyword">if</span> (x == xp.right) &#123;</span><br><span class="line">                    <span class="comment">// 插入的x是父节点的右子节点， 进行左旋</span></span><br><span class="line">                    root = rotateLeft(root, x = xp);</span><br><span class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 父节点设置为黑色</span></span><br><span class="line">                    xp.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="comment">// 右旋</span></span><br><span class="line">                        root = rotateRight(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 父节点是祖父节点的右子节点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 祖父节点的左子节点不为空且为红色</span></span><br><span class="line">            <span class="keyword">if</span> (xppl != <span class="keyword">null</span> &amp;&amp; xppl.red) &#123;</span><br><span class="line">                xppl.red = <span class="keyword">false</span>; <span class="comment">// 祖父节点的左子节点设置为黑色</span></span><br><span class="line">                xp.red = <span class="keyword">false</span>; <span class="comment">// 父节点设置为黑色</span></span><br><span class="line">                xpp.red = <span class="keyword">true</span>; <span class="comment">// 祖父节点设置为红色</span></span><br><span class="line">                x = xpp; <span class="comment">// 继续操作祖父节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 旋转</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == xp.left) &#123;</span><br><span class="line">                    root = rotateRight(root, x = xp);</span><br><span class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    xp.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                        root = rotateLeft(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码笔记 </tag>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JDK源码笔记】- HashMap扩容</title>
      <link href="2020/05/17/source-code-hashmap-resize.html"/>
      <url>2020/05/17/source-code-hashmap-resize.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>描述下HashMap put(k,v)的流程？<br>它的扩容流程是怎么样的？</p></blockquote><h3 id="HashMap-put-k-v-流程"><a href="#HashMap-put-k-v-流程" class="headerlink" title="HashMap put(k,v)流程"></a>HashMap put(k,v)流程</h3><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/3pSob4.png" alt="3pSob4"></p><ol><li>通过hash(key方法)获取到key的hash值</li><li>调用put方法, 将value存放到指定的位置<ol><li>根据hash值确定当前key所在node数组的索引 <code>(n - 1) &amp; hash</code></li><li>如果node[i]==null 则直接创建新数组</li><li>如果node[i]!=null<ol><li>判断 当前node的头结点的 hash和key是否都相等, 相等则需要操作的就是该node</li><li>判断当前节点是否为TreeNode，对TreeNode进行操作，并返回结果e</li><li>如果是链表则遍历链表，key存在则返回节点e，不存在则赋值</li><li>判断节点e有没有被赋值，覆盖旧值</li></ol></li><li>hashMap size进行加1，同时判断v新size是否大于扩容阈值从而判断是否需要扩容</li></ol></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 声明Node数组tab, Node节点</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="comment">// 对tab数组赋值为当前HashMap的table, 并判断是否为空, 或者长度为0</span></span><br><span class="line">        <span class="comment">// 为0进行则resize()数组, 并对 n赋值为当前tab的长度</span></span><br><span class="line">        <span class="comment">// resize() 对HashMap的table扩容, 并返回扩容后的新数组</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="comment">// 对 node p 进行赋值, 数组所在位置 即 node p 如果是null 则直接赋值</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// p 不为null, 声明 node e, key k</span></span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="comment">// 如果hash值相等且key相等, 直接将 e 赋值为当前node的头节点</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 如果是红黑树, 则对树进行操作, 返回节点e</span></span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 对链表进行遍历, 找到对应的节点</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="comment">// 将 e 赋值为  头节点p的next, 如果下一个节点为null</span></span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 对节点进行赋值</span></span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">// 如果长度到达数转换阈值, 则需要转换为红黑树</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果e节点的hash相等, key相等, 则 直接跳出循环 e 已经被赋值为 p.next</span></span><br><span class="line">                    <span class="comment">// 此时e节点的value没有被赋值</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">// 指针指向下一个节点, 继续遍历</span></span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="comment">// 对旧值进行覆盖, 并返回旧值</span></span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="comment">// 是否需要扩容</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="resize-扩容过程"><a href="#resize-扩容过程" class="headerlink" title="resize()扩容过程"></a>resize()扩容过程</h3><ol><li>JDK 1.7 扩容流程, 每次都需要数组扩容后, 链表需要重新计算在新数组的位置</li><li>JDK 1.8 不需要重新计算 (优化点)<ol><li>数组下标: (n - 1) &amp; hash 即数组长度-1 &amp; key的hash</li><li>扩容后的数组下标: ((n &lt;&lt; 1) - 1) &amp; hash 相当于在 高位1之前加了个1</li></ol></li></ol><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/GRQHSY.png" alt="GRQHSY"></p><p>如图所示, 真正发生影响的是新增的那一位(红色箭头所指), 所以 oldCap &amp; hash 完全可以判断该值是放在旧索引值的位置还是放在旧索引值+旧数组长度的位置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">// 旧数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">// 旧数组长度</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">// 旧的扩容阈值</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="comment">// 新的数组长度和新扩容阈值</span></span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 旧数组存在</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 新数组长度为旧数组长度的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">// 扩容阈值是旧扩容阈值的2倍</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 旧数组不存在, 相当于首次put(K, V)时, 将数组长度置为扩容阈值</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        <span class="comment">// 旧数组不存在, new HashMap()未指定长度, 初次put(K, V), 设置为默认值</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新的扩容阈值是0, 则将扩容阈值设置为 新数组长度*负载因子</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对全局的扩容阈值进行赋值</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    <span class="comment">// 创建新数组, 长度为新长度, 即原数组长度的2倍</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    <span class="comment">// 将table复制为新数组</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 对旧数组进行遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="comment">// 旧节点node赋值</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">// 只有头结点, 直接计算新的位置并赋值</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">// 树单独处理</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="comment">// next节点</span></span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 节点hash与旧数组长度 &amp; 的结果来决定元素所在位置, 参考上面图示所讲</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 在元索引出创建新链表</span></span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// 新索引出创建链表</span></span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">// 索引j处直接赋值</span></span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">// 索引 j + 老数组长度位置存放hiHead</span></span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码笔记 </tag>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JDK源码笔记】- HashMap的初始化</title>
      <link href="2020/05/11/source-code-hashmap-init.html"/>
      <url>2020/05/11/source-code-hashmap-init.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>HashMap初始化参数都是什么？默认是多少？<br>为什么建议初始化设置容量？<br>tableSizeFor方法是做什么的？<br>如何获取到一个key的hash值？及计算下标？</p></blockquote><h3 id="HashMap初始化参数都是什么？默认是多少？"><a href="#HashMap初始化参数都是什么？默认是多少？" class="headerlink" title="HashMap初始化参数都是什么？默认是多少？"></a>HashMap初始化参数都是什么？默认是多少？</h3><p>HashMap初始化参数分别是初始容量和负载因子。</p><p>初始容量(threshold)：默认 16， 必须是2的幂， 最大容量为 1 &lt;&lt; 30</p><p>负载因子(loadFactor)：是指哈希表的负载因子，当哈希表的长度大于<code>capacity * loadFactor</code>时会进行扩容，默认 0.75f</p><h3 id="为什么建议初始化设置容量"><a href="#为什么建议初始化设置容量" class="headerlink" title="为什么建议初始化设置容量"></a>为什么建议初始化设置容量</h3><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/3aQLYq.png" alt="3aQLYq"></p><p>这块涉及到HashMap的扩容， 在<code>阿里巴巴Java开发手册</code>中已经说明了原因。主要是为了减少频繁的扩容造成的资源损耗。</p><h3 id="tableSizeFor方法是做什么的？"><a href="#tableSizeFor方法是做什么的？" class="headerlink" title="tableSizeFor方法是做什么的？"></a>tableSizeFor方法是做什么的？</h3><p>初始化HashMap时, 如果传入初始容量, 在初始化时会调用 <code>tableSizeFor(initialCapacity)</code> 方法寻找大于等于当前值的下一个2的幂值.</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>; <span class="comment">//  -1操作, 防止当cap正好是2的幂时的处理</span></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">// n无符号右移1位, 然后和n做 | 运算, (1|0=1 1|1=1 0|0=0 0|1=1)</span></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>; <span class="comment">// n无符号右移2位, 然后和n做 | 运算,</span></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>; <span class="comment">// n无符号右移4位, 然后和n做 | 运算,</span></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>; <span class="comment">// n无符号右移8位, 然后和n做 | 运算,</span></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>; <span class="comment">// n无符号右移16位, 然后和n做 | 运算,</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后获得的结果为 cap-1的下一个2的幂值-1, 只需要对n+1即可</span></span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>假设cap值为100, 即0110 0100</li><li>cap的下一个2的幂为 0111 1111 即 1000 0000</li><li>0000 = 0111 1111 + 1</li><li>只需要考虑将 首个为1的最高位之后的值置为1, 然后+1即可</li><li>为防止cap本来就是2的幂, 则需要先进行减一操作</li></ol><p>如图所示:<br><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/51Xhtj.png" alt="51Xhtj"></p><p>最后执行的结果进行加1即可</p><h3 id="如何获取到一个key的hash值？"><a href="#如何获取到一个key的hash值？" class="headerlink" title="如何获取到一个key的hash值？"></a>如何获取到一个key的hash值？</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">// key的hashCode ^ 上自己的高16位， 如果是null的话则hash为0</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取到了hash值， 那如何计算在数组的那个位置呢？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// n为数组长度  数组下标</span></span><br><span class="line">i = (n - <span class="number">1</span>) &amp; hash</span><br></pre></td></tr></table></figure><p>数组长度都是 2的幂<br>假设 n = 1 &gt;&gt; x<br>则 n - 1 则表示 一个低x位全为1的数</p><p>(n - 1) &amp; hash 则相当于 一个低x位全为1的数和hash做&amp;操作.</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/OAZssV.png" alt="OAZssV"></p><p>通过图可以看出, 参与运算的只有低x位, 相当于之前的所有值都不会有效. 所以前面的hash(key) 将key.hashCode()高低16位做^操作, 可以保证, 高低16位都能参与运算.一定程度上避免hash碰撞.在源码注释中已经说明, 是肯定会有碰撞, 但是这是权衡之后的结果.</p>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码笔记 </tag>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown代码折叠</title>
      <link href="2020/04/20/markdown-code-folding.html"/>
      <url>2020/04/20/markdown-code-folding.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h3><h4 id="折叠内容"><a href="#折叠内容" class="headerlink" title="折叠内容"></a>折叠内容</h4><details><summary>折叠内容</summary>在markdown中折叠一部分内容, 点击可以展开.</details><h4 id="折叠代码"><a href="#折叠代码" class="headerlink" title="折叠代码"></a>折叠代码</h4><details><summary>折叠代码</summary><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>使用html</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">details</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">summary</span>&gt;</span>折叠内容<span class="tag">&lt;/<span class="name">summary</span>&gt;</span></span><br><span class="line">在markdown中折叠一部分内容, 点击可以展开.</span><br><span class="line"><span class="tag">&lt;/<span class="name">details</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">details</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">summary</span>&gt;</span>折叠代码<span class="tag">&lt;/<span class="name">summary</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> 代码块</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">details</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
            <tag> 小技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>雪花算法</title>
      <link href="2020/04/13/snowflake-algorithm.html"/>
      <url>2020/04/13/snowflake-algorithm.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>简单介绍下雪花算法, 以及Java版雪花算法的代码.<br>仅仅是一个最简单版本, 更深层次的指针回拨等. 相当于在开发过成功可以先使用.<br>尽量还是使用统一的分布式流水号生成系统, 保证流水号全局唯一.</p></blockquote><h3 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 0000000000 0000000000 0000000000 0000000000 0 00000 00000 000000000000</span><br></pre></td></tr></table></figure><p>使用64位long型数字作为全局唯一id<br>1位 无意义 0<br>41位 时间戳<br>5位 机房id<br>5位 机器id<br>12位自增序号 表示同一时间同一机房同一机器生成的序列号</p><ol><li><p>第一位为什么无意义<br> 二进制中 第一位代表符号位, 默认 0 表示生成的序列号为正数</p></li><li><p>41位时间戳<br> 41位最大能表示 2^41-1 的数字. 毫秒值 69.7年<br> (2^41-1)/1000/60/60/24</p><p> 当时间大于69.7即时间戳差值大于 2199023255551, 会开始出现负值流水号</p></li><li><p>10位<br> 机房id+机器id 2^10 1024台机器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 但是使用中不可能每部署一台机器都改下编号, 所以我做出以下改动</span></span><br><span class="line"><span class="comment">// 8位机器号(最大256) 2位机房号</span></span><br><span class="line"><span class="comment">// 机器号使用IP地址后三位 机房id 默认1</span></span><br><span class="line"><span class="comment">// 只需要确保机器的ip后三位不同即可</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MACHINE_BIT = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DATA_CENTER_BIT = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DATA_CENTER_ID = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> address;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    InetAddress localIp = IpUtils.getLocalIp();</span><br><span class="line">    address = localIp.getAddress()[<span class="number">3</span>] &amp; <span class="number">0xff</span>;</span><br><span class="line">    log.info(<span class="string">&quot;当前系统的 address 为: &#123;&#125;&quot;</span>, address);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>12位序列号<br> 表示同一毫秒内生成的id 2^12-1 个正整数</p></li></ol><p>SnowFlake每秒能够产生26万ID左右</p><p>优点:<br>生成ID时不依赖于DB，完全在内存生成，高性能高可用。<br>ID呈趋势递增，后续插入索引树的时候性能较好。<br>缺点:<br>依赖于系统时钟的一致性。如果某台机器的系统时钟回拨，有可能造成ID冲突，或者ID乱序</p><h3 id="SerialNumber"><a href="#SerialNumber" class="headerlink" title="SerialNumber"></a>SerialNumber</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialNumber</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 起始的时间戳 2018-01-01 00:00:00</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> START_STAMP = <span class="number">1514736000000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每一部分占用的位数</span></span><br><span class="line"><span class="comment">     * 序列号 占用位数 12 位 (同一毫秒内生成的id 2^12-1 个正整数)</span></span><br><span class="line"><span class="comment">     * 机器标识  占用位数 8 位 (一般是使用5位)</span></span><br><span class="line"><span class="comment">     * 数据中心 占用位数 2 位 (一般是使用5位)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SEQUENCE_BIT = <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MACHINE_BIT = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DATA_CENTER_BIT = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每一部分的最大值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MAX_DATA_CENTER_NUM = ~(-<span class="number">1L</span> &lt;&lt; DATA_CENTER_BIT);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MAX_MACHINE_NUM = ~(-<span class="number">1L</span> &lt;&lt; MACHINE_BIT);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MAX_SEQUENCE = ~(-<span class="number">1L</span> &lt;&lt; SEQUENCE_BIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每一部分向左的位移</span></span><br><span class="line"><span class="comment">     * 机器Id左移12位 (SEQUENCE_BIT = 12)</span></span><br><span class="line"><span class="comment">     * 数据中心左移20位 (SEQUENCE_BIT + MACHINE_BIT = 12 + 8)</span></span><br><span class="line"><span class="comment">     * 时间戳左移22位 (DATA_CENTER_LEFT + DATA_CENTER_BIT = 12 + 8 + 2)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MACHINE_LEFT = SEQUENCE_BIT;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DATA_CENTER_LEFT = SEQUENCE_BIT + MACHINE_BIT;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TIME_STAMP_LEFT = DATA_CENTER_LEFT + DATA_CENTER_BIT;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据中心 机器标识 序列号 上一次时间戳</span></span><br><span class="line"><span class="comment">     * 数据中心标识和机器标识一般是外部传入</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DATA_CENTER_ID = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> address;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sequence = <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastStamp = -<span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter DATE_TIME_FORMATTER = DateTimeFormatter.ofPattern(<span class="string">&quot;yyMMdd&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">      InetAddress localIp = IpUtils.getLocalIp();</span><br><span class="line">      address = localIp.getAddress()[<span class="number">3</span>] &amp; <span class="number">0xff</span>;</span><br><span class="line">      log.info(<span class="string">&quot;当前系统的 address 为: &#123;&#125;&quot;</span>, address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产生下一个ID</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">nextId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> currStamp = getNewStamp();</span><br><span class="line">        <span class="keyword">if</span> (currStamp &lt; lastStamp) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Clock moved backwards.  Refusing to generate id&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currStamp == lastStamp) &#123;</span><br><span class="line">            <span class="comment">// 相同毫秒内，序列号自增 (sequence + 1) &amp; (~(-1L &lt;&lt; SEQUENCE_BIT))</span></span><br><span class="line">            sequence = (sequence + <span class="number">1</span>) &amp; MAX_SEQUENCE;</span><br><span class="line">            <span class="comment">// 同一毫秒的序列数已经达到最大</span></span><br><span class="line">            <span class="keyword">if</span> (sequence == <span class="number">0L</span>) &#123;</span><br><span class="line">                currStamp = getNextMill();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不同毫秒内，序列号置为0</span></span><br><span class="line">            sequence = <span class="number">0L</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lastStamp = currStamp;</span><br><span class="line">        <span class="comment">// 时间戳部分 数据中心部分 机器标识部分 序列号部分</span></span><br><span class="line">        <span class="keyword">return</span> (currStamp - START_STAMP) &lt;&lt; TIME_STAMP_LEFT | DATA_CENTER_ID &lt;&lt; DATA_CENTER_LEFT</span><br><span class="line">            | address &lt;&lt; MACHINE_LEFT | sequence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">getNextMill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> mill = getNewStamp();</span><br><span class="line">        <span class="keyword">while</span> (mill &lt;= lastStamp) &#123;</span><br><span class="line">            mill = getNewStamp();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mill;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">getNewStamp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="IpUtils"><a href="#IpUtils" class="headerlink" title="IpUtils"></a>IpUtils</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuzhihang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/12/19 16:03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IpUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InetAddress <span class="title">getLocalIp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Enumeration&lt;NetworkInterface&gt; e = NetworkInterface.getNetworkInterfaces(); e.hasMoreElements(); ) &#123;</span><br><span class="line">                NetworkInterface item = e.nextElement();</span><br><span class="line">                <span class="keyword">for</span> (InterfaceAddress address : item.getInterfaceAddresses()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (item.isLoopback() || !item.isUp()) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (address.getAddress() <span class="keyword">instanceof</span> Inet4Address) &#123;</span><br><span class="line">                        <span class="keyword">return</span> address.getAddress();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> InetAddress.getLocalHost();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException | UnknownHostException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> 流水号 </tag>
            
            <tag> 雪花算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目启动失败:java.lang.NoClassDefFoundError</title>
      <link href="2020/04/12/no-class-def-found-error-rule-configuration.html"/>
      <url>2020/04/12/no-class-def-found-error-rule-configuration.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>近期遇到一个很久没有启动过的项目, 然后启动失败, 报 java.lang.NoClassDefFoundError, 现在记录问题排查情况.</p></blockquote><h4 id="错误代码"><a href="#错误代码" class="headerlink" title="错误代码"></a>错误代码</h4><ul><li>错误代码较长, 可以收缩, 直接看排查</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Error starting ApplicationContext. To display the conditions report re-run your application with &#39;debug&#39; enabled.]</span><br><span class="line">[2020-04-10 13:26:11.478]-[main]-[]-[ERROR]-[org.springframework.boot.SpringApplication:821]-[Application run failed]</span><br><span class="line">org.springframework.context.ApplicationContextException: Unable to start web server; nested exception is org.springframework.boot.web.server.WebServerException: Unable to start embedded Tomcat</span><br><span class="line">        at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.onRefresh(ServletWebServerApplicationContext.java:155) ~[spring-boot-2.1.6.RELEASE.jar!&#x2F;:2.1.6.RELEASE]</span><br><span class="line">        at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:543) ~[spring-context-5.1.8.RELEASE.jar!&#x2F;:5.1.8.RELEASE]</span><br><span class="line">        at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:140) ~[spring-boot-2.1.6.RELEASE.jar!&#x2F;:2.1.6.RELEASE]</span><br><span class="line">        at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:742) [spring-boot-2.1.6.RELEASE.jar!&#x2F;:2.1.6.RELEASE]</span><br><span class="line">        at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:389) [spring-boot-2.1.6.RELEASE.jar!&#x2F;:2.1.6.RELEASE]</span><br><span class="line">        at org.springframework.boot.SpringApplication.run(SpringApplication.java:311) [spring-boot-2.1.6.RELEASE.jar!&#x2F;:2.1.6.RELEASE]</span><br><span class="line">        at org.springframework.boot.SpringApplication.run(SpringApplication.java:1213) [spring-boot-2.1.6.RELEASE.jar!&#x2F;:2.1.6.RELEASE]</span><br><span class="line">        at org.springframework.boot.SpringApplication.run(SpringApplication.java:1202) [spring-boot-2.1.6.RELEASE.jar!&#x2F;:2.1.6.RELEASE]</span><br><span class="line">        at com.opay.im.WebApplication.main(WebApplication.java:32) [classes!&#x2F;:1.0-SNAPSHOT]</span><br><span class="line">        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[?:1.8.0_221]</span><br><span class="line">        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[?:1.8.0_221]</span><br><span class="line">        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[?:1.8.0_221]</span><br><span class="line">        at java.lang.reflect.Method.invoke(Method.java:498) ~[?:1.8.0_221]</span><br><span class="line">        at org.springframework.boot.loader.MainMethodRunner.run(MainMethodRunner.java:48) [opay-im-web-1.0-SNAPSHOT.jar:1.0-SNAPSHOT]</span><br><span class="line">        at org.springframework.boot.loader.Launcher.launch(Launcher.java:87) [opay-im-web-1.0-SNAPSHOT.jar:1.0-SNAPSHOT]</span><br><span class="line">        at org.springframework.boot.loader.Launcher.launch(Launcher.java:50) [opay-im-web-1.0-SNAPSHOT.jar:1.0-SNAPSHOT]</span><br><span class="line">        at org.springframework.boot.loader.JarLauncher.main(JarLauncher.java:58) [opay-im-web-1.0-SNAPSHOT.jar:1.0-SNAPSHOT]</span><br><span class="line">Caused by: org.springframework.boot.web.server.WebServerException: Unable to start embedded Tomcat</span><br><span class="line">        at org.springframework.boot.web.embedded.tomcat.TomcatWebServer.initialize(TomcatWebServer.java:124) ~[spring-boot-2.1.6.RELEASE.jar!&#x2F;:2.1.6.RELEASE]</span><br><span class="line">        at org.springframework.boot.web.embedded.tomcat.TomcatWebServer.&lt;init&gt;(TomcatWebServer.java:86) ~[spring-boot-2.1.6.RELEASE.jar!&#x2F;:2.1.6.RELEASE]</span><br><span class="line">        at org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory.getTomcatWebServer(TomcatServletWebServerFactory.java:414) ~[spring-boot-2.1.6.RELEASE.jar!&#x2F;:2.1.6.RELEASE]</span><br><span class="line">        at org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory.getWebServer(TomcatServletWebServerFactory.java:178) ~[spring-boot-2.1.6.RELEASE.jar!&#x2F;:2.1.6.RELEASE]</span><br><span class="line">        at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.createWebServer(ServletWebServerApplicationContext.java:179) ~[spring-boot-2.1.6.RELEASE.jar!&#x2F;:2.1.6.RELEASE]</span><br><span class="line">        at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.onRefresh(ServletWebServerApplicationContext.java:152) ~[spring-boot-2.1.6.RELEASE.jar!&#x2F;:2.1.6.RELEASE]</span><br><span class="line">        ... 16 more</span><br><span class="line">Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;servletEndpointRegistrar&#39; defined in class path resource [org&#x2F;springframework&#x2F;boot&#x2F;actuate&#x2F;autoconfigure&#x2F;endpoint&#x2F;web&#x2F;ServletEndpointManagementContextConfiguration$WebMvcServletEndpointManagementContextConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.boot.actuate.endpoint.web.ServletEndpointRegistrar]: Factory method &#39;servletEndpointRegistrar&#39; threw exception; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#39;healthEndpoint&#39; defined in class path resource [org&#x2F;springframework&#x2F;boot&#x2F;actuate&#x2F;autoconfigure&#x2F;health&#x2F;HealthEndpointConfiguration.class]: Unsatisfied dependency expressed through method &#39;healthEndpoint&#39; parameter 1; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;healthIndicatorRegistry&#39; defined in class path resource [org&#x2F;springframework&#x2F;boot&#x2F;actuate&#x2F;autoconfigure&#x2F;health&#x2F;HealthIndicatorAutoConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.boot.actuate.health.HealthIndicatorRegistry]: Factory method &#39;healthIndicatorRegistry&#39; threw exception; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#39;org.springframework.boot.actuate.autoconfigure.jdbc.DataSourceHealthIndicatorAutoConfiguration&#39;: Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#39;dataSource&#39; defined in class path resource [com&#x2F;opay&#x2F;im&#x2F;config&#x2F;DatabaseConfig.class]: Unsatisfied dependency expressed through method &#39;dataSource&#39; parameter 0; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;defaultDataSource&#39; defined in class path resource [com&#x2F;opay&#x2F;im&#x2F;config&#x2F;DatabaseConfig.class]: Initialization of bean failed; nested exception is java.lang.NoClassDefFoundError: org&#x2F;apache&#x2F;shardingsphere&#x2F;api&#x2F;config&#x2F;RuleConfiguration</span><br><span class="line">        at org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:627) ~[spring-beans-5.1.8.RELEASE.jar!&#x2F;:5.1.8.RELEASE]</span><br><span class="line">        at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:607) ~[spring-beans-5.1.8.RELEASE.jar!&#x2F;:5.1.8.RELEASE]</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1321) ~[spring-beans-5.1.8.RELEASE.jar!&#x2F;:5.1.8.RELEASE]</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1160) ~[spring-beans-5.1.8.RELEASE.jar!&#x2F;:5.1.8.RELEASE]</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:555) ~[spring-beans-5.1.8.RELEASE.jar!&#x2F;:5.1.8.RELEASE]</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:515) ~[spring-beans-5.1.8.RELEASE.jar!&#x2F;:5.1.8.RELEASE]</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:320) ~[spring-beans-5.1.8.RELEASE.jar!&#x2F;:5.1.8.RELEASE]</span><br><span class="line">        at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) ~[spring-beans-5.1.8.RELEASE.jar!&#x2F;:5.1.8.RELEASE]</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:318) ~[spring-beans-5.1.8.RELEASE.jar!&#x2F;:5.1.8.RELEASE]</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:204) ~[spring-beans-5.1.8.RELEASE.jar!&#x2F;:5.1.8.RELEASE]</span><br><span class="line">        at org.springframework.boot.web.servlet.ServletContextInitializerBeans.getOrderedBeansOfType(ServletContextInitializerBeans.java:211) ~[spring-boot-2.1.6.RELEASE.jar!&#x2F;:2.1.6.RELEASE]</span><br><span class="line">        at org.springframework.boot.web.servlet.ServletContextInitializerBeans.getOrderedBeansOfType(ServletContextInitializerBeans.java:202) ~[spring-boot-2.1.6.RELEASE.jar!&#x2F;:2.1.6.RELEASE]</span><br><span class="line">        at org.springframework.boot.web.servlet.ServletContextInitializerBeans.addServletContextInitializerBeans(ServletContextInitializerBeans.java:96) ~[spring-boot-2.1.6.RELEASE.jar!&#x2F;:2.1.6.RELEASE]</span><br><span class="line">        at org.springframework.boot.web.servlet.ServletContextInitializerBeans.&lt;init&gt;(ServletContextInitializerBeans.java:85) ~[spring-boot-2.1.6.RELEASE.jar!&#x2F;:2.1.6.RELEASE]</span><br><span class="line">        at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.getServletContextInitializerBeans(ServletWebServerApplicationContext.java:252) ~[spring-boot-2.1.6.RELEASE.jar!&#x2F;:2.1.6.RELEASE]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h4><ol><li>开始排查是因为缺少 <code>sharding-core-api-4.0.0-RC2.2-1.8.jar</code> 包下的一个文件, 但是本地是有的</li><li>本地可以启动</li><li>服务器启动失败, 可能是jar包缺少</li><li>最后结果发现 sharding-core-api-4.0.0-RC2.2-1.8.jar 是通过公司封装的一个包传递进来的, 而封装的那个jar包在私服上已经被删除了. <del>删除原因</del></li></ol>]]></content>
      
      
      <categories>
          
          <category> issue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> error </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac创建data目录失败</title>
      <link href="2020/01/05/mac-create-data-directory-failed.html"/>
      <url>2020/01/05/mac-create-data-directory-failed.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><blockquote><p>部分项目log日志输出路径为 /data/log, 发现无法创建目录<br>错误信息: <code>mkdir: cannot create directory ‘data’: Read-only file system</code></p></blockquote><h4 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h4><h5 id="关闭SPI"><a href="#关闭SPI" class="headerlink" title="关闭SPI"></a>关闭SPI</h5><ol><li>重启 按住CMD+R进入恢复模式</li><li>打开终端<br><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/feature/mac-spi.jpg" alt="spi关闭"></li><li>终端输入命令：csrutil disable</li></ol><h5 id="挂载data"><a href="#挂载data" class="headerlink" title="挂载data"></a>挂载data</h5><ol><li>在用户目录(可以自己找一个目录下创建data)</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~  % &gt; <span class="built_in">cd</span> ~</span><br><span class="line">~  % &gt; mkdir data</span><br></pre></td></tr></table></figure><ol start="2"><li>执行 <code>sudo mount -uw /</code> 重新挂载根目录</li><li>建立软链<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ln -s /Users/liuzhihang/data /data</span><br></pre></td></tr></table></figure></li><li>之后可以重启再打开spi了<br><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/feature/mac-spi2.png" alt="spi关闭"></li></ol>]]></content>
      
      
      <categories>
          
          <category> issue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> issue </tag>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo中插入Bilibili视频</title>
      <link href="2019/09/14/hexo-inserts-bilibili-video.html"/>
      <url>2019/09/14/hexo-inserts-bilibili-video.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>修改matery主题首页显示视频为Bilibili视频</p><p>在Markdown插入Bilibili视频, 并设置大小.</p></blockquote><h3 id="首先找到分享嵌入代码"><a href="#首先找到分享嵌入代码" class="headerlink" title="首先找到分享嵌入代码"></a>首先找到分享嵌入代码</h3><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://i.loli.net/2019/10/10/di3Cxcr9VLvjqM6.png" alt="Bilibili分享截图"></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;//player.bilibili.com/player.html?aid=17963687&amp;cid=29326684&amp;page=1&quot;</span> <span class="attr">scrolling</span>=<span class="string">&quot;no&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;no&quot;</span> <span class="attr">framespacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">allowfullscreen</span>=<span class="string">&quot;true&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="在markdown中使用嵌入代码"><a href="#在markdown中使用嵌入代码" class="headerlink" title="在markdown中使用嵌入代码"></a>在markdown中使用嵌入代码</h3><iframe src="//player.bilibili.com/player.html?aid=17963687&cid=29326684&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h3 id="调整大小和居中等"><a href="#调整大小和居中等" class="headerlink" title="调整大小和居中等"></a>调整大小和居中等</h3><p><a href="https://www.w3school.com.cn/tags/tag_iframe.asp">iframe标签属性设置</a></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    调整大小: width=&quot;xxx&quot; height=&quot;xxx&quot;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;//player.bilibili.com/player.html?aid=17963687&amp;cid=29326684&amp;page=1&quot;</span>  <span class="attr">width</span>=<span class="string">&quot;600&quot;</span> <span class="attr">height</span>=<span class="string">&quot;400&quot;</span>  <span class="attr">scrolling</span>=<span class="string">&quot;no&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;no&quot;</span> <span class="attr">framespacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">allowfullscreen</span>=<span class="string">&quot;true&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><iframe src="//player.bilibili.com/player.html?aid=17963687&cid=29326684&page=1" width="700" height="480"  scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h3 id="设置自适应"><a href="#设置自适应" class="headerlink" title="设置自适应"></a>设置自适应</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;position: relative; width: 100%; height: 0; padding-bottom: 75%;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;//player.bilibili.com/player.html?aid=17963687&amp;cid=29326684&amp;page=1&quot;</span>  <span class="attr">scrolling</span>=<span class="string">&quot;no&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;no&quot;</span> <span class="attr">framespacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">allowfullscreen</span>=<span class="string">&quot;true&quot;</span> <span class="attr">style</span>=<span class="string">&quot;position: absolute; width: 100%; height: 100%; left: 0; top: 0;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="//player.bilibili.com/player.html?aid=17963687&cid=29326684&page=1"  scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div><h3 id="matery-主题修改首页展示视频"><a href="#matery-主题修改首页展示视频" class="headerlink" title="matery 主题修改首页展示视频"></a>matery 主题修改首页展示视频</h3><p>找到 /themes/hexo-theme-matery/layout/_widget/video.ejs 将第十一行左右代码改成Bilibili视频即可, 引入的 script 可以删掉.</p><p>修改后如下.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;video-player&quot;</span>&gt;</span><br><span class="line">    &lt;% <span class="keyword">if</span> (theme.video.showTitle) &#123; %&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;title center-align&quot;</span>&gt;</span><br><span class="line">            &lt;i <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;fas fa-video-camera&quot;</span>&gt;&lt;/i&gt;&amp;nbsp;&amp;nbsp;&lt;%- theme.video.title %&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;% &#125; %&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;row&quot;</span>&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;col l8 offset-l2 m10 offset-m1 s12&quot;</span>&gt;</span><br><span class="line">            &lt;div id=<span class="string">&quot;dplayer&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;dplayer-video&quot;</span>&gt;</span><br><span class="line">                &lt;div style=<span class="string">&quot;position: relative; width: 100%; height: 0; padding-bottom: 75%;&quot;</span>&gt;</span><br><span class="line">                    &lt;iframe src=<span class="string">&quot;//player.bilibili.com/player.html?aid=16316393&amp;cid=26620787&amp;page=1&quot;</span>  scrolling=<span class="string">&quot;no&quot;</span> border=<span class="string">&quot;0&quot;</span> frameborder=<span class="string">&quot;no&quot;</span> framespacing=<span class="string">&quot;0&quot;</span> allowfullscreen=<span class="string">&quot;true&quot;</span> style=<span class="string">&quot;position: absolute; width: 100%; height: 100%; left: 0; top: 0;&quot;</span>&gt;&lt;/iframe&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis分布式锁的生产问题解决方案</title>
      <link href="2019/08/18/redis-distributed-lock-production-problem-solution.html"/>
      <url>2019/08/18/redis-distributed-lock-production-problem-solution.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>Java进阶训练营学习笔记<br>课程: <a href="https://apppukyptrl1086.pc.xiaoe-tech.com/detail/p_5d3110c3c0e9d_FnmTTtj4/6">Java进阶训练营</a><br>老师: 中华石杉<br>邀请码: <a href="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/feature/IMG_0340_phrrry.jpg">二维码</a></p></blockquote><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><pre><code>SET KEY VALUE TIME NXDEL KEY</code></pre><p>一般使用 NX, 只有在锁不存在的时候才加锁成功, 设置时间是为了锁永远得不到释放</p><h3 id="存在问题及解决方法"><a href="#存在问题及解决方法" class="headerlink" title="存在问题及解决方法"></a>存在问题及解决方法</h3><ol><li><p>A加锁, B释放</p><p> 方法: Redisson 在tryLock时</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> threadId = Thread.currentThread().getId();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">getLockName</span><span class="params">(<span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id + <span class="string">&quot;:&quot;</span> + threadId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// id 为 UUID</span></span><br></pre></td></tr></table></figure><p> 会将当前 uuId+线程id写入到锁信息中, unlock时会校验是否是当前线程</p></li><li><p>A lock锁住之后, 设置了时间, 但是在时间内未完成, 导致锁自动释放, 然后B获取锁同时进行操作</p><p> 方法: Redisson 在lock时会启动异步线程, 自动延期, 时间为 lockWatchdogTimeout(默认30s)</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Timeout task = commandExecutor.getConnectionManager().newTimeout(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">    省略...</span><br><span class="line">&#125;, internalLockLeaseTime / <span class="number">3</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 看源码是延时 1/3的时间后开始, 就是每次1/3时间的时候延期一次. 这样理解不知道对不对</p></li><li><p>主从下, A 加锁 Master 成功后未同步给Slave 便宕机, 导致 B发现未加锁<br> 方法: 可以修改源码, 同时加锁Master-Slave 才算加锁成功</p></li><li><p>集群状态下可以参考RedLock(红锁), 加锁多台机器, 多数成功才算成功(locks.size()/2 + 1)</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedissonRedLock</span> <span class="keyword">extends</span> <span class="title">RedissonMultiLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedissonRedLock</span><span class="params">(RLock... locks)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(locks);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何落地最终一致性事务</title>
      <link href="2019/08/17/how-to-land-the-final-consistency-transaction.html"/>
      <url>2019/08/17/how-to-land-the-final-consistency-transaction.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>Java进阶训练营学习笔记<br>课程: <a href="https://apppukyptrl1086.pc.xiaoe-tech.com/detail/p_5d3110c3c0e9d_FnmTTtj4/6">Java进阶训练营</a><br>老师: 中华石杉<br>邀请码: <a href="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/feature/IMG_0340_phrrry.jpg">二维码</a></p></blockquote><h3 id="作业：如果对自己的系统落地最终一致性事务，如何落地实现？"><a href="#作业：如果对自己的系统落地最终一致性事务，如何落地实现？" class="headerlink" title="作业：如果对自己的系统落地最终一致性事务，如何落地实现？"></a>作业：如果对自己的系统落地最终一致性事务，如何落地实现？</h3><ol><li>首先熟悉自己负责的业务, 熟悉系统间交互流程, 哪些可以异步, 哪些是必须同步</li><li>异步的时候要考虑是否需要一致性, 当前系统通知流程如图</li></ol><h3 id="如何落地最终一致性事务"><a href="#如何落地最终一致性事务" class="headerlink" title="如何落地最终一致性事务"></a>如何落地最终一致性事务</h3><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/feature/0812-task.png" alt="最终一致性事务方案"></p><h3 id="根据课程思考最终一致性事务修改"><a href="#根据课程思考最终一致性事务修改" class="headerlink" title="根据课程思考最终一致性事务修改:"></a>根据课程思考最终一致性事务修改:</h3><ol><li>在收到交易请求, 成功时可以 commit half message</li><li>同时 需要实现 check方法, 供RocketMQ回调, 检查本地事务状态</li><li>在交易成功或失败时再进行commit或rollback</li><li>rollback消息 RocketMQ会定期删除</li><li>通知系统收到消息存储到本地并通知商户</li></ol><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>但是考虑到在这边系统完全没有必要增加事务, 因为发送消息到MQ是在交易结束后, 直接用一个字段判断状态, 然后用定时保证投递到MQ即可.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RocketMQ的两段提交 half message</span><br><span class="line">执行流程</span><br><span class="line">根据流程结果: commit&#x2F;rockback</span><br></pre></td></tr></table></figure><p>可以改成</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">执行流程</span><br><span class="line">RocketMQ send(普通消息)</span><br></pre></td></tr></table></figure><p>在这边的使用场景中, 因为提交了 half message 也不会发送消息, 等到流程执行结束了, 然后使用send发送普通消息即可.</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>交易系统架构图</title>
      <link href="2019/08/10/trading-system-architecture.html"/>
      <url>2019/08/10/trading-system-architecture.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>Java进阶训练营学习笔记<br>课程: <a href="https://apppukyptrl1086.pc.xiaoe-tech.com/detail/p_5d3110c3c0e9d_FnmTTtj4/6">Java进阶训练营</a><br>老师: 中华石杉<br>邀请码: <a href="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/feature/IMG_0340_phrrry.jpg">二维码</a></p></blockquote><h3 id="交易系统架构"><a href="#交易系统架构" class="headerlink" title="交易系统架构"></a>交易系统架构</h3><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/feature/0806-task.png" alt="交易系统架构"></p><h3 id="请求流程"><a href="#请求流程" class="headerlink" title="请求流程:"></a>请求流程:</h3><ol><li>请求首先到SLB(阿里云)经过负载均衡后, 到Nginx</li><li>Nginx做简单负载均衡后发给交易API系统, 4C8G * 5 ECS(阿里云)</li><li>交易会根据请求参数, 路由到各个子系统, 使用dubbo</li><li>子系统收到请求, 请求风控系统校验风控</li><li>请求应用中心获取应用参数 (appId, appKey等)</li><li>拼装报文,请求渠道系统</li><li>返回信息</li></ol><h3 id="日志报送流程"><a href="#日志报送流程" class="headerlink" title="日志报送流程"></a>日志报送流程</h3><ol><li>交易成功报送清结算, 报送数据中心</li><li>filebeat拉取日志, 报送kafka, 因filebeat升级 同时存在5.x和6.x 需要加中间一层, 之前是直接报logstash</li><li>logstash对数据进行过滤然后根据type 分别保送到 elasticsearch和redis</li><li>监控系统监控redis队列数据, 满足规则, 报警(发消息到通知系统)</li><li>监控系统对es数据进行过滤, 放到mysql, 用来展示商户, 渠道的交易变化等信息</li><li>kibana(直接用的kibana)提供给技术支持查询日志. es数据会定期删除, 保留15-30天的数据, 仅仅技术支持用, 不需要效率很高, 所以机器配置相对较差.</li></ol><h3 id="扩容方案"><a href="#扩容方案" class="headerlink" title="扩容方案"></a>扩容方案</h3><p>公司体量较小, QPS高峰期也就500左右, TPS高峰期在100~200, 所以基本没有遇到问题.<br>之前有过一段时间公众号支付交易量较大, 主要做法是增加公众号机器, 同时增加API系统机器.<br>假如交易量提高, 一般应对就是增加机器, 和提高机器配置, 基本上都可以应对.</p><h3 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h3><p>定时系统是仅仅通过dubbo发送调用请求, 没有业务逻辑. 所以单体基本没有遇到挂掉. 也在考虑分布式定时任务.</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud架构原理图</title>
      <link href="2019/08/04/springcloud-architecture-schematic.html"/>
      <url>2019/08/04/springcloud-architecture-schematic.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>Java进阶训练营学习笔记<br>课程: <a href="https://apppukyptrl1086.pc.xiaoe-tech.com/detail/p_5d3110c3c0e9d_FnmTTtj4/6">Java进阶训练营</a><br>老师: 中华石杉<br>邀请码: <a href="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/feature/IMG_0340_phrrry.jpg">二维码</a></p></blockquote><h3 id="springcloud-通信原理"><a href="#springcloud-通信原理" class="headerlink" title="springcloud 通信原理"></a>springcloud 通信原理</h3><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/feature/0731-task.png" alt="通信原理"></p><h3 id="1-Eureka-集群"><a href="#1-Eureka-集群" class="headerlink" title="1. Eureka 集群"></a>1. Eureka 集群</h3><ol><li>Eureka启动后, 会向其他节点注册, 相互直接视为 peer, 并互相同步注册信息.</li></ol><h3 id="2-缓存机制"><a href="#2-缓存机制" class="headerlink" title="2. 缓存机制"></a>2. 缓存机制</h3><p>Eureka存在三个map: registry、readWriteCacheMap、readOnlyCacheMap</p><p>registry: CurrentHashMap 实时更新<br>readWriteCacheMap: Guava Cache/LoadingCache     也是实时更新<br>readOnlyCacheMap: CurrentHashMap 30秒同步 readWriteCacheMap一次</p><h3 id="3-服务注册"><a href="#3-服务注册" class="headerlink" title="3. 服务注册"></a>3. 服务注册</h3><p>服务注册后每30s发送一次心跳(renew)<br>客户端每30秒请注册中心获取一次配置, 并存到本地内存中</p><p>注册中心会定时检查心跳, 连续没有3个回踢掉服务</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dubbo底层原理架构图</title>
      <link href="2019/08/03/dubbo-bottom-structure-diagram.html"/>
      <url>2019/08/03/dubbo-bottom-structure-diagram.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>Java进阶训练营学习笔记<br>课程: <a href="https://apppukyptrl1086.pc.xiaoe-tech.com/detail/p_5d3110c3c0e9d_FnmTTtj4/6">Java进阶训练营</a><br>老师: 中华石杉<br>邀请码: <a href="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/feature/IMG_0340_phrrry.jpg">二维码</a></p></blockquote><h4 id="操作流程图"><a href="#操作流程图" class="headerlink" title="操作流程图"></a>操作流程图</h4><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/feature/0730-task.png" alt="操作流程"></p><h4 id="1-服务注册-故障及下线"><a href="#1-服务注册-故障及下线" class="headerlink" title="1. 服务注册, 故障及下线"></a>1. 服务注册, 故障及下线</h4><ol><li>注册: provider和consumer同时在zk上注册临时节点, 同时consumer订阅zk /dubbo/**/providers provider地址, providers发生变化, zk自动推送给consumer</li></ol><p>zk上结构如下</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ls /dubbo/cn.xxx.xxxService</span><br><span class="line"></span><br><span class="line">[consumers, routers, providers, configurators]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[consumer:&#x2F;&#x2F;机器ip&#x2F;接口?application&#x3D;服务名&amp;category&#x3D;consumers&amp;check&#x3D;false&amp;default.check&#x3D;false&amp;default.group&#x3D;beta&amp;default.timeout&#x3D;5000&amp;default.version&#x3D;1.0.0&amp;dubbo&#x3D;2.6.2&amp;interface&#x3D;接口&amp;methods&#x3D;方法1,方法2&amp;pid&#x3D;7828&amp;revision&#x3D;0.0.1&amp;side&#x3D;consumer&amp;timestamp&#x3D;1556173624632]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[dubbo:&#x2F;&#x2F;机器1ip:端口&#x2F;接口?anyhost&#x3D;true&amp;application&#x3D;WalletOrderApplicationConsumer&amp;delay&#x3D;2000&amp;dubbo&#x3D;2.5.3&amp;group&#x3D;beta&amp;heartbeat&#x3D;10000&amp;interface&#x3D;接口&amp;methods&#x3D;方法1,方法2&amp;pid&#x3D;22419&amp;retries&#x3D;0&amp;revision&#x3D;1.0.0&amp;side&#x3D;provider&amp;timeout&#x3D;10000&amp;timestamp&#x3D;1564743170669&amp;version&#x3D;1.0.0,</span><br><span class="line">dubbo:&#x2F;&#x2F;机器2ip:端口&#x2F;接口?anyhost&#x3D;true&amp;application&#x3D;WalletOrderApplicationConsumer&amp;delay&#x3D;2000&amp;dubbo&#x3D;2.5.3&amp;group&#x3D;beta&amp;heartbeat&#x3D;10000&amp;interface&#x3D;cn.ipaynow.webank.wallet.order.api.provider.DataCenterTaskService&amp;methods&#x3D;syncRechargesRefund,syncTrans,syncTransCancel,syncTransRefunds,syncRecharges&amp;pid&#x3D;16801&amp;retries&#x3D;0&amp;revision&#x3D;0.0.1&amp;side&#x3D;provider&amp;timeout&#x3D;10000&amp;timestamp&#x3D;1563792977340&amp;version&#x3D;1.0.0]</span><br></pre></td></tr></table></figure><ol start="2"><li>故障: zk自动删除临时节点</li><li>下线: 取消注册, 主动删除节点</li></ol><h4 id="2-Proxy-动态代理"><a href="#2-Proxy-动态代理" class="headerlink" title="2. Proxy 动态代理"></a>2. Proxy 动态代理</h4><p>根据配置的接口, 生成动态代理对象, 使用 JDK + JAVAASSIST 方式</p><ol><li><p>在服务提供端，将服务的具体实现类转为Invoker</p></li><li><p>在消费端，通过 getProxy(Invoker<T> invoker)将invoker转为客户端需要的接口</p></li><li><p>Invoker封装了Provider地址及Service接口信息</p></li></ol><h4 id="3-Cluster-集群层"><a href="#3-Cluster-集群层" class="headerlink" title="3. Cluster 集群层"></a>3. Cluster 集群层</h4><p>获取到要调用的Invoker</p><ol><li>多个服务端会有多个 Invoker对象, 组合成Directory, Directory在zk推送Provider节点变更时, 会发生变化</li><li>Router, 按照路由规则选出本次可以调用的 Directory子集,  zk注册中心 routers节点下配置</li><li>LoadBalance 从子集中按照负载均衡选出本次调用<ol><li>Random LoadBalance 随机</li><li>RoundRobin LoadBalance 轮询</li><li>LeastActive LoadBalance 最少活跃</li><li>ConsistentHash LoadBalance 一致性哈希</li></ol></li><li>容错<ol><li>Failover Cluster 失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 retries=”2″ 来设置重试次数(不含第一次)。</li><li>Failfast Cluster：快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</li><li>Failsafe Cluster：失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</li><li>Failback Cluster：失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</li><li>Forking Cluster：并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=”2″ 来设置最大并行数。</li></ol></li></ol><h4 id="4-Protocol-远程调用层"><a href="#4-Protocol-远程调用层" class="headerlink" title="4. Protocol 远程调用层"></a>4. Protocol 远程调用层</h4><p>包含两个接口, 分别是 暴露服务(export) 和 引用服务(refer) 分别对应provider 和 consumer<br>选择通信协议 dubbo, hessian, http等</p><h4 id="5-Exchange-数据交换层"><a href="#5-Exchange-数据交换层" class="headerlink" title="5. Exchange 数据交换层"></a>5. Exchange 数据交换层</h4><p>将请求信息封装为Request, 然后发送给 Transport层, 并将返回信息封装为Response</p><h4 id="6-Transport-网络传输层"><a href="#6-Transport-网络传输层" class="headerlink" title="6. Transport 网络传输层"></a>6. Transport 网络传输层</h4><p>使用netty或mina进行网络通信</p><h4 id="7-serialize-序列化层"><a href="#7-serialize-序列化层" class="headerlink" title="7. serialize 序列化层"></a>7. serialize 序列化层</h4><p>将请求报文和返回报文记性序列化和反序列化</p><h4 id="8-provider收到请求后先进行反序列化-然后在解析请求-通过动态代理调用相应方法"><a href="#8-provider收到请求后先进行反序列化-然后在解析请求-通过动态代理调用相应方法" class="headerlink" title="8. provider收到请求后先进行反序列化, 然后在解析请求, 通过动态代理调用相应方法"></a>8. provider收到请求后先进行反序列化, 然后在解析请求, 通过动态代理调用相应方法</h4>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot项目中使用SpringSecurity和JWT做权限认证</title>
      <link href="2019/07/22/springsecurity-jwt-springboot-project.html"/>
      <url>2019/07/22/springsecurity-jwt-springboot-project.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote><p>前段时间做了一个项目, 因为涉及到权限认证, 所以分别调研了 SpringSecurity 和 Apache Shiro. 最后选择使用了 SpringSecurity + JWT做权限认证,  现在项目已经结束, 总相关笔记.<br>项目下载地址 <a href="https://github.com/liuzhihang/jwt-demo">jwt-demo</a></p></blockquote><ol><li>使用JWT生成token</li><li>token存储在数据库中</li><li>使用 application/json 登录</li><li>使用手机号进行登录</li><li>URI动态拦截</li></ol><h2 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h2><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><ol><li>分别添加 SpringSecurity JWT 和 fastjson 依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--json--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.60<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="基础准备对象"><a href="#基础准备对象" class="headerlink" title="基础准备对象"></a>基础准备对象</h3><ul><li>主要是在<strong>用户登录成功handle</strong>时使用JWT生成Token返回给客户端.</li></ul><h4 id="基础使用dto"><a href="#基础使用dto" class="headerlink" title="基础使用dto"></a>基础使用dto</h4><p>请求返回基类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseReqDto</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String version;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseRespDto</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String resultCode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String resultMsg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String resultTime;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>登录请求返回对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginReqDto</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String token;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginRespDto</span> <span class="keyword">extends</span> <span class="title">BaseRespDto</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String token;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="用于验证的用户"><a href="#用于验证的用户" class="headerlink" title="用于验证的用户"></a>用于验证的用户</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuzhihang.demo.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.GrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户信息校验验证码</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuzhihang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDetailsImpl</span> <span class="keyword">implements</span> <span class="title">UserDetails</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 密码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 权限集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Collection&lt;? extends GrantedAuthority&gt; authorities;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.authorities;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAuthorities</span><span class="params">(Collection&lt;? extends GrantedAuthority&gt; authorities)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.authorities = authorities;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAccountNonExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAccountNonLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCredentialsNonExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="用户未登录handle"><a href="#用户未登录handle" class="headerlink" title="用户未登录handle"></a>用户未登录handle</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户登录认证, 未登录返回信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuzhihang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-06-04 13:52</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthenticationEntryPointImpl</span> <span class="keyword">implements</span> <span class="title">AuthenticationEntryPoint</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter FORMATTER = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyyMMddHHmmss&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commence</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException e)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        LoginRespDto respDto = <span class="keyword">new</span> LoginRespDto();</span><br><span class="line">        respDto.setResultCode(<span class="string">&quot;0001&quot;</span>);</span><br><span class="line">        respDto.setResultMsg(<span class="string">&quot;用户未登录&quot;</span>);</span><br><span class="line">        respDto.setResultTime(LocalDateTime.now().format(FORMATTER));</span><br><span class="line"></span><br><span class="line">        response.getWriter().write(JSON.toJSONString(respDto));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="用户登录验证失败handle"><a href="#用户登录验证失败handle" class="headerlink" title="用户登录验证失败handle"></a>用户登录验证失败handle</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户登录认证失败返回的信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuzhihang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-06-04 13:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthenticationFailureHandlerImpl</span> <span class="keyword">implements</span> <span class="title">AuthenticationFailureHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter FORMATTER = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyyMMddHHmmss&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthenticationFailure</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        LoginRespDto respDto = <span class="keyword">new</span> LoginRespDto();</span><br><span class="line">        respDto.setResultCode(<span class="string">&quot;0001&quot;</span>);</span><br><span class="line">        respDto.setResultMsg(<span class="string">&quot;用户登录认证失败&quot;</span>);</span><br><span class="line">        respDto.setResultTime(LocalDateTime.now().format(FORMATTER));</span><br><span class="line"></span><br><span class="line">        response.getWriter().write(JSON.toJSONString(respDto));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="用户无权访问handle"><a href="#用户无权访问handle" class="headerlink" title="用户无权访问handle"></a>用户无权访问handle</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当用户访问无权限页面时, 返回信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuzhihang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-06-04 14:03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessDeniedHandlerImpl</span> <span class="keyword">implements</span> <span class="title">AccessDeniedHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter FORMATTER = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyyMMddHHmmss&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        LoginRespDto respDto = <span class="keyword">new</span> LoginRespDto();</span><br><span class="line">        respDto.setResultCode(<span class="string">&quot;0002&quot;</span>);</span><br><span class="line">        respDto.setResultMsg(<span class="string">&quot;用户无权访问&quot;</span>);</span><br><span class="line">        respDto.setResultTime(LocalDateTime.now().format(FORMATTER));</span><br><span class="line"></span><br><span class="line">        response.getWriter().write(JSON.toJSONString(respDto));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="用户登录成功handle"><a href="#用户登录成功handle" class="headerlink" title="用户登录成功handle"></a>用户登录成功handle</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户登录成功之后的返回信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuzhihang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-06-04 14:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthenticationSuccessHandlerImpl</span> <span class="keyword">implements</span> <span class="title">AuthenticationSuccessHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter FORMATTER = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyyMMddHHmmss&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> JwtTokenUtil jwtTokenUtil;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthenticationSuccess</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        Authentication authentication)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        UserDetailsImpl userDetails = (UserDetailsImpl) authentication.getPrincipal();</span><br><span class="line"></span><br><span class="line">        String jwtToken = jwtTokenUtil.generateToken(userDetails);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把生成的token更新到数据库中</span></span><br><span class="line">        <span class="comment">// 更新DB操作 ...</span></span><br><span class="line"></span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        LoginRespDto respDto = <span class="keyword">new</span> LoginRespDto();</span><br><span class="line">        respDto.setToken(jwtToken);</span><br><span class="line">        respDto.setResultCode(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line">        respDto.setResultMsg(<span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">        respDto.setResultTime(LocalDateTime.now().format(FORMATTER));</span><br><span class="line"></span><br><span class="line">        response.getWriter().write(JSON.toJSONString(respDto));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JwtTokenUtil"><a href="#JwtTokenUtil" class="headerlink" title="JwtTokenUtil"></a>JwtTokenUtil</h2><p>主要用来生成token和通过token解析对象等操作.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuzhihang.demo.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.liuzhihang.demo.bean.UserDetailsImpl;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Claims;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Jwts;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.SignatureAlgorithm;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.Instant;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用 java-jwt jwt类库</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuzhihang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-06-05 09:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtTokenUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SignatureAlgorithm SIGN_TYPE = SignatureAlgorithm.HS256;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SECRET = <span class="string">&quot;jwt-secret&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JWT超时时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> EXPIRED_TIME = <span class="number">7</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * claims 为自定义的私有声明, 要放在前面</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 生成token</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">generateToken</span><span class="params">(UserDetails userDetails)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> instantNow = Instant.now().toEpochMilli();</span><br><span class="line"></span><br><span class="line">        Claims claims = Jwts.claims();</span><br><span class="line">        claims.put(Claims.SUBJECT, userDetails.getUsername());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Jwts.builder().setClaims(claims).setIssuedAt(<span class="keyword">new</span> Date(instantNow))</span><br><span class="line">                .setExpiration(<span class="keyword">new</span> Date(instantNow + EXPIRED_TIME))</span><br><span class="line">                .signWith(SIGN_TYPE, SECRET).compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * claims 为自定义的私有声明, 要放在前面</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 生成token</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">generateToken</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> instantNow = Instant.now().toEpochMilli();</span><br><span class="line"></span><br><span class="line">        Claims claims = Jwts.claims();</span><br><span class="line">        claims.put(Claims.SUBJECT, userName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Jwts.builder().setClaims(claims).setIssuedAt(<span class="keyword">new</span> Date(instantNow))</span><br><span class="line">                .setExpiration(<span class="keyword">new</span> Date(instantNow + EXPIRED_TIME))</span><br><span class="line">                .signWith(SIGN_TYPE, SECRET).compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将token解析, 映射为 UserDetails</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jwtToken</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">getUserDetailsFromToken</span><span class="params">(String jwtToken)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Claims claimsFromToken = getClaimsFromToken(jwtToken);</span><br><span class="line"></span><br><span class="line">        String userName = claimsFromToken.get(Claims.SUBJECT, String.class);</span><br><span class="line"></span><br><span class="line">        UserDetailsImpl userDetails = <span class="keyword">new</span> UserDetailsImpl();</span><br><span class="line">        userDetails.setUsername(userName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> userDetails;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证token</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">validateToken</span><span class="params">(String token, UserDetails userDetails)</span> </span>&#123;</span><br><span class="line">        UserDetailsImpl user = (UserDetailsImpl) userDetails;</span><br><span class="line">        String username = getPhoneNoFromToken(token);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (username.equals(user.getUsername()) &amp;&amp; !isTokenExpired(token));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 刷新令牌</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token 原令牌</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 新令牌</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">refreshToken</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        String refreshedToken;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Claims claims = getClaimsFromToken(token);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> instantNow = Instant.now().toEpochMilli();</span><br><span class="line"></span><br><span class="line">            refreshedToken = Jwts.builder().setClaims(claims).setIssuedAt(<span class="keyword">new</span> Date(instantNow))</span><br><span class="line">                    .setExpiration(<span class="keyword">new</span> Date(instantNow + EXPIRED_TIME))</span><br><span class="line">                    .signWith(SIGN_TYPE, SECRET).compact();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            refreshedToken = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> refreshedToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取token是否过期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">isTokenExpired</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        Date expiration = getExpirationDateFromToken(token);</span><br><span class="line">        <span class="keyword">return</span> expiration.before(<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据token获取username</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPhoneNoFromToken</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClaimsFromToken(token).getSubject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取token的过期时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getExpirationDateFromToken</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClaimsFromToken(token).getExpiration();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析JWT</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Claims <span class="title">getClaimsFromToken</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Jwts.parser().setSigningKey(SECRET).parseClaimsJws(token).getBody();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="WebSecurityConfig-核心配置"><a href="#WebSecurityConfig-核心配置" class="headerlink" title="WebSecurityConfig 核心配置"></a>WebSecurityConfig 核心配置</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuzhihang.demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.liuzhihang.demo.filter.CustomizeAuthenticationFilter;</span><br><span class="line"><span class="keyword">import</span> com.liuzhihang.demo.filter.JwtPerTokenFilter;</span><br><span class="line"><span class="keyword">import</span> com.liuzhihang.demo.service.UserDetailServiceImpl;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.http.SessionCreationPolicy;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.AuthenticationEntryPoint;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.access.AccessDeniedHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.authentication.AuthenticationFailureHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.authentication.AuthenticationSuccessHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuzhihang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-06-03 14:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDetailServiceImpl userDetailServiceImpl;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> JwtPerTokenFilter jwtPerTokenFilter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource(name = &quot;authenticationEntryPointImpl&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationEntryPoint authenticationEntryPoint;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource(name = &quot;authenticationSuccessHandlerImpl&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationSuccessHandler authenticationSuccessHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource(name = &quot;authenticationFailureHandlerImpl&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationFailureHandler authenticationFailureHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource(name = &quot;accessDeniedHandlerImpl&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> AccessDeniedHandler accessDeniedHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建用于认证授权的用户</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> auth</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureUserInfo</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 放入自己的认证授权用户, 内部逻辑需要自己实现</span></span><br><span class="line">        <span class="comment">// UserDetailServiceImpl implements UserDetailsService</span></span><br><span class="line">        auth.userDetailsService(userDetailServiceImpl);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http</span><br><span class="line">                <span class="comment">// 使用JWT, 关闭session</span></span><br><span class="line">                .csrf().disable().sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)</span><br><span class="line"></span><br><span class="line">                .and().httpBasic().authenticationEntryPoint(authenticationEntryPoint)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 登录的权限, 成功返回信息, 失败返回信息</span></span><br><span class="line">                .and().formLogin().permitAll()</span><br><span class="line"></span><br><span class="line">                .loginProcessingUrl(<span class="string">&quot;/login&quot;</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 配置url 权限 antMatchers: 匹配url 权限</span></span><br><span class="line">                .and().authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">&quot;/login&quot;</span>, <span class="string">&quot;/getVersion&quot;</span>)</span><br><span class="line">                .permitAll()</span><br><span class="line">                <span class="comment">// 其他需要登录才能访问</span></span><br><span class="line">                .anyRequest().access(<span class="string">&quot;@dynamicAuthorityService.hasPermission(request,authentication)&quot;</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 访问无权限 location 时</span></span><br><span class="line">                .and().exceptionHandling().accessDeniedHandler(accessDeniedHandler)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 自定义过滤</span></span><br><span class="line">                .and().addFilterAt(customAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class)</span><br><span class="line">                .addFilterBefore(jwtPerTokenFilter, UsernamePasswordAuthenticationFilter.class)</span><br><span class="line"></span><br><span class="line">                .headers().cacheControl();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 密码加密器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * BCryptPasswordEncoder：相同的密码明文每次生成的密文都不同，安全性更高</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">CustomizeAuthenticationFilter <span class="title">customAuthenticationFilter</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        CustomizeAuthenticationFilter filter = <span class="keyword">new</span> CustomizeAuthenticationFilter();</span><br><span class="line">        filter.setAuthenticationSuccessHandler(authenticationSuccessHandler);</span><br><span class="line">        filter.setAuthenticationFailureHandler(authenticationFailureHandler);</span><br><span class="line">        filter.setAuthenticationManager(authenticationManagerBean());</span><br><span class="line">        <span class="keyword">return</span> filter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="登录校验过程"><a href="#登录校验过程" class="headerlink" title="登录校验过程"></a>登录校验过程</h2><div class="mermaid">graph TD;    A(请求登录) --&gt; B(CustomizeAuthenticationFilter#attemptAuthentication 解析请求的json);    B --&gt; C(UserDetailServiceImpl#loadUserByUsername 验证用户名密码);    C --&gt; D(AuthenticationSuccessHandlerImpl#onAuthenticationSuccess 构建返回参数 包括token);    D --&gt; E(返回结果)</div><h3 id="自定义拦截器解析-json-报文"><a href="#自定义拦截器解析-json-报文" class="headerlink" title="自定义拦截器解析 json 报文"></a>自定义拦截器解析 json 报文</h3><p>前端请求登录报文类型为 application/json 需要后端增加拦截器, 对登录请求报文进行解析</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuzhihang.demo.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONException;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.AuthenticationServiceException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.UsernamePasswordAuthenticationToken;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.Authentication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.AuthenticationException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 自定义拦截器, 重写UsernamePasswordAuthenticationFilter 从而可以处理 application/json 中的json请求报文</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuzhihang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-06-12 19:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomizeAuthenticationFilter</span> <span class="keyword">extends</span> <span class="title">UsernamePasswordAuthenticationFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Authentication <span class="title">attemptAuthentication</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// attempt Authentication when Content-Type is json</span></span><br><span class="line">        <span class="keyword">if</span> (request.getContentType().equalsIgnoreCase(MediaType.APPLICATION_JSON_UTF8_VALUE)</span><br><span class="line">            || request.getContentType().equalsIgnoreCase(MediaType.APPLICATION_JSON_VALUE)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                BufferedReader br = request.getReader();</span><br><span class="line">                String str;</span><br><span class="line">                StringBuilder jsonStr = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                <span class="keyword">while</span> ((str = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    jsonStr.append(str);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                log.info(<span class="string">&quot;本次登录请求参数:&#123;&#125;&quot;</span>, jsonStr);</span><br><span class="line"></span><br><span class="line">                JSONObject jsonObject = JSON.parseObject(jsonStr.toString());</span><br><span class="line"></span><br><span class="line">                UsernamePasswordAuthenticationToken authRequest = <span class="keyword">new</span> UsernamePasswordAuthenticationToken(</span><br><span class="line">                    jsonObject.getString(<span class="string">&quot;username&quot;</span>), jsonObject.getString(<span class="string">&quot;password&quot;</span>));</span><br><span class="line">                setDetails(request, authRequest);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.getAuthenticationManager().authenticate(authRequest);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;用户登录, 请求参数 不正确&quot;</span>);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AuthenticationServiceException(<span class="string">&quot;获取报文请求参数失败&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (JSONException e) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;用户登录, 请求报文格式 不正确&quot;</span>);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AuthenticationServiceException(<span class="string">&quot;请求报文, 转换Json失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.error(<span class="string">&quot;用户登录, contentType 不正确&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AuthenticationServiceException(</span><br><span class="line">                <span class="string">&quot;请求 contentType 不正确, 请使用 application/json;charset=UTF-8 或者 application/json;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="用户认证模块"><a href="#用户认证模块" class="headerlink" title="用户认证模块"></a>用户认证模块</h3><ul><li>根据获取到的username从数据库中查询到密码, 将用户名密码赋值给UserDetails对象, 返回其他的框架会进行校验</li><li>这边使用中是使用的手机号+验证码登录, 所以 上面json解析的也是 phoneNo+verificationCode</li><li>在这块 username仅仅代指登录名, 可以是手机号可以是别的.</li><li>这边使用中验证码是从redis中获取的. 获取不到返回失败, 获取到和传递的不一致也算失败.</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuzhihang.demo.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.liuzhihang.demo.bean.UserDetailsImpl;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UsernameNotFoundException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuzhihang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component(&quot;userDetailServiceImpl&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDetailServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来验证登录名是否有权限进行登录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 可以通过数据库进行校验 也可以通过redis 等等</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UsernameNotFoundException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        UserDetailsImpl userDetailsImpl = <span class="keyword">new</span> UserDetailsImpl();</span><br><span class="line">        userDetailsImpl.setUsername(<span class="string">&quot;liuzhihang&quot;</span>);</span><br><span class="line">        userDetailsImpl.setPassword(<span class="keyword">new</span> BCryptPasswordEncoder().encode(<span class="string">&quot;123456789&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> userDetailsImpl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="请求校验过程"><a href="#请求校验过程" class="headerlink" title="请求校验过程"></a>请求校验过程</h2><div class="mermaid">graph TD;    A(请求接口) --&gt; B(JwtPerTokenFilter#doFilterInternal 验证Header中的token);    B --&gt; C(DynamicAuthorityService#hasPermission 验证有没有请求url权限);    C --&gt; D(处理逻辑);    D --&gt; E(返回结果)</div><h3 id="JWTToken拦截器"><a href="#JWTToken拦截器" class="headerlink" title="JWTToken拦截器"></a>JWTToken拦截器</h3><p>主要是拦截请求, 验证Header中的token是否正确</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuzhihang.demo.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.liuzhihang.demo.utils.JwtTokenUtil;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.UsernamePasswordAuthenticationToken;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.context.SecurityContextHolder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.authentication.WebAuthenticationDetailsSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.filter.OncePerRequestFilter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterChain;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuzhihang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-06-05 09:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtPerTokenFilter</span> <span class="keyword">extends</span> <span class="title">OncePerRequestFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtTokenUtil jwtTokenUtil;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存放Token的Header Key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HEADER_STRING = <span class="string">&quot;token&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        String token = request.getHeader(HEADER_STRING);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != token &amp;&amp; !jwtTokenUtil.isTokenExpired(token)) &#123;</span><br><span class="line">            UserDetails userDetails = jwtTokenUtil.getUserDetailsFromToken(token);</span><br><span class="line">            String username = userDetails.getUsername();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (username != <span class="keyword">null</span> &amp;&amp; SecurityContextHolder.getContext().getAuthentication() == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 通过 username 查询数据库 获取token 然后和库中token作比较</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (username.equals(<span class="string">&quot;liuzhihang&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                    UsernamePasswordAuthenticationToken authentication =</span><br><span class="line">                            <span class="keyword">new</span> UsernamePasswordAuthenticationToken(userDetails, <span class="keyword">null</span>, userDetails.getAuthorities());</span><br><span class="line">                    authentication.setDetails(<span class="keyword">new</span> WebAuthenticationDetailsSource().buildDetails(request));</span><br><span class="line">                    SecurityContextHolder.getContext().setAuthentication(authentication);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        filterChain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="URI动态校验"><a href="#URI动态校验" class="headerlink" title="URI动态校验"></a>URI动态校验</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuzhihang.demo.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.UsernamePasswordAuthenticationToken;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.Authentication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态权限认证</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuzhihang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-06-25 15:51</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component(value = &quot;dynamicAuthorityService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicAuthorityService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPermission</span><span class="params">(HttpServletRequest request, Authentication authentication)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object principal = authentication.getPrincipal();</span><br><span class="line">            <span class="keyword">if</span> (principal <span class="keyword">instanceof</span> UserDetails &amp;&amp; authentication <span class="keyword">instanceof</span> UsernamePasswordAuthenticationToken) &#123;</span><br><span class="line">                <span class="comment">// 本次请求的uri</span></span><br><span class="line">                String uri = request.getRequestURI();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取当前用户</span></span><br><span class="line">                UserDetails userDetails = (UserDetails) principal;</span><br><span class="line"></span><br><span class="line">                String username = userDetails.getUsername();</span><br><span class="line">                log.info(<span class="string">&quot;本次用户请求认证, username:&#123;&#125;, uri:&#123;&#125;&quot;</span>, username, uri);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 从数据库取逻辑</span></span><br><span class="line">                <span class="keyword">if</span> (username.equals(<span class="string">&quot;liuzhihang&quot;</span>))&#123;</span><br><span class="line">                    Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">                    set.add(<span class="string">&quot;/homeInfo&quot;</span>);</span><br><span class="line">                    set.add(<span class="string">&quot;/getAllUser&quot;</span>);</span><br><span class="line">                    set.add(<span class="string">&quot;/editUserInfo&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (set.contains(uri)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;用户请求登录, uri:&#123;&#125; error&quot;</span>, request.getRequestURI(), e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>脚本在 <a href="https://github.com/liuzhihang/jwt-demo/blob/master/src/test/java/ReqTest.http">httpclient脚本</a></p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">POST localhost:8080/login</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;username&quot;: &quot;liuzhihang&quot;,</span><br><span class="line">  &quot;password&quot;: &quot;123456789&quot;</span><br><span class="line">&#125;</span><br><span class="line">### 请求接口脚本</span><br><span class="line"></span><br><span class="line">POST localhost:8080/homeInfo</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"><span class="attribute">token</span>: eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJsaXV6aGloYW5nIiwiaWF0IjoxNTY5MDI1NjY4LCJleHAiOjE1Njk2MzA0Njh9.Kot_uLnwtcq-t5o4x3V-xBnpf-mKEi7OV2eAfgMCKLk</span><br><span class="line">###</span><br></pre></td></tr></table></figure><p>返回:</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;resultCode&quot;</span>: <span class="string">&quot;0000&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;resultMsg&quot;</span>: <span class="string">&quot;登录成功&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;resultTime&quot;</span>: <span class="string">&quot;20190920191038&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;token&quot;</span>: <span class="string">&quot;eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJsaXV6aGloYW5nIiwiaWF0IjoxNTY4OTc3ODM4LCJleHAiOjE1Njk1ODI2Mzh9.MAS9VkFdCF3agkCgTtc0VzPMFjY42vFyIvAEzkSeAfs&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/larger5/article/details/81063438">前后端分离 SpringBoot + SpringSecurity + JWT + RBAC 实现用户无状态请求验证</a></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JWT </tag>
            
            <tag> SpringSecurity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gitalk使用MD5生成Id</title>
      <link href="2019/07/20/gitalk-uses-md5-to-generate-an-id.html"/>
      <url>2019/07/20/gitalk-uses-md5-to-generate-an-id.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>Gitalk默认使用: location.pathname 作为 gitalk 的id, 但是location.path必须小于50位切换主题时, 每个主题使用的处理方式都不相同, 有可能会导致换了主题, 发现之前的评论不见了, 下面介绍使用MD5作为id, 同时在换主题时一定要修改这个id的规则.</p></blockquote><h3 id="Gitalk使用"><a href="#Gitalk使用" class="headerlink" title="Gitalk使用"></a>Gitalk使用</h3><p>使用<a href="https://github.com/gitalk/gitalk/blob/master/readme-cn.md">Gitalk</a>方法:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gitalk = <span class="keyword">new</span> Gitalk(&#123;</span><br><span class="line">  clientID: <span class="string">&#x27;GitHub Application Client ID&#x27;</span>,</span><br><span class="line">  clientSecret: <span class="string">&#x27;GitHub Application Client Secret&#x27;</span>,</span><br><span class="line">  repo: <span class="string">&#x27;GitHub repo&#x27;</span>,</span><br><span class="line">  owner: <span class="string">&#x27;GitHub repo owner&#x27;</span>,</span><br><span class="line">  admin: [<span class="string">&#x27;GitHub repo owner and collaborators, only these guys can initialize github issues&#x27;</span>],</span><br><span class="line">  id: location.pathname,      <span class="comment">// Ensure uniqueness and length less than 50</span></span><br><span class="line">  distractionFreeMode: <span class="literal">false</span>  <span class="comment">// Facebook-like distraction free mode</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">gitalk.render(<span class="string">&#x27;gitalk-container&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="使用MD5生成id"><a href="#使用MD5生成id" class="headerlink" title="使用MD5生成id"></a>使用MD5生成id</h3><ol><li>引入js</li></ol><p><a href="https://github.com/blueimp/JavaScript-MD5">MD5</a> js 下载地址</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;js/md5.min.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>修改js</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> gitalk_id = md5(location.pathname)</span><br><span class="line">    <span class="keyword">if</span> (&lt;%- page.comments_type == <span class="string">&#x27;404&#x27;</span>   %&gt;) &#123;</span><br><span class="line">        gitalk_id = md5(<span class="string">&#x27;https://liuzhihang.com/404&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> gitalk = <span class="keyword">new</span> Gitalk(&#123;</span><br><span class="line">        clientID: <span class="string">&#x27;&lt;%- theme.gitalk.oauth.clientId %&gt;&#x27;</span>,</span><br><span class="line">        clientSecret: <span class="string">&#x27;&lt;%- theme.gitalk.oauth.clientSecret %&gt;&#x27;</span>,</span><br><span class="line">        repo: <span class="string">&#x27;&lt;%- theme.gitalk.repo %&gt;&#x27;</span>,</span><br><span class="line">        owner: <span class="string">&#x27;&lt;%- theme.gitalk.owner %&gt;&#x27;</span>,</span><br><span class="line">        admin: &lt;%- <span class="built_in">JSON</span>.stringify(theme.gitalk.admin) %&gt;,</span><br><span class="line">        id: gitalk_id,</span><br><span class="line">        distractionFreeMode: <span class="literal">false</span>  <span class="comment">// Facebook-like distraction free mode</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    gitalk.render(<span class="string">&#x27;gitalk-container&#x27;</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA插件--Toolkit</title>
      <link href="2019/05/11/idea-plugin-toolkit.html"/>
      <url>2019/05/11/idea-plugin-toolkit.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Toolkit"><a href="#Toolkit" class="headerlink" title="Toolkit"></a>Toolkit</h1><div><a href="https://plugins.jetbrains.com/plugin/12384-toolkit"><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://img.shields.io/jetbrains/plugin/v/12384-toolkit.svg" alt="JetBrains Plugins"></a><a href="https://plugins.jetbrains.com/plugin/12384-toolkit/versions"><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="http://phpstorm.espend.de/badge/12384/version" alt="Version"></a><a href="https://plugins.jetbrains.com/plugin/12384-toolkit"><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://img.shields.io/jetbrains/plugin/d/12384-toolkit.svg" alt="Downloads"></a><a href="https://github.com/liuzhihang/toolkit/blob/master/LICENSE"><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://img.shields.io/badge/license-MIT-red.svg" alt="License"></a></div><p>一个小工具包, 暂时还有很多功能需要扩展.</p><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><ul><li>Mybatis<ul><li>通过侧栏箭头在 MyBatis XML文件和 Mapper文件之间相互跳转</li><li>mapper文件id简单检查</li></ul></li><li>Json<ul><li>JavaBean复制为Json字符串</li><li>Json字符串格式化</li><li>Json字符串转换为JavaBean</li><li>Json压缩</li></ul></li><li>XML: Xml格式化</li></ul><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><ul><li>文末演示</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul><li><p><strong>在线安装:</strong></p><ul><li><code>File</code> -&gt; <code>Setting</code> -&gt; <code>Plugins</code> -&gt; 搜索 <code>Toolkit</code></li></ul></li><li><p><strong>手动安装:</strong></p><ul><li><a href="https://github.com/liuzhihang/toolkit/releases">下载插件</a> -&gt; <code>File</code> -&gt; <code>Setting</code> -&gt; <code>Plugins</code> -&gt; <code>Install Plugin from Disk...</code></li></ul></li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li>右键菜单选择 <code>Tookit</code></li></ul><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><h2 id="v1-0-7-2020-02-27"><a href="#v1-0-7-2020-02-27" class="headerlink" title="v1.0.7 (2020-02-27)"></a><a href="https://github.com/liuzhihang/toolkit/releases/tag/v1.0.7">v1.0.7</a> (2020-02-27)</h2><ul><li>修改使用包装类型</li></ul><p><a href="./doc/ChangeNotes.md">查看更多历史更新记录</a></p><h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><h5 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis:"></a>MyBatis:</h5><p>&emsp;mybatis support: <a href="https://github.com/zhaoqin102/mybatis-support">https://github.com/zhaoqin102/mybatis-support</a></p><p>&emsp;free-idea-mybatis: <a href="https://github.com/wuzhizhan/free-idea-mybatis">https://github.com/wuzhizhan/free-idea-mybatis</a></p><h5 id="Json"><a href="#Json" class="headerlink" title="Json:"></a>Json:</h5><p>&emsp;GsonFormat: <a href="https://github.com/zzz40500/GsonFormat">https://github.com/zzz40500/GsonFormat</a></p><h2 id="本工具使用-JetBrains-IDEA-进行开发"><a href="#本工具使用-JetBrains-IDEA-进行开发" class="headerlink" title="本工具使用 JetBrains IDEA 进行开发"></a>本工具使用 JetBrains IDEA 进行开发</h2><p><a href="https://www.jetbrains.com/?from=Toolkit"><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/toolkit/jetbrains-logo.png" width="20%" height="20%"></a><a href="https://www.jetbrains.com/?from=Toolkit"><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/toolkit/idea-logo.png" width="20%" height="20%"> </a></p><h2 id="演示-1"><a href="#演示-1" class="headerlink" title="演示"></a>演示</h2><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/toolkit/copy-as-json.png" alt="copy-as-json"><br><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/toolkit/gif.gif" alt="gif"></p>]]></content>
      
      
      <categories>
          
          <category> IDEA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> plugin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>elasticsearch cat API</title>
      <link href="2019/03/14/elasticsearch-cat-api.html"/>
      <url>2019/03/14/elasticsearch-cat-api.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="cat-API"><a href="#cat-API" class="headerlink" title="cat API"></a>cat API</h4><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/cat.html">官方地址</a></p><blockquote><p>GET /_cat/XXX?v<br>GET /_cat/XXX?v&amp;format=json</p></blockquote><p>v 是指带着列信息</p><p>支持指定返回内容的格式 默认为text</p><p>?format=text(json/smile/yaml/cbor)</p><a id="more"></a><h5 id="查看节点别名"><a href="#查看节点别名" class="headerlink" title="查看节点别名"></a>查看节点别名</h5><blockquote><p>GET /_cat/aliases?v<br>curl -X GET “192.168.xxx.xxx:9200/_cat/aliases?v”</p></blockquote><h5 id="每个节点分配了几个shard，对磁盘的占用空间大小，使用率"><a href="#每个节点分配了几个shard，对磁盘的占用空间大小，使用率" class="headerlink" title="每个节点分配了几个shard，对磁盘的占用空间大小，使用率"></a>每个节点分配了几个shard，对磁盘的占用空间大小，使用率</h5><blockquote><p>GET /_cat/allocation?v<br>curl -X GET “192.168.xxx.xxx:9200/_cat/allocation?v”</p></blockquote><h5 id="群集或单个索引的document计数"><a href="#群集或单个索引的document计数" class="headerlink" title="群集或单个索引的document计数"></a>群集或单个索引的document计数</h5><blockquote><p>GET /_cat/count?v<br>curl -X GET “192.168.xxx.xxx:9200/_cat/count?v</p><p>GET /_cat/count/index_name?v<br>curl -X GET “192.168.xxx.xxx:9200/_cat/count/index_name?v”</p></blockquote><h5 id="显示集群中每个数据节点上fielddata当前正在使用的堆内存量"><a href="#显示集群中每个数据节点上fielddata当前正在使用的堆内存量" class="headerlink" title="显示集群中每个数据节点上fielddata当前正在使用的堆内存量"></a>显示集群中每个数据节点上fielddata当前正在使用的堆内存量</h5><blockquote><p>GET /_cat/fielddata?v<br>curl -X GET “192.168.xxx.xxx:9200/_cat/fielddata?v”</p></blockquote><h5 id="查看集群健康情况"><a href="#查看集群健康情况" class="headerlink" title="查看集群健康情况"></a>查看集群健康情况</h5><blockquote><p>GET /_cat/health?v<br>curl -X GET “192.168.xxx.xxx:9200/_cat/health?v”</p></blockquote><h5 id="查看索引的信息"><a href="#查看索引的信息" class="headerlink" title="查看索引的信息"></a>查看索引的信息</h5><blockquote><p>GET _cat/indices?v<br>GET _cat/indices/index_name?v<br>curl -X GET “192.168.xxx.xxx:9200/_cat/indices/twi*?v&amp;s=index”</p></blockquote><h5 id="查看master信息"><a href="#查看master信息" class="headerlink" title="查看master信息"></a>查看master信息</h5><blockquote><p>GET /_cat/master?v<br>curl -X GET “192.168.xxx.xxx:9200/_cat/master?v”</p></blockquote><h5 id="查看node信息"><a href="#查看node信息" class="headerlink" title="查看node信息"></a>查看node信息</h5><blockquote><p>GET /_cat/nodes?v<br>curl -X GET “192.168.xxx.xxx:9200/_cat/nodes?v”</p></blockquote><h5 id="当前pending没执行完的task的具体情况，执行的是什么操作"><a href="#当前pending没执行完的task的具体情况，执行的是什么操作" class="headerlink" title="当前pending没执行完的task的具体情况，执行的是什么操作"></a>当前pending没执行完的task的具体情况，执行的是什么操作</h5><blockquote><p>创建索引，更新映射，分配或失败分片的列表<br>GET /_cat/pending_tasks?v<br>curl -X GET “192.168.xxx.xxx:9200/_cat/pending_tasks?v”</p></blockquote><h5 id="查看安装的插件"><a href="#查看安装的插件" class="headerlink" title="查看安装的插件"></a>查看安装的插件</h5><blockquote><p>GET /_cat/plugins?v&amp;s=component&amp;h=name,component,version,description<br>curl -X GET “192.168.xxx.xxx:9200/_cat/plugins?v&amp;s=component&amp;h=name,component,version,description”</p></blockquote><h5 id="shard-recovery恢复的过程情况"><a href="#shard-recovery恢复的过程情况" class="headerlink" title="shard recovery恢复的过程情况"></a>shard recovery恢复的过程情况</h5><blockquote><p>GET /_cat/recovery?v<br>curl -X GET “192.168.xxx.xxx:9200/_cat/recovery?v”</p></blockquote><h5 id="查看在群集中注册的快照存储库"><a href="#查看在群集中注册的快照存储库" class="headerlink" title="查看在群集中注册的快照存储库"></a>查看在群集中注册的快照存储库</h5><blockquote><p>GET /_cat/repositories?v<br>curl -X GET “192.168.xxx.xxx:9200/_cat/repositories?v</p></blockquote><h5 id="查看线程池使用"><a href="#查看线程池使用" class="headerlink" title="查看线程池使用"></a>查看线程池使用</h5><blockquote><p>GET /_cat/thread_pool<br>curl -X GET “192.168.xxx.xxx:9200/_cat/thread_pool”</p></blockquote><h5 id="查看shard情况"><a href="#查看shard情况" class="headerlink" title="查看shard情况"></a>查看shard情况</h5><blockquote><p>GET _cat/shards?v<br>GET _cat/shards/index_name?v<br>curl -X GET “192.168.xxx.xxx:9200/_cat/shards/index_name?v</p></blockquote><h5 id="索引segment文件的情况，在哪个node上，有多少个document，占用了多少磁盘空间，有多少数据在内存中，是否可以搜索"><a href="#索引segment文件的情况，在哪个node上，有多少个document，占用了多少磁盘空间，有多少数据在内存中，是否可以搜索" class="headerlink" title="索引segment文件的情况，在哪个node上，有多少个document，占用了多少磁盘空间，有多少数据在内存中，是否可以搜索"></a>索引segment文件的情况，在哪个node上，有多少个document，占用了多少磁盘空间，有多少数据在内存中，是否可以搜索</h5><blockquote><p>GET /_cat/segments?v<br>GET _cat/segments/index_name?v<br>curl -X GET “192.168.xxx.xxx:9200/_cat/segments/index_name?v</p></blockquote><h5 id="查看tempalte"><a href="#查看tempalte" class="headerlink" title="查看tempalte"></a>查看tempalte</h5><blockquote><p>GET /_cat/templates?v&amp;s=name<br>curl -X GET “192.168.xxx.xxx:9200/_cat/templates?v&amp;s=name”</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ELK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ELK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么es集群至少需要三个节点</title>
      <link href="2019/03/13/why-does-the-es-cluster-require-at-least-three-nodes.html"/>
      <url>2019/03/13/why-does-the-es-cluster-require-at-least-three-nodes.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="elasticsearch集群"><a href="#elasticsearch集群" class="headerlink" title="elasticsearch集群"></a>elasticsearch集群</h4><div class="mermaid">graph LR;    A(Master Node) --- B(Data Node);    A --- C(Data Node);    B --- C;</div><p>Master: 在Elasticsearch中Master仅仅负责维护集群的状态</p><blockquote><ol><li>创建或删除索引</li><li>跟踪哪些节点是集群的一部分</li><li>决定将哪些碎片分配给哪个节点</li><li>等集群范围的操作</li></ol></blockquote><p>上面的一些集群信息, 是由Master节点进行维护, 但是 Master也会把节点信息, 同步给其他节点, 但是只有master节点可以修改.</p><a id="more"></a><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-node.html">点击查看Elasticsearch节点介绍</a></p><h4 id="为什么要至少三个节点"><a href="#为什么要至少三个节点" class="headerlink" title="为什么要至少三个节点"></a>为什么要至少三个节点</h4><p>首先查看 Elasticsearch 的配置文件, 如下:<br><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-discovery-zen.html">Zen Discovery 官方介绍</a></p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 传递初始主机列表，以便在启动新节点时执行发现</span></span><br><span class="line"><span class="attr">discovery.zen.ping.unicast.hosts:</span> [<span class="string">&quot;192.168.xxx.xxx:9300&quot;</span>, <span class="string">&quot;192.168.xxx.xxx:9300&quot;</span>]</span><br><span class="line"><span class="comment"># 选举Maste时需要的节点数 (total number of master-eligible nodes / 2 + 1) 防止“防止脑裂”</span></span><br><span class="line"><span class="attr">discovery.zen.minimum_master_nodes:</span> <span class="number">2</span></span><br><span class="line"><span class="comment"># 一个节点多久ping一次，默认1s</span></span><br><span class="line"><span class="attr">discovery.zen.fd.ping_interval:</span> <span class="string">1s</span></span><br><span class="line"><span class="comment"># 等待ping返回时间，默认30s</span></span><br><span class="line"><span class="attr">discovery.zen.fd.ping_timeout:</span> <span class="string">30s</span></span><br><span class="line"><span class="comment"># ping超时重试次数，默认3次</span></span><br><span class="line"><span class="attr">discovery.zen.fd.ping_retries:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><pre><code>discovery.zen.minimum_master_nodes: 2</code></pre><p>其中 minimum_master_nodes 配置是为了防止脑裂</p><h5 id="假设-Elasticsearch-有两个节点"><a href="#假设-Elasticsearch-有两个节点" class="headerlink" title="假设 Elasticsearch 有两个节点"></a>假设 Elasticsearch 有两个节点</h5><div class="mermaid">graph LR;    A(Master Node) --- B(Data Node);</div><div class="mermaid">graph LR;    A(Master Node) -.X.- B(Data Node);</div><ol><li><p>discovery.zen.minimum_master_nodes: 1</p><blockquote><p>此时出现网络波动, 导致 A—B 之间短暂断开连接,  根据选举规则, B将自己选举为 Master, 当网络波动结束, 就会出现两个Master的情况.</p></blockquote> <div class="mermaid">graph LR;    A(Master Node 宕机) --- B(Data Node);</div></li></ol><ol start="2"><li>discovery.zen.minimum_master_nodes: 2<blockquote><p>Master 出现故障, 则 B 将永远不可能将自己选择为 Master</p></blockquote></li></ol><h5 id="Elasticsearch-有三个节点"><a href="#Elasticsearch-有三个节点" class="headerlink" title="Elasticsearch 有三个节点"></a>Elasticsearch 有三个节点</h5><p>三节点配置: discovery.zen.minimum_master_nodes: 2</p><div class="mermaid">graph LR;    A(Master Node) -.X.- B(Data Node);    A -.X.- C(Data Node);    B --- C;</div><p>出现网络波动 A 节点 和 别的节点短暂断开连接</p><div class="mermaid">graph LR;    A(Master Node -&gt; Data Node) -.X.- B(Data Node -&gt; Master Node);    A -.X.- C(Data Node);    B --- C;</div><p>A节点降级, B和C 进行选举, 此处模拟选举B为 Master Node</p><div class="mermaid">graph LR;    A(Data Node) --- B(Master Node);    A --- C(Data Node);    B --- C;</div><p>网络恢复后的节点状况.</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>以上可以看出, 通过配置 minimum_master_nodes 来防止出现脑裂<br>同时在生产过程中, 为了尽量保持集群高可用, 至少需要三台机器搭建集群</p>]]></content>
      
      
      <categories>
          
          <category> ELK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ELK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch 数据写入流程</title>
      <link href="2019/03/12/elasticsearch-data-writing-process.html"/>
      <url>2019/03/12/elasticsearch-data-writing-process.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="简单流程"><a href="#简单流程" class="headerlink" title="简单流程"></a>简单流程</h4><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="/resources/image/elk/elasticsearch-writing-process.png" alt="elasticsearch写入过程"></p><ol><li><p>客户端随机选择一个node发送数据, 此时该node为协调节点(coordinating node)<br> 1.1. coordinating node 通过 _id计算出该document在哪个shard上, 假设为shard0, 计算方式如下:</p><blockquote><p>hash(_id) % number_of_primary_shards</p></blockquote><p> 1.2. node 根据 cluster state 获取到 shard0 在 node1 上</p><a id="more"></a></li><li><p>将消息发送到 node1 的 P0 上</p></li><li><p>P0 收到数据后, 将数据同步到 自己的 replica shard R0上</p></li><li><p>P0 和 R0 都处理完毕, 才会返回客户端成功</p></li></ol><blockquote><p>Px 为 primary shard<br>Rx 为 replica shard<br>当客户端请求为查询时, 路由到任意 shard(primary shard 或者 replica shard) 查询到数据即可返回.</p></blockquote><h4 id="详细流程"><a href="#详细流程" class="headerlink" title="详细流程"></a>详细流程</h4><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="/resources/image/elk/elasticsearch-writing-detailed-process.png" alt="elasticsearch-writing-detailed-process"></p><ol><li>P0收到document, 同时将数据写入到 内存buffer和translog中</li><li>每隔1s或buffer满时, buffer中的数据会 refresh 到segment中, 而后进入os cache, 一旦segment进入到 cache中,其中的数据, 则可以被搜索到<blockquote><p>refresh 时间可以手动设置, 也可以手动触发 refresh</p></blockquote></li><li>清空buffer, translog不处理</li><li>重复1-3操作, translog不断增大, translog每隔30分钟,或大到一定量时, 会触发commit操作</li><li>将buffer中内容刷新到segment中, 并清空buffer</li><li>将一个commit point 写入到磁盘文件中, 标识此次commit 对应的 segment</li><li>执行 fsync 将 os cache 中的数据强制刷新到磁盘文件中</li><li>删除 translog 文件</li></ol><h5 id="删除和更新操作"><a href="#删除和更新操作" class="headerlink" title="删除和更新操作"></a>删除和更新操作</h5><blockquote><p>在commit时, 如果操作为删除, 生成一个 .del文件, 其中将该document标记位deleted, 并不是真正的物理删除, 此时如果有查询请求, 会先查询 .del文件中是否有该记录, 如果有, 则回复不存在.<br>在commit时, 如果为更新操作, 则是将原document标记位deleted, 同时写入一条新数据</p></blockquote><h5 id="服务宕机重启-translog-日志作用"><a href="#服务宕机重启-translog-日志作用" class="headerlink" title="服务宕机重启, translog 日志作用"></a>服务宕机重启, translog 日志作用</h5><blockquote><p>translog是先写入到 os cache中, 然后每隔5s写入到磁盘文件中, 假如服务宕掉, 可能会失去5s数据, 也可以修改写入磁盘的时机, 但是可能会影响性能<br>translog中记录的是数据操作信息, 在服务宕机重启时, 会读取translog磁盘文件, 然后将translog中的数据重新恢复到 segment中, 然后进行后续操作</p></blockquote><h5 id="segment-merge-过程"><a href="#segment-merge-过程" class="headerlink" title="segment merge 过程"></a>segment merge 过程</h5><blockquote><p>segment 持续生成, 会导致 segment不断变多, 占用<a href="https://baike.baidu.com/item/%E6%96%87%E4%BB%B6%E5%8F%A5%E6%9F%84">文件句柄</a>, cpu资源等等<br>es后台有一个专门的程序负责合并segment, 将小的 segment 合成大的segment, 同时写一个commit point, 标识 新的segment file.<br>打开新的segment供查询使用, 删除旧的 segment<br>segment 合并过程中, 被标记位 deleted 的document 不会被合并. 即: 在合并 segment时, 才将 document 真正物理删除<br>合并的segment 可以使磁盘上已经commit的索引 也可以是内存中还未commit的索引</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ELK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ELK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>logstash input多个kafka异常</title>
      <link href="2019/03/04/logstash-input-multiple-kafka-exceptions.html"/>
      <url>2019/03/04/logstash-input-multiple-kafka-exceptions.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><div class="mermaid">graph LR;    filebeat --&gt; logstash;    log4j --&gt; logstash;    logstash --&gt; es;</div><p>filebeat 和 log4j appender 同时到 kafka, logstash在启动时报错, 错误如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javax.management.InstanceAlreadyExistsException: kafka.consumer:type&#x3D;app-info,id&#x3D;logstash-0</span><br></pre></td></tr></table></figure><a id="more"></a><h5 id="问题原因及解决"><a href="#问题原因及解决" class="headerlink" title="问题原因及解决"></a>问题原因及解决</h5><p>input 消费kafka时, 分别指定不同的 client_id.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kafka &#123;</span><br><span class="line">        bootstrap_servers &#x3D;&gt; [&quot;192.168.103.43:9092&quot;] # 注意这里配置的kafka的broker地址不是zk的地址</span><br><span class="line">        client_id &#x3D;&gt; &quot;kafka_client_1&quot;</span><br><span class="line">        group_id &#x3D;&gt; &quot;logstash&quot;</span><br><span class="line">        topics &#x3D;&gt; [&quot;ipaynow_log&quot;]  # kafka topic 名称</span><br><span class="line">        consumer_threads &#x3D;&gt; 5</span><br><span class="line">        decorate_events &#x3D;&gt; true</span><br><span class="line">        type &#x3D;&gt; &quot;string&quot;</span><br><span class="line">        codec &#x3D;&gt; &quot;json&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kafka &#123;</span><br><span class="line">        bootstrap_servers &#x3D;&gt; [&quot;192.168.103.43:9092&quot;] # 注意这里配置的kafka的broker地址不是zk的地址</span><br><span class="line">        client_id &#x3D;&gt; &quot;kafka_client_2&quot;</span><br><span class="line">        group_id &#x3D;&gt; &quot;logstash&quot;</span><br><span class="line">        topics &#x3D;&gt; [&quot;ipaynow-hunter&quot;]  # kafka topic 名称</span><br><span class="line">        consumer_threads &#x3D;&gt; 5</span><br><span class="line">        decorate_events &#x3D;&gt; true</span><br><span class="line">        type &#x3D;&gt; &quot;string&quot;</span><br><span class="line">        codec &#x3D;&gt; plain &#123; charset&#x3D;&gt;&quot;UTF-8&quot; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> issue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ELK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序无异常中断</title>
      <link href="2019/02/15/no-abnormal-interruption-of-the-program.html"/>
      <url>2019/02/15/no-abnormal-interruption-of-the-program.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><ol><li>程序执行到某一处之后停顿, 不能继续执行, 不抛出异常, 无返回值</li><li>本地测试正常</li><li>debug可以正常执行</li><li>操作为入库之前, 创建对象, 是一个很简单的set操作</li></ol><blockquote><p>payInfoExtra.setToAccType(agPayReqDto.getToAccType().getValue());</p><p>其中get操作获取的为一个枚举, 主要操作为从枚举中获取value set到另一个对象中</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AccTypeEnum <span class="title">getToAccType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> toAccType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="问题原因及解决"><a href="#问题原因及解决" class="headerlink" title="问题原因及解决"></a>问题原因及解决</h4><p>小伙伴在他们项目中复用本项目中的枚举类, 没有修改包名类名, 但是把枚举中value字段从 byte改成了String, 同时放在了依赖中, 提供给我们使用.<br>解决方案就很简单了, 让小伙伴修改包名类名就可以了.<br>原枚举类如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">AccTypeEnum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    PRI((<span class="keyword">byte</span>) <span class="number">0</span>, <span class="string">&quot;对私&quot;</span>),</span><br><span class="line">    PUB((<span class="keyword">byte</span>) <span class="number">1</span>, <span class="string">&quot;对公&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span> value;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> issue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> issue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>skywalking5集群部署</title>
      <link href="2018/12/27/skywalking5-cluster-deployment.html"/>
      <url>2018/12/27/skywalking5-cluster-deployment.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h4><ol><li>skywalking-5.0.0-GA</li><li>zookeeper-3.4.10</li><li>elasticsearch-5.6.14</li></ol><p>下载地址如下:</p><pre><code>skywalking: http://skywalking.apache.org/downloads/zookeeper: http://mirrors.hust.edu.cn/apache/zookeeper/elasticsearch: https://www.elastic.co/downloads/past-releases</code></pre><a id="more"></a><h4 id="安装zk集群"><a href="#安装zk集群" class="headerlink" title="安装zk集群"></a>安装zk集群</h4><ol><li>下载并解压zk<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://mirrors.hust.edu.cn/apache/zookeeper/zookeeper-3.4.10/zookeeper-3.4.10.tar.gz</span><br><span class="line">tar -xvf zookeeper-3.4.10.tar.gz</span><br></pre></td></tr></table></figure></li><li>修改配置文件<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> zookeeper-3.4.10/conf/</span><br><span class="line">cp zoo_sample.cfg zoo.cfg</span><br><span class="line">vim zoo.cfg</span><br></pre></td></tr></table></figure></li><li>内容如下<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tickTime=2000</span><br><span class="line">initLimit=10</span><br><span class="line">syncLimit=5</span><br><span class="line">dataDir=/opt/<span class="built_in">export</span>/app/zookeeper-3.4.10/data</span><br><span class="line">clientPort=2181</span><br><span class="line">server.1=192.168.***.236:2888:3888</span><br><span class="line">server.2=192.168.***.237:2888:3888</span><br></pre></td></tr></table></figure></li><li>写入集群myid<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt; /opt/<span class="built_in">export</span>/app/zookeeper-3.4.10/data/myid</span><br><span class="line"><span class="comment"># 另一台机器则写入2</span></span><br></pre></td></tr></table></figure></li><li>zk基本命令<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在zk的bin目录下</span></span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">./zkServer.sh start</span><br><span class="line"><span class="comment"># 停止</span></span><br><span class="line">./zkServer.sh stop</span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">./zkServer.sh status</span><br><span class="line"><span class="comment"># 查看zk的节点</span></span><br><span class="line">./zkCli.sh</span><br><span class="line"><span class="comment"># 连接后使用 ls / 命令查看</span></span><br><span class="line">ls /skywalking</span><br></pre></td></tr></table></figure></li></ol><h4 id="安装es集群"><a href="#安装es集群" class="headerlink" title="安装es集群"></a>安装es集群</h4><ol><li>下载并解压es<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.6.14.tar.gz</span><br><span class="line">tar -xvf elasticsearch-5.6.14.tar.gz</span><br></pre></td></tr></table></figure></li><li>修改配置文件<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> elasticsearch-5.6.14/config/</span><br><span class="line">vim elasticsearch.yml</span><br></pre></td></tr></table></figure></li><li>内容如下<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cluster.name: CollectorDBCluster</span><br><span class="line">node.name: node-1</span><br><span class="line">path.data: /opt/<span class="built_in">export</span>/app/elasticsearch-5.6.14/data</span><br><span class="line">path.logs: /opt/<span class="built_in">export</span>/app/elasticsearch-5.6.14/logs</span><br><span class="line">network.host: 192.168.***.234</span><br><span class="line">discovery.zen.ping.unicast.hosts: [<span class="string">&quot;192.168.***.234:9300&quot;</span>, <span class="string">&quot;192.168.***.235:9300&quot;</span>]</span><br><span class="line">discovery.zen.minimum_master_nodes: 2</span><br><span class="line">bootstrap.memory_lock: <span class="literal">false</span></span><br><span class="line">bootstrap.system_call_filter: <span class="literal">false</span></span><br><span class="line"><span class="comment"># 修改上报数据线程池大小</span></span><br><span class="line">thread_pool.bulk.queue_size: 1000</span><br></pre></td></tr></table></figure></li><li>常用命令<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 后台启动</span></span><br><span class="line">bin/elasticsearch -d</span><br><span class="line"><span class="comment"># 删除所有索引</span></span><br><span class="line">curl -XDELETE 192.168.***.234:9200/*</span><br></pre></td></tr></table></figure></li></ol><h4 id="安装skywalking"><a href="#安装skywalking" class="headerlink" title="安装skywalking"></a>安装skywalking</h4><p>☞ <a href="https://github.com/apache/incubator-skywalking/blob/v5.0.0-GA/docs/cn/Deploy-backend-in-cluster-mode-CN.md">官方地址</a></p><ol><li>下载并解压<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://mirrors.shu.edu.cn/apache/incubator/skywalking/5.0.0-GA/apache-skywalking-apm-incubating-5.0.0-GA.tar.gz</span><br><span class="line">tar -xvf apache-skywalking-apm-incubating-5.0.0-GA.tar.gz</span><br><span class="line">mv apache-skywalking-apm-incubating-5.0.0-GA skywalking-5.0.0-GA</span><br></pre></td></tr></table></figure></li><li>修改配置<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> skywalking-5.0.0-GA/config/</span><br><span class="line">vim application.yml</span><br></pre></td></tr></table></figure></li><li>修改内容如下<ol><li>集群配置 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cluster:</span><br><span class="line">    zookeeper:</span><br><span class="line">        hostPort: 192.168.***.236:2181,192.168.***.237:2181</span><br><span class="line">        sessionTimeout: 100000</span><br></pre></td></tr></table></figure></li><li>es配置 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">storage:</span><br><span class="line">    elasticsearch:</span><br><span class="line">        clusterName: CollectorDBCluster</span><br><span class="line">        clusterTransportSniffer: <span class="literal">true</span></span><br><span class="line">        clusterNodes: 192.168.***.234:9300,192.168.***.235:9300</span><br><span class="line">        <span class="comment"># 其他配置</span></span><br></pre></td></tr></table></figure></li><li>其他配置 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># host配置修改</span></span><br><span class="line">host: 192.168.***.236</span><br></pre></td></tr></table></figure></li></ol></li><li>修改webapp配置<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim webapp/webapp.yml</span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">collector:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/graphql</span></span><br><span class="line">    <span class="attr">ribbon:</span></span><br><span class="line">        <span class="attr">ReadTimeout:</span> <span class="number">10000</span></span><br><span class="line">        <span class="attr">listOfServers:</span> <span class="number">192.168</span><span class="string">.**.236:10800,192.168.**.237:10800</span></span><br></pre></td></tr></table></figure></li><li>常用命令<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动collector+webUI</span></span><br><span class="line">bin/startup.sh</span><br><span class="line"><span class="comment"># 只启动collector或webUI</span></span><br><span class="line">bin/collectorService.sh</span><br><span class="line">bin/webappService.sh</span><br></pre></td></tr></table></figure></li><li>探针使用<br> ☞ <a href="https://github.com/apache/incubator-skywalking/blob/v5.0.0-GA/docs/cn/Deploy-skywalking-agent-CN.md">官方地址</a><pre><code> java -javaagent:/path/to/skywalking-agent/skywalking-agent.jar -jar yourApp.jar</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> skywalking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ELK </tag>
            
            <tag> skywalking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>logstash时间戳差8个小时</title>
      <link href="2018/12/20/logstash-timestamp-difference-8-hours.html"/>
      <url>2018/12/20/logstash-timestamp-difference-8-hours.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="问题说明"><a href="#问题说明" class="headerlink" title="问题说明"></a>问题说明</h4><p>原始配置:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">elasticsearch &#123;</span><br><span class="line">        # manage_template &#x3D;&gt; false</span><br><span class="line">        template_overwrite &#x3D;&gt; true</span><br><span class="line">        template &#x3D;&gt; &quot;&#x2F;opt&#x2F;export&#x2F;app&#x2F;logstash-6.4.2&#x2F;bin&#x2F;dynamic_templates.json&quot;</span><br><span class="line">        user &#x3D;&gt; xxxxxxx</span><br><span class="line">        password &#x3D;&gt; xxxxxxx</span><br><span class="line">        index &#x3D;&gt; &quot;%&#123;sys_name&#125;-%&#123;+YYYY.MM.dd&#125;&quot;</span><br><span class="line">        hosts &#x3D;&gt; [&quot;172.19.3.51:9200&quot;,&quot;172.19.3.52:9200&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用logstash输出内容要es中时, 指定index为系统名称+时间(年月日), 时间会自动匹配‘@timestamp’字段并格式化, 但是在实际使用过程中, 发现在上午八点之前的消息会被创建到昨天的索引里面.查阅相关资料, 有介绍在时间戳上面增加8个小时的方式, 也可以使用. 这里结合自己业务使用的其他方式.</p><a id="more"></a><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ol><li><p>主要报送内容为filebeat的日志信息, 日志统一有时间戳, 格式如下:</p><pre><code> [trans-mediapay]-[2018-12-19 02:00:00:187]-[queryThreadPool-14]-[]-[WeBankServiceImpl.java:101]-[INFO ]-[测试2点的日志]</code></pre></li><li><p>解析时间戳的时间</p><ol><li>先匹配整体日志, 获取’log_time’字段</li><li>匹配’log_time’字段</li><li>生成元数据 ‘[@metadata][index_suffix]’<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">#  日志聚合使用全量配置</span></span><br><span class="line">grok &#123;</span><br><span class="line">match =&gt; &#123;</span><br><span class="line"><span class="string">&quot;message&quot;</span> =&gt; <span class="string">&quot;\[%&#123;DATA:sys_name&#125;\]-\[%&#123;DATA:log_time&#125;\]-\[%&#123;DATA:thread_name&#125;\]-\[%&#123;DATA:trace_id&#125;\]-\[%&#123;DATA:class_name&#125;\]-\[%&#123;DATA:log_level&#125;\]-%&#123;GREEDYDATA:log_msg&#125;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">grok&#123;</span><br><span class="line">        match =&gt; &#123; <span class="string">&quot;log_time&quot;</span> =&gt; [<span class="string">&quot;%&#123;INT:index_year&#125;-%&#123;INT:index_mouth&#125;-%&#123;INT:index_day&#125;&quot;</span>]&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mutate &#123;</span><br><span class="line">    <span class="comment"># 使用元数据 [@metadata][index_suffix]</span></span><br><span class="line">add_field =&gt; &#123; <span class="string">&quot;[@metadata][index_suffix]&quot;</span> =&gt; <span class="string">&quot;%&#123;index_year&#125;.%&#123;index_mouth&#125;.%&#123;index_day&#125;&quot;</span> &#125;</span><br><span class="line">        remove_field =&gt; [<span class="string">&quot;host&quot;</span>,<span class="string">&quot;beat&quot;</span>,<span class="string">&quot;tags&quot;</span>,<span class="string">&quot;[beat][name]&quot;</span>,<span class="string">&quot;[beat][version]&quot;</span>,<span class="string">&quot;prospector&quot;</span>,<span class="string">&quot;@version&quot;</span>,<span class="string">&quot;offset&quot;</span>,<span class="string">&quot;input&quot;</span>,<span class="string">&quot;y_index&quot;</span>,<span class="string">&quot;M_index&quot;</span>,<span class="string">&quot;d_index&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>输出时使用元数据, 该字段不会出现在es的字段中</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">elasticsearch &#123;</span><br><span class="line">        <span class="comment"># manage_template =&gt; false</span></span><br><span class="line">        template_overwrite =&gt; <span class="literal">true</span></span><br><span class="line">        template =&gt; <span class="string">&quot;/opt/export/app/logstash-6.4.2/bin/dynamic_templates.json&quot;</span></span><br><span class="line">        user =&gt; xxxxxxx</span><br><span class="line">        password =&gt; xxxxxxx</span><br><span class="line">        index =&gt; <span class="string">&quot;%&#123;sys_name&#125;-%&#123;[@metadata][index_suffix]&#125;&quot;</span></span><br><span class="line">        hosts =&gt; [<span class="string">&quot;xxxx:9200&quot;</span>,<span class="string">&quot;xxxx:9200&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> issue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ELK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>获取IP和byte转long遇到的小问题</title>
      <link href="2018/12/10/get-the-small-problem-encountered-by-ip-and-byte-to-long.html"/>
      <url>2018/12/10/get-the-small-problem-encountered-by-ip-and-byte-to-long.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>因为业务需求新项目的流水号系统从 ‘数据库自增步长+分段式锁’ 换成使用 <a href="https://github.com/liuzhihang/tool_demo/blob/master/src/main/java/com/ipaynow/tool/snowflake/SnowFlake.java">雪花流水号</a>, 修改机器标识和数据中心字段为自动获取ip后三位, 人工保证ip后三位不相同</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><a href="https://github.com/liuzhihang/tool_demo/blob/master/src/main/java/com/ipaynow/tool/snowflake/SnowFlakeSerial.java">雪花流水号 - 改造版</a></p><p>修改内容如下:<br>删除构造, 修改数据位数, 添加静态代码块</p><a id="more"></a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> MACHINE_BIT = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> DATA_CENTER_BIT = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        InetAddress localHost = InetAddress.getLocalHost();</span><br><span class="line">        address = localHost.getAddress()[<span class="number">3</span>] &amp; <span class="number">0xff</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前系统的 address 为: &quot;</span> + address);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;DATA_CENTER_ID can&#x27;t be greater than MAX_DATA_CENTER_NUM or less than 0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><h5 id="服务器配置host"><a href="#服务器配置host" class="headerlink" title="服务器配置host"></a>服务器配置host</h5><p>服务器对应的 hostname 需要配置ip地址</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /etc/hosts</span><br></pre></td></tr></table></figure><h5 id="byte-转换-long需要-amp-0xff"><a href="#byte-转换-long需要-amp-0xff" class="headerlink" title="byte 转换 long需要 &amp; 0xff"></a>byte 转换 long需要 &amp; 0xff</h5><p>当获取ip大于127时转换出来为负值, 所以需要 &amp; 0xff</p>]]></content>
      
      
      <categories>
          
          <category> issue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于LinkHashMap的LRU缓存淘汰</title>
      <link href="2018/11/19/elimination-of-lru-cache-based-on-linkhashmap.html"/>
      <url>2018/11/19/elimination-of-lru-cache-based-on-linkhashmap.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h5 id="LRU缓存淘汰"><a href="#LRU缓存淘汰" class="headerlink" title="LRU缓存淘汰"></a>LRU缓存淘汰</h5><p>LRU缓存淘汰是redis中的一种淘汰策略, 当内存大小不足以存放数据时, 此时存入新数据, 将删除较早存入的数据.<br>在dubbo中使用LRU来缓存 hostName.<br>在mysql中使用LRU来缓存 serverSideStatementCheckCache 和 serverSideStatementCache.</p><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ipaynow.tool.lru;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于LinkedHashMap LRU 缓存淘汰, 以下框架中都有使用</span></span><br><span class="line"><span class="comment"> * dubbo com.alibaba.dubbo.common.utils.LRUCache</span></span><br><span class="line"><span class="comment"> * com.mysql.jdbc.util.LRUCache</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuzhihang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/11/20 10:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRULinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置最大容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> maxCapacity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_CAPACITY = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRULinkedHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxCapacity = DEFAULT_MAX_CAPACITY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRULinkedHashMap</span><span class="params">(<span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// accessOrder设置为true 按照时间排序</span></span><br><span class="line">        <span class="keyword">super</span>(maxCapacity, DEFAULT_LOAD_FACTOR, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.maxCapacity = maxCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当链表长度大于最大容量时 删除最旧的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; maxCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.containsKey(key);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.get(key);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.put(key, value);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.remove(key);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.size();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">super</span>.clear();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> maxCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaxCapacity</span><span class="params">(<span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxCapacity = maxCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="测试代码及结果"><a href="#测试代码及结果" class="headerlink" title="测试代码及结果"></a>测试代码及结果</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ipaynow.tool.lru;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuzhihang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/11/20 10:58</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        LRULinkedHashMap&lt;String, String&gt; map = <span class="keyword">new</span> LRULinkedHashMap&lt;&gt;(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            map.put(LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss SSS&quot;</span>)), <span class="string">&quot;value&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = map.entrySet().iterator(); iterator.hasNext(); ) &#123;</span><br><span class="line">            Map.Entry&lt;String, String&gt; entry = iterator.next();</span><br><span class="line">            String key = entry.getKey();</span><br><span class="line">            String value = entry.getValue();</span><br><span class="line">            System.out.println(key + <span class="string">&quot;------------&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出结果:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2018-11-20 11:13:21 398------------value5</span><br><span class="line">2018-11-20 11:13:22 399------------value6</span><br><span class="line">2018-11-20 11:13:23 400------------value7</span><br><span class="line">2018-11-20 11:13:24 400------------value8</span><br><span class="line">2018-11-20 11:13:25 400------------value9</span><br><span class="line"></span><br><span class="line">Process finished with <span class="built_in">exit</span> code 0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
          <category> cache </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> cache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ELK常用启动命令</title>
      <link href="2018/10/29/elk-common-start-command.html"/>
      <url>2018/10/29/elk-common-start-command.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="elasticsearch启动命令"><a href="#elasticsearch启动命令" class="headerlink" title="elasticsearch启动命令"></a>elasticsearch启动命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 前台启动 关闭窗口连接后自动退出</span></span><br><span class="line">./bin/elasticsearch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后台启动</span></span><br><span class="line">./bin/elasticsearch  -d</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="logstash启动命令"><a href="#logstash启动命令" class="headerlink" title="logstash启动命令"></a>logstash启动命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 前台启动 -f 后面为配置文件</span></span><br><span class="line">./logstash -f logstash.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后台启动</span></span><br><span class="line">nohup ./logstash -f logstash.conf &amp;</span><br></pre></td></tr></table></figure><h4 id="kibana启动命令"><a href="#kibana启动命令" class="headerlink" title="kibana启动命令"></a>kibana启动命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 前台启动</span></span><br><span class="line">./bin/kibana</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后台启动</span></span><br><span class="line">./bin/kibana &amp;</span><br></pre></td></tr></table></figure><h5 id="kibana停止命令"><a href="#kibana停止命令" class="headerlink" title="kibana停止命令"></a>kibana停止命令</h5><p>当ps -ef | grep kibana 查不到时 可以<br>lsof -i:5601<br>kill -9 线程</p><h4 id="filebeat启动命令"><a href="#filebeat启动命令" class="headerlink" title="filebeat启动命令"></a>filebeat启动命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 前台启动</span></span><br><span class="line">./filebeat -e -c filebeat.yml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后台启动 不输出日志/输出日志</span></span><br><span class="line">nohup ./filebeat -e -c filebeat.yml &gt;/dev/null 2&gt;&amp;1 &amp;</span><br><span class="line">nohup ./filebeat -e -c filebeat.yml &gt; filebeat.log &amp;</span><br></pre></td></tr></table></figure><h5 id="jar包启动命令"><a href="#jar包启动命令" class="headerlink" title="jar包启动命令"></a>jar包启动命令</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 前台启动</span></span><br><span class="line">java -jar server.ja</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后台启动</span></span><br><span class="line">nohup java -jar server.jar &amp;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ELK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ELK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>search-guard-6 配置用户</title>
      <link href="2018/10/24/searchguard6-configuration-user.html"/>
      <url>2018/10/24/searchguard6-configuration-user.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="search-guard-配置用户"><a href="#search-guard-配置用户" class="headerlink" title="search-guard 配置用户"></a>search-guard 配置用户</h4><p>路径: /opt/export/app/elasticsearch-6.4.2/plugins/search-guard-6/sgconfig</p><h5 id="生成密码"><a href="#生成密码" class="headerlink" title="生成密码"></a>生成密码</h5><p>执行以下命令, 输入明文</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">plugins/search-guard-6/tools/hasher.sh -p mycleartextpassword</span><br></pre></td></tr></table></figure><a id="more"></a><h5 id="1-配置用户及密码"><a href="#1-配置用户及密码" class="headerlink" title="1. 配置用户及密码"></a>1. 配置用户及密码</h5><p>文件: sg_internal_users.yml</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">zhangsan:</span></span><br><span class="line">  <span class="attr">hash:</span> <span class="string">$2y$12$yKXk785zSTtB3kE7g.XnbOPrc690g9JE50Znwum924i2M/xYGG4qq</span></span><br><span class="line">  <span class="attr">roles:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">trans_group</span></span><br></pre></td></tr></table></figure><p>格式:</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">姓名:</span></span><br><span class="line">  <span class="string">密码:</span> <span class="string">XXXX(明文的hash,</span> <span class="string">使用search-guard的工具生成)</span></span><br><span class="line">  <span class="string">角色:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">角色名称</span></span><br></pre></td></tr></table></figure><h5 id="2-配置权限"><a href="#2-配置权限" class="headerlink" title="2. 配置权限"></a>2. 配置权限</h5><p>文件: sg_roles.xml</p><p>配置’?kibana’ 及’?kibana-6’ 权限是为了保证用户在kibana中能够正常使用kibana</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">sg_trans_group:</span></span><br><span class="line">  <span class="attr">cluster:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">cluster:monitor/nodes</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">cluster:monitor/health</span></span><br><span class="line">  <span class="attr">indices:</span></span><br><span class="line">    <span class="attr">&#x27;log-system&#x27;:</span></span><br><span class="line">      <span class="string">&#x27;*&#x27;</span><span class="string">:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">indices:admin/mappings/fields/get</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">indices:admin/validate/query</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">indices:data/read/search</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">indices:data/read/msearch</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">indices:admin/get</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">indices:data/read/field_stats</span></span><br><span class="line">    <span class="string">&#x27;?kibana&#x27;</span><span class="string">:</span></span><br><span class="line">      <span class="string">&#x27;*&#x27;</span><span class="string">:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">MANAGE</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">INDEX</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">READ</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">DELETE</span></span><br><span class="line">    <span class="string">&#x27;?kibana-6&#x27;</span><span class="string">:</span></span><br><span class="line">      <span class="string">&#x27;*&#x27;</span><span class="string">:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">MANAGE</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">INDEX</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">READ</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">DELETE</span></span><br></pre></td></tr></table></figure><p>格式:</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">权限名称:</span></span><br><span class="line">  <span class="string">集群:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">集群名称:权限</span></span><br><span class="line">  <span class="string">索引:</span></span><br><span class="line">    <span class="string">&#x27;索引名称&#x27;</span><span class="string">:</span></span><br><span class="line">      <span class="string">&#x27;类型&#x27;</span><span class="string">:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">权限</span></span><br></pre></td></tr></table></figure><h5 id="3-配置角色映射"><a href="#3-配置角色映射" class="headerlink" title="3. 配置角色映射"></a>3. 配置角色映射</h5><p>文件: sg_roles_mapping.yml</p><p>配置完用户的账户密码, 以及相应角色权限之后, 需要将用户和权限进行关联, 关联之后即可使用</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">sg_trans_group:</span></span><br><span class="line">   <span class="attr">backendroles:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">trans_group</span></span><br></pre></td></tr></table></figure><p>格式:</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">映射名称:</span></span><br><span class="line">  <span class="string">角色:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">用户的角色</span></span><br></pre></td></tr></table></figure><p>也可以使用以下方式进行关联:</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">sg_trans_group:</span></span><br><span class="line">   <span class="attr">users:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">zhangsan</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">lisi</span></span><br><span class="line"><span class="comment"># 即</span></span><br><span class="line"><span class="string">映射名称:</span></span><br><span class="line">  <span class="string">用户名称:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">用户名</span></span><br></pre></td></tr></table></figure><h5 id="4-使配置生效"><a href="#4-使配置生效" class="headerlink" title="4. 使配置生效"></a>4. 使配置生效</h5><p>使用以下命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./sgadmin.sh -cn 集群名称 -<span class="built_in">cd</span> ../sgconfig -ks ../../../config/sgadmin-keystore.jks -kspass changeit -ts ../../../config/truststore.jks -tspass changeit -nhnv</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ELK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ELK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>search-guard-6 安装</title>
      <link href="2018/10/23/searchguard6-installation.html"/>
      <url>2018/10/23/searchguard6-installation.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="ES-安装-search-guard-6"><a href="#ES-安装-search-guard-6" class="headerlink" title="ES 安装 search-guard-6"></a>ES 安装 search-guard-6</h4><h6 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h6><p>☞ <a href="https://docs.search-guard.com/latest/demo-installer">官方网站</a><br>在ES目录下执行命令</p><pre><code>bin/elasticsearch-plugin install -b com.floragunn:search-guard-6:6.4.2-23.1</code></pre><p>注: 安装版本需要和Elasticsearch版本相对应. <a href="https://docs.search-guard.com/latest/search-guard-versions">查看版本</a></p><p>这里不使用官方的快速构建方法</p><a id="more"></a><h6 id="生成证书"><a href="#生成证书" class="headerlink" title="生成证书"></a>生成证书</h6><ol><li><p>下载脚本<br> <code>git clone https://github.com/floragunncom/search-guard-ssl.git</code></p></li><li><p>证书配置<br> 路径<br> <code>**/elasticsearch-6.4.2/search-guard-ssl/example-pki-scripts</code></p><p> 目录内容 etc下可对证书进行配置<br> <img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="/resources/image/elk/configuration.png" alt="证书配置"></p></li><li><p>修改<a href="search-guard-ssl/example-pki-scripts/example.sh">example.sh</a></p></li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">OPENSSL_VER=<span class="string">&quot;<span class="subst">$(openssl version)</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$OPENSSL_VER</span> == *<span class="string">&quot;0.9&quot;</span>* ]]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Your OpenSSL version is too old: <span class="variable">$OPENSSL_VER</span>&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Please install version 1.0.1 or later&quot;</span></span><br><span class="line">        <span class="built_in">exit</span> -1</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Your OpenSSL version is: <span class="variable">$OPENSSL_VER</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line">./clean.sh</span><br><span class="line"><span class="comment"># 第一个参数为CA根证书密码，第二个参数为TS密码(truststore，信任证书密码)</span></span><br><span class="line">./gen_root_ca.sh capass changeit</span><br><span class="line"><span class="comment"># 生成节点证书： 第一个参数为节点编号，第二个参数为keystore文件密码，第三个参数为CA根证书密码。</span></span><br><span class="line"><span class="comment"># 此处我们只生成两个节点证书</span></span><br><span class="line">./gen_node_cert.sh 0 changeit capass &amp;&amp; ./gen_node_cert.sh 1 changeit capass</span><br><span class="line"><span class="comment"># 生成客户端证书： 第一个参数为客户端名称, 第二个参数为keystore文件名称，第三个参数为CA根证书名称。</span></span><br><span class="line">./gen_client_node_cert.sh spock changeit capass</span><br><span class="line">./gen_client_node_cert.sh kirk changeit capass</span><br><span class="line">./gen_client_node_cert.sh logstash changeit capass</span><br><span class="line">./gen_client_node_cert.sh filebeat changeit capass</span><br><span class="line">./gen_client_node_cert.sh kibana changeit capass</span><br><span class="line"><span class="comment"># 生成一个sgadmin客户端证书，用于配置管理</span></span><br><span class="line">./gen_client_node_cert.sh sgadmin changeit capass</span><br><span class="line"><span class="comment"># 生成一个javaapi访问的客户端证书</span></span><br><span class="line">./gen_client_node_cert.sh javaapi changeit capass</span><br><span class="line">rm -f ./*tmp*</span><br></pre></td></tr></table></figure><ol start="4"><li>生成证书移动到elasticsearch config 在ES目录下</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./example.sh</span><br><span class="line">cp node-0-keystore.jks sgadmin-keystore.jks truststore.jks /opt/<span class="built_in">export</span>/app/elasticsearch-6.4.2/config/</span><br></pre></td></tr></table></figure><ol start="5"><li>配置elasticsearch.yml, 增加以下配置</li></ol><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置节点间通信证书，节点间通信使用TLS是强制的</span></span><br><span class="line"><span class="attr">searchguard.ssl.transport.keystore_filepath:</span> <span class="string">node-0-keystore.jks</span></span><br><span class="line"><span class="attr">searchguard.ssl.transport.keystore_password:</span> <span class="string">changeit</span></span><br><span class="line"><span class="attr">searchguard.ssl.transport.truststore_filepath:</span> <span class="string">truststore.jks</span></span><br><span class="line"><span class="attr">searchguard.ssl.transport.truststore_password:</span> <span class="string">changeit</span></span><br><span class="line"><span class="comment"># 设置不校验hostname</span></span><br><span class="line"><span class="attr">searchguard.ssl.transport.enforce_hostname_verification:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">searchguard.ssl.transport.resolve_hostname:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment"># 配置管理员证书DN</span></span><br><span class="line"><span class="attr">searchguard.authcz.admin_dn:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">CN=sgadmin,OU=client,O=client,L=Test,</span> <span class="string">C=DE</span></span><br><span class="line"></span><br><span class="line"><span class="attr">bootstrap.memory_lock:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">bootstrap.system_call_filter:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">xpack.security.enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><ol start="6"><li>启动访问需要权限</li></ol><h6 id="添加脚本权限并初始化用户"><a href="#添加脚本权限并初始化用户" class="headerlink" title="添加脚本权限并初始化用户"></a>添加脚本权限并初始化用户</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/<span class="built_in">export</span>/app/elasticsearch-6.4.2/plugins/search-guard-6/tools</span><br><span class="line">chmod +x *.sh</span><br><span class="line">./sgadmin.sh -cn cluster-es -<span class="built_in">cd</span> ../sgconfig -ks ../../../config/sgadmin-keystore.jks -kspass changeit -ts ../../../config/truststore.jks -tspass changeit -nhnv</span><br></pre></td></tr></table></figure><p>每次更新用户权限或者新增修改用户, 只需要重新执行第三条命令, 更新用户信息即可</p><h4 id="Kibana安装"><a href="#Kibana安装" class="headerlink" title="Kibana安装"></a>Kibana安装</h4><p>参照官方网站安装配置即可. <a href="https://docs.search-guard.com/latest/demo-installer">官方网站</a>, 或者按照以下步骤.</p><ol><li>在kibana安装目录下执行一下吗命令</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/kibana-plugin install https://search.maven.org/remotecontent?filepath=com/floragunn/search-guard-kibana-plugin/6.4.2-15/search-guard-kibana-plugin-6.4.2-15.zip</span><br></pre></td></tr></table></figure><ol start="2"><li>修改kibana.yml</li></ol><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Use HTTPS instead of HTTP</span></span><br><span class="line"><span class="comment"># elasticsearch.url: &quot;https://localhost:9200&quot;</span></span><br><span class="line"><span class="attr">elasticsearch.url:</span> <span class="string">&quot;http://localhost:9200&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Configure the Kibana internal server user</span></span><br><span class="line"><span class="attr">elasticsearch.username:</span> <span class="string">&quot;kibanaserver&quot;</span></span><br><span class="line"><span class="attr">elasticsearch.password:</span> <span class="string">&quot;kibanaserver&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Disable SSL verification because we use self-signed demo certificates</span></span><br><span class="line"><span class="attr">elasticsearch.ssl.verificationMode:</span> <span class="string">none</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Whitelist the Search Guard Multi Tenancy Header</span></span><br><span class="line"><span class="attr">elasticsearch.requestHeadersWhitelist:</span> [ <span class="string">&quot;Authorization&quot;</span>, <span class="string">&quot;sgtenant&quot;</span> ]</span><br></pre></td></tr></table></figure><ol start="3"><li>打开对应域名登录<br><code>http://localhost:5601/</code></li></ol><h4 id="注"><a href="#注" class="headerlink" title="注:"></a>注:</h4><p>以上内容为参考自<a href="https://www.jianshu.com/u/d58afc984a4f">M醉逍遥</a>, 并搭建成功后总结记录, 以作备忘. 链接如下:<br><a href="https://www.jianshu.com/p/319913a944af">https://www.jianshu.com/p/319913a944af</a></p>]]></content>
      
      
      <categories>
          
          <category> ELK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ELK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo搭建博客</title>
      <link href="2018/10/08/hexo-build-blog.html"/>
      <url>2018/10/08/hexo-build-blog.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="安装node"><a href="#安装node" class="headerlink" title="安装node"></a>安装node</h3><p>下载地址: <a href="https://nodejs.org/en/">https://nodejs.org</a></p><p>查看当前版本: node -v</p><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="/resources/hexo/node-v.png" alt="node-v"></p><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><pre><code>npm install</code></pre><p>也可以使用<a href="https://npm.taobao.org/">淘宝镜像</a></p><pre><code>npm install -g cnpm --registry=https://registry.npm.taobao.orgcnpm install hexo</code></pre><a id="more"></a><h3 id="hexo常用命令"><a href="#hexo常用命令" class="headerlink" title="hexo常用命令"></a>hexo常用命令</h3><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><pre><code>hexo init</code></pre><h5 id="清除缓存"><a href="#清除缓存" class="headerlink" title="清除缓存"></a>清除缓存</h5><pre><code>hexo clean</code></pre><h5 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h5><pre><code>hexo ghexo generate</code></pre><h5 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h5><pre><code>hexo shexo server</code></pre><h5 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h5><pre><code>hexo dhexo deploy</code></pre><h5 id="生成并部署"><a href="#生成并部署" class="headerlink" title="生成并部署"></a>生成并部署</h5><pre><code>hexo g -d</code></pre>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器cpu占用率高</title>
      <link href="2018/09/25/server-cpu-occupancy-rate-is-high.html"/>
      <url>2018/09/25/server-cpu-occupancy-rate-is-high.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-top-命令找到占用cpu最高的进程"><a href="#1-top-命令找到占用cpu最高的进程" class="headerlink" title="1. top 命令找到占用cpu最高的进程"></a>1. top 命令找到占用cpu最高的进程</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">top - 14:37:14 up 34 days, 13:27,  2 users,  load average: 0.21, 0.29, 0.29</span><br><span class="line">Tasks: 151 total,   1 running, 150 sleeping,   0 stopped,   0 zombie</span><br><span class="line">Cpu(s):  4.4%us,  2.7%sy,  0.0%ni, 90.9%id,  0.5%wa,  0.0%hi,  0.2%si,  1.3%st</span><br><span class="line">Mem:  16334064k total, 16171240k used,   162824k free,    16716k buffers</span><br><span class="line">Swap: 16383996k total,  4470816k used, 11913180k free,   539788k cached</span><br><span class="line"></span><br><span class="line">PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND</span><br><span class="line">1818 tomcat    20   0 3643m 983m 7548 S  0.7 24.8 190:40.13 java</span><br><span class="line"></span><br></pre></td></tr></table></figure><a id="more"></a><p>字段解释:<br>top - 时间 运行时间 用户 系统负载<br>Tasks: 进程相关信息<br>Cpu(s): cpu相关信息<br>Mem: 内存相关<br>Swap: 交换区相关信息</p><p>进程相关信息<br>PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND</p><h3 id="2-使用top-H-p-查看该进程内所有线程"><a href="#2-使用top-H-p-查看该进程内所有线程" class="headerlink" title="2. 使用top -H -p  查看该进程内所有线程"></a>2. 使用top -H -p <pid> 查看该进程内所有线程</h3><p>top -H -p 1818</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND</span><br><span class="line">6656 tomcat    20   0 4193m 608m  11m R 21.0  3.8   1419:44 java</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-printf-“-x-n”-将10进制线程号转换为16进制结果"><a href="#3-printf-“-x-n”-将10进制线程号转换为16进制结果" class="headerlink" title="3. printf “%x\n”  将10进制线程号转换为16进制结果"></a>3. printf “%x\n” <pid> 将10进制线程号转换为16进制结果</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[liuzhihang@test08 ~]$ <span class="built_in">printf</span> <span class="string">&quot;%x\n&quot;</span> 1876</span><br><span class="line">754</span><br><span class="line">[liuzhihang@test08 ~]$</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-jstack-grep"><a href="#4-jstack-grep" class="headerlink" title="4. jstack  |grep "></a>4. jstack <pid> |grep <tid></h3><p>jstack 1818 | grep 754 -A 30</p><p>pid 为第一次执行top命令时的 pid<br>tid 为将第二次的pid进行十六进制转换后的结果</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;catalina-8180-89&quot;</span> <span class="comment">#1842 daemon prio=5 os_prio=0 tid=0x00007f4ec4096000 nid=0x5d96 waiting on condition [0x00007f4e87545000]</span></span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">- parking to <span class="built_in">wait</span> <span class="keyword">for</span>  &lt;0x00000000f418f898&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer<span class="variable">$ConditionObject</span>)</span><br><span class="line">at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer<span class="variable">$ConditionObject</span>.await(AbstractQueuedSynchronizer.java:2039)</span><br><span class="line">at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)</span><br><span class="line">at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:104)</span><br><span class="line">at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:32)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1074)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1134)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor<span class="variable">$Worker</span>.run(ThreadPoolExecutor.java:624)</span><br><span class="line">at org.apache.tomcat.util.threads.TaskThread<span class="variable">$WrappingRunnable</span>.run(TaskThread.java:61)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;catalina-8180-88&quot;</span> <span class="comment">#1841 daemon prio=5 os_prio=0 tid=0x00007f4eb848e800 nid=0x5d94 waiting on condition [0x00007f4e8bd8b000]</span></span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">at sun.misc.Unsafe.park(Native Method)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> issue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> issue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>final finally finalize区别</title>
      <link href="2018/09/06/final-finally-finalize-difference.html"/>
      <url>2018/09/06/final-finally-finalize-difference.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>final为java关键字, 可以作用于成员变量、方法、类上<br>1.作用于成员变量上, 基本类型则值不可修改, 如果成员变量为对象, 则该对象的引用不可修改.<br>2.作用于方法, 该方法不可被重写<br>3.作用于类, 该类不可继承</p><a id="more"></a><h3 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h3><p>异常处理的关键字, 无论异常是否发生, finally内逻辑总会执行.</p><h4 id="finally-和-return-的执行顺序"><a href="#finally-和-return-的执行顺序" class="headerlink" title="finally 和 return 的执行顺序"></a>finally 和 return 的执行顺序</h4><p>1.一般使用逻辑, return在try-catch-finally之后, 证明, 无论是否异常, finally都会执行</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(finallyTest());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">finallyTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;处理逻辑&quot;</span>);</span><br><span class="line">            <span class="comment">// int i = 1 / 0;</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;异常逻辑&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally执行了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;最终return返回&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.在try/catch内添加return<br>try/catch内的return执行完后会继续执行finally, 但是从打印结果来开, finally的语句先打印, 原因是因为 return的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(finallyTest());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">finallyTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;处理逻辑&quot;</span>);</span><br><span class="line">            <span class="comment">// int i = 1 / 0;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;try - return返回&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;异常逻辑&quot;</span>);</span><br><span class="line">            <span class="comment">// return &quot;catch - return返回&quot;;</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally执行了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;最终return返回&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">处理逻辑</span><br><span class="line">finally执行了</span><br><span class="line">try - <span class="built_in">return</span>返回</span><br></pre></td></tr></table></figure><p>3.finally里面添加return语句<br>finally里面return执行完后会直接返回, 不会再执行try块中的return语句</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(finallyTest());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">finallyTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;处理逻辑&quot;</span>);</span><br><span class="line">            <span class="comment">// int i = 1 / 0;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;try - return返回&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;异常逻辑&quot;</span>);</span><br><span class="line">            <span class="comment">// return &quot;catch - return返回&quot;;</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally执行了&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;finally - return返回&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// return &quot;最终return返回&quot;;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">处理逻辑</span><br><span class="line">finally执行了</span><br><span class="line">finally - <span class="built_in">return</span>返回</span><br></pre></td></tr></table></figure><p>4.finally内添加逻辑改变变量值<br>1).try中的return值只是暂时放在栈中, 所以最终返回的还是 10, finally中并没有改变其值<br>2).try中的return值如果是对象, 栈中存放的是对象的引用, 对象属性值还是可以通过finally修改</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(finallyTest());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">finallyTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;处理逻辑&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;try - return返回: &quot;</span> + temp;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;异常逻辑&quot;</span>);</span><br><span class="line">            <span class="comment">// return &quot;catch - return返回&quot;;</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            temp = <span class="number">100</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally执行了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;最终return返回: &quot;</span> + temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">处理逻辑</span><br><span class="line">finally执行了</span><br><span class="line">try - <span class="built_in">return</span>返回: 10</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Temp temp = <span class="keyword">new</span> Temp();</span><br><span class="line">        temp.temp = <span class="number">1</span>;</span><br><span class="line">        System.out.println(finallyTest(temp).toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Temp <span class="title">finallyTest</span><span class="params">(Temp temp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;处理逻辑&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;异常逻辑&quot;</span>);</span><br><span class="line">            <span class="comment">// return &quot;catch - return返回&quot;;</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            temp.temp = <span class="number">100</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally执行了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Temp&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;temp=&quot;</span> + temp +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">处理逻辑</span><br><span class="line">finally执行了</span><br><span class="line">Temp&#123;temp=100&#125;</span><br></pre></td></tr></table></figure><h3 id="finalize方法"><a href="#finalize方法" class="headerlink" title="finalize方法"></a>finalize方法</h3><p>Object类的方法, 子类可重写, 主要是垃圾回收时使用.</p>]]></content>
      
      
      <categories>
          
          <category> 源码学习 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池原理及源码解析</title>
      <link href="2018/09/05/thread-pool-principle-and-source-code-analysis.html"/>
      <url>2018/09/05/thread-pool-principle-and-source-code-analysis.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="线程池处理流程"><a href="#线程池处理流程" class="headerlink" title="线程池处理流程"></a>线程池处理流程</h3><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="/resources/concurrent/thread-pool.png" alt="线程池处理流程"></p><ol><li>判断核心线程池是否已满, 不满则创建新线程执行任务</li><li>等待队列如果有界, 判断等待队列是否已满, 不满, 则添加任务到等待队列</li><li>判断最大线程数是否已满, 不满则创建新线程执行任务</li><li>最大线程数已满, 按照既定策略处理新任务<a id="more"></a><h3 id="全参构造及各参数含义"><a href="#全参构造及各参数含义" class="headerlink" title="全参构造及各参数含义"></a>全参构造及各参数含义</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, // 核心线程数</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize, // 最大线程数</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime, // 核心线程外线程的存活时间</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit, // 存活时间的单位</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue, // 保存等待执行的线程的阻塞队列</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory, // 线程工厂</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span> </span>&#123; <span class="comment">// 线程拒绝策略</span></span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">                <span class="keyword">null</span> :</span><br><span class="line">                AccessController.getContext();</span><br><span class="line">        <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">        <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">        <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略 . . .</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>workQueue阻塞队列<br>ArrayBlockingQueue: 是一个基于数组结构的有界阻塞队列, 此队列按 FIFO(先进先出) 原则对元素进行排序.<br>LinkedBlockingQueue: 一个基于链表结构的阻塞队列,此队列按 FIFO(先进先出) 排序元素, 吞吐量通常要高于ArrayBlockingQueue. 静态工厂方法Executors.newFixedThreadPool()使用了这个队列<br>SynchronousQueue: 一个不存储元素的阻塞队列. 每个插入操作必须等到另一个线程调用移除操作, 否则插入操作一直处于阻塞状态, 吞吐量通常要高于LinkedBlockingQueue, 静态工厂方法Executors.newCachedThreadPool使用了这个队列.<br>PriorityBlockingQueue: 一个具有优先级的无限阻塞队列.</li></ol><p>2.threadFactory线程工厂<br>可以使用默认的工厂也可以自定义工厂, 或者使用 google guava 提供的工厂, 可以为线程命名和设置是否为守护线程</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 默认工厂</span><br><span class="line">ThreadFactory threadFactory = Executors.defaultThreadFactory();</span><br><span class="line">// google guava工具提供</span><br><span class="line">ThreadFactory namedThreadFactory = new ThreadFactoryBuilder().setNameFormat(<span class="string">&quot;demo-pool-%d&quot;</span>).build();</span><br></pre></td></tr></table></figure><p>3.handler线程拒绝策略<br>当线程池达到最大线程数, 并且队列满了, 新的线程要采取的处理策略.<br>1.AbortPolicy 拒绝新任务并抛出RejectedExecutionException异常<br>2.CallerRunsPolicy 直接在调用程序的线程中运行<br>3.DiscardOldestPolicy 放弃最早的任务, 即队列最前面的任务<br>4.DiscardPolicy 丢弃, 不处理</p><h3 id="Executors初始化线程池的四种方式"><a href="#Executors初始化线程池的四种方式" class="headerlink" title="Executors初始化线程池的四种方式"></a>Executors初始化线程池的四种方式</h3><p>这四种初始化线程池的方式, 前三种都是调用 ThreadPoolExecutor 类的构造创建的线程池, 只不过使用的阻塞队列方式不同.</p><ol><li>newFixedThreadPool()</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Executors</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 固定线程池</span></span><br><span class="line"><span class="comment">     * 核心线程数 = 最大线程数</span></span><br><span class="line"><span class="comment">     * 超时时间为0</span></span><br><span class="line"><span class="comment">     * LinkedBlockingQueue无界队列, 会持续等待</span></span><br><span class="line"><span class="comment">     * 使用默认拒绝策略 AbortPolicy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>newCachedThreadPool()</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Executors</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无界线程池</span></span><br><span class="line"><span class="comment">     * 核心线程数0 最大线程数 (2³¹ -1)</span></span><br><span class="line"><span class="comment">     * 超时时间 60秒</span></span><br><span class="line"><span class="comment">     * SynchronousQueue不存储元素的阻塞队列</span></span><br><span class="line"><span class="comment">     * 线程空闲时间超过60秒, 会自动释放资源, 提交任务如果没有空闲线程, 则会创建新线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                         <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                         <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.newSingleThreadExecutor()</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Executors</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建只有 1个线程的线程池</span></span><br><span class="line"><span class="comment">     * 如果线程异常, 则创建一个新的线程继续执行任务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.newSingleThreadExecutor()</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Executors</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ScheduledThreadPoolExecutor 继承 ThreadPoolExecutor 类</span></span><br><span class="line"><span class="comment">     * 可以在指定时间周期内执行任务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * ctx 为原子类型的变量, 有两个概念</span></span><br><span class="line"><span class="comment">    * workerCount, 表示有效的线程数</span></span><br><span class="line"><span class="comment">    * runState, 表示线程状态, 是否正在运行, 关闭等</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 29</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 容量 2²⁹-1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// runState is stored in the high-order bits 线程池的五中状态</span></span><br><span class="line">    <span class="comment">// 即高3位为111, 接受新任务并处理排队任务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">    <span class="comment">// 即高3位为000, 不接受新任务, 但处理排队任务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">    <span class="comment">// 即高3位为001, 不接受新任务, 不处理排队任务, 并中断正在进行的任务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">    <span class="comment">// 即高3位为010, 所有任务都已终止, 工作线程为0, 线程转换到状态TIDYING, 将运行terminate()钩子方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">    <span class="comment">// 即高3位为011, 标识terminate（）已经完成</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">    <span class="comment">// Packing and unpacking ctl 用来计算线程的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="execute方法"><a href="#execute方法" class="headerlink" title="execute方法"></a>execute方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 空则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">// 获取当前线程池的状态</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="comment">// 计算工作线程数 并判断是否小于核心线程数</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            <span class="comment">// addWorker提交任务, 提交成功则结束</span></span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">// 提交失败再次获取当前状态</span></span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断线程状态, 并插入队列, 失败则移除</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="comment">// 再次获取状态</span></span><br><span class="line">            <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">            <span class="comment">// 如果状态不是RUNNING, 并移除失败</span></span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                <span class="comment">// 调用拒绝策略</span></span><br><span class="line">                reject(command);</span><br><span class="line">            <span class="comment">// 如果工作线程为0 则调用 addWorker</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 提交任务失败 走拒绝策略</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="addWorker方法"><a href="#addWorker方法" class="headerlink" title="addWorker方法"></a>addWorker方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查任务是否可以提交</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">        retry:</span><br><span class="line">        <span class="comment">// 外层循环</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取当前状态</span></span><br><span class="line">            <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">            <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check if queue empty only if necessary. 检查线程池是否关闭</span></span><br><span class="line">            <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">                ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                   firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                   ! workQueue.isEmpty()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 内层循环</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">                <span class="comment">// 工作线程大于容量 或者大于 核心或最大线程数</span></span><br><span class="line">                <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                    wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// CAS 线程数增加, 成功则调到外层循环</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                    <span class="keyword">break</span> retry;</span><br><span class="line">                <span class="comment">// 失败则再次获取线程状态</span></span><br><span class="line">                c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">                <span class="comment">// 不相等则重新走外层循环</span></span><br><span class="line">                <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                    <span class="keyword">continue</span> retry;</span><br><span class="line">                <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建新worker 开始新线程</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">        Worker w = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">            <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">                <span class="comment">// 加锁</span></span><br><span class="line">                mainLock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                    <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                    <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                    <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                        (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                        <span class="comment">// 判断线程是否存活, 已存活抛出非法异常</span></span><br><span class="line">                        <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                        <span class="comment">//  设置包含池中的所有工作线程。仅在持有mainLock时访问 workers是 HashSet 集合</span></span><br><span class="line">                        <span class="comment">//  private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;();</span></span><br><span class="line">                        workers.add(w);</span><br><span class="line">                        <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                        <span class="comment">// 设置池最大大小, 并将 workerAdded设置为 true</span></span><br><span class="line">                        <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                            largestPoolSize = s;</span><br><span class="line">                        workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 解锁</span></span><br><span class="line">                    mainLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 添加成功 开始启动线程 并将 workerStarted 设置为 true</span></span><br><span class="line">                <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                    t.start();</span><br><span class="line">                    workerStarted = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 启动线程失败</span></span><br><span class="line">            <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">                addWorkerFailed(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> workerStarted;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动线程失败, 加锁</span></span><br><span class="line"><span class="comment">     * 移除线程, 并减少线程总数</span></span><br><span class="line"><span class="comment">     * 转换状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addWorkerFailed</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (w != <span class="keyword">null</span>)</span><br><span class="line">                workers.remove(w);</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            tryTerminate();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 并发和锁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程相关</title>
      <link href="2018/09/04/multithreaded-correlation.html"/>
      <url>2018/09/04/multithreaded-correlation.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>多个线程同时或交替运行, 单核CPU为顺序执行(交替执行), 多核情况下, 每个CPU有自己的运算器, 所以在多个CPU中可以同时运行.</p><a id="more"></a><h3 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h3><p>1.继承Thread</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        myThread.setName(<span class="string">&quot;测试&quot;</span>);</span><br><span class="line">        myThread.start();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>开始线程, 可以看出main线程和测试线程是两个独立的线程<br>调用myThread.run();方法相当于直接在主线程运行run方法, 而不是开启一个新的线程去执行</p><p>2.实现Runnable接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        MyRunable runable = <span class="keyword">new</span> MyRunable();</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(runable);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.使用线程池<br>3.1 可以在spring中配置相关线程池, 使用时从容器取出即可, 也可以自己声明线程池</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;threadPool&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 核心线程数，默认为1 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;corePoolSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;5&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 最大线程数，默认为Integer.MAX_VALUE --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 队列最大长度，一般需要设置值&gt;=notifyScheduledMainExecutor.maxNum；默认为Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment">    &lt;property name=&quot;queueCapacity&quot; value=&quot;1000&quot; /&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 线程池维护线程所允许的空闲时间，默认为60s --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;keepAliveSeconds&quot;</span> <span class="attr">value</span>=<span class="string">&quot;300&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 队列最大长度 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;queueCapacity&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2000&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 线程池对拒绝任务（无线程可用）的处理策略，目前只支持AbortPolicy、CallerRunsPolicy；默认为后者 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;rejectedExecutionHandler&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- AbortPolicy:直接抛出java.utils.concurrent.RejectedExecutionException异常 --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- CallerRunsPolicy:主线程直接执行该任务，执行完之后尝试添加下一个任务到线程池中，可以有效降低向线程池内添加任务的速度 --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- DiscardOldestPolicy:抛弃旧的任务、暂不支持；会导致被丢弃的任务无法再次被执行 --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- DiscardPolicy:抛弃当前任务、暂不支持；会导致被丢弃的任务无法再次被执行 --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;java.util.concurrent.ThreadPoolExecutor$CallerRunsPolicy&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3.2 Executors 创建线程池</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService threadPool = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> MyRunable());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当手动创建线程池时, 如果IDEA安装阿里 P3C 插件后会报错提示以下内容, 建议</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</span><br><span class="line">说明： Executors 返回的线程池对象的弊端如下：</span><br><span class="line">1） FixedThreadPool 和 SingleThreadPool:</span><br><span class="line">允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。</span><br><span class="line">2） CachedThreadPool 和 ScheduledThreadPool:</span><br><span class="line">允许的创建线程数量为 Integer.MAX_VALUE， 可能会创建大量的线程，从而导致 OOM。</span><br></pre></td></tr></table></figure><p>建议使用如下方式:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定时任务 建议为线程起名</span></span><br><span class="line">        ScheduledExecutorService executorService = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">3</span>,</span><br><span class="line">                <span class="keyword">new</span> BasicThreadFactory.Builder().namingPattern(<span class="string">&quot;example-schedule-pool-%d&quot;</span>).build());</span><br><span class="line">            executorService.scheduleAtFixedRate(<span class="keyword">new</span> MyRunable(), <span class="number">0</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程工厂</span></span><br><span class="line">        ThreadFactory namedThreadFactory = <span class="keyword">new</span> ThreadFactoryBuilder()</span><br><span class="line">                .setNameFormat(<span class="string">&quot;demo-pool-%d&quot;</span>).build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Common Thread Pool</span></span><br><span class="line">        ExecutorService pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">20</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">1024</span>), namedThreadFactory, <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">        pool.execute(()-&gt; System.out.println(Thread.currentThread().getName()));</span><br><span class="line">        pool.shutdown();<span class="comment">//gracefully shutdown</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><p>1.myThread.setPriority(1);设置优先级<br>2.优先级从低到高为 1-10, Thread类提供 Thread.MIN_PRIORITY=1, Thread.NORM_PRIORITY=5, Thread.MAX_PRIORITY=10<br>3.默认优先级为 5 即 NORM_PRIORITY<br>4.优先级高的仅代表获取进入运行机会的几率大, 并不代表一定会比优先级低的先执行</p><h3 id="sleep-和wait"><a href="#sleep-和wait" class="headerlink" title="sleep()和wait()"></a>sleep()和wait()</h3><p>1.sleep()线程未释放锁, 时间结束后线程继续执行<br>2.wait线程释放锁, 需要使用notify或notifyAll<br>3.wait常用于线程之间的交互</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuzhihang.tool.alternate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 交替打印奇偶数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuzhihang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/9/4 18:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AlternateNum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Num num = <span class="keyword">new</span> Num();</span><br><span class="line"></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Odd(num));</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Even(num));</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Num</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> anInt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Odd</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Num num;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Odd</span><span class="params">(Num num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (num.anInt &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">            <span class="comment">// 使用同一把锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (num) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num.flag) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;奇数 -&gt; &quot;</span> + num.anInt);</span><br><span class="line">                    num.anInt++;</span><br><span class="line">                    num.flag = <span class="keyword">false</span>;</span><br><span class="line">                    num.notify();</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        num.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Even</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Num num;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Even</span><span class="params">(Num num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (num.anInt &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">            <span class="comment">// 使用同一把锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (num) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!num.flag) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;偶数 -&gt; &quot;</span> + num.anInt);</span><br><span class="line">                    num.anInt++;</span><br><span class="line">                    num.flag = <span class="keyword">true</span>;</span><br><span class="line">                    num.notify();</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        num.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 并发和锁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射和序列化破解单例</title>
      <link href="2018/08/27/reflection-and-serialization-cracking-singleton.html"/>
      <url>2018/08/27/reflection-and-serialization-cracking-singleton.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>主要介绍通过反射的方式获取单例对象, 验证<a href="https://liuzhihangs.github.io/2018/02/21/lazy-singleton-mode-thread-safe.html">单例模式</a>的安全性.<br>主要从以下几个角度来介绍反射下的单例<br>饿汉式<br>双重锁检查<br><a href="https://liuzhihangs.github.io/2018/08/17/use-enumeration-to-implement-a-singleton.html">枚举单例</a></p><a id="more"></a><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p><a href="https://github.com/liuzhihang/demo_design_pattern/blob/master/src/main/java/com/liuzhihang/demo/singleton/HungerPattern.java">饿汉式</a>直接使用反射即可破解单例模式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            HungerPattern hungerPattern = HungerPattern.getHungerPattern();</span><br><span class="line"></span><br><span class="line">            Class&lt;HungerPattern&gt; hungerPatternClass = HungerPattern.class;</span><br><span class="line"></span><br><span class="line">            Constructor&lt;HungerPattern&gt; conA = hungerPatternClass.getDeclaredConstructor();</span><br><span class="line">            Constructor&lt;HungerPattern&gt; conB = hungerPatternClass.getDeclaredConstructor();</span><br><span class="line"></span><br><span class="line">            conA.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            conB.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            HungerPattern instanceA = conA.newInstance();</span><br><span class="line">            HungerPattern instanceB = conB.newInstance();</span><br><span class="line">            <span class="comment">// instanceA 和 instanceB 不是同一对象</span></span><br><span class="line">            System.out.println(hungerPattern.hashCode());</span><br><span class="line">            System.out.println(instanceA.hashCode());</span><br><span class="line">            System.out.println(instanceB.hashCode());</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\jdk1.8\bin\java.exe . . .</span><br><span class="line">713338599</span><br><span class="line">168423058</span><br><span class="line">821270929</span><br><span class="line"></span><br><span class="line">Process finished with <span class="built_in">exit</span> code 0</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="双重锁检查"><a href="#双重锁检查" class="headerlink" title="双重锁检查"></a>双重锁检查</h3><p><a href="https://github.com/liuzhihang/demo_design_pattern/blob/master/src/main/java/com/liuzhihang/demo/singleton/DoubleCheckLockLazyPattern.java">双重锁检查</a>同样存在相同的情况</p><ol><li>直接使用<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DoubleCheckLockLazyPattern pattern = DoubleCheckLockLazyPattern.getDoubleCheckLockLazyPattern();</span><br><span class="line"></span><br><span class="line">            Class&lt;DoubleCheckLockLazyPattern&gt; patternClass = DoubleCheckLockLazyPattern.class;</span><br><span class="line"></span><br><span class="line">            Constructor&lt;DoubleCheckLockLazyPattern&gt; conA = patternClass.getDeclaredConstructor();</span><br><span class="line">            Constructor&lt;DoubleCheckLockLazyPattern&gt; conB = patternClass.getDeclaredConstructor();</span><br><span class="line"></span><br><span class="line">            conA.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            conB.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            DoubleCheckLockLazyPattern patternA = conA.newInstance();</span><br><span class="line">            DoubleCheckLockLazyPattern patternB = conA.newInstance();</span><br><span class="line"></span><br><span class="line">            System.out.println(pattern.hashCode());</span><br><span class="line">            System.out.println(patternA.hashCode());</span><br><span class="line">            System.out.println(patternB.hashCode());</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p>输出结果</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\jdk1.8\bin\java.exe . . .</span><br><span class="line">713338599</span><br><span class="line">168423058</span><br><span class="line">821270929</span><br><span class="line"></span><br><span class="line">Process finished with <span class="built_in">exit</span> code 0</span><br></pre></td></tr></table></figure><ol start="2"><li>在双重锁检查私有构造内加入异常</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class DoubleCheckLockLazyPattern &#123;</span><br><span class="line"></span><br><span class="line">    private <span class="function"><span class="title">DoubleCheckLockLazyPattern</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">        // 加入异常判断, 防止反射</span><br><span class="line">        <span class="keyword">if</span> (doubleCheckLockLazyPattern != null) &#123;</span><br><span class="line">            throw new RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static volatile DoubleCheckLockLazyPattern doubleCheckLockLazyPattern = null;</span><br><span class="line"></span><br><span class="line">    public static DoubleCheckLockLazyPattern <span class="function"><span class="title">getDoubleCheckLockLazyPattern</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            <span class="keyword">if</span> (doubleCheckLockLazyPattern == null) &#123;</span><br><span class="line">                // 一系列操作</span><br><span class="line">                Thread.sleep(100);</span><br><span class="line">                synchronized (DoubleCheckLockLazyPattern.class) &#123;</span><br><span class="line">                    // 二次检查</span><br><span class="line">                    <span class="keyword">if</span> (doubleCheckLockLazyPattern == null) &#123;</span><br><span class="line">                        doubleCheckLockLazyPattern = new DoubleCheckLockLazyPattern();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> doubleCheckLockLazyPattern;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\jdk1.8\bin\java.exe . . .</span><br><span class="line">java.lang.reflect.InvocationTargetException</span><br><span class="line">at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span><br><span class="line">at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)</span><br><span class="line">at java.lang.reflect.Constructor.newInstance(Constructor.java:423)</span><br><span class="line">at com.liuzhihang.demo.singleton.ReflectTest.main(ReflectTest.java:24)</span><br><span class="line">Caused by: java.lang.RuntimeException</span><br><span class="line">at com.liuzhihang.demo.singleton.DoubleCheckLockLazyPattern.&lt;init&gt;(DoubleCheckLockLazyPattern.java:15)</span><br><span class="line">... 5 more</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>通过序列化反序列化获取对象</li></ol><p>DoubleCheckLockLazyPattern 实现序列化</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class ReflectTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            DoubleCheckLockLazyPattern pattern = DoubleCheckLockLazyPattern.getDoubleCheckLockLazyPattern();</span><br><span class="line"></span><br><span class="line">            FileOutputStream fos= new FileOutputStream(<span class="string">&quot;C:/Users/liuzhihang/desktop/pattern.txt&quot;</span>);</span><br><span class="line">            ObjectOutputStream oos = new ObjectOutputStream(fos);</span><br><span class="line">            oos.writeObject(pattern);</span><br><span class="line">            oos.close();</span><br><span class="line">            fos.close();</span><br><span class="line">            ObjectInputStream oisA = new ObjectInputStream(new FileInputStream(<span class="string">&quot;C:/Users/liuzhihang/desktop/pattern.txt&quot;</span>));</span><br><span class="line">            DoubleCheckLockLazyPattern patternA= (DoubleCheckLockLazyPattern) oisA.readObject();</span><br><span class="line"></span><br><span class="line">            ObjectInputStream oisB = new ObjectInputStream(new FileInputStream(<span class="string">&quot;C:/Users/liuzhihang/desktop/pattern.txt&quot;</span>));</span><br><span class="line">            DoubleCheckLockLazyPattern patternB= (DoubleCheckLockLazyPattern) oisB.readObject();</span><br><span class="line"></span><br><span class="line">            System.out.println(pattern.hashCode());</span><br><span class="line">            System.out.println(patternA.hashCode());</span><br><span class="line">            System.out.println(patternB.hashCode());</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\jdk1.8\bin\java.exe . . .</span><br><span class="line">258952499</span><br><span class="line">1702297201</span><br><span class="line">1996181658</span><br><span class="line"></span><br><span class="line">Process finished with <span class="built_in">exit</span> code 0</span><br></pre></td></tr></table></figure><ol start="4"><li>修改反序列化方法, 可以防止反序列化</li></ol><p>添加以下方法</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">private Object <span class="function"><span class="title">readResolve</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> doubleCheckLockLazyPattern;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\jdk1.8\bin\java.exe . . .</span><br><span class="line">258952499</span><br><span class="line">258952499</span><br><span class="line">258952499</span><br><span class="line"></span><br><span class="line">Process finished with <span class="built_in">exit</span> code 0</span><br></pre></td></tr></table></figure><h3 id="枚举单例"><a href="#枚举单例" class="headerlink" title="枚举单例"></a>枚举单例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">SingletonEnum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Resource resource;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    SingletonEnum() &#123;</span><br><span class="line">        <span class="keyword">this</span>.resource = <span class="keyword">new</span> Resource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Resource <span class="title">getResource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> resource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="枚举单例分析"><a href="#枚举单例分析" class="headerlink" title="枚举单例分析"></a>枚举单例分析</h4><p>在枚举反射获取对象时抛出异常, 通过 Constructor类 源码可以看出, 在反射创建对象时会判断是否是枚举修饰, 是则抛出异常</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@CallerSensitive</span><br><span class="line">  public T newInstance(Object ... initargs)</span><br><span class="line">      throws InstantiationException, IllegalAccessException,</span><br><span class="line">             IllegalArgumentException, InvocationTargetException</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">if</span> (!override) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class="line">              Class&lt;?&gt; <span class="built_in">caller</span> = Reflection.getCallerClass();</span><br><span class="line">              checkAccess(<span class="built_in">caller</span>, clazz, null, modifiers);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ((clazz.getModifiers() &amp; Modifier.ENUM) != 0)</span><br><span class="line">          throw new IllegalArgumentException(<span class="string">&quot;Cannot reflectively create enum objects&quot;</span>);</span><br><span class="line">      ConstructorAccessor ca = constructorAccessor;   // <span class="built_in">read</span> volatile</span><br><span class="line">      <span class="keyword">if</span> (ca == null) &#123;</span><br><span class="line">          ca = acquireConstructorAccessor();</span><br><span class="line">      &#125;</span><br><span class="line">      @SuppressWarnings(<span class="string">&quot;unchecked&quot;</span>)</span><br><span class="line">      T inst = (T) ca.newInstance(initargs);</span><br><span class="line">      <span class="built_in">return</span> inst;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>同时在父类 Enum类 中重写了 readObject方法, 所以枚举也可以避免反序列化</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * prevent default deserialization</span><br><span class="line"> */</span><br><span class="line">private void readObject(ObjectInputStream <span class="keyword">in</span>) throws IOException,</span><br><span class="line">    ClassNotFoundException &#123;</span><br><span class="line">    throw new InvalidObjectException(<span class="string">&quot;can&#x27;t deserialize enum&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 源码学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码学习 </tag>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射</title>
      <link href="2018/08/24/reflection.html"/>
      <url>2018/08/24/reflection.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>java反射可以在运行时获取对象的成员和属性, 并且可以动态的创建对象并调用对象的属性.<br>反射一般编程中很少使用,但是在很多框架中都使用了反射, 比如配置Spring的Xml配置文件中, 就使用全类名配置方式, 其实就是反射的一种使用方式.</p><p>同时反射对单例模式有一定的影响, 可以参考<a href="https://liuzhihang.com/2018/08/27/reflection-and-serialization-cracking-singleton.html">反射获取单例对象</a></p><a id="more"></a><h3 id="获取反射对象"><a href="#获取反射对象" class="headerlink" title="获取反射对象"></a>获取反射对象</h3><p>获取反射Class对象一共三种方式</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 1. 使用实例获取</span><br><span class="line">User user = new User();</span><br><span class="line">Class&lt;? extends User&gt; aClass = user.getClass();</span><br><span class="line">// 2. 使用类获取</span><br><span class="line">Class&lt;User&gt; userClass = User.class;</span><br><span class="line">// 3. 全类名获取, 可能会抛出 ClassNotFoundException 异常</span><br><span class="line">Class&lt;?&gt; aClass1 = Class.forName(<span class="string">&quot;com.liuzhihang.tool.reflect.User&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="获取属性"><a href="#获取属性" class="headerlink" title="获取属性"></a>获取属性</h3><ol><li>获取字段<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 获取所有公有字段 (public)</span><br><span class="line">Field[] fields = aClass.getFields();</span><br><span class="line">// 获取所有字段 (public 缺省, protected, private)</span><br><span class="line">Field[] fields = aClass.getDeclaredFields()</span><br><span class="line">// 获取指定公共字段</span><br><span class="line">Field age = aClass.getField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">// 获取指定字段 (public 缺省, protected, private)</span><br><span class="line">Field userName = aClass.getDeclaredField(<span class="string">&quot;userName&quot;</span>);</span><br></pre></td></tr></table></figure></li></ol><h3 id="获取构造"><a href="#获取构造" class="headerlink" title="获取构造"></a>获取构造</h3><ol><li>获取构造<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 获取所有构造 不能获取私有</span><br><span class="line">Constructor&lt;?&gt;[] constructors = aClass.getConstructors();</span><br><span class="line"></span><br><span class="line">// 获取指定参数类型的构造 不能获取私有 空则获取空参构造 getConstructor(Class&lt;?&gt;... parameterTypes)</span><br><span class="line">Constructor&lt;User&gt; constructor = aClass.getConstructor(String.class);</span><br><span class="line"></span><br><span class="line">// 获取所有构造 包含私有</span><br><span class="line">Constructor&lt;?&gt;[] declaredConstructors = aClass.getDeclaredConstructors();</span><br><span class="line"></span><br><span class="line">// 获取指定参数类型的构造 可以获取私有 空则获取空参构造 getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)</span><br><span class="line">Constructor&lt;User&gt; declaredConstructor = aClass.getDeclaredConstructor(String.class);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>使用构造创建对象</li></ol><p>可以通过 constructor.setAccessible(true); 暴力破解忽略访问修饰符, 来使用私有构造参数</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Constructor&lt;User&gt; constructor = aClass.getDeclaredConstructor(String.class);</span><br><span class="line">// 暴力破解</span><br><span class="line">constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">User <span class="built_in">test</span> = constructor.newInstance(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h3><ol><li>获取方法<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 获取所有公共方法(包含父类)</span><br><span class="line">Method[] methods = aClass.getMethods();</span><br><span class="line">// 获取所有方法</span><br><span class="line">Method[] methods = aClass.getDeclaredMethods();</span><br><span class="line">// 获取私有方法 第一个参数填方法名称</span><br><span class="line">Method address = aClass.getDeclaredMethod(<span class="string">&quot;setAddress&quot;</span>, String.class);</span><br><span class="line">// 获取公共方法</span><br><span class="line">Method address = aClass.getMethod(<span class="string">&quot;setAddress&quot;</span>, String.class);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>使用方法<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;com.liuzhihang.tool.reflect.User&quot;</span>)</span><br><span class="line"></span><br><span class="line">Method address = aClass.getDeclaredMethod(<span class="string">&quot;setAddress&quot;</span>, String.class);</span><br><span class="line"></span><br><span class="line">User user = aClass.getConstructor().newInstance();</span><br><span class="line"></span><br><span class="line">System.out.println(user.toString());</span><br><span class="line">// 解除私有限制</span><br><span class="line">address.setAccessible(<span class="literal">true</span>);</span><br><span class="line">// 使用invoke来调用方法</span><br><span class="line">address.invoke(user, <span class="string">&quot;北京&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(user.toString());</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="获取其他属性"><a href="#获取其他属性" class="headerlink" title="获取其他属性"></a>获取其他属性</h3><p>还可以获取类实现的接口, 父类, 注解, 以及判断类的类型等多种使用方式.</p>]]></content>
      
      
      <categories>
          
          <category> utils </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LinkList相关学习</title>
      <link href="2018/08/23/linklist-related-learning.html"/>
      <url>2018/08/23/linklist-related-learning.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote><p>LinkList也是工作中常见的集合, 底层使用双向链表结构<br>比较适合新增和删除, 查询和修改需要遍历相对<a href="https://liuzhihang.com/2018/08/23/arraylist-related-learning.html">ArrayList</a>比较消耗性能</p></blockquote><a id="more"></a><h3 id="内部类-Node"><a href="#内部类-Node" class="headerlink" title="内部类 Node"></a>内部类 Node</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 元素值</span></span><br><span class="line">    E item;</span><br><span class="line">    <span class="comment">// 下一个节点</span></span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    <span class="comment">// 上一个几点</span></span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">    <span class="comment">// 构造一个新节点 指向上一个节点和下一个节点</span></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="add-新增"><a href="#add-新增" class="headerlink" title="add 新增"></a>add 新增</h3><p>通过代码可以看出, 在新增元素时只需要创建一个新节点 Node, 并将原始链表最后一个Node的next指向新Node</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * Links e as last element.</span><br><span class="line"> */</span><br><span class="line">void linkLast(E e) &#123;</span><br><span class="line">    // 声明 l 为最后一个节点</span><br><span class="line">    final Node&lt;E&gt; l = last;</span><br><span class="line">    // 创建新节点, 指向上一个节点, 下一个节点为空</span><br><span class="line">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);</span><br><span class="line">    // 最后一个节点为新创建的节点</span><br><span class="line">    last = newNode;</span><br><span class="line">    // 判断是否为第一个元素, 否则将 新创建的 Node加入链表</span><br><span class="line">    <span class="keyword">if</span> (l == null)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="remove-删除"><a href="#remove-删除" class="headerlink" title="remove 删除"></a>remove 删除</h3><p>1.删除操作需要遍历链表找到相应元素, 然后移动指针即可<br>2.删除首尾元素直接移动指针即可 removeFirst()/removeLast() 方法</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == null) &#123;</span><br><span class="line">        // 遍历链表</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != null; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == null) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != null; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 删除元素</span><br><span class="line"> */</span><br><span class="line">E unlink(Node&lt;E&gt; x) &#123;</span><br><span class="line">    // assert x != null;</span><br><span class="line">    final E element = x.item;</span><br><span class="line">    final Node&lt;E&gt; next = x.next;</span><br><span class="line">    final Node&lt;E&gt; prev = x.prev;</span><br><span class="line">    // 判断上一个Node是否为空</span><br><span class="line">    <span class="keyword">if</span> (prev == null) &#123;</span><br><span class="line">        // 空, 该节点为链表头, 将下一个节点设置为链表头</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        // 不为空, 将上一个节点的next 指向当前节点的 next, 并将当前节点的 prev置为空</span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = null;</span><br><span class="line">    &#125;</span><br><span class="line">    // 判断下一个Node是否为空</span><br><span class="line">    <span class="keyword">if</span> (next == null) &#123;</span><br><span class="line">        // 空, 该节点为链表尾, 将链表尾设置为当前节点的上一个节点</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        // 不为空, 将下一个节点的prev, 设置为上一个节点, 并将当前节点的 next置为空</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x.item = null;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="built_in">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="get-set"><a href="#get-set" class="headerlink" title="get/set"></a>get/set</h3><p>get/set时都需要获取指定索引的元素, 使用二分法查找, 然后进行遍历查找, 所以此处相较于<a href="https://liuzhihang.com/2018/08/23/arraylist-related-learning.html">ArrayList</a>多了遍历查询, 虽然使用了二分法进行优化, 但是get/set操作相比ArrayList来说性能还是相对较差</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">    // 校验索引</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    // 二分法遍历查找节点</span><br><span class="line">    <span class="built_in">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public E <span class="built_in">set</span>(int index, E element) &#123;</span><br><span class="line">    // 校验索引</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    // 二分法遍历查找节点</span><br><span class="line">    Node&lt;E&gt; x = node(index);</span><br><span class="line">    // 修改Node节点的 item值</span><br><span class="line">    E oldVal = x.item;</span><br><span class="line">    x.item = element;</span><br><span class="line">    <span class="built_in">return</span> oldVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 返回指定索引处非null节点.</span><br><span class="line"> */</span><br><span class="line">Node&lt;E&gt; node(int index) &#123;</span><br><span class="line">    // assert isElementIndex(index);</span><br><span class="line"></span><br><span class="line">    // 判断索引是否小于长度的一半 (二分法) 然后遍历查找</span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; 1)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (int i = 0; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="built_in">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (int i = size - 1; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="built_in">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 源码学习 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码学习 </tag>
            
            <tag> LinkList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList相关学习</title>
      <link href="2018/08/23/arraylist-related-learning.html"/>
      <url>2018/08/23/arraylist-related-learning.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>ArrayList是工作中常用的集合, 基于数组实现, 可以插入空数据, 也支持随机访问.<br>ArrayList比较适合 get/set操作, 因为 add/remove需要移动数据, 相对来说比较消耗性能.</p></blockquote><h3 id="默认初始长度"><a href="#默认初始长度" class="headerlink" title="默认初始长度"></a>默认初始长度</h3><p>1.默认初始长度为 10<br>2.底层结构为Object[] 数组</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">private static final int DEFAULT_CAPACITY = 10;</span><br><span class="line"></span><br><span class="line">private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 构造一个初始容量为10的空列表</span><br><span class="line"> */</span><br><span class="line">public <span class="function"><span class="title">ArrayList</span></span>() &#123;</span><br><span class="line">    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="添加方法-add"><a href="#添加方法-add" class="headerlink" title="添加方法 add()"></a>添加方法 add()</h3><ol><li>向数组中添加元素, 流程如下</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 将指定的元素追加到此列表的末尾.</span><br><span class="line"> */</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    // 扩容</span><br><span class="line">    ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class="line">    // 添加元素</span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.扩容过程</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">transient Object[] elementData;</span><br><span class="line"></span><br><span class="line">// 扩容</span><br><span class="line">private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line">// 计算容量, elementData为空 则使用默认容量 10, 指定容量</span><br><span class="line">private static int calculateCapacity(Object[] elementData, int minCapacity) &#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="built_in">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line">// 修改次数自增, 并且如果 新的长度-原长度&gt;0 则使用 grow(minCapacity)方法进行扩容</span><br><span class="line">private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; 0)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>添加元素赋值<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">elementData[size++] = e;</span><br></pre></td></tr></table></figure></li></ol><h3 id="扩容流程-grow-minCapacity"><a href="#扩容流程-grow-minCapacity" class="headerlink" title="扩容流程 grow(minCapacity)"></a>扩容流程 grow(minCapacity)</h3><p>通过扩容流程可以看出扩容过程中, 是将创建一个原数组1.5倍大小的新数组, 同时将数组元素复制到新数组, 所以一般使用中, 尽量指定数组大小, 从而避免数组的复制.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 增加容量确保能容纳 minCapacity 数量的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="comment">// 获取当前 elementData 的长度</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// 获取新的长度 为当前长度的 1.5倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 比较并交换</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">// 防止超出最大长度</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    <span class="comment">// 数组复制</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除-remove-方法"><a href="#删除-remove-方法" class="headerlink" title="删除 remove 方法"></a>删除 remove 方法</h3><p>删除过程中使用 System.arraycopy 本地方法, 对数组进行复制, 所以 ArrayList的 新增和删除方法性能不如, <a href="https://liuzhihang.com/2018/08/23/linklist-related-learning.html">LinkList</a>, 但是 get和set方法, 则直接根据索引修改数据, 比较适合对数据进行修改的操作.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 删除指定位置的元素, 后面的元素将前移</span><br><span class="line"> */</span><br><span class="line">public E remove(int index) &#123;</span><br><span class="line"></span><br><span class="line">    // 检查索引 否则抛出 IndexOutOfBoundsException(outOfBoundsMsg(index))</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    // 修改次数自增</span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    int numMoved = size - index - 1;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; 0)</span><br><span class="line">        // 数组复制</span><br><span class="line">        System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = null; // clear to <span class="built_in">let</span> GC <span class="keyword">do</span> its work</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 删除指定元素</span><br><span class="line"> */</span><br><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == null) &#123;</span><br><span class="line">        <span class="keyword">for</span> (int index = 0; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == null) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (int index = 0; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * System.arraycopy 方法拷贝 删除</span><br><span class="line"> */</span><br><span class="line">private void fastRemove(int index) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    int numMoved = size - index - 1;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; 0)</span><br><span class="line">        System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = null; // clear to <span class="built_in">let</span> GC <span class="keyword">do</span> its work</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 源码学习 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>@Value注入属性的小bug</title>
      <link href="2018/08/21/value-injects-a-small-bug-in-the-property.html"/>
      <url>2018/08/21/value-injects-a-small-bug-in-the-property.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="Value注入属性"><a href="#Value注入属性" class="headerlink" title="@Value注入属性"></a>@Value注入属性</h4><p>工作中一些公共属性, 一般通过@Value注入的对象的属性中, 使用方式如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeChatConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 微信支付参数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;wx.appId&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String WX_APP_ID;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过@Value注解, 将配置文件中的值注入到对象属性中, 在使用时只需要注入WeChatConfig对象然后调用即可, 而实际工作中, 往往用静态属性, 方便使用, 于是可以写成如下方式</p><a id="more"></a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeChatConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 微信支付参数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;wx.appId&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String WX_APP_ID;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用此方式不会报错, 但是却取不到属性值, 并且不会报错. 变通方式可以如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeChatConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 微信支付参数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;wx.appId&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String WX_APP_ID;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;wx.app.id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setWxAppId</span><span class="params">(String wxAppId)</span> </span>&#123;</span><br><span class="line">        WX_APP_ID = wxAppId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意: 此处的 set方法不可以设置为静态, 否则同样不能注入属性</p>]]></content>
      
      
      <categories>
          
          <category> issue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> issue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用枚举实现单例</title>
      <link href="2018/08/17/use-enumeration-to-implement-a-singleton.html"/>
      <url>2018/08/17/use-enumeration-to-implement-a-singleton.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>介绍使用枚举的方式创建单例, 其他方式可以参考<a href="https://liuzhihang.com/2018/02/21/singleton-pattern.html">单例模式</a></p><a id="more"></a><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用枚举单例</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuzhihang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/8/17 17:34</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonPattern</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonPattern</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonPattern <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span>   SingleEnum.INSTANCE.getSingletonPattern();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">SingleEnum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 单例</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        INSTANCE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> SingletonPattern singletonPattern;</span><br><span class="line"></span><br><span class="line">        SingleEnum() &#123;</span><br><span class="line">            <span class="keyword">this</span>.singletonPattern = <span class="keyword">new</span> SingletonPattern();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> SingletonPattern <span class="title">getSingletonPattern</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> singletonPattern;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>1.比双重锁检查相对简洁<br>2.线程安全<br>3.自动处理序列化<br>4.防止反射</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch基本语句</title>
      <link href="2018/06/26/elasticsearch-basic-statement.html"/>
      <url>2018/06/26/elasticsearch-basic-statement.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="查看集群"><a href="#查看集群" class="headerlink" title="查看集群"></a>查看集群</h3><h4 id="1-查看集群健康"><a href="#1-查看集群健康" class="headerlink" title="1. 查看集群健康"></a>1. 查看集群健康</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X GET <span class="string">&quot;localhost:9200/_cat/health?v&quot;</span></span><br></pre></td></tr></table></figure><h4 id="2-查看集群节点"><a href="#2-查看集群节点" class="headerlink" title="2. 查看集群节点"></a>2. 查看集群节点</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X GET <span class="string">&quot;localhost:9200/_cat/nodes?v&quot;</span></span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="3-查看集群所有索引"><a href="#3-查看集群所有索引" class="headerlink" title="3. 查看集群所有索引"></a>3. 查看集群所有索引</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X GET <span class="string">&quot;localhost:9200/_cat/indices?v&quot;</span></span><br></pre></td></tr></table></figure><h3 id="get-获取指定数据"><a href="#get-获取指定数据" class="headerlink" title="get 获取指定数据"></a>get 获取指定数据</h3><h4 id="1-直接获取数据"><a href="#1-直接获取数据" class="headerlink" title="1. 直接获取数据"></a>1. 直接获取数据</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X GET <span class="string">&quot;localhost:9200/monitor_log_mch_order_out/logs/AWSudIFgTuj3oZBEhyxK?pretty&quot;</span></span><br></pre></td></tr></table></figure><p>格式为 /{index}/{type}/{id}</p><table><thead><tr><th align="left">字段</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">monitor_log_mch_order_out</td><td align="left">索引 (_index)</td></tr><tr><td align="left">logs</td><td align="left">索引的类型 (_type), 不知道类型可以用 _all 匹配</td></tr><tr><td align="left">AWSudIFgTuj3oZBEhyxK</td><td align="left">id (_id)</td></tr><tr><td align="left">pretty</td><td align="left">json格式显示数据, 可省略</td></tr></tbody></table><h4 id="2-屏蔽或只查看-source"><a href="#2-屏蔽或只查看-source" class="headerlink" title="2. 屏蔽或只查看 _source"></a>2. 屏蔽或只查看 _source</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X GET <span class="string">&quot;localhost:9200/monitor_log_mch_order_out/logs/AWSudIFgTuj3oZBEhyxK?pretty&amp;_source=false&quot;</span></span><br></pre></td></tr></table></figure><p>添加 _source=false 即可</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X GET <span class="string">&quot;localhost:9200/monitor_log_mch_order_out/logs/AWSudIFgTuj3oZBEhyxK/_source?pretty&quot;</span></span><br></pre></td></tr></table></figure><h4 id="3-过滤字段"><a href="#3-过滤字段" class="headerlink" title="3. 过滤字段"></a>3. 过滤字段</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X GET <span class="string">&quot;localhost:9200/monitor_log_mch_order_out/logs/AWSudIFgTuj3oZBEhyxK?pretty&amp;_source_include=log*&amp;_source_exclude=logType&quot;</span></span><br></pre></td></tr></table></figure><p>获取包含 log* 且不为 logType 的字段</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X GET <span class="string">&quot;localhost:9200/monitor_log_mch_order_out/logs/AWSudIFgTuj3oZBEhyxK?pretty&amp;_source=logType,logLevel&quot;</span></span><br></pre></td></tr></table></figure><p>只查询指定字段的简易写法</p><h3 id="mget-多条件匹配查询"><a href="#mget-多条件匹配查询" class="headerlink" title="mget 多条件匹配查询"></a>mget 多条件匹配查询</h3><ol><li><p>匹配多个索引, 同时查询多个id的数据</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X GET <span class="string">&quot;localhost:9200/_mget?pretty&quot;</span> -H <span class="string">&#x27;Content-Type: application/json&#x27;</span> -d<span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    &quot;docs&quot; : [</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            &quot;_index&quot; : &quot;monitor_log_mch_order_out&quot;,</span></span><br><span class="line"><span class="string">            &quot;_type&quot; : &quot;logs&quot;,</span></span><br><span class="line"><span class="string">            &quot;_id&quot; : &quot;AWSudIFgTuj3oZBEhyxK&quot;</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            &quot;_index&quot; : &quot;monitor_log_mch_order_out&quot;,</span></span><br><span class="line"><span class="string">            &quot;_type&quot; : &quot;logs&quot;,</span></span><br><span class="line"><span class="string">            &quot;_id&quot; : &quot;AWSuXewETuj3oZBEhywS&quot;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>可以将索引写在host后面, 代表查询的都为同一索引下的数据</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X GET <span class="string">&quot;localhost:9200/monitor_log_mch_order_out/_mget?pretty&quot;</span> -H <span class="string">&#x27;Content-Type: application/json&#x27;</span> -d<span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    &quot;docs&quot; : [</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            &quot;_type&quot; : &quot;logs&quot;,</span></span><br><span class="line"><span class="string">            &quot;_id&quot; : &quot;AWSudIFgTuj3oZBEhyxK&quot;</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            &quot;_type&quot; : &quot;logs&quot;,</span></span><br><span class="line"><span class="string">            &quot;_id&quot; : &quot;AWSuXewETuj3oZBEhywS&quot;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>合并index和type, 代表查询的都为同一索引下type也相同的数据</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X GET <span class="string">&quot;localhost:9200/monitor_log_mch_order_out/logs/_mget?pretty&quot;</span> -H <span class="string">&#x27;Content-Type: application/json&#x27;</span> -d<span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    &quot;docs&quot; : [</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            &quot;_id&quot; : &quot;AWSudIFgTuj3oZBEhyxK&quot;</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            &quot;_id&quot; : &quot;AWSuXewETuj3oZBEhywS&quot;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#x27;</span></span><br></pre></td></tr></table></figure><p>简化后如下:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X GET <span class="string">&quot;localhost:9200/monitor_log_mch_order_out/logs/_mget?pretty&quot;</span> -H <span class="string">&#x27;Content-Type: application/json&#x27;</span> -d<span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;ids&quot; : [&quot;AWSudIFgTuj3oZBEhyxK&quot;, &quot;AWSuXewETuj3oZBEhywS&quot;]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#x27;</span></span><br></pre></td></tr></table></figure></li></ol><p>注: 当多个条件的 _type 相同时 可以使用 _all 或者省略</p><ol start="4"><li>过滤字段, 每个Id分别对 _source进行过滤<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X GET <span class="string">&quot;localhost:9200/monitor_log_mch_order_out/_mget?pretty&quot;</span> -H <span class="string">&#x27;Content-Type: application/json&#x27;</span> -d<span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    &quot;docs&quot; : [</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            &quot;_id&quot; : &quot;AWSudIFgTuj3oZBEhyxK&quot;,</span></span><br><span class="line"><span class="string">            &quot;_source&quot; : false</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            &quot;_id&quot; : &quot;AWSuXewETuj3oZBEhywS&quot;,</span></span><br><span class="line"><span class="string">            &quot;_source&quot; : [&quot;bizId&quot;, &quot;method&quot;]</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            &quot;_id&quot; : &quot;AWSuLAYqTuj3oZBEhysH&quot;,</span></span><br><span class="line"><span class="string">            &quot;_source&quot; : &#123;</span></span><br><span class="line"><span class="string">                &quot;include&quot;: [&quot;log*&quot;],</span></span><br><span class="line"><span class="string">                &quot;exclude&quot;: [&quot;logLevel&quot;]</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#x27;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="search-搜索"><a href="#search-搜索" class="headerlink" title="_search 搜索"></a>_search 搜索</h3><h4 id="1-匹配bizId-查询"><a href="#1-匹配bizId-查询" class="headerlink" title="1. 匹配bizId 查询"></a>1. 匹配bizId 查询</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X GET <span class="string">&quot;localhost:9200/monitor_log_mch_order_out/_search?pretty&amp;q=bizId:2009011201807190133430748068&quot;</span></span><br></pre></td></tr></table></figure><h4 id="2-同时指定类型"><a href="#2-同时指定类型" class="headerlink" title="2. 同时指定类型"></a>2. 同时指定类型</h4><p>同时指定类型, 多个类型用 ‘,’ 隔开, 也支持多个索引勇士搜索, 多个索引用 ‘,’ 隔开, 或者模糊搜索</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X GET <span class="string">&quot;localhost:9200/monitor_log_mch_order_out/logs/_search?pretty&amp;q=bizId:2009011201807190133430748068&quot;</span></span><br></pre></td></tr></table></figure><h4 id="3-占位符-all-匹配所有索引"><a href="#3-占位符-all-匹配所有索引" class="headerlink" title="3. 占位符 _all 匹配所有索引"></a>3. 占位符 _all 匹配所有索引</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X GET <span class="string">&quot;localhost:9200/_all/logs/_search?pretty&amp;q=bizId:2009011201807190133430748068&quot;</span></span><br></pre></td></tr></table></figure><h4 id="4-匹配所有索引所有类型"><a href="#4-匹配所有索引所有类型" class="headerlink" title="4. 匹配所有索引所有类型"></a>4. 匹配所有索引所有类型</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X GET <span class="string">&quot;localhost:9200/_search?pretty&amp;q=bizId:2009011201807190133430748068&quot;</span></span><br></pre></td></tr></table></figure><p>注: q 代表映射query_string</p><h4 id="5-请求体的方式"><a href="#5-请求体的方式" class="headerlink" title="5. 请求体的方式"></a>5. 请求体的方式</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X GET <span class="string">&quot;localhost:9200/monitor_log_mch_order_out/logs/_search?pretty&quot;</span> -H <span class="string">&#x27;Content-Type: application/json&#x27;</span> -d<span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    &quot;query&quot; : &#123;</span></span><br><span class="line"><span class="string">        &quot;term&quot; : &#123; &quot;bizId&quot; : &quot;2009011201807190133430748068&quot; &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="6-分页查询-from-size"><a href="#6-分页查询-from-size" class="headerlink" title="6. 分页查询 from/size"></a>6. 分页查询 from/size</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X GET <span class="string">&quot;localhost:9200/monitor_log_mch_order_out/logs/_search?pretty&quot;</span> -H <span class="string">&#x27;Content-Type: application/json&#x27;</span> -d<span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;from&quot; : 0, &quot;size&quot; : 1,</span></span><br><span class="line"><span class="string">    &quot;query&quot; : &#123;</span></span><br><span class="line"><span class="string">        &quot;term&quot; : &#123; &quot;bizId&quot; : &quot;2009011201807190133430748068&quot; &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="7-查询并过滤字段"><a href="#7-查询并过滤字段" class="headerlink" title="7. 查询并过滤字段"></a>7. 查询并过滤字段</h4><p>根据字段查询并筛选掉指定字段</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X GET <span class="string">&quot;localhost:9200/_search?pretty&quot;</span> -H <span class="string">&#x27;Content-Type: application/json&#x27;</span> -d<span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    &quot;_source&quot;: &#123;</span></span><br><span class="line"><span class="string">        &quot;includes&quot;: [ &quot;costTime&quot;, &quot;bizId&quot; ],</span></span><br><span class="line"><span class="string">        &quot;excludes&quot;: [ &quot;logLevel&quot; ]</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    &quot;query&quot; : &#123;</span></span><br><span class="line"><span class="string">        &quot;term&quot; : &#123; &quot;bizId&quot; : &quot;2009011201807190133430748068&quot; &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h3><h4 id="1-按照时间范围查询"><a href="#1-按照时间范围查询" class="headerlink" title="1. 按照时间范围查询"></a>1. 按照时间范围查询</h4><p>可以省略索引查询全部</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X GET <span class="string">&quot;localhost:9200/monitor_log_mch_order_out/_search?pretty&quot;</span> -H <span class="string">&#x27;Content-Type: application/json&#x27;</span> -d<span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    &quot;query&quot;: &#123;</span></span><br><span class="line"><span class="string">        &quot;range&quot; : &#123;</span></span><br><span class="line"><span class="string">            &quot;time&quot; : &#123;</span></span><br><span class="line"><span class="string">                &quot;gte&quot;: &quot;2018-07-19 00:14:25:000&quot;,</span></span><br><span class="line"><span class="string">                &quot;lte&quot;: &quot;2018-07-19 00:14:30:000&quot;,</span></span><br><span class="line"><span class="string">                &quot;format&quot;: &quot;yyyy-MM-dd HH:mm:ss:SSS&quot;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ELK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ELK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>logstash配置</title>
      <link href="2018/06/20/logstash-configuration.html"/>
      <url>2018/06/20/logstash-configuration.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">input</span> &#123;</span><br><span class="line">    <span class="string">beats</span> &#123;</span><br><span class="line">        <span class="string">port</span> <span class="string">=&gt;</span> <span class="string">&quot;5043&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置日志输入方式为 filebeat, 并配置端口</p><a id="more"></a><h3 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="string">grok</span> &#123;</span><br><span class="line">        <span class="string">match</span> <span class="string">=&gt;</span> &#123;</span><br><span class="line">        <span class="string">&quot;message&quot;</span> <span class="string">=&gt;</span> <span class="string">&quot;\[<span class="template-variable">%&#123;DATA:time&#125;</span>\]-\[<span class="template-variable">%&#123;DATA:method&#125;</span>\] - \[<span class="template-variable">%&#123;DATA:catalina&#125;</span>\] -\[<span class="template-variable">%&#123;DATA:logLevel&#125;</span>\] - \[<span class="template-variable">%&#123;DATA:index_prefix&#125;</span>\|<span class="template-variable">%&#123;WORD:logType&#125;</span>\|<span class="template-variable">%&#123;WORD:sysNo&#125;</span>\|<span class="template-variable">%&#123;WORD:objType&#125;</span>\|<span class="template-variable">%&#123;DATA:funcode&#125;</span>\|<span class="template-variable">%&#123;WORD:monitorObjNo&#125;</span>\|<span class="template-variable">%&#123;WORD:bizId&#125;</span>\|<span class="template-variable">%&#123;WORD:respCode&#125;</span>\|<span class="template-variable">%&#123;DATA:respMsg&#125;</span>\|<span class="template-variable">%&#123;WORD:costTime&#125;</span>|<span class="template-variable">%&#123;DATA:exField&#125;</span>\]&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="string">grok</span>&#123;</span><br><span class="line">         <span class="string">match</span> <span class="string">=&gt;</span> &#123; <span class="string">&quot;time&quot;</span> <span class="string">=&gt;</span> [<span class="string">&quot;<span class="template-variable">%&#123;INT:y_index&#125;</span>-<span class="template-variable">%&#123;INT:M_index&#125;</span>-<span class="template-variable">%&#123;INT:d_index&#125;</span>&quot;</span>]&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="string">mutate</span> &#123;</span><br><span class="line">        <span class="string">add_field</span> <span class="string">=&gt;</span> &#123; <span class="string">&quot;[@metadata][index_suffix]&quot;</span> <span class="string">=&gt;</span> <span class="string">&quot;<span class="template-variable">%&#123;y_index&#125;</span><span class="template-variable">%&#123;M_index&#125;</span><span class="template-variable">%&#123;d_index&#125;</span>&quot;</span> &#125;</span><br><span class="line">        <span class="string">remove_field</span> <span class="string">=&gt;</span> [<span class="string">&quot;beat&quot;</span>,<span class="string">&quot;host&quot;</span>,<span class="string">&quot;thread&quot;</span>,<span class="string">&quot;class&quot;</span>,<span class="string">&quot;source&quot;</span>,<span class="string">&quot;tags&quot;</span>,<span class="string">&quot;type&quot;</span>,<span class="string">&quot;y_index&quot;</span>,<span class="string">&quot;M_index&quot;</span>,<span class="string">&quot;d_index&quot;</span>]</span><br><span class="line">        <span class="string">lowercase</span> <span class="string">=&gt;</span> [ <span class="string">&quot;index_prefix&quot;</span> ]</span><br><span class="line">        <span class="string">lowercase</span> <span class="string">=&gt;</span> [ <span class="string">&quot;funcode&quot;</span> ]</span><br><span class="line">        <span class="string">lowercase</span> <span class="string">=&gt;</span> [ <span class="string">&quot;objType&quot;</span> ]</span><br><span class="line">        <span class="string">lowercase</span> <span class="string">=&gt;</span> [ <span class="string">&quot;monitorObjNo&quot;</span> ]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>使用gork过滤器对日志进行筛选, 并对部分字段赋值.</li><li>使用mutate插件对字段进行转换, add_field 为添加字段 [@metadata][index_suffix] 意思是添加临时字段, 该字段不会输出到es中</li></ol><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">output</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="string">if</span>  [<span class="string">logType</span>] <span class="string">==</span> <span class="string">&quot;info&quot;</span>  &#123;</span><br><span class="line">                 <span class="string">elasticsearch</span> &#123;</span><br><span class="line">                        <span class="string">hosts</span> <span class="string">=&gt;</span> [ <span class="string">&quot;xxx.xxx.xxx.xxx:9200&quot;</span> ]</span><br><span class="line">                        <span class="string">index</span> <span class="string">=&gt;</span> <span class="string">&quot;<span class="template-variable">%&#123;index_prefix&#125;</span>_<span class="template-variable">%&#123;objType&#125;</span>_<span class="template-variable">%&#123;funcode&#125;</span>_<span class="template-variable">%&#123;[@metadata][index_suffix]&#125;</span>&quot;</span></span><br><span class="line">                        <span class="string">user</span> <span class="string">=&gt;</span> <span class="string">elastic</span></span><br><span class="line">                        <span class="string">password</span> <span class="string">=&gt;</span> <span class="string">xxx</span></span><br><span class="line">                 &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="string">if</span> [<span class="string">logType</span>] <span class="string">==</span> <span class="string">&quot;error&quot;</span> &#123;</span><br><span class="line">                <span class="string">redis</span> &#123;</span><br><span class="line">                        <span class="string">data_type</span> <span class="string">=&gt;</span> <span class="string">&quot;list&quot;</span></span><br><span class="line">                        <span class="string">db</span> <span class="string">=&gt;</span> <span class="number">0</span></span><br><span class="line">                        <span class="comment">#key =&gt; &quot;%&#123;index_prefix&#125;_%&#123;sysNo&#125;_%&#123;objType&#125;_%&#123;funcode&#125;_%&#123;[@metadata][index_suffix]&#125;&quot;</span></span><br><span class="line">                        <span class="string">key</span> <span class="string">=&gt;</span> <span class="string">&quot;<span class="template-variable">%&#123;index_prefix&#125;</span>_<span class="template-variable">%&#123;sysNo&#125;</span>_<span class="template-variable">%&#123;objType&#125;</span>_<span class="template-variable">%&#123;monitorObjNo&#125;</span>&quot;</span></span><br><span class="line">                        <span class="string">host</span> <span class="string">=&gt;</span> <span class="string">&quot;xxx.xxx.xxx.xxx&quot;</span></span><br><span class="line">                        <span class="string">port</span> <span class="string">=&gt;</span> <span class="string">&quot;6379&quot;</span></span><br><span class="line">                        <span class="string">password</span> <span class="string">=&gt;</span> <span class="string">&quot;xxx&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将过滤后的字段按照类型输出到Es或者redis队列中</p><h3 id="启动命令"><a href="#启动命令" class="headerlink" title="启动命令"></a>启动命令</h3><pre><code>    ./bin/logstash -f first-pipelines.yml    nohup ./logstash -f ../first-pipelines.yml &gt;/dev/null 2&gt;&amp;1 &amp;</code></pre><h3 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输出到控制台</span></span><br><span class="line"><span class="string">stdout</span> &#123; <span class="string">codec</span> <span class="string">=&gt;</span> <span class="string">rubydebug</span> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ELK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ELK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>filebeat配置</title>
      <link href="2018/06/20/filebeat-configuration.html"/>
      <url>2018/06/20/filebeat-configuration.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="filebeat配置"><a href="#filebeat配置" class="headerlink" title="filebeat配置"></a>filebeat配置</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">filebeat.prospectors:</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">input_type:</span> <span class="string">log</span></span><br><span class="line"><span class="comment">#读取日志的路径</span></span><br><span class="line">  <span class="attr">paths:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/opt/export/log/info-xxx.log</span></span><br><span class="line">  <span class="attr">fields:</span></span><br><span class="line">    <span class="attr">log_type:</span> <span class="string">&quot;monitor_log&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">fields_under_root:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">#过滤部分日志</span></span><br><span class="line">  <span class="attr">include_lines:</span> [<span class="string">&#x27;Monitor_log&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#----------------------------- Logstash output --------------------------------</span></span><br><span class="line"><span class="attr">output.logstash:</span></span><br><span class="line">  <span class="comment"># The Logstash hosts</span></span><br><span class="line">  <span class="attr">hosts:</span> [<span class="string">&quot;xxx.xxx.xxx.xxx:5043&quot;</span>,<span class="string">&quot;xxx.xxx.xxx.xxx:5043&quot;</span>]</span><br><span class="line">  <span class="attr">loadbalance:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#================================ Logging =====================================</span></span><br><span class="line"></span><br><span class="line"><span class="attr">logging.level:</span> <span class="string">info</span></span><br><span class="line"><span class="attr">logging.to_files:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">logging.to_syslog:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">logging.files:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">/opt/export/app/filebeat/logs</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mybeat.log</span></span><br><span class="line">  <span class="attr">keepfiles:</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>过滤不包含指定字段的日志, 并仅仅输出到logstash, 也可以直接输出到Elasticsearch</p><h3 id="启动命令"><a href="#启动命令" class="headerlink" title="启动命令"></a>启动命令</h3><ol><li>前台启动：关闭窗口连接后自动退出</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./filebeat -e -c filebeat.yml</span><br></pre></td></tr></table></figure><ol start="2"><li>后台启动:</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nohup ./filebeat -e -c filebeat.yml &gt;/dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><ol start="3"><li>关闭:</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 xxxx</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ELK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ELK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>监控系统架构</title>
      <link href="2018/06/20/monitoring-system-architecture.html"/>
      <url>2018/06/20/monitoring-system-architecture.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="监控系统基本框架"><a href="#监控系统基本框架" class="headerlink" title="监控系统基本框架"></a>监控系统基本框架</h3><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="/resources/image/elk/elk.png" alt="监控系统基本架构"></p><a id="more"></a><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ol><li>各业务系统按照指定格式打印日志</li><li>filebeat自动读取日志信息, 并进行过滤, 输出到logstash</li><li>logstash进行二次处理, 将日志内容格式化, 并将 info日志和error日志分别存放到Elasticsearch和redis队列中</li><li>监控系统定时从Es和redis中获取数据, 存放到mysql并进行报警分析</li><li>使用EChart图形化展示信息<br>…</li></ol>]]></content>
      
      
      <categories>
          
          <category> ELK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ELK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程的生命周期</title>
      <link href="2018/06/15/thread-life-cycle.html"/>
      <url>2018/06/15/thread-life-cycle.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><p><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="/resources/concurrent/thread-life.png" alt="java内存模型"></p><a id="more"></a><h3 id="图解析"><a href="#图解析" class="headerlink" title="图解析"></a>图解析</h3><p>1.一般情况下线程主要经历: 准备, 就绪, 运行, 死亡四种状态.<br>2.准备:即创建线程, 包括集成Thread, 线程池, spring方式等等<br>3.就绪:线程创建并调用start()方法并不代表线程将立即获得资源, 而是进入到就绪状态进行资源分配<br>4.运行:抢占到资源的线程将执行, 执行过程可能会含有一些别的操作<br>&emsp;1).线程等待, 直到调用 notify()或notifyAll()方法被唤醒, 这里唤醒后不会立即继续执行线程, 而是进入就绪状态重新抢占资源<br>&emsp;2).线程休眠, 直到休眠时间结束, 同样结束后不会立即继续执行线程, 而是进入就绪状态重新抢占资源<br>&emsp;3).线程阻塞, IO资源阻塞, 锁等方式使线程进入阻塞队列, 释放锁将继续执行<br>5.死亡: 调用<del>stop()</del>方法, 线程中断, 或线程执行完毕则线程死亡</p>]]></content>
      
      
      <categories>
          
          <category> 并发和锁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>synchronized锁的介绍</title>
      <link href="2018/06/13/introduction-of-synchronized-lock.html"/>
      <url>2018/06/13/introduction-of-synchronized-lock.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="synchronized锁的使用"><a href="#synchronized锁的使用" class="headerlink" title="synchronized锁的使用"></a>synchronized锁的使用</h3><p>synchronized可以使用在方法和代码块中, 使用的方式不同锁代表的含义不同, 下面将从几个方面进行介绍.</p><ul><li>普通方法</li><li>静态方法</li><li>代码块synchronized(this)</li><li>代码块synchronized(*.class)</li></ul><a id="more"></a><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul><li>在使用synchronized关键字中锁主要分为两类, 一种是对象锁, 另一种类锁</li><li>普通加锁方法和synchronized(this)都是对象锁, 静态加锁方法和synchronized(*.class)都是类锁</li><li>对象锁: 同一对象持有锁, 相同对象等待, 其他对象不受影响; 不同对象持有锁, 互不影响.</li><li>类锁: 类锁时, 只要该类的对象持有锁, 无论是否为同一对象访问静态同步方法时都等待, 访问非静态同步方法不受影响.</li><li>对象锁和类锁互相不影响</li></ul><h3 id="测试代码及过程"><a href="#测试代码及过程" class="headerlink" title="测试代码及过程"></a>测试代码及过程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuzhihang.tool.sync;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuzhihang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/7/11 16:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncMainTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SyncTest syncTest1 = <span class="keyword">new</span> SyncTest();</span><br><span class="line">        <span class="comment">// SyncTest syncTest2 = new SyncTest();</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; syncTest1.methodA(), <span class="string">&quot;线程 01 &quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; syncTest1.methodB(), <span class="string">&quot;线程 02 &quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;start&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;sleep&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;start&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;sleep&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">300</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上为一个简单的测试代码, 指使用两个线程分别调用两个方法, 通过打印结果可以看出顺序是乱序的, 其中线程的 start() 顺序并不代表线程的执行顺序, 在下面测试中假设是 “线程01” 先执行.</p><h4 id="1-A-B-方法分别添加synchronized关键字-同一对象"><a href="#1-A-B-方法分别添加synchronized关键字-同一对象" class="headerlink" title="1.A B 方法分别添加synchronized关键字 + 同一对象"></a>1.A B 方法分别添加synchronized关键字 + 同一对象</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结论: 方法 A 阻塞, 方法 B 等待 A 执行完毕后才继续执行.</p><h4 id="2-A-B-方法分别添加synchronized关键字-不同对象"><a href="#2-A-B-方法分别添加synchronized关键字-不同对象" class="headerlink" title="2.A B 方法分别添加synchronized关键字 + 不同对象"></a>2.A B 方法分别添加synchronized关键字 + 不同对象</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncMainTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SyncTest syncTest1 = <span class="keyword">new</span> SyncTest();</span><br><span class="line">        SyncTest syncTest2 = <span class="keyword">new</span> SyncTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; syncTest1.methodA(), <span class="string">&quot;线程 01 &quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; syncTest2.methodB(), <span class="string">&quot;线程 02 &quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结论: 方法 A 阻塞, 方法 B 不受影响.</p><h4 id="3-A-方法分别添加synchronized关键字-B方法不添加"><a href="#3-A-方法分别添加synchronized关键字-B方法不添加" class="headerlink" title="3.A 方法分别添加synchronized关键字 B方法不添加"></a>3.A 方法分别添加synchronized关键字 B方法不添加</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结论: 方法 A 阻塞, 方法 B 不受影响.</p><h4 id="4-A-B-方法分别添加-static-synchronized-不同对象"><a href="#4-A-B-方法分别添加-static-synchronized-不同对象" class="headerlink" title="4.A B 方法分别添加 static synchronized  + 不同对象"></a>4.A B 方法分别添加 static synchronized  + 不同对象</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncMainTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SyncTest syncTest1 = <span class="keyword">new</span> SyncTest();</span><br><span class="line">        SyncTest syncTest2 = <span class="keyword">new</span> SyncTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; syncTest1.methodA(), <span class="string">&quot;线程 01 &quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; syncTest2.methodB(), <span class="string">&quot;线程 02 &quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结论: 方法 A 阻塞, 方法 B 等待 A结束后继续执行.</p><h4 id="5-A-方法添加-static-synchronized-B-方法添加-synchronized-不同对象"><a href="#5-A-方法添加-static-synchronized-B-方法添加-synchronized-不同对象" class="headerlink" title="5.A 方法添加 static synchronized, B 方法添加 synchronized  + 不同对象"></a>5.A 方法添加 static synchronized, B 方法添加 synchronized  + 不同对象</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncMainTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SyncTest syncTest1 = <span class="keyword">new</span> SyncTest();</span><br><span class="line">        SyncTest syncTest2 = <span class="keyword">new</span> SyncTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; syncTest1.methodA(), <span class="string">&quot;线程 01 &quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; syncTest2.methodB(), <span class="string">&quot;线程 02 &quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结论: 方法 A 阻塞, 方法 B 不受影响.</p><h4 id="6-A-B-方法内添加-synchronized-this"><a href="#6-A-B-方法内添加-synchronized-this" class="headerlink" title="6.A B 方法内添加 synchronized(this)"></a>6.A B 方法内添加 synchronized(this)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结论: 同一对象 A 阻塞 B等待, 不同对象 A阻塞 B不受影响</p><h4 id="7-A-B-方法内添加-synchronized-SyncTest-class"><a href="#7-A-B-方法内添加-synchronized-SyncTest-class" class="headerlink" title="7.A B 方法内添加 synchronized(SyncTest.class)"></a>7.A B 方法内添加 synchronized(SyncTest.class)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SyncTest.class) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SyncTest.class) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结论: 同一/不同对象 A 阻塞 B等待</p><h4 id="8-A-方法内添加-synchronized-SyncTest-class-B-方法内添加-synchronized-this"><a href="#8-A-方法内添加-synchronized-SyncTest-class-B-方法内添加-synchronized-this" class="headerlink" title="8.A 方法内添加 synchronized(SyncTest.class), B 方法内添加 synchronized(this)"></a>8.A 方法内添加 synchronized(SyncTest.class), B 方法内添加 synchronized(this)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SyncTest.class) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结论: 同一/不同对象 A 阻塞 B不受影响</p><h4 id="9-A-方法内添加-synchronized-SyncTest-class-B-方法内添加-synchronized-OtherObj"><a href="#9-A-方法内添加-synchronized-SyncTest-class-B-方法内添加-synchronized-OtherObj" class="headerlink" title="9.A 方法内添加 synchronized(SyncTest.class), B 方法内添加 synchronized(OtherObj)"></a>9.A 方法内添加 synchronized(SyncTest.class), B 方法内添加 synchronized(OtherObj)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String string = <span class="string">&quot;lock&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SyncTest.class) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (string) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结论: 同一/不同对象 A 阻塞 B不受影响</p>]]></content>
      
      
      <categories>
          
          <category> 并发和锁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>synchronized同步锁原理</title>
      <link href="2018/06/11/synchronized-synchronous-lock-principle.html"/>
      <url>2018/06/11/synchronized-synchronous-lock-principle.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul><li>在多线程操作中volatile关键字可以保证共享变量的内存可见性, 但是并不能保证操作的原子性, 这时候就需要用到锁, synchronized同步锁是java关键字, 是内置的语言实现.</li><li>synchronized加锁和线程结束或异常锁的释放过程由JVM进行控制</li><li>synchronized关键字可以使用在方法和同步代码块中, 不同的使用方式, 锁的结果是不同的</li><li>重量级锁 + 可重入</li></ul><a id="more"></a><h3 id="synchronized底层原理"><a href="#synchronized底层原理" class="headerlink" title="synchronized底层原理"></a>synchronized底层原理</h3><p>1.代码示例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuzhihang.tool.java;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuzhihang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/06/11 16:05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncTest1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncTest2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.使用 javap -v SynchronizedTest.class 查看代码的对应字节码如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ javap -v SynchronizedTest.class</span><br><span class="line">Classfile &#x2F;C:&#x2F;Users&#x2F;liuzhihang&#x2F;Desktop&#x2F;SynchronizedTest.class</span><br><span class="line">  Last modified 2018-7-10; size 518 bytes</span><br><span class="line">  MD5 checksum ba48def77b226e7b9ac28121ec423c16</span><br><span class="line">  Compiled from &quot;SynchronizedTest.java&quot;</span><br><span class="line">public class com.liuzhihang.tool.java.SynchronizedTest</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">&#x2F;&#x2F; 常量池省略</span><br><span class="line">&#123;</span><br><span class="line">  &#x2F;&#x2F; 构造方法省略</span><br><span class="line"></span><br><span class="line">  public void syncTest1();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;3, locals&#x3D;3, args_size&#x3D;1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: dup</span><br><span class="line">         2: astore_1</span><br><span class="line">         3: monitorenter</span><br><span class="line">         4: aload_0</span><br><span class="line">         5: dup</span><br><span class="line">         6: getfield      #2                    &#x2F;&#x2F; Field i:I</span><br><span class="line">         9: iconst_1</span><br><span class="line">        10: iadd</span><br><span class="line">        11: putfield      #2                    &#x2F;&#x2F; Field i:I</span><br><span class="line">        14: aload_1</span><br><span class="line">        15: monitorexit</span><br><span class="line">        16: goto          24</span><br><span class="line">        19: astore_2</span><br><span class="line">        20: aload_1</span><br><span class="line">        21: monitorexit</span><br><span class="line">        22: aload_2</span><br><span class="line">        23: athrow</span><br><span class="line">        24: return</span><br><span class="line">      Exception table:</span><br><span class="line">  &#x2F;&#x2F; 省略代码</span><br><span class="line"></span><br><span class="line">  public synchronized void syncTest2();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_SYNCHRONIZED</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;3, locals&#x3D;1, args_size&#x3D;1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: dup</span><br><span class="line">         2: getfield      #3                  &#x2F;&#x2F; Field j:I</span><br><span class="line">         5: iconst_1</span><br><span class="line">         6: iadd</span><br><span class="line">         7: putfield      #3                  &#x2F;&#x2F; Field j:I</span><br><span class="line">        10: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 22: 0</span><br><span class="line">        line 23: 10</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;SynchronizedTest.java&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.结论</p><ul><li>同步语句块的实现使用的是 monitorenter 和 monitorexit 指令, 其中有两个 monitorexit 因为不能确保是正常结束还是异常结束, 所以另一个是用来确保异常结束时释放 monitor指令.</li><li>同步方法时使用的是 flags中的 ACC_SYNCHRONIZED 来标识该方法为同步方法, JVM在调用该方法时便会执行相应的同步调用.</li><li>每个线程都维护自己的监视器(monitor), 只要是同步调用进行相关操作时要先获得 monitor, 否则将被阻塞</li></ul>]]></content>
      
      
      <categories>
          
          <category> 并发和锁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>volatile关键字</title>
      <link href="2018/06/09/volatile-keyword.html"/>
      <url>2018/06/09/volatile-keyword.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>在多线程操作共享变量时, 会使用volatile修饰共享变量, 比如单例模式的双重锁检查中, 并且在concurrent包下也大量使用了volatile关键字;<br>volatile可以对类属性进行修饰, 从而确保线程每次都是从主存中获取属性, 操作完毕后写回主存.</p><a id="more"></a><h3 id="java内存模型"><a href="#java内存模型" class="headerlink" title="java内存模型"></a>java内存模型</h3><img src= "https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/loading.gif" data-lazy-src="/resources/concurrent/volatile.png" width="800" hegiht="800" align=center /><p> 在多线程同时对共享变量进行操作过程中, 每个线程会拷贝一份共享变量到自己的工作内存中进行相关操作, 操作完毕后会将结果写入到主存中.<br> 而volatile关键字可以保证操作的可见性和有序性, 但是却不能保证原子性.</p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>指一个操作或者多个操作要么全部执行要么全部都不执行, 操作过程整体是一个原子, 不被分割打断.</p><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>当多个线程访问同一个变量时, 一个线程修改了这个变量的值, 其他线程能够立即看得到修改的值.</p><h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>即程序执行的顺序按照代码的先后顺序执行<br>主要原因是因为处理器在处理程序时会进行指令重排, 对代码进行优化, 指令重排在单线程中得到的结果是一致的, 但是在多线程中就会造成各种错误.</p><h3 id="volatile关键字作用"><a href="#volatile关键字作用" class="headerlink" title="volatile关键字作用"></a>volatile关键字作用</h3><p>1.使用volatile关键字修饰的变量,会强制将修改的值写入到主存中<br>2.volatile不保证原子性, 在多线程操作下仅能保证操作别的线程可见, 在多线程情况下同时操作共享变量依然会有数据不正确的情况.<br>3.volatile会防止指令重排</p>]]></content>
      
      
      <categories>
          
          <category> 并发和锁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> volatile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringAop代理的选择</title>
      <link href="2018/05/21/springaop-agent-selection.html"/>
      <url>2018/05/21/springaop-agent-selection.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Spring动态创建bean过程, 是如何进行选择使用 jdk还是cglib进行代理的, 可以通过源码进行解析</p><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><p>通过断点进行跟踪主要执行过程在 DefaultAopProxyFactory, 通过判断条件是使用Cglib还是Jdk</p><a id="more"></a><h3 id="相关源码解析"><a href="#相关源码解析" class="headerlink" title="相关源码解析"></a>相关源码解析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAopProxyFactory</span> <span class="keyword">implements</span> <span class="title">AopProxyFactory</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">    <span class="comment">//判断条件 是否优化, 返回是否直接代理目标类以及任何接口或者没有用户提供的代理接口</span></span><br><span class="line"><span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line"><span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;TargetSource cannot determine target class: &quot;</span> +</span><br><span class="line"><span class="string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否是接口, 和已经使用jdk代理</span></span><br><span class="line"><span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Determine whether the supplied &#123;<span class="doctag">@link</span> AdvisedSupport&#125; has only the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.aop.SpringProxy&#125; interface specified</span></span><br><span class="line"><span class="comment"> * (or no proxy interfaces specified at all).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasNoUserSuppliedProxyInterfaces</span><span class="params">(AdvisedSupport config)</span> </span>&#123;</span><br><span class="line">Class&lt;?&gt;[] ifcs = config.getProxiedInterfaces();</span><br><span class="line"><span class="keyword">return</span> (ifcs.length == <span class="number">0</span> || (ifcs.length == <span class="number">1</span> &amp;&amp; SpringProxy.class.isAssignableFrom(ifcs[<span class="number">0</span>])));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> aop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cglib动态代理</title>
      <link href="2018/05/18/cglib-dynamic-proxy.html"/>
      <url>2018/05/18/cglib-dynamic-proxy.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Spring动态代理可以选择使用jdk动态代理, 或者cglib动态代理,  cglib动态代理位于 net.sf.cglib.proxy 包下.</p><p>使用时涉及<br>接口: net.sf.cglib.proxy.MethodInterceptor<br>用来生成动态子类的类类: net.sf.cglib.proxy.Enhancer</p><p>注意: cglib 动态代理是基于类的代理, 是通过对指定的业务类生成一个子类, 并覆盖其中业务方法实现代理. 因为使用继承, 所以被代理类不能使 final 修饰</p><a id="more"></a><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><p>1.创建MethodInterceptor接口的实现类, 并编写intercept方法的实现<br>2.通过methodProxy.invokeSuper(o, objects);调用父类的方法<br>3.创建Enhancer, 通过 setSuperclass(Class superclass)方法指定父类(被代理类), 通过 setCallback(final Callback callback)方法指定代理<br>4.enhancer.create() 生成代理, 调用被代理类的方法</p><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><p>按照步骤编写简易逻辑代码.</p><h4 id="创建MethodInterceptor接口的实现类"><a href="#创建MethodInterceptor接口的实现类" class="headerlink" title="创建MethodInterceptor接口的实现类"></a>创建MethodInterceptor接口的实现类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于类的代理 即使类没有实现接口也可以被代理</span></span><br><span class="line"><span class="comment"> * 主要是基于类生成一个继承的子类 所以 类和方法不要声明为 final</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuzhihang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/5/18 10:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMethodInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;cglib动态代理 before . . .&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Object invoke = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            invoke = methodProxy.invokeSuper(o, objects);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">            System.err.println(<span class="string">&quot;cglib动态代理 error: &quot;</span> + throwable.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;cglib动态代理 after . . .&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> invoke;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建Enhancer"><a href="#创建Enhancer" class="headerlink" title="创建Enhancer"></a>创建Enhancer</h4><p>创建Enhancer, 通过 setSuperclass(Class superclass)方法指定父类(被代理类), 通过 setCallback(final Callback callback)方法指定代理</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibMainTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(SubjectCglib.class);</span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> MyMethodInterceptor());</span><br><span class="line"></span><br><span class="line">        SubjectCglib subjectCglib = (SubjectCglib) enhancer.create();</span><br><span class="line"></span><br><span class="line">        System.err.println(subjectCglib.getAge(<span class="string">&quot;liuzhihang&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="可以将二者合并到MyInterceptor中"><a href="#可以将二者合并到MyInterceptor中" class="headerlink" title="可以将二者合并到MyInterceptor中"></a>可以将二者合并到MyInterceptor中</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于类的代理 即使类没有实现接口也可以被代理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuzhihang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/5/18 10:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCglibInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.object = object;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(object.getClass());</span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;cglib动态代理 before . . .&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Object invoke = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            invoke = methodProxy.invokeSuper(o, objects);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">            System.err.println(<span class="string">&quot;cglib动态代理 error: &quot;</span> + throwable.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;cglib动态代理 after . . .&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> invoke;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 动态代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jdk动态代理及源码解析</title>
      <link href="2018/05/17/jdk-dynamic-proxy-and-source-code-analysis.html"/>
      <url>2018/05/17/jdk-dynamic-proxy-and-source-code-analysis.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Spring动态代理可以选择使用jdk动态代理, 或者cglib动态代理,  jdk动态代理位于 java.lang.reflect 包下.</p><p>使用时涉及<br>接口: java.lang.reflect.InvocationHandler<br>动态代理类: java.lang.reflect.Proxy</p><p>注意: JDK 动态代理是基于接口的代理, 只能对实现接口的类生成代理, 不能对类进行代理</p><a id="more"></a><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><p>1.创建InvocationHandler接口的实现类, 并编写invoke方法的实现<br>2.创建被代理类的接口及实现类<br>3.使用动态代理类Proxy的静态方法生成代理类实例<br>4.使用实例调用方法</p><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><p>按照步骤编写简易逻辑代码.</p><h4 id="创建InvocationHandler接口的实现类"><a href="#创建InvocationHandler接口的实现类" class="headerlink" title="创建InvocationHandler接口的实现类"></a>创建InvocationHandler接口的实现类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JDK 动态代理</span></span><br><span class="line"><span class="comment"> * 基于接口的代理, 只能对实现接口的类生成代理, 不能对类进行代理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuzhihang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/5/17 10:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 目标对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyInvocationHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;jdk 动态代理 before . . . &quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;当前代理方法为:&quot;</span> + method);</span><br><span class="line">        Object invoke = method.invoke(target, args);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;jdk 动态代理 after . . . &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> invoke;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建被代理类的接口及实现类"><a href="#创建被代理类的接口及实现类" class="headerlink" title="创建被代理类的接口及实现类"></a>创建被代理类的接口及实现类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被代理类的接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuzhihang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/5/17 10:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取名字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取年龄</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">getAge</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被代理类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuzhihang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/5/17 10:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubjectImpl</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SubjectImpl的获取名字方法 . . .&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;liuzhihang&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAge</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(name + <span class="string">&quot;开始获取年龄 . . .&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;25&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用动态代理类Proxy的静态方法生成代理类实例"><a href="#使用动态代理类Proxy的静态方法生成代理类实例" class="headerlink" title="使用动态代理类Proxy的静态方法生成代理类实例"></a>使用动态代理类Proxy的静态方法生成代理类实例</h4><p>获取代理类实例有以下两种方式, 一种是通过Proxy.newProxyInstance(..)获取,  一种是通过 Proxy.getProxyClass(..) 方式获取<br>1.Proxy.newProxyInstance(..)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当代理类实例调用方法时, 会自动跳转到代理类关联的 handler 对象, 通过 method.invoke(target, args) 进行调用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuzhihang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/5/17 10:49</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyMainTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Subject subject = <span class="keyword">new</span> SubjectImpl();</span><br><span class="line"></span><br><span class="line">        ClassLoader classLoader = subject.getClass().getClassLoader();</span><br><span class="line">        Class&lt;?&gt;[] interfaces = subject.getClass().getInterfaces();</span><br><span class="line"></span><br><span class="line">        MyInvocationHandler handler = <span class="keyword">new</span> MyInvocationHandler(subject);</span><br><span class="line">        <span class="comment">// 生成代理类实例</span></span><br><span class="line">        Subject proxyInstance = (Subject) Proxy.newProxyInstance(classLoader, interfaces, handler);</span><br><span class="line"></span><br><span class="line">        String name = proxyInstance.getName();</span><br><span class="line">        String instanceAge = proxyInstance.getAge(<span class="string">&quot;liuzhihang&quot;</span>);</span><br><span class="line">        System.err.println(name + <span class="string">&quot; &quot;</span> + instanceAge);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.Proxy.getProxyClass(..)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当代理类实例调用方法时, 会自动跳转到代理类关联的 handler 对象, 通过 method.invoke(target, args) 进行调用</span></span><br><span class="line"><span class="comment"> * 此方式有异常抛出</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuzhihang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/5/17 10:49</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyMainTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        Subject subject = <span class="keyword">new</span> SubjectImpl();</span><br><span class="line"></span><br><span class="line">        ClassLoader classLoader = subject.getClass().getClassLoader();</span><br><span class="line">        Class&lt;?&gt;[] interfaces = subject.getClass().getInterfaces();</span><br><span class="line"></span><br><span class="line">        MyInvocationHandler handler = <span class="keyword">new</span> MyInvocationHandler(subject);</span><br><span class="line"></span><br><span class="line">            Class&lt;?&gt; proxyClass = Proxy.getProxyClass(classLoader, interfaces);</span><br><span class="line">            Constructor&lt;?&gt; constructor = proxyClass.getConstructor(InvocationHandler.class);</span><br><span class="line"></span><br><span class="line">            Subject subject1 = (Subject) constructor.newInstance(handler);</span><br><span class="line">            String name1 = subject1.getName();</span><br><span class="line">            String instanceAge1 = subject1.getAge(<span class="string">&quot;liuzhihang&quot;</span>);</span><br><span class="line">            System.err.println(name1 + <span class="string">&quot; &quot;</span> + instanceAge1);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException | IllegalAccessException | InvocationTargetException | InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">D:\jdk1.8\bin\java.exe . . .</span><br><span class="line">liuzhihang 25</span><br><span class="line">jdk 动态代理 before . . .</span><br><span class="line">当前代理方法为:public abstract java.lang.String com.liuzhihang.tool.proxy.jdk.Subject.getName()</span><br><span class="line">SubjectImpl的获取名字方法 . . .</span><br><span class="line">jdk 动态代理 after . . .</span><br><span class="line">jdk 动态代理 before . . .</span><br><span class="line">当前代理方法为:public abstract java.lang.String com.liuzhihang.tool.proxy.jdk.Subject.getAge(java.lang.String)</span><br><span class="line">liuzhihang开始获取年龄 . . .</span><br><span class="line">jdk 动态代理 after . . .</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>结论: 代理实例在每次调用方法是都会通过代理类进行调用</p><h3 id="相关源码解析"><a href="#相关源码解析" class="headerlink" title="相关源码解析"></a>相关源码解析</h3><p>完整注释可自己查看相关源码, 源码过程应当DeBug多走走.<br>1.调用 Proxy.newProxyInstance 方法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &#x2F;**</span><br><span class="line"> * 返回指定接口的代理类实例，该接口将方法调用分派给指定的调用处理程序</span><br><span class="line"> *&#x2F;</span><br><span class="line">@CallerSensitive</span><br><span class="line">public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 非空校验</span><br><span class="line">    Objects.requireNonNull(h);</span><br><span class="line"></span><br><span class="line">    final Class&lt;?&gt;[] intfs &#x3D; interfaces.clone();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 获取系统安全接口</span><br><span class="line">    final SecurityManager sm &#x3D; System.getSecurityManager();</span><br><span class="line">    if (sm !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 校验权限</span><br><span class="line">        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 从缓存中获取代理类 或者 生成新的代理类</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Class&lt;?&gt; cl &#x3D; getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 通过反射获取构造函数对象并生成代理类实例</span><br><span class="line">     *&#x2F;</span><br><span class="line">    try &#123;</span><br><span class="line">        if (sm !&#x3D; null) &#123;</span><br><span class="line">            checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 获取构造</span><br><span class="line">        final Constructor&lt;?&gt; cons &#x3D; cl.getConstructor(constructorParams);</span><br><span class="line">        final InvocationHandler ih &#x3D; h;</span><br><span class="line">        &#x2F;&#x2F; 验证代理类的修饰符</span><br><span class="line">        if (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">            &#x2F;&#x2F; 修改访问权限</span><br><span class="line">            AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                public Void run() &#123;</span><br><span class="line">                    &#x2F;&#x2F; 将此对象的可访问标志设置为指定的布尔值, true表示反射对象在使用时应禁止Java语言访问检查, false表示反射对象应强制执行Java语言访问检查</span><br><span class="line">                    cons.setAccessible(true);</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;生成实例, 并将参数传入构造</span><br><span class="line">        return cons.newInstance(new Object[]&#123;h&#125;);</span><br><span class="line">    &#125; catch (IllegalAccessException | InstantiationException e) &#123;</span><br><span class="line">        throw new InternalError(e.toString(), e);</span><br><span class="line">    &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">        Throwable t &#x3D; e.getCause();</span><br><span class="line">        if (t instanceof RuntimeException) &#123;</span><br><span class="line">            throw (RuntimeException) t;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new InternalError(t.toString(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">        throw new InternalError(e.toString(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看出获取代理类是在 Class&lt;?&gt; cl = getProxyClass0(loader, intfs); 处, 继续相关逻辑<br>2.获取代理类相关逻辑</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 生成代理类, 之前必须进行权限检查</span><br><span class="line"> *&#x2F;</span><br><span class="line">private static Class&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class="line">                                       Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">    if (interfaces.length &gt; 65535) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;interface limit exceeded&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;如果由实现给定接口的给定加载器定义的代理类存在，则它将简单地返回缓存副本; 否则，它将通过Proxy Class Factory创建代理类</span><br><span class="line">    return proxyClassCache.get(loader, interfaces);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.proxyClassCache.get(loader, interfaces);<br>java.lang.reflect.WeakCache#get(..) 介绍</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &#x2F;**</span><br><span class="line"> * 通过缓存查找值, 如果缓存中没有给定的（key，sub Key）对的条目或条目已被清除，则它总是评估&#123;Key sub Key Factory&#125;函数并可选择评估&#123;Factory value&#125;函数</span><br><span class="line"> *&#x2F;</span><br><span class="line">public V get(K key, P parameter) &#123;</span><br><span class="line">    &#x2F;&#x2F; 非空校验</span><br><span class="line">    Objects.requireNonNull(parameter);</span><br><span class="line">    &#x2F;&#x2F; 判断移除队列</span><br><span class="line">    expungeStaleEntries();</span><br><span class="line">    &#x2F;&#x2F; 缓存key</span><br><span class="line">    Object cacheKey &#x3D; CacheKey.valueOf(key, refQueue);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 延迟加载使用二级map</span><br><span class="line">    ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap &#x3D; map.get(cacheKey);</span><br><span class="line">    if (valuesMap &#x3D;&#x3D; null) &#123;</span><br><span class="line">        ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; oldValuesMap</span><br><span class="line">                &#x3D; map.putIfAbsent(cacheKey,</span><br><span class="line">                valuesMap &#x3D; new ConcurrentHashMap&lt;&gt;());</span><br><span class="line">        if (oldValuesMap !&#x3D; null) &#123;</span><br><span class="line">            valuesMap &#x3D; oldValuesMap;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 创建子key 并根据key 检索supplier</span><br><span class="line">    Object subKey &#x3D; Objects.requireNonNull(subKeyFactory.apply(key, parameter));</span><br><span class="line">    &#x2F;&#x2F; 根据key获取supplier</span><br><span class="line">    Supplier&lt;V&gt; supplier &#x3D; valuesMap.get(subKey);</span><br><span class="line">    Factory factory &#x3D; null;</span><br><span class="line"></span><br><span class="line">    while (true) &#123;</span><br><span class="line">        if (supplier !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; supplier 可能为 Factory 或者 CacheValue&lt;V&gt; 的实例, 从缓存中获取到则直接返回</span><br><span class="line">            V value &#x3D; supplier.get();</span><br><span class="line">            if (value !&#x3D; null) &#123;</span><br><span class="line">                return value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; factory不存在则创建</span><br><span class="line">        if (factory &#x3D;&#x3D; null) &#123;</span><br><span class="line">            factory &#x3D; new Factory(key, parameter, subKey, valuesMap);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; supplier 为null</span><br><span class="line">        if (supplier &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 从valuesMap获取supplier</span><br><span class="line">            supplier &#x3D; valuesMap.putIfAbsent(subKey, factory);</span><br><span class="line">            if (supplier &#x3D;&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F; successfully installed Factory</span><br><span class="line">                supplier &#x3D; factory;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; else retry with winning supplier</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (valuesMap.replace(subKey, supplier, factory)) &#123;</span><br><span class="line">                &#x2F;&#x2F; successfully replaced</span><br><span class="line">                &#x2F;&#x2F; cleared CacheEntry &#x2F; unsuccessful Factory</span><br><span class="line">                &#x2F;&#x2F; with our Factory</span><br><span class="line">                supplier &#x3D; factory;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; retry with current supplier</span><br><span class="line">                supplier &#x3D; valuesMap.get(subKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以发现重点在 Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter)); 获取 subKey 的过程中.<br>4.subKeyFactory.apply(key, parameter)<br>Debug发现在此处调用的是 java.lang.reflect.Proxy.ProxyClassFactory 静态内部类,<br>此处根据接口的数量生成二级缓存</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个工厂函数, 用于生成, 定义并返回给定ClassLoader和接口数组的代理类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyClassFactory</span></span></span><br><span class="line">        implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 所有代理类的前缀</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String proxyClassNamePrefix = <span class="string">&quot;$Proxy&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// next number to use for generation of unique proxy class names</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong nextUniqueNumber = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在IdentityHashMap中, 当且仅当两个key严格相等（key1==key2）时，IdentityHashMap才认为两个key相等</span></span><br><span class="line">        Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = <span class="keyword">new</span> IdentityHashMap&lt;&gt;(interfaces.length);</span><br><span class="line">        <span class="comment">// 循环接口数组</span></span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 验证类加载器是否将此接口的名称解析为同一个Class对象</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Class&lt;?&gt; interfaceClass = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获取接口的 class</span></span><br><span class="line">                interfaceClass = Class.forName(intf.getName(), <span class="keyword">false</span>, loader);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (interfaceClass != intf) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                        intf + <span class="string">&quot; is not visible from class loader&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 验证interfaceClass是否为接口</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (!interfaceClass.isInterface()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                        interfaceClass.getName() + <span class="string">&quot; is not an interface&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 验证接口是否重复</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (interfaceSet.put(interfaceClass, Boolean.TRUE) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                        <span class="string">&quot;repeated interface: &quot;</span> + interfaceClass.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String proxyPkg = <span class="keyword">null</span>;     <span class="comment">// package to define proxy class in</span></span><br><span class="line">        <span class="keyword">int</span> accessFlags = Modifier.PUBLIC | Modifier.FINAL;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 验证所有非公开代理接口是否在同一个包中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">            <span class="keyword">int</span> flags = intf.getModifiers();</span><br><span class="line">            <span class="keyword">if</span> (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">                accessFlags = Modifier.FINAL;</span><br><span class="line">                String name = intf.getName();</span><br><span class="line">                <span class="keyword">int</span> n = name.lastIndexOf(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                String pkg = ((n == -<span class="number">1</span>) ? <span class="string">&quot;&quot;</span> : name.substring(<span class="number">0</span>, n + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    proxyPkg = pkg;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pkg.equals(proxyPkg)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                            <span class="string">&quot;non-public interfaces from different packages&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果没有非公开的代理接口，使用 com.sun.proxy package</span></span><br><span class="line">            proxyPkg = ReflectUtil.PROXY_PACKAGE + <span class="string">&quot;.&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 为要生成的代理类选择一个名称</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">long</span> num = nextUniqueNumber.getAndIncrement();</span><br><span class="line">        String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 生成代理类</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> defineClass0(loader, proxyName,</span><br><span class="line">                    proxyClassFile, <span class="number">0</span>, proxyClassFile.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassFormatError e) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * A ClassFormatError here means that (barring bugs in the</span></span><br><span class="line"><span class="comment">             * proxy class generation code) there was some other</span></span><br><span class="line"><span class="comment">             * invalid aspect of the arguments supplied to the proxy</span></span><br><span class="line"><span class="comment">             * class creation (such as virtual machine limitations</span></span><br><span class="line"><span class="comment">             * exceeded).</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.生辰给代理类<br>byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);<br>可以在测试类中添加以下内容打印出代理类:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">System.setProperty(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);</span><br></pre></td></tr></table></figure><p>代理类内容如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by Fernflower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.sun.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.liuzhihang.tool.proxy.jdk.Subject;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m4;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getName</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getAge</span><span class="params">(String var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m4, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;equals&quot;</span>, Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>));</span><br><span class="line">            m3 = Class.forName(<span class="string">&quot;com.liuzhihang.tool.proxy.jdk.Subject&quot;</span>).getMethod(<span class="string">&quot;getName&quot;</span>);</span><br><span class="line">            m2 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;toString&quot;</span>);</span><br><span class="line">            m4 = Class.forName(<span class="string">&quot;com.liuzhihang.tool.proxy.jdk.Subject&quot;</span>).getMethod(<span class="string">&quot;getAge&quot;</span>, Class.forName(<span class="string">&quot;java.lang.String&quot;</span>));</span><br><span class="line">            m0 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;hashCode&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出生成的$Proxy0类继承Proxy动态代理类并实现了Subject被代理接口, 实现所有方法<br>通过 super.h.invoke(this, m1, new Object[]{var1}) 内部调用了 InvocationHandler.invoke(…)方法, 通过反射调用代理实例的方法</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 动态代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>懒汉单例模式线程安全</title>
      <link href="2018/02/21/lazy-singleton-mode-thread-safe.html"/>
      <url>2018/02/21/lazy-singleton-mode-thread-safe.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>一个类中只有一个实例, 且能够自行实例化提供这个实例, 同时提供全局访问的方法.</p></blockquote><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>1.构造私有化: 确保外部不能使用new直接创建对象<br>2.内部静态属性创建实例<br>3.对外公共静态获取对象方法</p><a id="more"></a><h4 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单例模式</span></span><br><span class="line"><span class="comment"> * 1. 构造私有化: 确保外部不能使用new直接创建对象</span></span><br><span class="line"><span class="comment"> * 2. 内部静态属性创建实例</span></span><br><span class="line"><span class="comment"> * 3. 对外公共静态获取对象方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuzhihang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/3/27 17:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonPattern</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonPattern</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonPattern singletonPattern = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonPattern <span class="title">getSingletonPattern</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (singletonPattern == <span class="keyword">null</span>) &#123;</span><br><span class="line">            singletonPattern = <span class="keyword">new</span> SingletonPattern();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> singletonPattern;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>1.懒汉式: 懒汉模式, 项目启动时不生成对象, 而是在首次创建该对象的时候生成唯一实例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉模式, 项目启动时不生成对象, 而是在首次创建该对象的时候生成唯一实例</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuzhihang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/4/2 16:24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyPattern</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyPattern</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazyPattern lazyPattern = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyPattern <span class="title">getLazyPattern</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (lazyPattern == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 模拟一系列耗时操作</span></span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                lazyPattern = <span class="keyword">new</span> LazyPattern();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> lazyPattern;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.饿汉式: 项目启动时, 进行加载, 会导致项目启动较慢, 并且无论后面是否用到都会进行加载</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 饿汉式单例模式</span></span><br><span class="line"><span class="comment"> * 项目启动时, 进行加载, 会导致项目启动较慢, 并且无论后面是否用到都会进行加载</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuzhihang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/4/2 18:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungerPattern</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungerPattern</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HungerPattern hungerPattern = <span class="keyword">new</span> HungerPattern();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungerPattern <span class="title">getHungerPattern</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hungerPattern;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><p>在多线程情况下对单例模式进行测试:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuzhihang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/3/27 19:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ThreadTest[] threadTests = <span class="keyword">new</span> ThreadTest[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadTests.length; i++) &#123;</span><br><span class="line">            threadTests[i] = <span class="keyword">new</span> ThreadTest();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadTests.length; i++) &#123;</span><br><span class="line">            threadTests[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 懒汉模式</span></span><br><span class="line">        System.out.println(LazyPattern.getLazyPattern().hashCode());</span><br><span class="line">        <span class="comment">// 饿汉模式</span></span><br><span class="line">        <span class="comment">// System.out.println(HungerPattern.getHungerPattern().hashCode());</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果:</p><p>1.饿汉模式</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">D:\jdk1.8\bin\java.exe . . .</span><br><span class="line">1294123621</span><br><span class="line">1294123621</span><br><span class="line">1294123621</span><br><span class="line">1294123621</span><br><span class="line">1294123621</span><br><span class="line">1294123621</span><br><span class="line">1294123621</span><br><span class="line">1294123621</span><br><span class="line">1294123621</span><br><span class="line">1294123621</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>2.懒汉模式</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">D:\jdk1.8\bin\java.exe . . .</span><br><span class="line">140919816</span><br><span class="line">1359128134</span><br><span class="line">1385166630</span><br><span class="line">924507082</span><br><span class="line">67641385</span><br><span class="line">508832262</span><br><span class="line">574926395</span><br><span class="line">140919816</span><br><span class="line">1442414714</span><br><span class="line">896298396</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>结论: 在懒汉单例模式下不能保证线程的安全性</p><h3 id="懒汉模式的线程安全优化"><a href="#懒汉模式的线程安全优化" class="headerlink" title="懒汉模式的线程安全优化"></a>懒汉模式的线程安全优化</h3><p>饿汉模式会造成资源浪费, 启动慢等结果, 下面对懒汉模式进行线程安全优化.</p><h4 id="synchronized-锁住静态方法"><a href="#synchronized-锁住静态方法" class="headerlink" title="synchronized 锁住静态方法"></a>synchronized 锁住静态方法</h4><p>锁住静态方法 类级锁 影响范围较大, 导致效率相对较低</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式</span></span><br><span class="line"><span class="comment"> * 在方法上添加 synchronized 关键字 锁类</span></span><br><span class="line"><span class="comment"> * 同步方法的方式, 导致效率相对较低</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuzhihang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/4/3 14:27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncLazyPattern</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SyncLazyPattern</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SyncLazyPattern syncLazyPattern = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SyncLazyPattern <span class="title">getSyncLazyPattern</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (syncLazyPattern == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                syncLazyPattern = <span class="keyword">new</span> SyncLazyPattern();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> syncLazyPattern;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="synchronized-锁住代码块"><a href="#synchronized-锁住代码块" class="headerlink" title="synchronized 锁住代码块"></a>synchronized 锁住代码块</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuzhihang.demo.singleton;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 锁代码块的方式虽然可以保证结果一致性</span></span><br><span class="line"><span class="comment"> * 但锁住很多操作, 同样会导致效率低下</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuzhihang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/4/3 15:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncCodeBlockLazyPattern</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SyncCodeBlockLazyPattern</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SyncCodeBlockLazyPattern syncCodeBlockLazyPattern = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SyncCodeBlockLazyPattern <span class="title">getSyncCodeBlockLazyPattern</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 锁住具体执行业务逻辑的代码</span></span><br><span class="line">            <span class="keyword">synchronized</span> (SyncCodeBlockLazyPattern.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (syncCodeBlockLazyPattern == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    syncCodeBlockLazyPattern = <span class="keyword">new</span> SyncCodeBlockLazyPattern();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> syncCodeBlockLazyPattern;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="双重检查锁机制-推荐"><a href="#双重检查锁机制-推荐" class="headerlink" title="双重检查锁机制(推荐)"></a>双重检查锁机制(推荐)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuzhihang.demo.singleton;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双重锁检查机制, 仅锁住创建对象的部分代码</span></span><br><span class="line"><span class="comment"> * 注意: 在对象前 添加 volatile 关键字 确保可见性, 即 每次获取值从主内存中获取, 同时防止指令重排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuzhihang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/4/3 15:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboCheckLockLazyPattern</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DubboCheckLockLazyPattern</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> DubboCheckLockLazyPattern dubboCheckLockLazyPattern = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DubboCheckLockLazyPattern <span class="title">getDubboCheckLockLazyPattern</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (dubboCheckLockLazyPattern == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 一系列操作</span></span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (DubboCheckLockLazyPattern.class) &#123;</span><br><span class="line">                    <span class="comment">// 二次检查</span></span><br><span class="line">                    <span class="keyword">if</span> (dubboCheckLockLazyPattern == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        dubboCheckLockLazyPattern = <span class="keyword">new</span> DubboCheckLockLazyPattern();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dubboCheckLockLazyPattern;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>poi读写Excel简单介绍</title>
      <link href="2018/02/15/poi-read-and-write-excel-brief-introduction.html"/>
      <url>2018/02/15/poi-read-and-write-excel-brief-introduction.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>Apache POI 可以对Microsoft Office 进行操作, 下面是工作中使用的对Excel进行读写操作的常用方式.</p></blockquote><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- excel poi --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.poi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>poi<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.poi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>poi-ooxml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>主要介绍读写时, 分别常用到的一些对象及其含义, 方便自己编写util.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuzhihang.tool.excel.poi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.poi.hssf.usermodel.HSSFWorkbook;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.ss.usermodel.Row;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.ss.usermodel.Sheet;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.ss.usermodel.Workbook;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.xssf.usermodel.XSSFSheet;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.xssf.usermodel.XSSFWorkbook;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuzhihang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/4/20 16:12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExcelTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// readerTest();</span></span><br><span class="line">        writerTest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writerTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;c:Users/liuzhihang/Desktop/test.xlsx&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;读取的文件存在!&quot;</span>);</span><br><span class="line">            file.delete();</span><br><span class="line">        &#125;</span><br><span class="line">        file.createNewFile();</span><br><span class="line">        <span class="comment">// 操作 .xls 的 workbook</span></span><br><span class="line">        Workbook hssfWorkbook = <span class="keyword">new</span> HSSFWorkbook();</span><br><span class="line">        <span class="comment">// 操作 .xlsx 的 workbook</span></span><br><span class="line">        XSSFWorkbook xssfWorkbook = <span class="keyword">new</span> XSSFWorkbook();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 sheet 页</span></span><br><span class="line">        XSSFSheet sheet = xssfWorkbook.createSheet();</span><br><span class="line">        <span class="comment">// 创建 0 行 操作对象</span></span><br><span class="line">        Row row0 = sheet.createRow(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 创建单元格并赋值</span></span><br><span class="line">        row0.createCell(<span class="number">0</span>).setCellValue(<span class="string">&quot;序号&quot;</span>);</span><br><span class="line"></span><br><span class="line">        OutputStream outputStream = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">        <span class="comment">// 写入文件</span></span><br><span class="line">        xssfWorkbook.write(outputStream);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readerTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;c:Users/liuzhihang/Desktop/parkingLotTempLate.xlsx&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Workbook workBook = ExcelUtil.getWorkBook(file);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 excel 页</span></span><br><span class="line">        <span class="comment">// Sheet sheetByIndex = workBook.getSheetAt(0);</span></span><br><span class="line">        <span class="comment">// Sheet sheetByName = workBook.getSheet(&quot;Sheet0&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 操作 sheet</span></span><br><span class="line">        Sheet sheet = workBook.getSheetAt(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 获取最后一行行数 从 0 开始</span></span><br><span class="line">        <span class="keyword">int</span> lastRowNum = sheet.getLastRowNum();</span><br><span class="line">        <span class="comment">// 获取总行数</span></span><br><span class="line">        <span class="keyword">int</span> physicalNumberOfRows = sheet.getPhysicalNumberOfRows();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 操作行 获取第0行</span></span><br><span class="line">        Row row = sheet.getRow(<span class="number">0</span>);</span><br><span class="line">        String value = row.getCell(<span class="number">0</span>).getStringCellValue();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="ExcelUtil-简单工具"><a href="#ExcelUtil-简单工具" class="headerlink" title="ExcelUtil 简单工具"></a>ExcelUtil 简单工具</h3><p>poi读写 excel 的简单工具 <a href="https://github.com/liuzhihang/my_project/blob/master/my_project_tool/src/main/java/com/liuzhihang/tool/excel/poi/ExcelUtil.java">ExcelUtil</a>, 实际工作中可结合javaBean使用并重新编写util.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuzhihang.tool.excel.poi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.log4j.Log4j2;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.hssf.usermodel.HSSFWorkbook;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.ss.usermodel.Cell;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.ss.usermodel.Row;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.ss.usermodel.Sheet;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.ss.usermodel.Workbook;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.xssf.usermodel.XSSFWorkbook;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuzhihang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/4/20 12:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Log4j2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExcelUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取两列excel 返回第二列的集合</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> workbook</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">readExcelForTwoColumns</span><span class="params">(Workbook workbook)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (workbook == <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;获取 workbook 为null&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Sheet sheet = workbook.getSheetAt(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//获取总行数</span></span><br><span class="line">            <span class="keyword">int</span> rowNum = sheet.getLastRowNum();</span><br><span class="line">            <span class="comment">//正文内容应该从第二行开始，第一行为文件的标头的标题</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rowNum; i++) &#123;</span><br><span class="line">                Row row = sheet.getRow(i + <span class="number">1</span>);</span><br><span class="line">                String value = getCellValue(row.getCell(<span class="number">1</span>)).toString();</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.isNotBlank(value)) &#123;</span><br><span class="line">                    list.add(value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写 excel</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> excelFile</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writerExcelForTwoColumns</span><span class="params">(File excelFile, List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        OutputStream outputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            outputStream = <span class="keyword">new</span> FileOutputStream(excelFile);</span><br><span class="line"></span><br><span class="line">            Workbook workBook = <span class="keyword">null</span>;</span><br><span class="line">            String fileName = excelFile.getName();</span><br><span class="line">            <span class="keyword">if</span> (fileName.endsWith(<span class="string">&quot;.xls&quot;</span>)) &#123;</span><br><span class="line">                workBook = <span class="keyword">new</span> HSSFWorkbook();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fileName.endsWith(<span class="string">&quot;.xlsx&quot;</span>)) &#123;</span><br><span class="line">                workBook = <span class="keyword">new</span> XSSFWorkbook();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;文件格式不正确!, 当前文件名:&#123;&#125;&quot;</span>, fileName);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;文件格式不正确&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 创建第 0 页</span></span><br><span class="line">            Sheet sheet = workBook.createSheet();</span><br><span class="line">            Row row1 = sheet.createRow(<span class="number">0</span>);</span><br><span class="line">            row1.createCell(<span class="number">0</span>).setCellValue(<span class="string">&quot;序号&quot;</span>);</span><br><span class="line">            row1.createCell(<span class="number">1</span>).setCellValue(<span class="string">&quot;编号&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">                Row row = sheet.createRow(i + <span class="number">1</span>);</span><br><span class="line">                row.createCell(<span class="number">0</span>).setCellValue(i + <span class="number">1</span>);</span><br><span class="line">                row.createCell(<span class="number">1</span>).setCellValue(list.get(i));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            workBook.write(outputStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;写excel失败&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                outputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取工作表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Workbook <span class="title">getWorkBook</span><span class="params">(File file)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        String fileName = file.getName();</span><br><span class="line">        Workbook workbook = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream inputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            <span class="keyword">if</span> (fileName.endsWith(<span class="string">&quot;.xls&quot;</span>)) &#123;</span><br><span class="line">                workbook = <span class="keyword">new</span> HSSFWorkbook(inputStream);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fileName.endsWith(<span class="string">&quot;.xlsx&quot;</span>)) &#123;</span><br><span class="line">                workbook = <span class="keyword">new</span> XSSFWorkbook(inputStream);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;文件格式不正确!, 当前文件名:&#123;&#125;&quot;</span>, fileName);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;文件格式不正确&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> workbook;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取单元格的数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cell</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getCellValue</span><span class="params">(Cell cell)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cell != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (cell.getCellTypeEnum()) &#123;</span><br><span class="line">                <span class="comment">// 数字</span></span><br><span class="line">                <span class="keyword">case</span> NUMERIC:</span><br><span class="line">                    <span class="keyword">return</span> cell.getNumericCellValue();</span><br><span class="line">                <span class="comment">// 字符串</span></span><br><span class="line">                <span class="keyword">case</span> STRING:</span><br><span class="line">                    <span class="keyword">return</span> cell.getStringCellValue();</span><br><span class="line">                <span class="comment">// 公式</span></span><br><span class="line">                <span class="keyword">case</span> FORMULA:</span><br><span class="line">                    <span class="keyword">return</span> cell.getCellFormula();</span><br><span class="line">                <span class="comment">// 布尔</span></span><br><span class="line">                <span class="keyword">case</span> BOOLEAN:</span><br><span class="line">                    <span class="keyword">return</span> cell.getBooleanCellValue();</span><br><span class="line">                <span class="keyword">case</span> ERROR:</span><br><span class="line">                    <span class="keyword">return</span> cell.getErrorCellValue();</span><br><span class="line">                <span class="comment">// 空</span></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> utils </category>
          
      </categories>
      
      
        <tags>
            
            <tag> poi </tag>
            
            <tag> excel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>protostuff序列化工具</title>
      <link href="2018/02/05/protostuff-serialization-tool.html"/>
      <url>2018/02/05/protostuff-serialization-tool.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>在很多地方都需要用到序列化, 比如在使用redis缓存对象时, 一般情况是实现java Serializable接口. 简单介绍下在慕课网学习到的一个新的序列化工具 —- protostuff.</p><p>在学习中介绍使用该工具可以大大减少对象序列化后字节所占空间, 并提高序列化时间等.</p><p>1.<a href="https://www.imooc.com/video/11823">慕课网课程地址</a><br>2.<a href="https://github.com/eishay/jvm-serializers/wiki">序列化相关工具比较</a></p><a id="more"></a><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- protostuff 序列化工具 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.dyuproject.protostuff<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>protostuff-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.dyuproject.protostuff<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>protostuff-runtime<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="相关使用"><a href="#相关使用" class="headerlink" title="相关使用"></a>相关使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.dyuproject.protostuff.LinkedBuffer;</span><br><span class="line"><span class="keyword">import</span> com.dyuproject.protostuff.ProtostuffIOUtil;</span><br><span class="line"><span class="keyword">import</span> com.dyuproject.protostuff.runtime.RuntimeSchema;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuzhihang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/4/18 15:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtostuffUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">byte</span>[] serialize(T t, Class&lt;T&gt; cls) &#123;</span><br><span class="line"></span><br><span class="line">        RuntimeSchema&lt;T&gt; schema = RuntimeSchema.createFrom(cls);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ProtostuffIOUtil.toByteArray(t, schema, LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">unSerialize</span><span class="params">(<span class="keyword">byte</span>[] bytes, Class&lt;T&gt; cls)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        RuntimeSchema&lt;T&gt; schema = RuntimeSchema.createFrom(cls);</span><br><span class="line">        T message = schema.newMessage();</span><br><span class="line">        ProtostuffIOUtil.mergeFrom(bytes, message, schema);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuzhihang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/4/17 19:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuzhihang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/4/17 19:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtostuffTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(<span class="string">&quot;test0001&quot;</span>);</span><br><span class="line">        user.setUserName(<span class="string">&quot;测试用户0001&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(JSON.toJSONString(user));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] serialize = ProtostuffUtil.serialize(user, User.class);</span><br><span class="line"></span><br><span class="line">        User unSerialize = ProtostuffUtil.unSerialize(serialize, User.class);</span><br><span class="line"></span><br><span class="line">        System.err.println(JSON.toJSONString(unSerialize));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果:</span><br><span class="line">&#123;<span class="string">&quot;id&quot;</span>:<span class="string">&quot;test0001&quot;</span>,<span class="string">&quot;userName&quot;</span>:<span class="string">&quot;测试用户0001&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;id&quot;</span>:<span class="string">&quot;test0001&quot;</span>,<span class="string">&quot;userName&quot;</span>:<span class="string">&quot;测试用户0001&quot;</span>&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> utils </category>
          
      </categories>
      
      
        <tags>
            
            <tag> utils </tag>
            
            <tag> serialize </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Transactional声明式事务</title>
      <link href="2018/01/27/transactional-declarative-transaction.html"/>
      <url>2018/01/27/transactional-declarative-transaction.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>1.声明式事务管理建立在AOP之上的. 其本质是对方法前后进行拦截, 然后在目标方法开始之前创建或者加入一个事务, 在执行完目标方法之后根据执行情况提交或者回滚事务.<br>2.声明式事务最大的优点就是不需要通过编程的方式管理事务, 这样就不需要在业务逻辑代码中掺杂事务管理的代码, 只需在配置文件中做相关的事务规则声明(或通过基于@Transactional注解的方式), 便可以将事务规则应用到业务逻辑中.<br>3.声明式事务不足的地方在于, 与编程式事务相比, 只能作用到方法级别, 无法像编程式事务那样可以作用到代码块级别.</p><h3 id="xml配置"><a href="#xml配置" class="headerlink" title="xml配置"></a>xml配置</h3><p>1.添加命名空间</p><a id="more"></a><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>  <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">.</span> <span class="attr">.</span> <span class="attr">.</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="tag"><span class="string">        . . .</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/tx/spring-tx-3.0.xsd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.添加相关事务支持</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指向数据源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;masterDataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开启事务的Annotation支持 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Transactional注解-使用"><a href="#Transactional注解-使用" class="headerlink" title="@Transactional注解 使用"></a>@Transactional注解 使用</h3><p>@Transactional 可以作用于接口,接口方法,类以及类方法上. 只需要在相应接口,类或方法上加上@Transactional注解即可.</p><h3 id="Transactional-注解介绍"><a href="#Transactional-注解介绍" class="headerlink" title="@Transactional 注解介绍"></a>@Transactional 注解介绍</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.transaction.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Inherited;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.AliasFor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.TransactionDefinition;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Isolation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Propagation;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;) : 可用于接口, 类, 枚举, 注解, 方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Retention</span>(RetentionPolicy.RUNTIME) : 注解会在class字节码文件中存在，在运行时可以通过反射获取到</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Inherited</span> :　子类可以继承父类中的注解</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Documented</span> : 注解将被包含在javadoc中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Transactional &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事务管理器的别名</span></span><br><span class="line"><span class="comment">     * 系统指定多个事务管理器时可通过别名进行区分</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AliasFor(&quot;transactionManager&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可通过在 transactionManager 中设置 &lt;qualifier value=&quot;managerOne&quot;/&gt; 属性类指定名称</span></span><br><span class="line"><span class="comment">     * 可用于确定目标事务管理器，匹配特定的限定符值（或bean名称）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AliasFor(&quot;value&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">transactionManager</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事务的传播机制</span></span><br><span class="line"><span class="comment">     * 默认 Propagation.REQUIRED</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Propagation <span class="title">propagation</span><span class="params">()</span> <span class="keyword">default</span> Propagation.REQUIRED</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事务的隔离级别</span></span><br><span class="line"><span class="comment">     * 默认 Isolation.DEFAULT</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Isolation <span class="title">isolation</span><span class="params">()</span> <span class="keyword">default</span> Isolation.DEFAULT</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事务超时时间</span></span><br><span class="line"><span class="comment">     * 默认 TransactionDefinition.TIMEOUT_DEFAULT 即 -1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">timeout</span><span class="params">()</span> <span class="keyword">default</span> TransactionDefinition.TIMEOUT_DEFAULT</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置事务只读</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">readOnly</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置需要进行回滚的异常类数组，当方法中抛出指定异常数组中的异常时，则进行事务回滚</span></span><br><span class="line"><span class="comment">     * rollbackFor = Exception.class 或 rollbackFor = &#123;RuntimeException.class, Exception.class&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;? extends Throwable&gt;[] rollbackFor() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置需要进行回滚的异常类名称数组，当方法中抛出指定异常名称数组中的异常时, 事务进行回滚</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] rollbackForClassName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置不需要进行回滚的异常类数组，当方法中抛出指定异常数组中的异常时，则不进行事务回滚</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;? extends Throwable&gt;[] noRollbackFor() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置不需要进行回滚的异常类名称数组，当方法中抛出指定异常名称数组中的异常时, 事务不进行回滚</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] noRollbackForClassName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="传播行为介绍"><a href="#传播行为介绍" class="headerlink" title="传播行为介绍"></a>传播行为介绍</h3><p>事务的传播行为, 一共 7 种<br>1.枚举介绍</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.transaction.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.TransactionDefinition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Propagation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 支持当前事务, 如果不存在, 则创建一个新事务</span></span><br><span class="line"><span class="comment">     * 事务的默认设置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    REQUIRED(TransactionDefinition.PROPAGATION_REQUIRED),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 支持当前事务, 如果不存在, 则以非事务方式执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SUPPORTS(TransactionDefinition.PROPAGATION_SUPPORTS),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 支持当前事务, 如果不存在则抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    MANDATORY(TransactionDefinition.PROPAGATION_MANDATORY),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始一个新的事务, 并暂停当前事务(如果存在)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    REQUIRES_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以非事务方式执行, 暂停当前事务(如果存在)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NOT_SUPPORTED(TransactionDefinition.PROPAGATION_NOT_SUPPORTED),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以非事务方式执行, 如果存在则抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NEVER(TransactionDefinition.PROPAGATION_NEVER),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果当前事务存在, 则在嵌套事务中执行.</span></span><br><span class="line"><span class="comment">     * 如果事务不存在, 则等同于 PROPAGATION_REQUIRED</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NESTED(TransactionDefinition.PROPAGATION_NESTED);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    Propagation(<span class="keyword">int</span> value) &#123; <span class="keyword">this</span>.value = value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.value; &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.列表</p><table><thead><tr><th>Propagation</th><th>含义</th></tr></thead><tbody><tr><td>REQUIRED</td><td>支持当前事务, 如果不存在, 则创建一个新事务</td></tr><tr><td>SUPPORTS</td><td>支持当前事务, 如果不存在, 则以非事务方式执行</td></tr><tr><td>MANDATORY</td><td>支持当前事务, 如果不存在则抛出异常</td></tr><tr><td>REQUIRES_NEW</td><td>开始一个新的事务, 并暂停当前事务(如果存在)</td></tr><tr><td>NOT_SUPPORTED</td><td>以非事务方式执行, 暂停当前事务(如果存在)</td></tr><tr><td>NEVER</td><td>以非事务方式执行, 如果存在则抛出异常</td></tr><tr><td>NESTED</td><td>如果当前事务存在, 则在嵌套事务中执行. 如果事务不存在, 则等同于 PROPAGATION_REQUIRED</td></tr></tbody></table><h3 id="隔离级别介绍"><a href="#隔离级别介绍" class="headerlink" title="隔离级别介绍"></a>隔离级别介绍</h3><p>1.枚举介绍</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.transaction.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.TransactionDefinition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Isolation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用底层数据存储默认的隔离级别</span></span><br><span class="line"><span class="comment">     * 一般存储底层默认为: READ_COMMITTED</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    DEFAULT(TransactionDefinition.ISOLATION_DEFAULT),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读未提交</span></span><br><span class="line"><span class="comment">     * 会出现脏读和不可重复读, 一般不使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    READ_UNCOMMITTED(TransactionDefinition.ISOLATION_READ_UNCOMMITTED),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读已提交</span></span><br><span class="line"><span class="comment">     * 该级别仅禁止事务读取其中未提交更改的行</span></span><br><span class="line"><span class="comment">     * 可能会出现不可重复读取和幻像读取</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    READ_COMMITTED(TransactionDefinition.ISOLATION_READ_COMMITTED),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可重复读</span></span><br><span class="line"><span class="comment">     * 禁止事务读取其中有未提交更改的行, 并且还禁止一个事务读取一行, 第二个事务更改该行. 并且第一个事务重新读取该行, 第二次获取不同值的情况</span></span><br><span class="line"><span class="comment">     * 即 禁止 读未提交, 不可重复读</span></span><br><span class="line"><span class="comment">     * 会出现幻读</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    REPEATABLE_READ(TransactionDefinition.ISOLATION_REPEATABLE_READ),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 串行</span></span><br><span class="line"><span class="comment">     * 所有事物依次执行, 不会影响别的事务, 所以会防止 不可重复读 脏读 幻读</span></span><br><span class="line"><span class="comment">     * 会影响性能</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SERIALIZABLE(TransactionDefinition.ISOLATION_SERIALIZABLE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    Isolation(<span class="keyword">int</span> value) &#123; <span class="keyword">this</span>.value = value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.value; &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.列表</p><table><thead><tr><th>Isolation</th><th>含义</th></tr></thead><tbody><tr><td>DEFAULT</td><td>使用底层数据存储默认的隔离级别, 一般存储底层默认为: READ_COMMITTED</td></tr><tr><td>READ_UNCOMMITTED</td><td>读未提交, 会出现脏读和不可重复读, 一般不使用</td></tr><tr><td>READ_COMMITTED</td><td>该级别仅禁止事务读取其中未提交更改的行. 可能会出现不可重复读取和幻像读取</td></tr><tr><td>REPEATABLE_READ</td><td>可重复读, 禁止事务读取其中有未提交更改的行, 并且还禁止一个事务读取一行, 第二个事务更改该行. 并且第一个事务重新读取该行, 第二次获取不同值的情况. 即 禁止 读未提交, 不可重复读. 会出现幻读</td></tr><tr><td>SERIALIZABLE</td><td>串行, 所有事物依次执行, 不会影响别的事务, 所以会防止 不可重复读 脏读 幻读. 会影响性能</td></tr></tbody></table><p>3.脏读 幻读 不可重复读</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>脏读</td><td>当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。</td></tr><tr><td>幻读</td><td>事务读取时不存在该数据, 读取后发现该数据存在. 中间因为别的事务在进行插入操作</td></tr><tr><td>不可重复读</td><td>一个事务在读取该数据时另一个事务在修改该数据, 导致多次读取数据内容不一致</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> transactional </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整数包装类型的缓存</title>
      <link href="2018/01/15/integer-wrapper-type-cache.html"/>
      <url>2018/01/15/integer-wrapper-type-cache.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>部分包装类型存在缓存机制, 会在JVM启动时, 缓存一定数量的对象, 有助于节省内存, 提高性能.</p></blockquote><h3 id="缓存区间"><a href="#缓存区间" class="headerlink" title="缓存区间"></a>缓存区间</h3><table><thead><tr><th>类型</th><th>范围</th><th>是否修改</th></tr></thead><tbody><tr><td>Integer</td><td>-128 到 127</td><td>true : -XX:AutoBoxCacheMax=size 修改</td></tr><tr><td>ByteCache</td><td>-128 到 127</td><td>false</td></tr><tr><td>ShortCache</td><td>-128 到 127</td><td>false</td></tr><tr><td>LongCache</td><td>-128 到 127</td><td>false</td></tr><tr><td>CharacterCache</td><td>0 到 127</td><td>false</td></tr></tbody></table><a id="more"></a><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer a = <span class="number">100</span>;</span><br><span class="line">Integer b = <span class="number">100</span>;</span><br><span class="line">Integer c = <span class="number">1000</span>;</span><br><span class="line">Integer d = <span class="number">1000</span>;</span><br><span class="line">Integer e = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">Integer f = Integer.valueOf(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(a == b); <span class="comment">// true</span></span><br><span class="line">System.out.println(c == d); <span class="comment">// false</span></span><br><span class="line">System.out.println(a == e); <span class="comment">// false</span></span><br><span class="line">System.out.println(f == e); <span class="comment">// false</span></span><br><span class="line">System.out.println(a == f); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>== 在比较对象时, 判断是否指向同一地址</p><p>a b f 都是从缓存中取出数据, 所以地址是相同的</p><p>c d 不在缓存范围内, 所以是新的对象</p><p>e 是新对象</p><h3 id="IntegerCache"><a href="#IntegerCache" class="headerlink" title="IntegerCache"></a>IntegerCache</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="comment">// high value may be configured by property</span></span><br><span class="line">            <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">            String integerCacheHighPropValue =</span><br><span class="line">                sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                    i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                    <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                    h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                    <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            high = h;</span><br><span class="line"></span><br><span class="line">            cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> j = low;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">                cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">            <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以通过设置 java.lang.Integer.IntegerCache.high 来修改缓存的值. 方法为修改 JVM 的启动参数 -XX:AutoBoxCacheMax=size</p>]]></content>
      
      
      <categories>
          
          <category> 源码学习 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Interceptor拦截器</title>
      <link href="2018/01/10/interceptor.html"/>
      <url>2018/01/10/interceptor.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Interceptor: 拦截器，作用类似 Filter, 主要作用是拦截用户请求, 在 Action 执行的前后各执行一段代码, 进行相应的业务处理.</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>权限认证<br>统一逻辑处理<br>日志监控等</p><a id="more"></a><h3 id="使用方式及方法介绍"><a href="#使用方式及方法介绍" class="headerlink" title="使用方式及方法介绍"></a>使用方式及方法介绍</h3><p>使用方式分为两种, 一种为: 实现HandlerInterceptor接口或者是继承实现了HandlerInterceptor接口的类, 另一种为: 实现Spring的WebRequestInterceptor接口, 或者是继承实现了WebRequestInterceptor的类.<br>1.HandlerInterceptor 介绍</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.web.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求处理之前调用 链式 会按照声明顺序依次执行</span></span><br><span class="line"><span class="comment">     * 返回 true 则继续执行下一个 Interceptor 无则执行 Controller</span></span><br><span class="line"><span class="comment">     * 返回 false 请求结束</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在请求处理之后，DispatcherServlet进行视图返回渲染之前进行调用，可以在这个方法中对Controller 处理之后的ModelAndView 对象进行操作。</span></span><br><span class="line"><span class="comment">     * 调度程序Servlet在执行链中处理一个处理程序，由任意数量的拦截器组成，处理器本身在最后。 使用这种方法，每个拦截器可以后处理一个执行，并按照执行链的相反顺序进行应用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求处理完成后的回调，即渲染视图后的回调。 将被调用处理程序执行的任何结果，从而允许适当的资源清理。</span></span><br><span class="line"><span class="comment">     * 注意：只有当这个拦截器的预处理方法已经成功完成并返回时才会被调用</span></span><br><span class="line"><span class="comment">     * 与postHandle方法一样，该方法将以相反的顺序在链中的每个拦截器上调用，因此第一个拦截器将成为最后被调用的拦截器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.WebRequestInterceptor 介绍</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.web.context.request;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.ModelMap;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.WebRequest;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WebRequestInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在调用之前拦截请求处理程序的执行。 允许准备上下文资源（如Hibernate Session）并将它们公开为请求属性或线程本地对象.</span></span><br><span class="line"><span class="comment">     * 即 准备一些需要的资源, 例如, 将请求属性放置到 WebRequest 中</span></span><br><span class="line"><span class="comment">     * 无返回对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preHandle</span><span class="params">(WebRequest request)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在视图呈现前（如果有的话）在成功调用之后拦截请求处理程序的执行。</span></span><br><span class="line"><span class="comment">     * 允许在成功处理程序执行后修改上下文资源（例如，刷新休眠会话）</span></span><br><span class="line"><span class="comment">     * 可以通过修改 ModelMap 的属性来改变你返回的试图模型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(WebRequest request, ModelMap model)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 求处理完成后的回调，即渲染视图后的回调。 将被调用处理程序执行的任何结果，从而允许适当的资源清理。</span></span><br><span class="line"><span class="comment">     * 注意：只有在拦截器的预处理方法成功完成时才会调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(WebRequest request, Exception ex)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="xml-配置"><a href="#xml-配置" class="headerlink" title="xml 配置"></a>xml 配置</h3><p>1.在 *-servlet.xml 中添加 MVC schema</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;</span><br><span class="line">xsi:schemaLocation=&quot; http://www.springframework.org/schema/mvc</span><br><span class="line">http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd&quot;</span><br></pre></td></tr></table></figure><p>2.配置 mvc:interceptors 标签</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 拦截路径 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定拦截器 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.liuzhihang.myprojext.controller.interceptor.RequestInterceptor&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuzhihang.myprojext.controller.interceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 处理逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> interceptor </tag>
            
            <tag> servlet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>utils工具--ValidationUtil 参数校验</title>
      <link href="2017/12/30/utils-tool-validationutil-parameter-check.html"/>
      <url>2017/12/30/utils-tool-validationutil-parameter-check.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在工作中不可避免的要面对很多参数校验, 比如写新接口时需要对传入VO的必要字段进行校验, String 是否为空, Integer 最小值, 对象是否为null, 等等.<br>而使用 hibernate的validator工具对参数进行校验, 可以极大的简化流程, 当然不可避免的就是需要在被校验字段上加上注解信息.</p><h6 id="1-相关依赖"><a href="#1-相关依赖" class="headerlink" title="1. 相关依赖"></a>1. 相关依赖</h6><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 参数校验工具 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.4.2.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.glassfish.web<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>el-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a><h6 id="2-ValidationUtil"><a href="#2-ValidationUtil" class="headerlink" title="2. ValidationUtil"></a>2. ValidationUtil</h6><p>对加上相关注解字段进行校验, 使用到 <a href="https://github.com/liuzhihang/tool_demo/blob/master/src/main/java/com/liuzhihang/tool/xml/JaxbUtil.java">ValidationUtil.java</a>和<a href="https://github.com/liuzhihang/tool_demo/blob/master/src/main/java/com/liuzhihang/tool/validate/ValidationResult.java">ValidationResult.java</a>两个文件, 也可在工具中直接抛出异常.</p><p>ValidationUtil 内容如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuzhihang.tool.validate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.CollectionUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.validation.ConstraintViolation;</span><br><span class="line"><span class="keyword">import</span> javax.validation.Validation;</span><br><span class="line"><span class="keyword">import</span> javax.validation.Validator;</span><br><span class="line"><span class="keyword">import</span> java.beans.IntrospectionException;</span><br><span class="line"><span class="keyword">import</span> java.beans.Introspector;</span><br><span class="line"><span class="keyword">import</span> java.beans.PropertyDescriptor;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对添加 hibernate.validator 注解的字段进行校验</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 使用前 需要引入 hibernate-validator 依赖</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuzhihang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/11/22 11:08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidationUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Validator validator = Validation.buildDefaultValidatorFactory().getValidator();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 会 验证 所有字段</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回所有不符合的信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ValidationResult <span class="title">validateAllField</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">        ValidationResult result = <span class="keyword">new</span> ValidationResult(<span class="keyword">true</span>);</span><br><span class="line">        StringBuilder errorMsg = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">            result.setHasPass(<span class="keyword">false</span>);</span><br><span class="line">            result.setErrorMsg(<span class="string">&quot;The class is null!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;ConstraintViolation&lt;T&gt;&gt; violationSet = validator.validate(obj);</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isNotEmpty(violationSet)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (ConstraintViolation&lt;T&gt; violation : violationSet) &#123;</span><br><span class="line">                errorMsg.append(violation.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">            result.setHasPass(<span class="keyword">false</span>);</span><br><span class="line">            result.setErrorMsg(errorMsg.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证指定字段 是否符合信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fieldName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ValidationResult <span class="title">validateOneField</span><span class="params">(T obj, String fieldName)</span> </span>&#123;</span><br><span class="line">        ValidationResult result = <span class="keyword">new</span> ValidationResult(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">            result.setHasPass(<span class="keyword">false</span>);</span><br><span class="line">            result.setErrorMsg(<span class="string">&quot;The class is null!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;ConstraintViolation&lt;T&gt;&gt; violationSet = validator.validateProperty(obj, fieldName);</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isNotEmpty(violationSet)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (ConstraintViolation&lt;T&gt; violation : violationSet) &#123;</span><br><span class="line">                result.setHasPass(<span class="keyword">false</span>);</span><br><span class="line">                result.setErrorMsg(violation.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证 所有字段, 当第一个不符合时 则直接返回信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ValidationResult <span class="title">validateAllFieldForOneBack</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">        ValidationResult result = <span class="keyword">new</span> ValidationResult(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">            result.setHasPass(<span class="keyword">false</span>);</span><br><span class="line">            result.setErrorMsg(<span class="string">&quot;The class is null!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            PropertyDescriptor[] propertyDescriptors = Introspector.getBeanInfo(obj.getClass()).getPropertyDescriptors();</span><br><span class="line">            <span class="keyword">for</span> (PropertyDescriptor propertyDescriptor : propertyDescriptors) &#123;</span><br><span class="line">                result = validateOneField(obj, propertyDescriptor.getName());</span><br><span class="line">                <span class="keyword">if</span> (result.getHasPass()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IntrospectionException e) &#123;</span><br><span class="line">            result.setHasPass(<span class="keyword">false</span>);</span><br><span class="line">            result.setErrorMsg(<span class="string">&quot;This validate has error : &quot;</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ValidationResult 内容如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuzhihang.tool.validate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: liuzhihang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2018/1/6 17:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidationResult</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Boolean hasPass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String errorMsg;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ValidationResult</span><span class="params">(Boolean hasPass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hasPass = hasPass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">getHasPass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hasPass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHasPass</span><span class="params">(Boolean hasPass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hasPass = hasPass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getErrorMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> errorMsg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setErrorMsg</span><span class="params">(String errorMsg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.errorMsg = errorMsg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ValidationResult&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;hasPass=&quot;</span> + hasPass +</span><br><span class="line">                <span class="string">&quot;, errorMsg=&#x27;&quot;</span> + errorMsg + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="3-常用注解"><a href="#3-常用注解" class="headerlink" title="3. 常用注解"></a>3. 常用注解</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Bean Validation 中内置的 constraint</span><br><span class="line">@Null   被注释的元素必须为 null</span><br><span class="line">@NotNull    被注释的元素必须不为 null</span><br><span class="line">@AssertTrue     被注释的元素必须为 true</span><br><span class="line">@AssertFalse    被注释的元素必须为 false</span><br><span class="line">@Min(value)     被注释的元素必须是一个数字，其值必须大于等于指定的最小值</span><br><span class="line">@Max(value)     被注释的元素必须是一个数字，其值必须小于等于指定的最大值</span><br><span class="line">@DecimalMin(value)  被注释的元素必须是一个数字，其值必须大于等于指定的最小值</span><br><span class="line">@DecimalMax(value)  被注释的元素必须是一个数字，其值必须小于等于指定的最大值</span><br><span class="line">@Size(max&#x3D;, min&#x3D;)   被注释的元素的大小必须在指定的范围内</span><br><span class="line">@Digits (integer, fraction)     被注释的元素必须是一个数字，其值必须在可接受的范围内</span><br><span class="line">@Past   被注释的元素必须是一个过去的日期</span><br><span class="line">@Future     被注释的元素必须是一个将来的日期</span><br><span class="line">@Pattern(regex&#x3D;,flag&#x3D;)  被注释的元素必须符合指定的正则表达式</span><br><span class="line"></span><br><span class="line">Hibernate Validator 附加的 constraint</span><br><span class="line">@NotBlank(message &#x3D;)   验证字符串非null，且长度必须大于0</span><br><span class="line">@Email  被注释的元素必须是电子邮箱地址</span><br><span class="line">@Length(min&#x3D;,max&#x3D;)  被注释的字符串的大小必须在指定的范围内</span><br><span class="line">@NotEmpty   被注释的字符串的必须非空</span><br><span class="line">@Range(min&#x3D;,max&#x3D;,message&#x3D;)  被注释的元素必须在合适的范围内</span><br></pre></td></tr></table></figure><h6 id="4-测试示例"><a href="#4-测试示例" class="headerlink" title="4 测试示例"></a>4 测试示例</h6><p><a href="https://github.com/liuzhihang/tool_demo/blob/master/src/main/java/com/liuzhihang/tool/validate/ValidationVo.java">代码</a>:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuzhihang.tool.validate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.validator.constraints.NotBlank;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.validator.constraints.NotEmpty;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.Min;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotNull;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuzhihang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/11/22 18:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidationVo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;The name must notEmpty!&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;The age must notNull!&quot;)</span></span><br><span class="line">    <span class="meta">@Min(value = 1, message = &quot;The age must greater than 0!&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ValidationVo validationVo = <span class="keyword">new</span> ValidationVo();</span><br><span class="line">        System.out.println(ValidationUtil.validateAllField(validationVo).toString());</span><br><span class="line">        validationVo.setAge(<span class="number">1</span>);</span><br><span class="line">        System.out.println(ValidationUtil.validateAllField(validationVo).toString());</span><br><span class="line">        validationVo.setName(<span class="string">&quot;二蛋&quot;</span>);</span><br><span class="line">        System.out.println(ValidationUtil.validateAllField(validationVo).toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ValidationResult&#123;hasPass&#x3D;false, errorMsg&#x3D;&#39;The name must notEmpty!The age must notNull!&#39;&#125;</span><br><span class="line">ValidationResult&#123;hasPass&#x3D;false, errorMsg&#x3D;&#39;The name must notEmpty!&#39;&#125;</span><br><span class="line">ValidationResult&#123;hasPass&#x3D;true, errorMsg&#x3D;&#39;null&#39;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> utils </category>
          
      </categories>
      
      
        <tags>
            
            <tag> utils </tag>
            
            <tag> validation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xml解析--dom4j</title>
      <link href="2017/12/30/xml-parsing-dom4j.html"/>
      <url>2017/12/30/xml-parsing-dom4j.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在工作中有时候会用到dom4j对xml文件或者字符串进行解析, 以下内容为随手笔记, 防止以后遗忘.</p><h5 id="1-相关依赖"><a href="#1-相关依赖" class="headerlink" title="1. 相关依赖"></a>1. 相关依赖</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- dom4j --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>dom4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dom4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a><h5 id="2-获取dom对象"><a href="#2-获取dom对象" class="headerlink" title="2. 获取dom对象"></a>2. 获取dom对象</h5><p>获取dom对象方式主要以下几种:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取 xml 文件 方式</span></span><br><span class="line">SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">Document doc1 = reader.read(<span class="keyword">new</span> File(<span class="string">&quot;src/main/java/com/liuzhihang/tool/xml/alipay.xml&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析 xml 文本 方式</span></span><br><span class="line">String aliPayStr = XmlTest.getAliPayStr();</span><br><span class="line">Document doc2 = DocumentHelper.parseText(aliPayStr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主动创建</span></span><br><span class="line">Document doc3 = DocumentHelper.createDocument();</span><br><span class="line">Element element = doc3.addElement(<span class="string">&quot;Test&quot;</span>);</span><br></pre></td></tr></table></figure><h6 id="3-操作dom对象"><a href="#3-操作dom对象" class="headerlink" title="3. 操作dom对象"></a>3. 操作dom对象</h6><p>当获取到dom对象后便可以通过以下方式对dom进行操作</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取根节点</span></span><br><span class="line">Element rootElement = dom.getRootElement();</span><br><span class="line"><span class="comment">// System.out.println(rootElement.getName());</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取子节点</span></span><br><span class="line">Element element = rootElement.element(<span class="string">&quot;response&quot;</span>).element(<span class="string">&quot;alipay&quot;</span>);</span><br><span class="line"><span class="comment">// System.out.println(element.asXML());</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取节点的文字</span></span><br><span class="line">String text = element.element(<span class="string">&quot;alipay_buyer_login_id&quot;</span>).getText();</span><br><span class="line"><span class="comment">// System.out.println(text);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取节点下的所有节点 快捷键 iter / itco</span></span><br><span class="line">List elements = element.elements();</span><br><span class="line"><span class="comment">// for (Object o : elements) &#123;</span></span><br><span class="line"><span class="comment">//     Element tempElement = (Element) o;</span></span><br><span class="line"><span class="comment">//     System.out.println(tempElement.getName() + &quot;\t&quot; + tempElement.getText());</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// for (Iterator iterator = elements.iterator(); iterator.hasNext(); ) &#123;</span></span><br><span class="line"><span class="comment">//     Element next =  (Element)iterator.next();</span></span><br><span class="line"><span class="comment">//     System.out.println(next.getName() + &quot;\t&quot; + next.getText());</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取节点下所有节点 Iterator对象 快捷键 itit</span></span><br><span class="line">Iterator iterator = element.elementIterator();</span><br><span class="line"><span class="comment">// while (iterator.hasNext()) &#123;</span></span><br><span class="line"><span class="comment">//     Element next =  (Element)iterator.next();</span></span><br><span class="line"><span class="comment">//     System.out.println(next.getName() + &quot;\t&quot; + next.getText());</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加节点</span></span><br><span class="line">Element testElement = element.addElement(<span class="string">&quot;testElement&quot;</span>);</span><br><span class="line"><span class="comment">// 指定添加文字</span></span><br><span class="line">testElement.setText(<span class="string">&quot;测试添加文字&quot;</span>);</span><br><span class="line">System.out.println(element.asXML());</span><br><span class="line"><span class="comment">// 删除节点</span></span><br><span class="line"><span class="keyword">boolean</span> remove = element.remove(testElement);</span><br><span class="line">System.out.println(remove + <span class="string">&quot;\n&quot;</span> + element.asXML());</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="4-详细代码"><a href="#4-详细代码" class="headerlink" title="4. 详细代码"></a>4. 详细代码</h6><p><a href="https://github.com/liuzhihang/tool_demo/blob/master/src/main/java/com/liuzhihang/tool/xml/Dom4jTest.java">Dom4jTest.java</a></p>]]></content>
      
      
      <categories>
          
          <category> utils </category>
          
      </categories>
      
      
        <tags>
            
            <tag> utils </tag>
            
            <tag> xml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xml解析--JaxbUtil</title>
      <link href="2017/12/17/xml-parsing-jaxbutil.html"/>
      <url>2017/12/17/xml-parsing-jaxbutil.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>主要介绍使用jaxb对xml进行解析, 互转.</p><p>jaxb 是相对较多的xml工具, 只需要在javaBean的属性上添加相应注解, 就可以使用工具进行解析. 具体使用过程如下:</p><h5 id="1-编写javaBean并添加注解"><a href="#1-编写javaBean并添加注解" class="headerlink" title="1. 编写javaBean并添加注解"></a>1. 编写javaBean并添加注解</h5><p>使用过程中一般常用@XmlRootElement, @XmlAccessorType, @XmlElement, @XmlAttribute四个注解, 其余使用方式可以再自行深入研究.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@XmlRootElement</span>: 根元素</span><br><span class="line"><span class="meta">@XmlAccessorType</span>: java对象生成xml文件时对java对象属性的访问方式</span><br><span class="line">    属性为XmlAccessType.FIELD 指java所有成员变量</span><br><span class="line"><span class="meta">@XmlElement</span>: 子节点, name 可指定节点名</span><br><span class="line"><span class="meta">@XmlAttribute</span>: 映射为xml文件的属性, name 可指定属性名</span><br></pre></td></tr></table></figure><a id="more"></a><p>javaBean:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@XmlRootElement(name = &quot;alipay&quot;)</span></span><br><span class="line"><span class="meta">@XmlAccessorType(XmlAccessType.FIELD)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AliPayXml</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@XmlElement(name = &quot;alipay_buyer_login_id&quot; )</span></span><br><span class="line">    <span class="keyword">private</span> String buyerLoginId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@XmlElement(name = &quot;alipay_buyer_user_id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String buyerUserId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-使用-JaxbUtil"><a href="#2-使用-JaxbUtil" class="headerlink" title="2. 使用 JaxbUtil"></a>2. 使用 JaxbUtil</h5><p><a href="https://github.com/liuzhihang/tool_demo/blob/master/src/main/java/com/liuzhihang/tool/xml/JaxbUtil.java">JaxbUtil</a>代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liuzhihang.tool.xml;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.bind.JAXBContext;</span><br><span class="line"><span class="keyword">import</span> javax.xml.bind.JAXBException;</span><br><span class="line"><span class="keyword">import</span> javax.xml.bind.Marshaller;</span><br><span class="line"><span class="keyword">import</span> javax.xml.bind.Unmarshaller;</span><br><span class="line"><span class="keyword">import</span> java.io.StringReader;</span><br><span class="line"><span class="keyword">import</span> java.io.StringWriter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Jaxb 工具</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuzhihang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/11/28 19:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JaxbUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CHARTSET = <span class="string">&quot;UTF-8&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">bean2Xml</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> JAXBException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bean2Xml(obj, CHARTSET);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">bean2Xml</span><span class="params">(Object obj, String chartset)</span> <span class="keyword">throws</span> JAXBException </span>&#123;</span><br><span class="line">        JAXBContext jaxbContext = JAXBContext.newInstance(obj.getClass());</span><br><span class="line">        Marshaller marshaller = jaxbContext.createMarshaller();</span><br><span class="line">        marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, <span class="keyword">true</span>);</span><br><span class="line">        marshaller.setProperty(Marshaller.JAXB_ENCODING, chartset);</span><br><span class="line">        StringWriter writer = <span class="keyword">new</span> StringWriter();</span><br><span class="line">        marshaller.marshal(obj, writer);</span><br><span class="line">        <span class="keyword">return</span> writer.getBuffer().toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">xml2Bean</span><span class="params">(String xmlString, Class&lt;T&gt; clazz)</span> <span class="keyword">throws</span> JAXBException </span>&#123;</span><br><span class="line">        JAXBContext jaxbContext = JAXBContext.newInstance(clazz);</span><br><span class="line">        Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();</span><br><span class="line">        T t = (T) unmarshaller.unmarshal(<span class="keyword">new</span> StringReader(xmlString));</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="3-测试代码"><a href="#3-测试代码" class="headerlink" title="3. 测试代码"></a>3. 测试代码</h5><p>待测试字符串: xmlStr</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">alipay</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">alipay_buyer_login_id</span>&gt;</span>176****3035<span class="tag">&lt;/<span class="name">alipay_buyer_login_id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">alipay_buyer_user_id</span>&gt;</span>2088912868994947<span class="tag">&lt;/<span class="name">alipay_buyer_user_id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">alipay</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试代码:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: liuzhihang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2017/12/17 23:11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JaxbTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> JAXBException </span>&#123;</span><br><span class="line">        String aliPayXmlStr = <span class="string">&quot;&lt;alipay&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;  &lt;alipay_buyer_login_id&gt;176****3035&lt;/alipay_buyer_login_id&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;  &lt;alipay_buyer_user_id&gt;2088912868994947&lt;/alipay_buyer_user_id&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&lt;/alipay&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        AliPayXml aliPayXml = JaxbUtil.xml2Bean(aliPayXmlStr, AliPayXml.class);</span><br><span class="line">        System.out.println(JSON.toJSONString(aliPayXml));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果:</p><p>打印的为json格式结果, 可debugger查看. 同样也可以将javaBean转换为xmlStr</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;buyerLoginId&quot;:&quot;176****3035&quot;,&quot;buyerUserId&quot;:&quot;2088912868994947&quot;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> utils </category>
          
      </categories>
      
      
        <tags>
            
            <tag> utils </tag>
            
            <tag> xml </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
