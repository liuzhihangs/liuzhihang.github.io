<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL next-key lock 加锁范围总结</title>
      <link href="2021/06/07/mysql-next-key-4.html"/>
      <url>2021/06/07/mysql-next-key-4.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>三篇文章分别通过实际操作，介绍了主键、非主键唯一索引、普通索引、普通字段四个方面介绍了加锁的范围。</p><p>本篇文章再做一个总结。</p><h3 id="data-locks"><a href="#data-locks" class="headerlink" title="data_locks"></a>data_locks</h3><pre><code class="sql">select * from performance_schema.data_locks;</code></pre><table><thead><tr><th align="left">LOCK_MODE</th><th align="left">LOCK_DATA</th><th align="left">锁范围</th></tr></thead><tbody><tr><td align="left">X,REC_NOT_GAP</td><td align="left">15</td><td align="left">15 那条数据的行锁</td></tr><tr><td align="left">X,GAP</td><td align="left">15</td><td align="left">15 那条数据之前的间隙，不包含 15</td></tr><tr><td align="left">X</td><td align="left">15</td><td align="left">15 那条数据的间隙，包含 15</td></tr></tbody></table><ol><li><code>LOCK_MODE = X</code> 是前开后闭区间；</li><li><code>X,GAP</code> 是前开后开区间（间隙锁）；</li><li><code>X,REC_NOT_GAP</code> 行锁。</li></ol><p>这个单独介绍，是希望我理解的没有错误，如果大佬看到了，错误之处一定要帮忙指正出来。</p><h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><ol><li>加锁时，会先给表添加意向锁，IX 或 IS；</li><li>加锁是如果是多个范围，是分开加了多个锁，每个范围都有锁；（这个可以实践下 id &lt; 20 的情况）</li><li>主键等值查询，数据存在时，会对该主键索引的值加行锁 <code>X,REC_NOT_GAP</code>；</li><li>主键等值查询，数据不存在时，会对查询条件主键值所在的间隙添加间隙锁 <code>X,GAP</code>；</li><li>主键等值查询，范围查询时情况则比较复杂：<ol><li>8.0.17 版本是前开后闭，而 8.0.18 版本及以后，修改为了<code>前开后开</code>区间；</li><li>临界 <code>&lt;=</code> 查询时，8.0.17 会锁住下一个 next-key 的前开后闭区间，而 8.0.18 及以后版本，修复了这个 bug。</li></ol></li></ol><h3 id="非主键唯一索引"><a href="#非主键唯一索引" class="headerlink" title="非主键唯一索引"></a>非主键唯一索引</h3><ol><li>非主键唯一索引等值查询，数据存在，for update 是会在主键加锁的，而 for share 只有在走覆盖索引的情况下，会仅在自己索引上加锁；</li><li>非主键索引等值查询，数据不存在，无论是否索引覆盖，相当于一个范围查询，仅仅会在非主键索引上加锁，加的还是间隙锁，前开后开区间； </li><li>在非主键唯一索引范围查询时，不是覆盖索引的时候，会对相应的范围加前开后闭区间，并且如果存在数据，会对对应的主键加行锁；</li><li>在非主键唯一索引范围查询时，如果是覆盖索引时，会对所有的后闭区间对应的主键，加行锁；</li><li>在非主键唯一索引加锁时，还是存在 next-key 锁住下一个区间的 bug。</li></ol><h3 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h3><ol><li>普通索引等值查询，因为不能确定唯一性，所以即使定位到记录，也是会向后查询，直到查询到不为该值的记录，从而锁定该值的区间；</li><li>普通索引的锁也是加载该索引上的，如果涉及到存在的记录，会对该主键加行锁；</li><li>普通索引的范围查询，同样出现 next-key 查询下一个区间的 bug。</li></ol><h3 id="普通字段"><a href="#普通字段" class="headerlink" title="普通字段"></a>普通字段</h3><p>普通字段查询，会查询全表，这里锁的话就会锁住主键的所有区间。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过实际操作，最大的感受就是不能眼高手低，看书也好，看文章也罢，一定要实际操作。</p><p>纸上得来终觉浅。</p><h4 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h4><ul><li><a href="https://mp.weixin.qq.com/s/7GUNktCI0ek2HQmIp4R0rQ">https://mp.weixin.qq.com/s/JS2gJHb1qS618TQISxMAAw</a></li><li><a href="https://mp.weixin.qq.com/s/6RTWDpiqU6z3YVc88e0xBQ">看来，MySQL next-key lock 的 bug 并没有被修复！</a></li><li><a href="https://mp.weixin.qq.com/s/JS2gJHb1qS618TQISxMAAw">MySQL 加锁范围三——普通索引和普通字段</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> next-key </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Toolkit Json 转实体也可以支持 lombok 了！</title>
      <link href="2021/06/07/ides-plugin-toolkit-lombok.html"/>
      <url>2021/06/07/ides-plugin-toolkit-lombok.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>近日小伙伴提建议希望 Toolkit 支持 lombok。</p><p>个人认为 GsonFormat 不香么？</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/cE07XB-xXDwrd.png"></p><p>我没使用 GsonFormat，所以为什么不能用的，我也没法给评价。</p><p>不过，既然是小伙伴的需求，那还是得加的！</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/851623049420_.pic-h5X5W1.jpg"></p><h3 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h3><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/1-d9Qj14.gif"></p><h4 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h4><ol><li>在官方插件库搜索 <code>Toolkit</code></li><li>github：<a href="https://github.com/liuzhihang/toolkit/releases">https://github.com/liuzhihang/toolkit/releases</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> IDEA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> plugin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL普通索引的加锁</title>
      <link href="2021/06/06/mysql-next-key-3.html"/>
      <url>2021/06/06/mysql-next-key-3.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>前面已经介绍了主键索引的加锁范围和非主键唯一索引的加锁范围。</p><p>主键索引：</p><ol><li>加锁时，会先给表添加意向锁，IX 或 IS；</li><li>加锁是如果是多个范围，是分开加了多个锁，每个范围都有锁；（这个可以实践下 id &lt; 20 的情况）</li><li>主键等值查询，数据存在时，会对该主键索引的值加行锁 <code>X,REC_NOT_GAP</code>；</li><li>主键等值查询，数据不存在时，会对查询条件主键值所在的间隙添加间隙锁 <code>X,GAP</code>；</li><li>主键等值查询，范围查询时情况则比较复杂：<ol><li>8.0.17 版本是前开后闭，而 8.0.18 版本及以后，修改为了<code>前开后开</code>区间；</li><li>临界 <code>&lt;=</code> 查询时，8.0.17 会锁住下一个 next-key 的前开后闭区间，而 8.0.18 及以后版本，修复了这个 bug。</li></ol></li></ol><p>非主键唯一索引:</p><ol><li>非主键唯一索引等值查询，数据存在，for update 是会在主键加锁的，而 for share 只有在走覆盖索引的情况下，会仅在自己索引上加锁；</li><li>非主键索引等值查询，数据不存在，无论是否索引覆盖，相当于一个范围查询，仅仅会在非主键索引上加锁，加的还是间隙锁，前开后开区间； </li><li>在非主键唯一索引范围查询时，不是覆盖索引的时候，会对相应的范围加前开后闭区间，并且如果存在数据，会对对应的主键加行锁；</li><li>在非主键唯一索引范围查询时，如果是覆盖索引时，会对所有的后闭区间对应的主键，加行锁；</li><li>在非主键唯一索引加锁时，还是存在 next-key 锁住下一个区间的 bug。</li></ol><p>这篇文章来一起看一下普通索引和普通字段的加锁范围是什么?</p><h3 id="数据库表数据"><a href="#数据库表数据" class="headerlink" title="数据库表数据"></a>数据库表数据</h3><pre><code class="mysql">CREATE TABLE `t` (  `id` int NOT NULL COMMENT &#39;主键&#39;,  `a` int DEFAULT NULL COMMENT &#39;唯一索引&#39;,  `c` int DEFAULT NULL COMMENT &#39;普通索引&#39;,  `d` int DEFAULT NULL,  PRIMARY KEY (`id`),  UNIQUE KEY `uniq_a` (`a`),  KEY `idx_c` (`c`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci</code></pre><p>数据库数据如下：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/OQIkdN-UySKyv.png"></p><p>思路和非主键唯一索引相同，只不过唯一的区别是这里看的是 c 和 d 字段。</p><p>因为前面小伙伴对 data_locks 应该有了一定的了解，这里就直接分析 data_locks 的数据信息。</p><h3 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h3><h4 id="普通索引等值查询-——-数据存在"><a href="#普通索引等值查询-——-数据存在" class="headerlink" title="普通索引等值查询 —— 数据存在"></a>普通索引等值查询 —— 数据存在</h4><pre><code class="bash">mysql&gt; begin; select * from t where c = 210 for update;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/2uZM0N-XFfgwF.png"></p><p>直接分析 data_locks</p><ol><li>表意向锁；</li><li>索引 idx_c 上添加了 210 区间的前开后闭锁；</li><li>索引 idx_c 上添加了 215 区间的间隙锁，LOCK_MODE 为 <code>X,GAP</code>；</li><li>主键上添加了 15 的行锁 ，LOCK_MODE 为 <code>X,REC_NOT_GAP</code>。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/vXAW0t-nlBAeC.png"></p><p>主要是因为普通索引不能唯一锁定一条记录，所以要锁定该字段的前后范围。</p><h4 id="普通索引等值查询-——-数据不存在"><a href="#普通索引等值查询-——-数据不存在" class="headerlink" title="普通索引等值查询 —— 数据不存在"></a>普通索引等值查询 —— 数据不存在</h4><pre><code class="bash">mysql&gt; begin; select * from t where c = 211 for update;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/ovvkVj-D3I4mH.png"></p><p>直接分析 data_locks</p><ol><li>表意向锁；</li><li>索引 idx_c 上添加了 215 区间的间隙锁。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/vXAW0t-nlBAeC.png"></p><p>分析是因为数据不存在，只需要锁住 215 间隙就可以了，因为 215 和 210 肯定不属于这个范围。</p><h4 id="普通索引范围查询"><a href="#普通索引范围查询" class="headerlink" title="普通索引范围查询"></a>普通索引范围查询</h4><pre><code class="bash">mysql&gt; begin; select * from t where c &gt; 210 and c &lt;= 215 for update;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/DqKkhF-CgVYYa.png"></p><p>对于锁住 idx_c 索引的 215 的前开后闭区间是可以理解的，但是锁住了 220 就不太理解了，应该也是那个 bug 没有完全修复。</p><h3 id="普通字段"><a href="#普通字段" class="headerlink" title="普通字段"></a>普通字段</h3><p>普通字段就更好理解了。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/1a7fLd-rmcYQ4.png"></p><p>对普通字段而言，无论是哪个查询，都需要扫描全部记录，所以这个锁直接加在了主键上，并且是锁住全部的区间。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文在基于第一篇和第二篇的基础上，直接通过分析 data_locks 的信息，进行判断加锁范围。</p><pre><code class="sql">select * from performance_schema.data_locks;</code></pre><table><thead><tr><th align="left">LOCK_MODE</th><th align="left">LOCK_DATA</th><th align="left">锁范围</th></tr></thead><tbody><tr><td align="left">X,REC_NOT_GAP</td><td align="left">15</td><td align="left">15 那条数据的行锁</td></tr><tr><td align="left">X,GAP</td><td align="left">15</td><td align="left">15 那条数据之前的间隙，不包含 15</td></tr><tr><td align="left">X</td><td align="left">15</td><td align="left">15 那条数据的间隙，包含 15</td></tr></tbody></table><ol><li><code>LOCK_MODE = X</code> 是前开后闭区间；</li><li><code>X,GAP</code> 是前开后开区间（间隙锁）；</li><li><code>X,REC_NOT_GAP</code> 行锁。</li></ol><p>从而得出普通索引和普通字段的结论。</p><h4 id="普通索引-1"><a href="#普通索引-1" class="headerlink" title="普通索引"></a>普通索引</h4><ol><li>普通索引等值查询，因为不能确定唯一性，所以即使定位到记录，也是会向后查询，直到查询到不为该值的记录，从而锁定该值的区间；</li><li>普通索引的锁也是加载该索引上的，如果涉及到存在的记录，会对该主键加行锁；</li><li>普通索引的范围查询，同样出现 next-key 查询下一个区间的 bug。</li></ol><h4 id="普通字段-1"><a href="#普通字段-1" class="headerlink" title="普通字段"></a>普通字段</h4><p>普通字段查询，会查询全表，这里锁的话就会锁住主键的所有区间。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> next-key </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>看来，MySQL next-key lock 的 bug 并没有被修复！</title>
      <link href="2021/06/06/mysql-next-key-2.html"/>
      <url>2021/06/06/mysql-next-key-2.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在上一篇文章<a href="https://mp.weixin.qq.com/s/7GUNktCI0ek2HQmIp4R0rQ">《MySQL next-key lock 加锁范围是什么？》</a>中已经介绍了主键索引的加锁范围，现在来回顾一下：</p><ol><li>加锁时，会先给表添加意向锁，IX 或 IS；</li><li>加锁是如果是多个范围，是分开加了多个锁，每个范围都有锁；（这个可以实践下 id &lt; 20 的情况）</li><li>主键等值查询，数据存在时，会对该主键索引的值加行锁 <code>X,REC_NOT_GAP</code>；</li><li>主键等值查询，数据不存在时，会对查询条件主键值所在的间隙添加间隙锁 <code>X,GAP</code>；</li><li>主键等值查询，范围查询时情况则比较复杂：<ol><li>8.0.17 版本是前开后闭，而 8.0.18 版本及以后，修改为了<code>前开后开</code>区间；</li><li>临界 <code>&lt;=</code> 查询时，8.0.17 会锁住下一个 next-key 的前开后闭区间，而 8.0.18 及以后版本，修复了这个 bug。</li></ol></li></ol><p>这篇文章会对非主键唯一索引进行操作实践。</p><h3 id="数据库表数据"><a href="#数据库表数据" class="headerlink" title="数据库表数据"></a>数据库表数据</h3><pre><code class="mysql">CREATE TABLE `t` (  `id` int NOT NULL COMMENT &#39;主键&#39;,  `a` int DEFAULT NULL COMMENT &#39;唯一索引&#39;,  `c` int DEFAULT NULL COMMENT &#39;普通索引&#39;,  `d` int DEFAULT NULL,  PRIMARY KEY (`id`),  UNIQUE KEY `uniq_a` (`a`),   KEY `idx_c` (`c`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci</code></pre><p>数据库数据如下：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/OQIkdN-UySKyv.png"></p><p>数据库的字段 a 是唯一索引。</p><h3 id="非主键唯一索引"><a href="#非主键唯一索引" class="headerlink" title="非主键唯一索引"></a>非主键唯一索引</h3><h4 id="非主键唯一索引等值查询-——-数据存在"><a href="#非主键唯一索引等值查询-——-数据存在" class="headerlink" title="非主键唯一索引等值查询 —— 数据存在"></a>非主键唯一索引等值查询 —— 数据存在</h4><pre><code class="bash">mysql&gt; begin; select * from t where a = 110 for update;</code></pre><p>分析一下这条 SQL：</p><ol><li>select * 查询条件肯定会回表；</li><li>唯一索引，所以定位到数据后不需要继续查询；</li><li>猜测是锁住唯一索引及对应的主键索引。</li></ol><p>查看 data_locks</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/GQORN6-fvpdIA.png"></p><ol><li>表锁 IX；</li><li>索引 uniq_a 上面加了 <code>X,REC_NOT_GAP</code> 行锁，其中 <code>110, 10</code> 表示是 a = 110 这行数据，后面的 10 是这行数据对应的主键；</li><li>主键 id = 10 上添加了 <code>X,REC_NOT_GAP</code> 行锁。</li></ol><p>一切和分析的一样。</p><p>如果把 for update 换成 for share，其实也是相同，在主键和唯一索引上都加了锁。</p><p>这里执行的 SQL 都是 <code>select *</code>，如果替换为 <code>select id</code> 呢？</p><pre><code class="bash">mysql&gt; begin; select id from t where a = 110 for update;</code></pre><p>分析一下这条 SQL：</p><ol><li>select id 查询，满足索引覆盖，不会回表；</li><li>唯一索引，所以定位到数据后不需要继续查询；</li><li>那这里是锁主键索引还是两个都锁？</li></ol><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/c71q8f-wIYfLE.png"></p><p>所以看出并无什么区别。</p><p>把 for update 换成 for share，这时候区别来了：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/BhidHG-PTCPXQ.png"></p><p>只有两条锁记录：表意向锁和 uniq_a 索引的 <code>S,REC_NOT_GAP</code> 锁。</p><p>很明显，for share 覆盖索引时，只是对自己的索引加锁。</p><pre><code class="sql">update t set c = 2101 where id = 10;</code></pre><p>这时候使用主键更新 c 是否能更新？ 那下面两个 SQL 呢？</p><pre><code class="sql">update t set a = 1101 where id = 10;update t set c = 2101 where a = 110;</code></pre><p>执行结果很显然，第一个可以执行，而后两个是会阻塞的。</p><p>所以，非主键唯一索引等值查询，数据存在，for update 是会在主键加锁的，而 for share 只有在走覆盖索引的情况下，会仅在自己索引上加锁。</p><h4 id="非主键唯一索引等值查询-——-数据不存在"><a href="#非主键唯一索引等值查询-——-数据不存在" class="headerlink" title="非主键唯一索引等值查询 —— 数据不存在"></a>非主键唯一索引等值查询 —— 数据不存在</h4><pre><code class="bash">mysql&gt; begin; select * from t where a = 111 for update;</code></pre><p>分析这一条 SQL：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/Zph2hj-xSDqZr.png"></p><ol><li>首先加了 for update，肯定会在 索引 uniq_a 和 主键索引上都加上锁；</li><li>字段 a 具有唯一性，但是数据 <code>a = 111</code> 不存在，会一直查，查到 115 区间；</li><li>所以会加索引 uniq_a 和 主键索引的间隙锁。（并不对 ）</li></ol><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/o3ureD-O480WZ.png"></p><p>事实证明，分析结果不正确。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/VL01st-lEoJDn.png"></p><p>并且我执行 <code>update t set c = 2101 where id = 15;</code> 也过了。</p><p>所以是不是可以理解为，非主键索引等值查询，数据不存在，相当于一个范围查询，仅仅会在非主键索引上加锁，加的还是间隙锁，前开后开区间；</p><p>如果此时走索引覆盖呢？ 其实结果也是相同的。</p><h4 id="非主键唯一索引范围查询"><a href="#非主键唯一索引范围查询" class="headerlink" title="非主键唯一索引范围查询"></a>非主键唯一索引范围查询</h4><pre><code class="bash">mysql&gt; begin; select * from t where a &gt;= 110 and a &lt; 115 for update;</code></pre><p>分析 SQL</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/Zph2hj-xSDqZr.png"></p><ol><li>a &gt;= 110 and a &lt; 115，非主键唯一索引 [110,115)，肯定是要加锁的；</li><li>对应的主键索引 10 应该也会加锁！</li></ol><p>事实证明，又一次是错误的！</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/MghL9l-c99D7E.png"></p><p>分析 data_locks:</p><ol><li>怎么会对非主键唯一索引的 110 加了锁？LOCK_MODE 还是 X，如果加了行锁我还能理解。</li><li>怎么会对非主键唯一索引的 115 加了锁？</li></ol><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/au7tX3-lAoIKf.png"></p><p>很明显 110 和 115 之前的间隙以及它们自身的记录都被锁住了。</p><p>经过一番分析，难道是因为<code>前开后闭</code>。</p><p>脑袋炸裂呀，完全和主键索引的 next-key lock 加锁范围不同，人家 sql 是什么就锁什么。</p><blockquote><p>有小伙伴知道原因可以告诉我。</p></blockquote><p>如果我把 sql 改成下面的这种呢？</p><pre><code class="bash">mysql&gt; begin; select *  from t where a &gt; 110 and a &lt; 114 for update;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/IurzWR-vR9L9X.png"></p><p>诶？？？</p><p>奇了怪了！</p><p>我唯一能想到的原因就是前开后闭了。 因为 <code>a &gt;= 10</code> 中的等于是属于上一个区间的，所以需要锁住上一个区间。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/H3lSVr-S2bWh3.png"></p><p>我只能说懵逼三连了！！！</p><p>其实还是有结论的：</p><p>在非主键唯一索引范围查询时，会对相应的范围加前开后闭区间，并且如果存在数据，会对对应的主键加行锁。</p><p>这时候如果走覆盖索引呢？？</p><pre><code class="bash">mysql&gt; begin; select id from t where a &gt;= 110 and a &lt; 115 for update;</code></pre><p>按照刚才的思路，前开后闭：</p><ol><li>锁住主键索引 110 的区间，115 的区间</li><li>锁住主键 10 的行锁</li></ol><p>事实又错了！</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/bIIbrs-KnSV2L.png"></p><p>还锁住了主键 15 的行锁。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/7XTPOL-TIJd6P.png"></p><p>把等号去掉 15 是锁住的。</p><p>感觉脑袋完全不够用啊。重点是我没有理解怎么主键还是前开后开，这里就前开后闭了？</p><p>难道我在这里试试那个 bug？</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/MBViKy-J1lL28.png"></p><p>啪啪打脸啊！</p><p>之前还说这个 bug 在 8.0.18 被修复了，并优化成了前开后开区间，这直接打脸，明摆着没有修复。</p><p>我只是操作 <code>a &gt; 100 and a &lt;= 115 for update;</code> 竟然把 120 给我锁住了，不就是 next-key 的 bug。</p><p>尝试一下 sql</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/cOA3Jh-MMlpms.png"></p><p>很明显~ 这个 bug 在非主键唯一索引上，并没有修复！！！</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在非主键唯一索引情况下：</p><ol><li>非主键唯一索引等值查询，数据存在，for update 是会在主键加锁的，而 for share 只有在走覆盖索引的情况下，会仅在自己索引上加锁；</li><li>非主键索引等值查询，数据不存在，无论是否索引覆盖，相当于一个范围查询，仅仅会在非主键索引上加锁，加的还是间隙锁，前开后开区间； </li><li>在非主键唯一索引范围查询时，不是覆盖索引的时候，会对相应的范围加前开后闭区间，并且如果存在数据，会对对应的主键加行锁；</li><li>在非主键唯一索引范围查询时，如果是覆盖索引时，会对所有的后闭区间对应的主键，加行锁。</li></ol><p>实践完本文的所有操作，个人处于有些懵逼的状态。我使用的版本是 <code>8.0.25</code></p><ol><li>主键不是前开后闭，而非主键唯一索引看样子又很遵循前开后闭原则；</li><li>next key 的 bug 在非主键唯一索引上，并没有被修复！</li></ol><p>仔细一想，似乎又可以理解。</p><p>因为主键上的 next-key 的 bug 被修复了，同时优化了前开后闭区间为前开后开区间，而非主键唯一索引上这个 bug 没有被修复，所以没有优化。</p><p>嗯~ 大概就是这样吧！</p><h4 id="相关推荐"><a href="#相关推荐" class="headerlink" title="相关推荐"></a>相关推荐</h4><ul><li><a href="https://mp.weixin.qq.com/s/7GUNktCI0ek2HQmIp4R0rQ">MySQL next-key lock 加锁范围是什么？</a></li><li><a href="https://mp.weixin.qq.com/s/g8sVbhSpe9ZswavSCH8YcQ">使用 Docker 安装并连接 MySQL</a></li><li><a href="https://mp.weixin.qq.com/s/UlUQ95gVt8I8wmVOEjn1aw">Spring 是如何解决循环依赖的</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> next-key </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Docker 安装并连接 MySQL</title>
      <link href="2021/06/06/docker-mysql.html"/>
      <url>2021/06/06/docker-mysql.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>作为开发，在本机捣鼓一下 Docker 还是很有必要的，本篇文章介绍如何使用 Docker 安装 MySQL，并在终端（iTerm2）使用命令连接 MySQL。</p><h3 id="安装-MySQL"><a href="#安装-MySQL" class="headerlink" title="安装 MySQL"></a>安装 MySQL</h3><p>核心命令如下：</p><pre><code class="bash"># 用 8.0.17 版本举例docker pull mysql:8.0.17# 运行 mysqldocker run -itd --name mysql8.0.17 -p 23306:3306 -e MYSQL_ROOT_PASSWORD=root mysql:8.0.17docker ps</code></pre><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/kiUEMZ-BRFqnd.png"></p><h3 id="登录-MySQL"><a href="#登录-MySQL" class="headerlink" title="登录 MySQL"></a>登录 MySQL</h3><pre><code class="bash"># 进入容器docker exec -it mysql8.0.17 bash# 登录 mysqlmysql -u root -p</code></pre><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/rihiCJ-jLUwPZ.png"></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL next-key lock 加锁范围是什么？</title>
      <link href="2021/06/06/mysql-next-key-1.html"/>
      <url>2021/06/06/mysql-next-key-1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>某天，突然被问到 MySQL 的 next-key lock，我瞬间的反应就是：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/40_d42e4365795250c1255b9208f810f067-gCOzuQ.jpg"></p><p>这都是啥啥啥？？？</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/821622636549_.pic_hd-5VZsrw.jpg"></p><p>这一个截图我啥也看不出来呀？</p><p>仔细一看，好像似曾相识，这不是《MySQL 45 讲》里面的内容么？</p><h3 id="什么是-next-key-lock"><a href="#什么是-next-key-lock" class="headerlink" title="什么是 next-key lock"></a>什么是 next-key lock</h3><blockquote><p>A next-key lock is a combination of a record lock on the index record and a gap lock on the gap before the index record.</p></blockquote><p>官网的解释大概意思就是：<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html#innodb-next-key-locks">next-key</a> 锁是索引记录上的记录锁和索引记录之前的间隙上的间隙锁的组合。</p><p>先给自己来一串小问号？？？</p><ol><li>在主键、唯一索引、普通索引以及普通字段上加锁，是锁住了哪些索引？</li><li>不同的查询条件，分别锁住了哪些范围的数据？</li><li>for share 和 for update 等值查询和范围查询的锁范围？</li><li>当查询的等值不存在时，锁范围是什么？</li><li>当查询条件分别是主键、唯一索引、普通索引时有什么区别？</li></ol><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/841622637169_.pic-FOjThi.jpg"></p><p>既然啥都不懂，那只好从头开始操作实践一把了！</p><p>先看看看 《MySQL 45 讲》中丁奇老师的结论：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/BqOu0A-N27nbe.png"></p><p>看了这结论，应该可以解答一大部分问题，不过有一句非常非常重点的话需要关注：<code>MySQL 后面的版本可能会改变加锁策略，所以这个规则只限于截止到现在的最新版本，即 5.x 系列&lt;=5.7.24，8.0 系列 &lt;=8.0.13</code></p><p>所以，以上的规则，对现在的版本并不一定适用，下面我以 <code>MySQL 8.0.25</code> 版本为例，进行多角度验证 next-key lock 加锁范围。</p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>MySQL 版本：8.0.25</p><p>隔离级别：可重复读（RR）</p><p>存储引擎：InnoDB</p><pre><code class="bash">mysql&gt; select @@global.transaction_isolation,@@transaction_isolation\Gmysql&gt; show create table t\G</code></pre><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/UEeXMi-9hhKLV.png"></p><blockquote><p>如何使用 Docker 安装 MySQL，可以参考另一篇文章《使用 Docker 安装并连接 MySQL》</p></blockquote><h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><p>首先来验证主键索引的 next-key lock 的范围</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/Mp0EYA-6uRRmo.png"></p><p>此时数据库的数据如图所示，对主键索引来说此时数据间隙如下：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/21dk1Y-UnM3iP.png"></p><h4 id="主键等值查询-——-数据存在"><a href="#主键等值查询-——-数据存在" class="headerlink" title="主键等值查询 —— 数据存在"></a>主键等值查询 —— 数据存在</h4><pre><code class="bash">mysql&gt; begin; select * from t where id = 10 for update;</code></pre><p>这条 SQL，对 <code>id = 10</code> 进行加锁，可以先思考一下加了什么锁？锁住了什么数据？</p><p>可以通过 <code>data_locks</code> 查看锁信息，SQL 如下：</p><pre><code class="bash"># mysql&gt; select * from performance_schema.data_locks;mysql&gt; select * from performance_schema.data_locks\G</code></pre><p>具体字段含义可以参考 <a href="https://dev.mysql.com/doc/mysql-perfschema-excerpt/8.0/en/performance-schema-data-locks-table.html" title="The data_locks Table">官方文档</a></p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/y18bw5-co1PT1.png"></p><p>结果主要包含引擎、库、表等信息，咱们需要重点关注以下几个字段：</p><ul><li>INDEX_NAME：锁定索引的名称</li><li>LOCK_TYPE：锁的类型，对于 InnoDB，允许的值为 RECORD 行级锁 和 TABLE 表级锁。</li><li>LOCK_MODE：锁的类型：S, X, IS, IX, and gap locks</li><li>LOCK_DATA：锁关联的数据，对于 InnoDB，当 LOCK_TYPE 是 RECORD（行锁），则显示值。当锁在主键索引上时，则值是锁定记录的主键值。当锁是在辅助索引上时，则显示辅助索引的值，并附加上主键值。</li></ul><p>结果很明显，这里是对表添加了一个 IX 锁 并对主键索引 id = 10 的记录，添加了一个 <code>X,REC_NOT_GAP</code> 锁，表示只锁定了记录。</p><p>同样 <code>for share</code> 是对表添加了一个 IS 锁并对主键索引 id = 10 的记录，添加了一个 S 锁。</p><p>可以得出结论：</p><p>对主键等值加锁，且值存在时，会对表添加意向锁，同时会对主键索引添加行锁。</p><h4 id="主键等值查询-——-数据不存在"><a href="#主键等值查询-——-数据不存在" class="headerlink" title="主键等值查询 —— 数据不存在"></a>主键等值查询 —— 数据不存在</h4><pre><code class="bash">mysql&gt; select * from t where id = 11 for update;</code></pre><p>如果是数据不存在的时候，会加什么锁呢？锁的范围又是什么？</p><p>在验证之前，分析一下数据的间隙。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/21dk1Y-UnM3iP.png"></p><ol><li><code>id = 11</code> 是肯定不存在的。但是加了 <code>for update</code>，这时需要加 next-key lock，<code>id = 11</code> 所属区间为 (10,15] 的<del>前开后闭</del>区间；</li><li>因为是<code>等值查询</code>，不需要锁 <code>id = 15</code> 那条记录，next-key lock 会退化为间隙锁；</li><li>最终区间为 (10,15) 的前开后开区间。</li></ol><p>使用 data_locks 分析一下锁信息：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/j6xBAd-Y9ridM.png"></p><p>看下锁的信息 <code>X,GAP</code> 表示加了间隙锁，其中 LOCK_DATA = 15，表示锁的是 主键索引 id = 15 之前的间隙。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/38yaLn-YpzQIe.png"></p><p>此时在另一个 Session 执行 SQL，答案显而易见，是 id = 12 不可以插入，而 id = 15 是可以更新的。</p><p>可以得出结论，在数据不存在时，主键等值查询，会锁住该主键查询条件所在的间隙。</p><h4 id="主键范围查询（重点）"><a href="#主键范围查询（重点）" class="headerlink" title="主键范围查询（重点）"></a>主键范围查询（重点）</h4><pre><code class="bash">mysql&gt; begin; select * from t where id &gt;= 10 and id &lt; 11 for update;</code></pre><p>根据 《MySQL 45 讲》分析得出下面结果：</p><ol><li><code>id &gt;= 10</code> 定位到 10 所在的区间 (10,+∞)；</li><li>因为是 &gt;= 存在等值判断，所以需要包含 10 这个值，变为 [10,+∞) 前闭后闭区间；</li><li><code>id &lt; 11</code> 限定后续范围，则根据 11 判断下一个区间为 15 的<del>前开后闭</del>区间；</li><li>结合起来则是 [10,15]。（不完全正确）</li></ol><p>先看下 data_locks </p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/21dk1Y-UnM3iP.png"></p><p>可以看到除了表锁之外，还有 id = 10 的行锁（<code>X,REC_NOT_GAP</code>）以及主键索引 id = 15 之前的间隙锁（<code>X,GAP</code>）。</p><p>所以实际上 id = 15 是可以进行更新的。也就是说<code>前开后闭区间</code>出现了问题，个人认为应该是 <code>id &lt; 11</code> 这个条件判断，导致不需要进行了锁 15 这个行锁。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/RJZbYw-eLqOOx.png"></p><p>结果验证也是正确的，id = 12 插入阻塞，id = 15 更新成功。</p><p>当范围的右侧是包含等值查询呢？</p><pre><code class="bash">mysql&gt; begin; select * from t where id &gt; 10 and id &lt;= 15 for update;</code></pre><p>来分析一下这个 SQL：</p><ol><li><code>id &gt; 10</code> 定位到 10 所在的区间 (10,+∞)；</li><li><code>id &lt;= 15</code> 定位是 (-∞, 15]；</li><li>结合起来则是 (10,15]。</li></ol><p>同样先看一下 data_locks</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/w9GByI-VXHPMX.png"></p><p>可以看出只添加了一个主键索引 id = 15 的 X 锁。</p><p>验证下 id = 15 是否可以更新？再验证 id = 16 是否可以插入？</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/r3atK6-Qd4HI2.png"></p><p>事实证明是没有问题的！</p><p>当然，这里有小伙伴会说，在 《MySQL 45 讲》 里面说这里有一个 bug，会锁住下一个 next-key。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/05X8RW-YlHAYH.png" alt="《MySQL 45 讲》 第 21 讲"></p><p>事实证明，这个 bug 已经被修复了。修复版本为 <code>MySQL 8.0.18</code>。但是并没有完全修复！！！</p><blockquote><p>参考链接地址：</p><p><a href="https://dev.mysql.com/doc/relnotes/mysql/8.0/en/news-8-0-18.html#mysqld-8-0-18-bug">https://dev.mysql.com/doc/relnotes/mysql/8.0/en/news-8-0-18.html#mysqld-8-0-18-bug</a></p><p>搜索关键字：Bug #29508068)</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/V0Vpx9-OyLrZO.png"></p><p>咱们可以分别用 8.0.17 进行复现一下：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/BMC5V6-wJfVAY.png" alt="MySQL 8.0.17"></p><p>在 8.0.17 中 <code>id &lt;= 15</code> 会将 id = 20 这条数据也锁着，而在 8.0.25 版本中则不会。所以这个 bug 是被修复了的。</p><p>再来看下是<code>前开后闭</code>还是<code>前开后开</code>的问题，严谨一下，使用 8.0.17 和 8.0.18 做比较。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/TvS2v7-ZRADCK.png" alt="MySQL 8.0.17"></p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/gzTIxv-85c6li.png" alt="MySQL 8.0.18"></p><p>现在我估计大概率是在 8.0.18 版本修复 <code>Bug #29508068</code> 的时候，把这个<code>前开后闭</code>给优化成了<code>前开后开</code>了。</p><p>对比 data_locks 数据：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/DKiqVN-0lV4UV.png"></p><p>注意红色下划线部分，在 8.0.17 版本中 <code>id &lt; 17</code> 时 LOCK_MODE 是 <code>X</code>，而在 8.0.25 版本中则是 <code>X,GAP</code>。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文主要通过实际操作，对主键加锁时的 next-key lock 范围进行了验证，并查阅资料，对比版本得出不同的结论。</p><h4 id="结论一："><a href="#结论一：" class="headerlink" title="结论一："></a>结论一：</h4><ol><li>加锁时，会先给表添加意向锁，IX 或 IS；</li><li>加锁是如果是多个范围，是分开加了多个锁，每个范围都有锁；（这个可以实践下 id &lt; 20 的情况）</li><li>主键等值查询，数据存在时，会对该主键索引的值加行锁 <code>X,REC_NOT_GAP</code>；</li><li>主键等值查询，数据不存在时，会对查询条件主键值所在的间隙添加间隙锁 <code>X,GAP</code>；</li><li>主键等值查询，范围查询时情况则比较复杂：<ol><li>8.0.17 版本是前开后闭，而 8.0.18 版本及以后，进行了优化，主键时判断不等，不会锁住后闭的区间。</li><li>临界 <code>&lt;=</code> 查询时，8.0.17 会锁住下一个 next-key 的前开后闭区间，而 8.0.18 及以后版本，修复了这个 bug。</li></ol></li></ol><blockquote><p>优化后，导致后开，这个不知道是因为优化后，主键的区间会直接后开，还是因为是个 bug。具体小伙伴可以尝试一下。 </p></blockquote><h4 id="结论二"><a href="#结论二" class="headerlink" title="结论二"></a>结论二</h4><p>通过使用 <code>select * from performance_schema.data_locks;</code> 和操作实践，可以看出 LOCK_MODE 和 LOCK_DATE 的关系：</p><table><thead><tr><th align="left">LOCK_MODE</th><th align="left">LOCK_DATA</th><th align="left">锁范围</th></tr></thead><tbody><tr><td align="left">X,REC_NOT_GAP</td><td align="left">15</td><td align="left">15 那条数据的行锁</td></tr><tr><td align="left">X,GAP</td><td align="left">15</td><td align="left">15 那条数据之前的间隙，不包含 15</td></tr><tr><td align="left">X</td><td align="left">15</td><td align="left">15 那条数据的间隙，包含 15</td></tr></tbody></table><ol><li><code>LOCK_MODE = X</code> 是前开后闭区间；</li><li><code>X,GAP</code> 是前开后开区间（间隙锁）；</li><li><code>X,REC_NOT_GAP</code> 行锁。</li></ol><p>基本已经摸清主键的 next-key lock 范围，注意版本使用的是 8.0.25。</p><h4 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h4><ol><li>那唯一索引的 next-key lock 范围是什么?</li><li>当索引覆盖时锁的范围和加锁的索引分别是什么？</li><li>我为什么说这个 bug 没有完全修复，也是在非主键唯一索引中复现了这个 bug​。</li></ol><p>文章篇幅有限，小伙伴可以先自己思考一下，尽量自己操作试一试，实践出真知。至于具体答案，那就需要下一篇文章进行验证并总结结论了。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> next-key </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac 常用软件推荐 —— Java 开发工程师</title>
      <link href="2021/05/25/mac-common-software-java.html"/>
      <url>2021/05/25/mac-common-software-java.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>记录一下自己用的 Mac 软件，如果小伙伴需要，可以下载体验一下。</p><blockquote><p>在 Github 上有一个地址：</p><p><a href="https://github.com/jaywcjlove/awesome-mac/blob/master/README-zh.md">https://github.com/jaywcjlove/awesome-mac/blob/master/README-zh.md</a></p></blockquote><p>这里仅介绍我所使用过，并一直在使用，而且觉得很不错的软件推荐给小伙伴。</p><h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><p>作为开发，必须得把吃饭的家伙放在第一位！</p><h4 id="IntelliJ-IDEA"><a href="#IntelliJ-IDEA" class="headerlink" title="IntelliJ IDEA"></a>IntelliJ IDEA</h4><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/qgY5j1-YGM4Hm.png"></p><p>相关地址：<a href="https://www.jetbrains.com/idea/">IntelliJ IDEA</a></p><p>IDEA，就是吃饭的家伙，没啥可介绍的。</p><p>这里额外推荐我的 IDEA 插件：</p><p><a href="https://mp.weixin.qq.com/s/Q8YW4cGmJiwmmOwjRSSOMw">Toolkit</a>：支持MyBatis、Json、XML、Base64等操作的工具包。</p><p><a href="https://mp.weixin.qq.com/s/MzWzxIM7yhYumitpF3v3Kg">Doc View</a>：一个IntelliJ IDEA插件，可以通过注释直接生成Markdown文档。</p><h4 id="DataGrip"><a href="#DataGrip" class="headerlink" title="DataGrip"></a>DataGrip</h4><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/kPt8jW-bOp97L.png"></p><p>相关地址：<a href="https://www.jetbrains.com/datagrip/">DataGrip</a></p><p>虽然 IDEA 中内置了数据库工具，但是相比而言，更喜欢用独立的客户端 DataGrip，尤其是编写 SQL 的时候，各种快捷键、实时模版、代码提醒都非常方便。</p><h4 id="Navicat-Premium"><a href="#Navicat-Premium" class="headerlink" title="Navicat Premium"></a>Navicat Premium</h4><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/oYDje3-ZBAN4I.png"></p><p>相关地址：<a href="https://www.navicat.com.cn/products/navicat-premium">Navicat Premium</a></p><p>DataGrip 写 SQL 比较方便，不过 Navicat 也同样不逊色，只不过有时候喜欢用 Navicat 进行查看数据库。</p><h4 id="iTerm2"><a href="#iTerm2" class="headerlink" title="iTerm2"></a>iTerm2</h4><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/dxvFzj-aIEK4y.png"></p><p>相关地址：<a href="https://iterm2.com/">iTerm2</a></p><p>在 Mac 上超级好用的终端工具，至于配色，在网上搜一搜，教程一大堆。</p><h4 id="RedisDesktopManager"><a href="#RedisDesktopManager" class="headerlink" title="RedisDesktopManager"></a>RedisDesktopManager</h4><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/uDjxvV-RQpSc8.png"></p><p>相关地址：<a href="https://github.com/uglide/RedisDesktopManager">RedisDesktopManager</a></p><p>有时候会连上 Redis 查看里面的值，用 RDM 还是比较方便的，之前在 Win 的时候就很喜欢用。</p><p>不过后来收费了，可以找别人编译的版本，或者在 <a href="https://apps.apple.com/cn/app/rdm-redis-%E7%9A%84-gui/id1475905948?mt=12">AppStore</a> 一次性购买。</p><h4 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h4><p>偶尔玩玩，这个我用的也不熟。</p><h4 id="Postman"><a href="#Postman" class="headerlink" title="Postman"></a>Postman</h4><p>Postman 常用的接口测试工具，也有很多高级功能，不过我暂时也不会用，也没有用过。</p><h4 id="SwitchHosts"><a href="#SwitchHosts" class="headerlink" title="SwitchHosts"></a>SwitchHosts</h4><p><a href="https://swh.app/zh/">SwitchHosts</a> 是一个管理、切换多个 hosts 方案的工具。</p><p>重点是开源免费，使用方便。</p><h3 id="画图工具"><a href="#画图工具" class="headerlink" title="画图工具"></a>画图工具</h3><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/GSW05R-VlWv6n.png"></p><p>画图工具就两个。</p><h4 id="XMind"><a href="#XMind" class="headerlink" title="XMind"></a>XMind</h4><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/T0YmIK-qxS1o5.png"></p><p>相关地址：<a href="https://www.xmind.cn/">XMind</a></p><p>画思维导图的时候一般使用这个，梳理知识点，记录笔记的时候非常方便。</p><h4 id="draw-io"><a href="#draw-io" class="headerlink" title="draw.io"></a>draw.io</h4><p>在之前的文章中有过介绍过，不仅可以画流程图，还可以修改为手绘风格。</p><p><a href="https://mp.weixin.qq.com/s/ngpTOx4XO0SDeqxH-0Yjgg">给大家介绍下，这是我的流程图软件 —— draw.io</a></p><p>桌面版地址：<a href="https://github.com/jgraph/drawio-desktop/releases">drawio-desktop</a></p><h3 id="笔记工具"><a href="#笔记工具" class="headerlink" title="笔记工具"></a>笔记工具</h3><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/OOXeqk-AuMh9f.png"></p><h4 id="Visual-Studio-Code"><a href="#Visual-Studio-Code" class="headerlink" title="Visual Studio Code"></a>Visual Studio Code</h4><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/NDKsh1-uC5iFo.png"></p><p>相关地址：<a href="https://code.visualstudio.com/">Visual Studio Code</a></p><p>我知道 VS Code 很强大，但是在我这里的定位就是一个笔记软件，用来写 Markdown 笔记。同时还能打开 .sql .text .img 等等其他格式的文件。</p><p>安装的插件：One Dark Pro、Markdown All in One、Markdown Preview Mermaid Support、Markdown Table Maker、Project Manager、Paste Image。</p><p>安装这些插件，已经可以让 VS Code 当一个很可以的 Markdown 软件了，其他的一些插件就是格式化插件了。不介绍也罢。</p><h4 id="Bear-Panda"><a href="#Bear-Panda" class="headerlink" title="Bear/Panda"></a>Bear/Panda</h4><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/Nv7atN-mML3jV.png"></p><p>相关地址：</p><p><a href="https://bear.app/">Bear</a></p><p><a href="https://bear.app/cn/alpha/">Panda</a></p><p>Bear 是一个非常简洁好用的笔记软件，以标签为维度进行整理记录笔记，标签可以嵌套从而整理为多级目录。</p><p>Panda 是一个测试版，会对 Bear 的编辑器进行重构，并且支持动图，表格等功能。非常期待将 Panda 合并到 Bear 后发布的新版本。</p><h3 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h3><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/menVVZ-YnXe4m.png"></p><p><a href="https://github.com/gee1k/uPic">uPic</a>：开源免费图床工具，支持上传图片到图床，并返回图片链接。其中链接可以是普通 URL、HTML、或者 Markdown。</p><p><a href="https://github.com/ripperhe/Bob">Bob</a>：Mac 端翻译软件，支持划词翻译、截图翻译以及手动输入翻译。开源免费，需要自己配置翻译服务，一般我使用的是<code>腾讯翻译君</code>和<code>阿里翻译</code>的 API。</p><p><a href="https://apps.apple.com/cn/app/paste-clipboard-manager/id967805235">Paste</a>、<a href="https://apps.apple.com/cn/app/pastepal-clipboard-manager/id1503446680">PastePal</a>：这俩都是剪贴板工具，并且 UI 风格差不多，只不过是 Paste 是订阅制，而 PastePal 是买断制。</p><p><a href="https://apps.apple.com/cn/app/xnip-%E6%88%AA%E5%9B%BE-%E6%A0%87%E6%B3%A8/id1221250572?mt=12">Xnip</a>：截图软件，开始的时候用微信截图，但是不能滚动截图，后来一直使用 Xnip 进行截图。</p><p><a href="https://manytricks.com/moom/">Moom</a>：窗口管理工具，进行窗口排列非常方便。</p><p><a href="https://github.com/keycastr/keycastr">KeyCastr</a>：按键回显工具，在录制视频的时候，需要按键回显，类似下图。</p><p><a href="https://apps.apple.com/cn/app/gif-brewery-3-by-gfycat/id1081413713?mt=12">GIF Brewery 3</a>：视频转 gif 工具。</p><p>还有一些其他的工具，比如 Office、微信、QQ 等等，这些就没啥介绍的必要了，大家下载，捣鼓捣鼓就玩的明白啦。</p><h4 id="相关推荐"><a href="#相关推荐" class="headerlink" title="相关推荐"></a>相关推荐</h4><ul><li><a href="https://mp.weixin.qq.com/s/ngpTOx4XO0SDeqxH-0Yjgg">给大家介绍下，这是我的流程图软件 —— draw.io</a></li><li><a href="https://mp.weixin.qq.com/s/Q8YW4cGmJiwmmOwjRSSOMw">Toolkit 大更新：UI 更美观，用起来更方便！</a></li><li><a href="https://mp.weixin.qq.com/s/MzWzxIM7yhYumitpF3v3Kg">IDEA 文档插件 DocView：支持编辑文档注释</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> software </tag>
            
            <tag> mac </tag>
            
            <tag> 工具册 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Toolkit 大更新：UI 更美观，用起来更方便！</title>
      <link href="2021/04/17/idea-plugin-toolkit-0417.html"/>
      <url>2021/04/17/idea-plugin-toolkit-0417.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>前段时间有小伙伴在群里聊天，说到 <code>Toolkit</code> 下载量到 4.9k 了。就突然想起来，很久没有更新这个插件。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/VrU468-rYoqP5.png"></p><blockquote><p>PS：我是用它申请了 License，一般时候使用 Json 格式化功能。</p></blockquote><p>趁着周末，更新了下版本，下面介绍直接介绍更新后的版本。</p><h3 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h3><h4 id="UI-界面"><a href="#UI-界面" class="headerlink" title="UI 界面"></a>UI 界面</h4><p>这次修改最大的就是 UI 界面，基本参考 <code>Doc View</code> 的 UI，全面进行改造，同时对代码也进行的一定程度上的重构。</p><p>同时增加快捷键 <code>Control + Shift + T</code> 直接唤起操作面板的功能。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/kpvNXe-m0Kk4q.png"></p><p>UI 界面调整，以标签页的形式直接展示功能，方便使用。</p><h4 id="Json-Format"><a href="#Json-Format" class="headerlink" title="Json Format"></a>Json Format</h4><p>保留原有功能：</p><ol><li>代码格式化；</li><li>压缩为一行；</li><li>移除文本中的转移符（<code>\</code>）；</li><li>快捷生成实体类字段。</li></ol><p>新增功能：</p><ol><li>快捷复制；</li><li>原生查找。</li></ol><p>动图演示：</p><ul><li>快捷键打开</li></ul><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/open-VBcGlL.gif" alt="快捷打开"></p><ul><li>Json 格式化</li></ul><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/json-format-OQe9gp.gif" alt="Json 格式化"></p><ul><li>压缩 Json 字符串为一行</li></ul><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/json-compress-V4fllY.gif" alt="Json 压缩"></p><ul><li>查找字段</li></ul><p>因为直接使用的原生 Editor 当做面板，所以是支持 <code>⌘ + F</code> 直接局内搜索的。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/json-search-juQZNn.gif" alt="局内搜索"></p><ul><li>生成字段</li></ul><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/json-generate-cSwjqG.gif" alt="生成字段"></p><p>到这里关于 Json 工具的介绍基本就结束了，这也是我在开发过成功经常用到的几个功能。当然<code>快捷复制</code>、<code>移除转移符</code>这些功能就需要小伙伴自己研究了。</p><h4 id="Copy-As-Json"><a href="#Copy-As-Json" class="headerlink" title="Copy As Json"></a>Copy As Json</h4><p>当在 Java 类中的时候，可以在右键菜单找到 <code>Copy As Json</code> 这个选项，顾名思义，就是将当前实体类转为 Json 字符串。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/copy-as-json-h2wTGo.gif" alt="Copy As Json"></p><blockquote><p>如果小伙伴仅仅想使用 Copy As Json 功能，可以在插件商城搜索，有一个插件仅支持将实体复制为 Json。</p></blockquote><p>也有一个注意的地方， 如果 <code>Control + Shift + T</code> 唤起 Toolkit 面板的地方是 Java 实体，这时候 Toolkit 面包会多一个标签页—— <code>Entity Json</code>，可以直接查看当前实体对应的 Json 字符串。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/OOwSN3-ktDpn9.png" alt="Entity Json"></p><p>如果焦点不在 Java 实体中，是没有这个标签页的！</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/PlWy6F-33LRk1.png" alt="全局唤起"></p><h4 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h4><ul><li>Base64</li><li>Url Encode/Decode</li></ul><h4 id="移除功能"><a href="#移除功能" class="headerlink" title="移除功能"></a>移除功能</h4><ul><li>移除 XML 格式化：</li></ul><p>XML 格式化使用场景越来越少，毕竟现在基本上不会有使用 XML 作为请求返回报文的了吧！</p><ul><li>移除 MyBatis Jump</li></ul><p>现在 Toolkit 没有 Mapper 接口和 Mapper XML 之间进行互相跳转，以及检测 Mapper XML 内接口是否重复的功能了。不过可以在插件商城单独下载 <code>MyBatis Jump</code>。</p><blockquote><p>MyBatis Jump 仅有跳转和检测功能，如果小伙伴们已经使用了带跳转功能的其他 MyBatis 插件，就没必要额外安装这个了。</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上就是这次的更新，主要是还是更方便工作开发。</p><p>比如经常性的对请求入参出参的 Json 字符串进行格式化</p><p>比如直接根据文档的 Json 串生成实体，省去一个一个定义字段的痛苦。</p><p>比如数据库表扩展字段存放的是Json 格式，需要压缩为一行。（IDEA 的 <code>Control + Shift + J</code> 也可以压缩一行）。</p><p>等等。</p><p>后续的话可能会有 SQL 格式化、Json 字符串对比（对比参数字段是不是少了）。</p><p>最后：</p><p>代码已经重构，相对比之前结构还是很清晰的。</p><p>有其他需要添加的功能可以提交 PR，也可以留言或者提 Issue。</p><h4 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h4><p>项目地址：<a href="https://github.com/liuzhihang/toolkit">https://github.com/liuzhihang/toolkit</a></p><p>插件地址：<a href="https://plugins.jetbrains.com/plugin/12384-toolkit">https://plugins.jetbrains.com/plugin/12384-toolkit</a></p><h4 id="相关推荐"><a href="#相关推荐" class="headerlink" title="相关推荐"></a>相关推荐</h4><ul><li><a href="https://mp.weixin.qq.com/s/75h_j5McIRQ3Z0fB72MZuA">小伙伴想写个 IDEA 插件么？这些 API 了解一下！</a></li><li><a href="https://mp.weixin.qq.com/s/Bm8sLyWWiNSlP3l7gz6h_g">IDEA 插件找不到？看这里！那就自己敲一个！</a></li><li><a href="https://mp.weixin.qq.com/s/MzWzxIM7yhYumitpF3v3Kg">IDEA 文档插件 DocView：支持编辑文档注释</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> IDEA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> plugin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工作中的设计模式 ——  建造者模式</title>
      <link href="2021/04/15/design-patterns-builder.html"/>
      <url>2021/04/15/design-patterns-builder.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>建造者模式是一种创建型设计模式，使你能够分步骤创建复杂对象。该模式允许你使用相同的创建代码生成不同类型和形式的对象。</p><p>一个 Builder 类会一步一步构造最终对象。这个 Builder 类是独立于其他对象的。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>在阅读源码过程中经常看到建造者模式，主要是为了简化复杂对象的创建。</p><blockquote><p>具体那些房子啥的举例子就不扯了，以实际工作中的应用为主。</p></blockquote><h4 id="Builder-注解"><a href="#Builder-注解" class="headerlink" title="@Builder 注解"></a>@Builder 注解</h4><p>如果小伙伴使用 lombok 这个框架的话，那一定对 <code>@Builder</code> 这个注解不会陌生。</p><pre><code class="java">@Data@Builderpublic class UserRespVo &#123;    /**     * 用户名字     */    private String userName;    /**     * 用户 id     */    private String userId;    public static void main(String[] args) &#123;        UserRespVo respVo = UserRespVo.builder()                .userId(&quot;liuzhihang&quot;)                .userName(&quot;程序员小航&quot;)                .build();    &#125;&#125;</code></pre><p>看一下编译后的 .class 文件。</p><pre><code class="java">public class UserRespVo &#123;    private String userName;    private String userId;    UserRespVo(final String userName, final String userId) &#123;        this.userName = userName;        this.userId = userId;    &#125;    public static UserRespVo.UserRespVoBuilder builder() &#123;        return new UserRespVo.UserRespVoBuilder();    &#125;    public static class UserRespVoBuilder &#123;        private String userName;        private String userId;        UserRespVoBuilder() &#123;        &#125;        public UserRespVo.UserRespVoBuilder userName(final String userName) &#123;            this.userName = userName;            return this;        &#125;        public UserRespVo.UserRespVoBuilder userId(final String userId) &#123;            this.userId = userId;            return this;        &#125;        public UserRespVo build() &#123;            return new UserRespVo(this.userName, this.userId);        &#125;    &#125;&#125;</code></pre><p>其实就是在内部创建了一个 Builder 的静态内部类，以及一个 builder() 方法。这样就可以进行<code>链式调用</code>了。</p><p>如果对于复杂对象的创建，小伙伴也可以采用 lombok 的这种方式，先创建 builder 对象，然后一步一步构建对象。</p><h4 id="在源码和工作中"><a href="#在源码和工作中" class="headerlink" title="在源码和工作中"></a>在源码和工作中</h4><p>在阅读源码，或者是使用开源软件的时候，经常会遇到建造者模式，比如 <code>OkHttp3Utils</code></p><pre><code class="java">private static OkHttpClient client = new OkHttpClient            .Builder()            .readTimeout(60, TimeUnit.SECONDS)            .connectTimeout(60, TimeUnit.SECONDS)            .writeTimeout(120, TimeUnit.SECONDS)            .build();</code></pre><p>比如 <code>Eureka</code> 源码中 <code>InstanceInfo</code> 的构建。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/2SIt1R-kcBSH6.png" alt="InstanceInfo.Builder"></p><p>比如使用 <code>Elasticsearch</code> 创建 client 的代码 </p><pre><code class="java">RestClient restClient = RestClient.builder(    new HttpHost(&quot;localhost&quot;, 9200, &quot;http&quot;),    new HttpHost(&quot;localhost&quot;, 9201, &quot;http&quot;))    .build();</code></pre><p>还比如 Mybatis Plus，等等等…… </p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文介绍了在工作中使用建造者模式，因为这是在工作中经常见到的一种设计模式。只不过很多人容易忽略，然后看各种资料，又是房子又是窗户的，云里雾里，一大堆代码。</p><p>淡定，淡定，没必要的。其实很多设计模式在不知不觉中已经使用了，只不过没有归纳总结而已。</p><h4 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h4><ol><li>《深入设计模式》：<a href="https://refactoringguru.cn/design-patterns">https://refactoringguru.cn/design-patterns</a></li><li>封面图：<a href="https://refactoringguru.cn/design-patterns/builder">https://refactoringguru.cn/design-patterns/builder</a></li></ol><h4 id="相关推荐"><a href="#相关推荐" class="headerlink" title="相关推荐"></a>相关推荐</h4><ul><li><a href="https://mp.weixin.qq.com/s/otF145cpGuNA655BRD5ceQ">工作中的设计模式 —— 原型模式</a></li><li><a href="https://mp.weixin.qq.com/s/UalG6xIveNJ4XtqirVX6ww">工作中的设计模式 —— 策略模式</a></li><li><a href="https://mp.weixin.qq.com/s/Hn3C5a_hNPcscB93XlFO8Q">Spring 自调用事务失效，你是怎么解决的？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工作中的设计模式 —— 策略模式</title>
      <link href="2021/04/07/design-patterns-strategy.html"/>
      <url>2021/04/07/design-patterns-strategy.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>策略模式是一种行为设计模式，它能让你定义一系列算法，并将每种算法分别放入独立的类中，以使算法的对象能够相互替换。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>策略模式在工作中使用的相对是比较多的，像支付场景，计费场景，优惠场景，活动奖励、用户等级等等。</p><p>当然也有很多直白的说法，就是替换一大堆的 if else。</p><pre><code class="java">if (x == aaa) &#123;    // 200 行代码&#125; else if (x == bbb) &#123;    // 200 行代码&#125; else if (x == ccc) &#123;    // 200 行代码&#125;</code></pre><p>按照上面的 if else 逻辑，其中 aaa、bbb、ccc 就是不同的策略。而使用策略模式的目的，就是当又增加了 ddd、eee 等等的时候，更方便的扩展。</p><p>这里以工作中遇到的场景举例：</p><blockquote><p>这里选择使用计费场景中的计费策略举例：<br>在计费场景中，需要每日给用户发放利息，同时用户分为普通用户、持卡用户，他们有分别的利率以及计息方式。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/tikn5j-MwpKTQ.png"></p><p>很明显，在计费时要使用策略模式，按照以下模式进行开发。</p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><h4 id="定义计算接口"><a href="#定义计算接口" class="headerlink" title="定义计算接口"></a>定义计算接口</h4><pre><code class="java">public interface RevenueCalculator &#123;    RevenueDTO calculate(BigDecimal asset);&#125;</code></pre><h4 id="定义不同的计算实现"><a href="#定义不同的计算实现" class="headerlink" title="定义不同的计算实现"></a>定义不同的计算实现</h4><p>对外暴露的是一个接口，而具体的实现，则需要自己去扩展。下面展示了三个实现。</p><pre><code class="java">@Componentpublic class DefaultRevenueCalculator implements RevenueCalculator &#123;    @Override    public RevenueDTO calculate(BigDecimal asset) &#123;        return null;    &#125;&#125;</code></pre><pre><code class="java">@Componentpublic class StepRateGeneralRevenueCalculator implements RevenueCalculator &#123;    @Override    public RevenueDTO calculate(BigDecimal asset) &#123;        return null;    &#125;&#125;</code></pre><pre><code class="java">@Componentpublic class StepRateHoldCardRevenueCalculator implements RevenueCalculator &#123;    @Override    public RevenueDTO calculate(BigDecimal asset) &#123;        return null;    &#125;&#125;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/6tQZxO-pUxRYN.png"></p><p>当然这里 StepRateHoldCardRevenueCalculator 和 StepRateGeneralRevenueCalculator 有抽象相同的业务逻辑，也可以抽出来一层工厂方法。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/L1HqZy-wGoxKa.png"></p><p>这些在这里都不是重点。</p><p>通过实现接口的方式，在后面有新的计费策略时，就写一个新的实现类就可以了。</p><p>现在的问题是，我如何确定哪个用户走那一套策略呢？</p><h4 id="策略类"><a href="#策略类" class="headerlink" title="策略类"></a>策略类</h4><pre><code class="java">public enum UserTypeEnum implements BaseEnum &#123;    /**     * OWealth 原始计息方式     */    DEFAULT_USER(-1, &quot;原计息方式&quot;, &quot;defaultRevenueCalculator&quot;),    /**     * 普通用户     */    GENERAL_USER(0, &quot;默认用户&quot;, &quot;stepRateGeneralRevenueCalculator&quot;),    /**     * 持卡用户     */    HOLD_CARD_USER(1, &quot;持卡用户&quot;, &quot;stepRateHoldCardRevenueCalculator&quot;),    ;    // 省略代码&#125;</code></pre><pre><code class="java">public class RevenueCalculatorFactory &#123;    public static RevenueCalculator getCalculator(UserTypeEnum userType) &#123;        return SpringContextHolder.getBean(userType.getServiceName());    &#125;&#125;</code></pre><p>这里只是介绍了使用枚举维护用户类型和策略实现的关系，也可以在这里面写 if else 判断策略，或者维护在数据库中。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文介绍了在工作中使用策略模式，总结一下经常使用到的场景：</p><ol><li>支付方式的选择：微信、支付宝、银联等等</li><li>计费策略不同：不同的用户计费方式不同（收费/运费等）</li><li>活动规则选择：不同的活动走不同计算的逻辑</li><li>计息方式不同：不同的用户（产品）计算利息的方式不同<br>…</li></ol><p>更多的就需要小伙伴去发现和总结了。</p><blockquote><p>渔、就在这里，能不能打到鱼，那就靠耐心了。<br>加油</p></blockquote><h4 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h4><ol><li>《深入设计模式》：<a href="https://refactoringguru.cn/design-patterns">https://refactoringguru.cn/design-patterns</a></li><li>封面图：<a href="https://refactoringguru.cn/design-patterns/strategy">https://refactoringguru.cn/design-patterns/strategy</a></li></ol><h4 id="相关推荐"><a href="#相关推荐" class="headerlink" title="相关推荐"></a>相关推荐</h4><ul><li><a href="https://mp.weixin.qq.com/s/otF145cpGuNA655BRD5ceQ">工作中的设计模式 —— 原型模式</a></li><li><a href="https://mp.weixin.qq.com/s/UlUQ95gVt8I8wmVOEjn1aw">Spring 是如何解决循环依赖的？</a></li><li><a href="https://mp.weixin.qq.com/s/Hn3C5a_hNPcscB93XlFO8Q">Spring 自调用事务失效，你是怎么解决的？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【工具册】- IDEA 文档插件 DocView 版本更新：支持编辑文档注释</title>
      <link href="2021/04/02/doc-view-editor.html"/>
      <url>2021/04/02/doc-view-editor.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>IDEA 文档插件 Doc View 又更新了新版本，本次更新版本如下：</p><ol><li>支持在方法右键菜单选择 Doc Editor 直接编辑文档<ol><li>编辑接口文档名称</li><li>编辑接口描述</li><li>编辑字段是否必填</li><li>编辑字段注释说明</li><li>点击确定, 会回写到源文件的注释中</li></ol></li><li>支持在 Entity 中通过邮件菜单选择Doc Editor 编辑字段信息<ol><li>编辑字段是否必填</li><li>编辑字段注释说明</li><li>点击确定, 会回写到源文件的注释中</li><li>支持将 Entity 复制为 Json 字符串</li><li>复制 Json 字符串时, 支持 Entity 中包含对象的转换</li></ol></li><li>从 Doc View 预览界面直接跳转到编辑界面</li></ol><p>是不是看着挺多的，下面，咱们就了解下具体都是什么吧！</p><h3 id="Doc-Editor"><a href="#Doc-Editor" class="headerlink" title="Doc Editor"></a>Doc Editor</h3><h4 id="在方法右键菜单"><a href="#在方法右键菜单" class="headerlink" title="在方法右键菜单"></a>在方法右键菜单</h4><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/l3sIe0-7D3bOv.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/HoTgCq-XO0gau.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/OCNAp3-lO5ujJ.png"></p><p>弹起操作面板，可编辑参数如下：</p><ol><li>接口名称：默认取方法名，当有注释且注释 tag 为 @docName 时，会取 @docName 对应的名称；</li><li>接口描述：取注释的描述内容；</li><li>请求/返回参数：请求返回参数的是否必填、描述。</li></ol><p>下面使用动图演示：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/doceditor-1-0ILFLN.gif"></p><h4 id="在实体类右键菜单"><a href="#在实体类右键菜单" class="headerlink" title="在实体类右键菜单"></a>在实体类右键菜单</h4><p>在实体类中右键菜单，其实相当于方法中的请求/返回参数那一部分。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/LC0bRs-ZOdH6L.png"></p><p>操作面板操作如下：</p><ol><li>是否必填：将使用注释 tag @required 作为是否必填的标识。当然也支持 <code>javax.validation.constraints</code> 的部分注解；</li><li>描述信息：描述内容为注释内容，修改后会回写到注释中；</li><li>复制为 Json 字符串，支持多级嵌套。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/docview-2-MeKcA8.gif"></p><p>如果上述内容点击 <code>Copy as Json</code> 会将实体转换为 Json 字符串复制到剪贴板。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/doceditor-3-3SonEN.gif"></p><h4 id="直接从预览界面跳转"><a href="#直接从预览界面跳转" class="headerlink" title="直接从预览界面跳转"></a>直接从预览界面跳转</h4><p>当打开 Doc View 文档界面时，左下角可以通过编辑按钮跳转到 Doc Editor 界面。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/sULj8S-O9MBRf.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Doc View 本次更新介绍就到这里就结束了，有兴趣的小伙伴，可以自己安装体验。</p><p>欢迎小伙伴们提出 Issue 和 PR。</p><p>项目地址：<a href="https://github.com/liuzhihang/doc-view">https://github.com/liuzhihang/doc-view</a><br>插件地址：<a href="https://plugins.jetbrains.com/plugin/15305-doc-view">https://plugins.jetbrains.com/plugin/15305-doc-view</a></p><p>【广告】</p><p>为了方便沟通交流，我创建了一个<strong>技术交流群</strong>，在群里可以交流技术，聊天提问，有兴趣的小伙伴可以通过公众号加我好友，发送进群，我会拉你进群。<br>PS：事先说好哦，不准发广告。</p>]]></content>
      
      
      <categories>
          
          <category> 工具册 </category>
          
          <category> Doc View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具册 </tag>
            
            <tag> Doc View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工作中的设计模式 —— 原型模式</title>
      <link href="2021/03/10/design-patterns-prototype.html"/>
      <url>2021/03/10/design-patterns-prototype.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>原型模式是一种创建型设计模式， 使你能够复制已有对象， 而又无需使代码依赖它们所属的类。</p><p>通俗说法，就是将一个类作为原型，然后复制出来另一个类。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>这么一说，是不是发现我们经常使用？</p><p>比如咱们项目中有 BO、DTO、VO，但是在开发过程中，需要各种转换，get/set，一般情况下大家都会使用 <code>BeanUtils</code>，将一个类的属性值 set 到另一个类的属性值中，然后返回。</p><blockquote><p>当然，也有一个实体直接从头捅到尾的。</p></blockquote><p>关于 BeanUtils 的 copy 方法，各个框架都提供了相关工具，不过 <code>Java 开发手册</code> 有指出 <code>Apache BeanUtils 性能较差</code>、也推荐了其他框架。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/yfjv8s-XuDRVl.png" alt="Java 开发手册"></p><p>这里介绍的是使用 Cglib BeanCopier。</p><h3 id="封装工具类"><a href="#封装工具类" class="headerlink" title="封装工具类"></a>封装工具类</h3><p>查看文档，先封装一个工具类：</p><pre><code class="java">public class BeanCopierUtils &#123;    private BeanCopierUtils() &#123;    &#125;    /**     * 将source对象的属性拷贝到target对象中去     *     * @param source source对象     * @param target target对象     */    public static void copyProperties(Object source, Object target) &#123;        BeanCopier beanCopier = BeanCopier.create(source.getClass(), target.getClass(), false);        beanCopier.copy(source, target, null);    &#125;&#125;</code></pre><p>看到这里是不是感觉，如果我使用 <code>BeanCopier</code> 比较频繁，然后每次都 create 创建对象，是不是很麻烦？</p><p>所以就想到需要用缓存！</p><p>将 BeanCopier 作为一个<code>元</code>，在各个线程使用的时候，共享。</p><pre><code class="java">public class BeanCopierUtils &#123;    private BeanCopierUtils() &#123;    &#125;    /**     * BeanCopier缓存     */    private static Map&lt;String, BeanCopier&gt; CACHE = new HashMap&lt;&gt;();    /**     * 将source对象的属性拷贝到target对象中去     *     * @param source source对象     * @param target target对象     */    public static void copyProperties(Object source, Object target) &#123;        String cacheKey = source.getClass().getName() + target.getClass().getName();        BeanCopier beanCopier;        if (!CACHE.containsKey(cacheKey)) &#123;            // 进入到这里会创建一个BeanCopier实例并且放在缓存map中            beanCopier = BeanCopier.create(source.getClass(), target.getClass(), false);            CACHE.put(cacheKey, beanCopier);        &#125; else &#123;            beanCopier = CACHE.get(cacheKey);        &#125;        beanCopier.copy(source, target, null);    &#125;&#125;</code></pre><p>然后再代码中就可以欢快的使用啦！</p><pre><code class="java">BeanCopierUtils.copyProperties(dto, vo);</code></pre><p>到这里，大家发现，好像就封装了一个工具类，和原型模式并没有什么关系啊。</p><h3 id="对象的-clone"><a href="#对象的-clone" class="headerlink" title="对象的 clone"></a>对象的 clone</h3><p>到此其实在代码中都可以使用了，不过还是要在 DTO、VO 中声明 clone 方法，这样之后使用才会更方便~</p><pre><code class="java">/** * 将当前对象转化为目标对象 * * @param clazz * @param &lt;T&gt; * @return * @throws Exception */public &lt;T&gt; T clone(Class&lt;T&gt; clazz) throws Exception &#123;    T target = clazz.newInstance();    BeanCopierUtils.copyProperties(this, target);    return target;&#125;</code></pre><p>现在使用的时候就可以</p><pre><code class="java">AccountVO accountVO = accountDTO.clone(AccountVO.class);</code></pre><p>不过也是有弊端的，比如这里使用的是泛型，我明明是 UserVO 要 Clone ， 你非得传一个 AddressDTO，那我也没得办法了。</p><p>至于进一步演化，可以将 clone 抽象到公共方法中，比如给所有 DTO 创建一个 BaseDTO。</p><p>还有深拷贝这块，也需要注意。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实工作中有很多设计模式，只不过用到了，大家没有发现。</p><p>当然工作中使用的时候，都是一切为了敏捷，可能并没有定义什么 Prototype 接口之类的，但是还是要多总结。</p><p>最后，小伙伴们工作中，有使用什么设计模式，以及实际中的应用场景，欢迎留言分享。</p><h4 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h4><ol><li>《深入设计模式》：<a href="https://refactoringguru.cn/design-patterns">https://refactoringguru.cn/design-patterns</a></li><li>封面图：<a href="https://refactoringguru.cn/design-patterns/prototype">https://refactoringguru.cn/design-patterns/prototype</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA 敏捷开发技巧——实时模版</title>
      <link href="2021/02/15/idea-live-templates.html"/>
      <url>2021/02/15/idea-live-templates.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文通过自定义模版，在 IDEA 中，通过简单的几个字符，快捷生成既定的代码。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/3-G7xXaS.gif" alt="fori"></p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/4-HeyMbU.gif" alt="iter"></p><h3 id="自定义模版"><a href="#自定义模版" class="headerlink" title="自定义模版"></a>自定义模版</h3><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/1-gm9BXy.gif" alt="comment"></p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/2-r0vlvT.gif" alt="slf"></p><h4 id="如何自定义模版"><a href="#如何自定义模版" class="headerlink" title="如何自定义模版"></a>如何自定义模版</h4><blockquote><p>Windows and Linux</p><p><code>File</code> -&gt; <code>Settings</code> -&gt; <code>Editor</code> -&gt; <code>Live Templates</code>  </p></blockquote><blockquote><p>macOS</p><p><code>IntelliJ IDEA</code> -&gt; <code>Preferences</code> -&gt; <code>Editor</code> -&gt; <code>Live Templates</code> </p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/mZdGqO-DwKxrE.png" alt="Live Templates 设置"></p><ul><li><strong>先添加一个 group，表示这里都是自己自定义的。</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/jGlxti-FyRLyk.png" alt="添加 Group"></p><p>这个名字就自己随便取了，只要知道是自己的就可以。比如我的叫 <code>My Template</code>。</p><ul><li><strong>添加 Template 到自己创建的 group 里面</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/3ewYTY-hjtzbg.png" alt="添加 Template"></p><p>下面分别介绍里面的变量：</p><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">Abbreviation</td><td align="left">缩写，需要用什么缩写唤起模版。</td></tr><tr><td align="left">Description</td><td align="left">描述，写不写都行。</td></tr><tr><td align="left">Template Text</td><td align="left">模版内容，这是关键！前后使用 <code>$</code> 包裹的内容即变量 —— <code>$变量$ </code>。</td></tr><tr><td align="left">Applicable in</td><td align="left">就是在哪一块生效，配置了这个就可以使用 <code>⌘+J</code> 快捷唤起所有的在该处生效的模版。</td></tr><tr><td align="left">Edit Variables</td><td align="left">编辑变量，为变量赋予对应的属性。</td></tr><tr><td align="left">Options</td><td align="left">一些选项 <br> 1. Expand with： 展开按键 <br> 2. Reformat according to style：重新格式化  <br> 3. Use static import if possible：使用静态导入 <br> 4. Shorten FQ names：缩短全类名，自动添加 import</td></tr></tbody></table><ul><li><strong>编辑 Template Text</strong></li></ul><pre><code class="text">/** * $END$ * * @author liuzhihang * @date $date$ $time$ */</code></pre><p>其中 <code>$END$</code> 是系统变量，意思是最后光标停留在哪。</p><ul><li><strong>编辑变量 Edit Variables</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/wtQ4Dq-l1S3aA.png"></p><p>然后点击确定就可以生成模版了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>也有一些其他的内置变量，可以参考地址：</p><p><a href="https://www.jetbrains.com/help/idea/edit-template-variables-dialog.html#predefined_functions">https://www.jetbrains.com/help/idea/edit-template-variables-dialog.html#predefined_functions</a></p><p>如果小伙伴有其他的小技巧，小工具，也可以留言分享。</p><h4 id="相关推荐"><a href="#相关推荐" class="headerlink" title="相关推荐"></a>相关推荐</h4><ul><li><a href="https://mp.weixin.qq.com/s/3FRquSf9kiO_R9G3ZLyHUQ">IDEA 敏捷开发技巧——后缀完成</a></li><li><a href="https://mp.weixin.qq.com/s/ngpTOx4XO0SDeqxH-0Yjgg">给大家介绍下，这是我的流程图软件 —— draw.io</a></li><li><a href="https://mp.weixin.qq.com/s/GBgpiWS6B66XVvX5nLUq8g">头大！写文档太麻烦了！快来试试这款 IDEA 插件啊！爽到飞起~</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具册 </category>
          
          <category> Doc View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具册 </tag>
            
            <tag> Doc View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA 敏捷开发技巧——后缀完成</title>
      <link href="2021/02/10/idea-postfix-completion.html"/>
      <url>2021/02/10/idea-postfix-completion.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>“工欲善其事，必先利其器。”</p><p>所以说今天来看一看如何压榨 IDEA ，让你的 IDEA 使用的更顺手！</p><p>今日技巧：</p><ul><li>后缀完成</li><li>自定义后缀完成模版</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/sout-ShVzVM.gif" alt=".sout 示例"></p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/if-EkdoN9.gif" alt=".if 示例"></p><p>上面动图使用了 <code>.sout</code> <code>.if</code> 来举例，相信有些小伙伴在工作中经常使用。如果没有使用过，也可以🦑尝试一下。</p><h3 id="自定义后缀模版"><a href="#自定义后缀模版" class="headerlink" title="自定义后缀模版"></a>自定义后缀模版</h3><p>因为打印日志的时候，为了方便日志的查看，一般会将实体打印成 Json <del>（性能问题先忽略）</del>。</p><p>然后就可以使用这个方式来自定义后缀完成的模版。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/jsons-lb1HBJ.gif" alt=".jsons 模版"></p><p>是不是瞬间感觉方便很多了。</p><h4 id="如何自定义后缀模版"><a href="#如何自定义后缀模版" class="headerlink" title="如何自定义后缀模版"></a>如何自定义后缀模版</h4><blockquote><p>Windows and Linux</p><p><code>File</code> -&gt; <code>Settings</code> -&gt; <code>Editor</code> -&gt; <code>General</code> -&gt; <code>Postfix Completion</code>  </p></blockquote><blockquote><p>macOS</p><p><code>IntelliJ IDEA</code> -&gt; <code>Preferences</code> -&gt; <code>Editor</code> -&gt; <code>General</code> -&gt; <code>Postfix Completion</code>  </p></blockquote><p>总之，就是设置页面，找到 <code>Postfix Completion</code>， 不是（Live Templates）。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/Wfwdxc-FKpNrV.png" alt="Postfix Completion 设置"></p><p>左下角有个  <img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/icons.general.add-EI0r5S.svg" alt="Add button"> 可以创建新的模版。</p><p>当然也可以使用 <img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/icons.general.remove-Pl6t37.svg" alt="Remove button">、 <img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/icons.actions.edit-qVT4eX.svg" alt="Edit button">、 <img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/icons.actions.copy-es8UYd.svg" alt="Duplicate button"> 进行删除、编辑、复制。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/BH34d4-xaQdaP.png" alt="配置 .jsons"></p><p>注意：</p><ol><li>用全类名，在生成的时候会自动 <code>import</code>，并且把包名省略掉，</li><li><code>Apply to the topmost expression</code> 没有打勾。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>小伙伴们，快点配置下试试吧。</p><p>后续也会分享其他的小技巧，提高大家的开（mo）发（🐟）效率。</p><p>如果小伙伴有其他的小技巧，小工具，也可以留言分享。</p><h4 id="相关推荐"><a href="#相关推荐" class="headerlink" title="相关推荐"></a>相关推荐</h4><ul><li><a href="https://mp.weixin.qq.com/s/ngpTOx4XO0SDeqxH-0Yjgg">给大家介绍下，这是我的流程图软件 —— draw.io</a></li><li><a href="https://mp.weixin.qq.com/s/GBgpiWS6B66XVvX5nLUq8g">头大！写文档太麻烦了！快来试试这款 IDEA 插件啊！爽到飞起~</a></li><li><a href="https://mp.weixin.qq.com/s/75h_j5McIRQ3Z0fB72MZuA">小伙伴想写个 IDEA 插件么？这些 API 了解一下！</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具册 </category>
          
          <category> Doc View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具册 </tag>
            
            <tag> Doc View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 事务、异步和循环依赖有什么关系？</title>
      <link href="2021/02/01/spring-sync-translational.html"/>
      <url>2021/02/01/spring-sync-translational.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在循环依赖中有一种循环依赖，就是自注入：自己依赖自己。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/fW0NNi-8qZU54.png"></p><h3 id="事务的自注入"><a href="#事务的自注入" class="headerlink" title="事务的自注入"></a>事务的自注入</h3><p>在 <a href="https://mp.weixin.qq.com/s/Hn3C5a_hNPcscB93XlFO8Q">Spring 自调用事务失效，你是怎么解决的？</a> 有小伙伴提出可以自己注入自己来解决事务失效。</p><p>具体使用方式如下：</p><pre><code class="java">@Slf4j@Servicepublic class OrderBizServiceImpl implements OrderBizService &#123;    // 注入自己    @Autowired    private OrderBizService orderBizService;    @Override    public void callBack() throws Exception &#123;        // 一系列的逻辑        // 需要事务操作更新订单和用户金额        orderBizService.updateOrderStatusAndUserBalance();    &#125;    @Override    @Transactional(rollbackFor = Exception.class)    public void updateOrderStatusAndUserBalance() throws Exception &#123;        // 内部是事务逻辑    &#125;&#125;</code></pre><p>是不是发现很神奇的事情，事务生效了。</p><p>其实这里注入自己，其实是注入的一个代理对象，调事务，也是调的代理对象的事务，所以事务生效。</p><blockquote><p>Spring 事务失效原因：</p><p>事务只能应用到 public 方法上才会有效；<br>事务需要从外部调用，Spring 自调用会失效；<br>建议事务注解 @Transactional 一般添加在实现类上。</p></blockquote><h3 id="异步的自注入"><a href="#异步的自注入" class="headerlink" title="异步的自注入"></a>异步的自注入</h3><p>发现 @Transactional 注解可以自注入解决事务失效的问题，在某次开发中，自然而然想到 @Async 异步是不是也可以自注入解决循环依赖的问题。</p><p>NO， NO， NO……</p><p>事实告诉我们是不可以的！</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/8eItMS-VUNWGY.png"></p><p>从错误开始着手：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/d8qJGr-iDX7TR.png" alt="抛出异常部分 doCreateBean"></p><p>开始往上面反推 <strong>exposedObject == bean</strong> 是这一块出了问题。</p><p>也就是说异步的时候，再次从二级缓存中获取的和初始的不相同。</p><p>Object earlySingletonReference = getSingleton(beanName, false);</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/yz6iH3-PG6zMy.png" alt="从二级缓存再次获取 Bean"></p><p>这一次获取的时候发现不同所以报错。</p><p>那就开始 Debug， 按照循环依赖的逻辑，执行到 <code>populateBean</code> 时，属性赋值，发现有依赖自己，此时会创建自己。</p><p>执行 singleton.getObject 方法</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/J8MiKx-5rZGsk.png" alt="getEarlyBeanReference"></p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/GRsoxq-zDv3Y0.png" alt="getBeanPostProcessors()"></p><p>而此时执行 getEarlyBeanReference 先判断 <code>InfrastructureAdvisorAutoProxyCreator</code> true 调用 wrapIfNecessary 判断是否生成一个代理对象，这里并没有生成代理对象。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/aOuJH2-8heoG2.png"></p><p>然后开始执行异步的 <code>AsyncAnnotationBeanPostProcessor</code> 判断为 false。所以没有执行异步的生成代理对象逻辑。</p><p>那就继续往下看</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/JOkfqE-FB4fGj.png" alt="到这一步还是正常的"></p><p>进入到 initializeBean 的逻辑，有一部分叫做 <strong>applyBeanPostProcessorsAfterInitialization</strong></p><blockquote><p>方面小伙伴搜索，所以贴出来代码关键字。IDEA 使用 <code>⌘ + Shift + F</code> 搜索。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/zt90fX-92rqmZ.png" alt="applyBeanPostProcessorsAfterInitialization"></p><p>循环执行后置处理器：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/oardNw-MNrM5t.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/y7jblu-f9c8ra.png"></p><p>发现执行完 <strong>AsyncAnnotationBeanPostProcessor</strong> 这个 PostProcessor 后，对象被改变了。从而导致二级缓存和当前的 Bean 不同。</p><p>以上也就是为什么 @Async 自调用不可以，因为在后面初始化阶段被代理修改了对象。</p><h4 id="Transactional-为什么可以呢？"><a href="#Transactional-为什么可以呢？" class="headerlink" title="@Transactional 为什么可以呢？"></a>@Transactional 为什么可以呢？</h4><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/h9qjzJ-PtrEyJ.png" alt="getEarlyBeanReference"></p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/umX1vi-m1rUT7.png" alt="getBeanPostProcessors()"></p><p>先判断 <strong>InfrastructureAdvisorAutoProxyCreator</strong> true 生成一个代理对象。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/xhyHmk-R2XONP.png" alt="生成代理对象"></p><p>事务的处理器 <strong>PersistenceExceptionTranslationPostProcessor</strong> 也没有执行。</p><p>继续 Debug 关注 <strong>applyBeanPostProcessorsAfterInitialization</strong></p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/DXReoS-4TOcfo.png"></p><p>执行结束，发现 Bean 没有发生改变。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>@Transactional：</strong> 是在循环依赖从二级缓存升到三级缓存的时候已经生成了代理对象。</li><li><strong>@Async：</strong> 是在初始化阶段（initializeBean）去生成代理对象。然后 @Async 导致后面判断 <code>exposedObject == bean</code> 为 false ，从而抛出异常。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/QUx5E6-LTVWfh.png" alt="自注入"></p><p>可以看出图中有两处会执行 BeanPostProcessor ：</p><ol><li>在 singletonFactory.getObject 时，如果是 <strong>SmartInstantiationAwareBeanPostProcessor</strong> 的子类会执行 getEarlyBeanReference 方法。</li><li>在 initializeBean 的 applyBeanPostProcessorsAfterInitialization 时会执行所有 BeanPostProcessor 的 postProcessAfterInitialization 的方法。</li></ol><blockquote><p>也有其他的地方在执行后置处理器，比如 applyBeanPostProcessorsBeforeInitialization ，只不过这里关注这俩处。</p></blockquote><p>而这两处都有可能生成代理对象， @Transactional 是在 getEarlyBeanReference 处生成的代理对象，所以后面判断 Bean 是否被改变时为 true，而 @Async 是在后面异步生成了代理对象，所以判断不通过。</p><p>至此，分析完毕，错误之处，欢迎指正。</p><h4 id="相关推荐"><a href="#相关推荐" class="headerlink" title="相关推荐"></a>相关推荐</h4><ul><li><a href="https://mp.weixin.qq.com/s/sscl6CtQWCap381bj9Fe2A">Spring 动态代理时是如何解决循环依赖的？为什么要使用三级缓存？</a></li><li><a href="https://mp.weixin.qq.com/s/UlUQ95gVt8I8wmVOEjn1aw">Spring 是如何解决循环依赖的？</a></li><li><a href="https://mp.weixin.qq.com/s/Hn3C5a_hNPcscB93XlFO8Q">Spring 自调用事务失效，你是怎么解决的？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 源码笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 动态代理时是如何解决循环依赖的？为什么要使用三级缓存？</title>
      <link href="2021/01/30/source-spring-circular-dependence-2.html"/>
      <url>2021/01/30/source-spring-circular-dependence-2.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在研究 <a href="https://mp.weixin.qq.com/s/UlUQ95gVt8I8wmVOEjn1aw">『 Spring 是如何解决循环依赖的 』</a> 的时候，了解到 Spring 是借助<em>三级缓存</em>来解决循环依赖的。</p><p>同样在上一节留下了疑问：</p><ol><li>循环依赖为什么要使用三级缓存？而不是使用二级缓存？</li><li>AOP 动态代理对循环依赖的有没有什么影响？</li></ol><p>本篇文章也是围绕上面的内容进行展开。</p><blockquote><p>笔记也在不断整理，之前可能会有点杂乱。</p></blockquote><h3 id="循序渐进，看一看什么是循环依赖？"><a href="#循序渐进，看一看什么是循环依赖？" class="headerlink" title="循序渐进，看一看什么是循环依赖？"></a>循序渐进，看一看什么是循环依赖？</h3><p>开始先简单回顾一下 Bean 的创建过程，当然小伙伴也可以直接阅读<a href="https://mp.weixin.qq.com/s/qZ4xXlqpNzsdHkvFm02Yuw">『 单例 Bean 的创建 』</a>这篇文章。</p><p>不过考虑到阅读本文前再阅读上一篇文章、Debug 等等，会比较耗时，所以本篇文章前面一小部分会先对之前的文章内容做简要概括，也相当于对我自己学习的知识进行一个总结。</p><p>先来回顾一下三级缓存的概念。</p><blockquote><p><strong>singletonObjects：</strong> 一级缓存，存储单例对象，Bean 已经实例化，初始化完成。</p><p><strong>earlySingletonObjects：</strong> 二级缓存，存储 singletonObject，这个 Bean 实例化了，还没有初始化。</p><p><strong>singletonFactories：</strong> 三级缓存，存储 singletonFactory。</p></blockquote><h4 id="Bean-的创建过程"><a href="#Bean-的创建过程" class="headerlink" title="Bean 的创建过程"></a>Bean 的创建过程</h4><pre><code class="java">@Servicepublic class CircularServiceA &#123;    private String fieldA = &quot;字段 A&quot;;&#125;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/Py9LKD-MrHkh6.png" alt="单例 Bean 的创建过程"></p><p>通过上面的流程，可以看出 Spring 在创建 Bean 的过程中重点是在 AbstractAutowireCapableBeanFactory 中的以下三个步骤：</p><ol><li><strong>实例化 createBeanInstance：</strong> 其中实例化 Bean 并对 Bean 进行赋值，像例子中的 <code>fieldA</code> 字段在这里就会赋值。</li><li><strong>属性注入 populateBean：</strong> 可以理解为对 Bean 里面的属性进行赋值。(会依赖其他 Bean)</li><li><strong>初始化 initializeBean：</strong> 执行初始化和 Bean 的后置处理器。</li></ol><blockquote><p>实例化赋值源码可以阅读：</p><p>BeanUtils.instantiateClass(constructorToUse) </p></blockquote><h4 id="如果要依赖其他-Bean-呢？"><a href="#如果要依赖其他-Bean-呢？" class="headerlink" title="如果要依赖其他 Bean 呢？"></a>如果要依赖其他 Bean 呢？</h4><p>那如果 CircularServiceA 依赖了其他 Bean 呢？</p><pre><code class="java">@Servicepublic class CircularServiceA &#123;    private String fieldA = &quot;字段 A&quot;;    @Autowired    private CircularServiceB circularServiceB;&#125;@Servicepublic class CircularServiceB &#123;&#125;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/41pskM-PPjKdq.png" alt="A 依赖了 B"></p><p>当 A 依赖了 B 的时候，在 <code>createBeanInstance</code> 这一步，并不会对 B 进行属性赋值。</p><p>而是在 <code>populatedBean</code> 这里查找依赖项，并创建 B。</p><h4 id="循环依赖下的创建过程"><a href="#循环依赖下的创建过程" class="headerlink" title="循环依赖下的创建过程"></a>循环依赖下的创建过程</h4><p>循环依赖的场景，在上一篇文章已经有所讲解，这里仅仅画图说明一下。</p><pre><code class="java">@Servicepublic class CircularServiceA &#123;    private String fieldA = &quot;字段 A&quot;;    @Autowired    private CircularServiceB circularServiceB;&#125;@Servicepublic class CircularServiceB &#123;    @Autowired    private CircularServiceA circularServiceA;&#125;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/giuIlH-DkGpSm.png" alt="A B 循环依赖"></p><p>在 A 和 B 循环依赖的场景中：</p><p>B <code>populatedBean</code> 查找依赖项 A 的时候，从一级缓存中虽然未获取到 A，但是发现 A 在创建中。</p><p>此时，从三级缓存中获取 A 的 <code>singletonFactory</code> 调用工厂方法，创建 <code>getEarlyBeanReference</code> A 的早期引用并返回。</p><p>B 引用到 A ，B 就可以初始化完毕，然后 A 同样也可以初始化完毕了。</p><h3 id="二级缓存能否解决循环依赖"><a href="#二级缓存能否解决循环依赖" class="headerlink" title="二级缓存能否解决循环依赖"></a>二级缓存能否解决循环依赖</h3><p>通过上面的图，仔细分析一下，其实把二级缓存拿掉，在 B 尝试获取 A 的时候直接返回 A 的实例，是不是也是可以的？</p><p>答案是：可以的！</p><p>但是为什么还是用三级缓存呢？ </p><p>网上的很多资料说是和动态代理有关系，那就从动态代理的方面继续往下分析分析。</p><h3 id="动态代理的场景"><a href="#动态代理的场景" class="headerlink" title="动态代理的场景"></a>动态代理的场景</h3><p>在 JavaConfig（配置类） 上添加 <code>@EnableAspectJAutoProxy</code> 注解，开启 AOP ，通过 Debug 循序渐进看一看动态代理对循环依赖的影响。</p><h4 id="动态代理下，Bean-的创建过程"><a href="#动态代理下，Bean-的创建过程" class="headerlink" title="动态代理下，Bean 的创建过程"></a>动态代理下，Bean 的创建过程</h4><pre><code class="java">@Servicepublic class CircularServiceA &#123;    private String fieldA = &quot;字段 A&quot;;    public void methodA() &#123;        System.out.println(&quot;方法 A 执行&quot;);    &#125;&#125;@Aspect@Componentpublic class AspectA &#123;    @Before(&quot;execution(public void com.liuzhihang.circular.CircularServiceA.methodA())&quot;)    public void beforeA() &#123;        System.out.println(&quot;beforeA 执行&quot;);    &#125;&#125;</code></pre><p>只有 A 的情况下，给 A 添加切面，开始 Debug。</p><p>前面的流程都相同，在 initializeBean 开始出现差异。</p><p>这一步需要初始化 Bean 并执行 Bean 的后置处理器。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/kbDvax-3FjpZe.png" alt="执行后置处理器"></p><p>其中有一个处理器为： <code>AnnotationAwareAspectJAutoProxyCreator</code> 其实就是加的注解切面，会跳转到 <code>AbstractAutoProxyCreator 类的 postProcessAfterInitialization 方法</code></p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/oCPVZ3-a5XbM4.png" alt="postProcessAfterInitialization"></p><p>如图所示：wrapIfNecessary 方法会判断是否满足代理条件，是的话返回一个代理对象，否则返回当前 Bean。</p><p>后续调用 <code>getProxy</code> <code>、createAopProxy</code> 等等，最终执行到下面一部分。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/igrrym-36KWWI.png"></p><p>最终会执行到这里，AOP 代理相关的就不细看了。</p><p>一路放行，直到 initializeBean 执行结束。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/bcpJAn-uJAqpn.png" alt="A 被替换为了代理对象"></p><p>此时发现：A 被替换为了代理对象。</p><p>所以 doCreateBean 返回，以及后面放到一级缓存中的都是代理对象。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/LfRIEB-Do8LUy.png" alt="红框部分为差异"></p><h4 id="有循环依赖的动态代理"><a href="#有循环依赖的动态代理" class="headerlink" title="有循环依赖的动态代理"></a>有循环依赖的动态代理</h4><p>这一次把循环依赖打开：</p><pre><code class="java">@Servicepublic class CircularServiceA &#123;    private String fieldA = &quot;字段 A&quot;;    @Autowired    private CircularServiceB circularServiceB;    public void methodA() &#123;        System.out.println(&quot;方法 A 执行&quot;);    &#125;&#125;@Aspect@Componentpublic class AspectA &#123;    @Before(&quot;execution(public void com.liuzhihang.circular.CircularServiceA.methodA())&quot;)    public void beforeA() &#123;        System.out.println(&quot;beforeA 执行&quot;);    &#125;&#125;@Servicepublic class CircularServiceB &#123;    @Autowired    private CircularServiceA circularServiceA;    public void methodB() &#123;    &#125;&#125;@Aspect@Componentpublic class AspectB &#123;    @Before(&quot;execution(public void com.liuzhihang.circular.CircularServiceB.methodB())&quot;)    public void beforeB() &#123;        System.out.println(&quot;beforeB 执行&quot;);    &#125;&#125;</code></pre><p>开始 Debug，前面的一些列流程，都和正常的没有什么区别。而唯一的区别在于，创建 B 的时候，需要从三级缓存获取 A。</p><p>此时在 <code>getSingleton</code> 方法中会调用：<code>singletonObject = singletonFactory.getObject();</code></p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/GPjbsP-tKWmpm.png" alt="B 属性赋值时，从三级缓存获取 A"></p><p>有时会比较疑惑 <code>singletonFactory.getObject()</code> 调用的是哪里？</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/J3DYgB-O3XP0I.png" alt="三级缓存获取对象"></p><p>所以这一块调用的是 <code>getEarlyBeanReference</code>，开始遍历执行 <code>BeanPostProcessor</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/UBxYMT-FMcSHX.png" alt="getEarlyBeanReference"></p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/3oXKgp-5uCoST.png" alt="getEarlyBeanReference"></p><p>看到 <code>wrapIfNecessary</code> 就明白了吧！这块会获取一个<code>代理对象</code>。 </p><p><strong>也就是说此时返回，并放到二级缓存的是一个 A 的代理对象。</strong></p><p>这样 B 就创建完毕了！</p><p>到 A 开始初始化并执行后置处理器了！因为 A 也有代理，所以 A 也会执行到 <code>postProcessAfterInitialization</code> 这一部分！</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/STKWOC-FGcZvJ.png" alt="判断二级缓存"></p><p>但是在执行 <code>wrapIfNecessary</code> 之前，会先判断代理对象缓存是否有 A 了。</p><p><code>this.earlyProxyReferences.remove(cacheKey) != bean</code></p><p>但是这块获取到的是 A 的代理对象。肯定是 false 。 所以不会再生成一次 A 的代理对象。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/iqIHlA-MYz92A.png" alt="代理 - 循环依赖"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>可以看到，循环依赖下，有没有代理情况下的区别就在：</p><p><code>singletonObject = singletonFactory.getObject();</code></p><p>在循环依赖发生的情况下 B 中的 A 赋值时：</p><ol><li>无代理：getObject 直接返回原来的 Bean</li><li>有代理：getObject 返回的是代理对象</li></ol><p>然后都放到<strong>二级缓存</strong>。</p><h4 id="为什么要三级缓存"><a href="#为什么要三级缓存" class="headerlink" title="为什么要三级缓存?"></a>为什么要三级缓存?</h4><ol><li>假设去掉三级缓存</li></ol><p>去掉三级缓存之后，Bean 直接创建 <code>earlySingletonObjects</code>， 看着好像也可以。</p><p>如果有代理的时候，在 <code>earlySingletonObjects</code> 直接放代理对象就行了。</p><p>但是会导致一个问题：<strong>在实例化阶段就得执行后置处理器，判断有 AnnotationAwareAspectJAutoProxyCreator 并创建代理对象</strong>。</p><p>这么一想，是不是会对 Bean 的生命周期有影响。</p><p>同样，先创建 <code>singletonFactory</code> 的好处就是：<strong>在真正需要实例化的时候，再使用 singletonFactory.getObject() 获取 Bean 或者 Bean 的代理</strong>。相当于是延迟实例化。</p><ol start="2"><li>假设去掉二级缓存</li></ol><p>如果去掉了二级缓存，则需要直接在 <code>singletonFactory.getObject()</code> 阶段初始化完毕，并放到一级缓存中。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/AxHpdh-HXV06Z.png" alt="B 和 C 都依赖 A"></p><p>那有这么一种场景，B 和 C 都依赖了 A。</p><p>要知道在有代理的情况下 <code>singletonFactory.getObject()</code> 获取的是代理对象。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/BCNbfb-9D6nlz.png" alt="多次获取代理对象不同"></p><p>而多次调用 <code>singletonFactory.getObject()</code> 返回的代理对象是不同的，就会导致 B 和 C 依赖了不同的 A。</p><p>那如果获取 B 到之后直接放到一级缓存，然后 C 再获取呢？</p><p>😳 …… </p><p>一级缓存放的是已经初始化完毕的 Bean，要知道 A 依赖了 B 和 C ，A 这时候还没有初始化完毕。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>循环依赖的场景有很多，本文只是通过 Debug ，来了解到循环依赖和 AOP 之间的关系，以及了解到为什么要用三级缓存。</p><p>当然，Spring 设计之初是什么样子的？如何一步一步发展成现在这种的？</p><p>肯定是不能慢慢去研究了，所以只能以现在的版本，去揣测作者的意图。</p><p>不足之处，多多指正。</p><h4 id="相关推荐"><a href="#相关推荐" class="headerlink" title="相关推荐"></a>相关推荐</h4><ul><li><a href="https://mp.weixin.qq.com/s/UlUQ95gVt8I8wmVOEjn1aw">Spring 是如何解决循环依赖的？</a></li><li><a href="https://mp.weixin.qq.com/s/qZ4xXlqpNzsdHkvFm02Yuw">Spring 源码学习 16：单例 Bean 创建</a></li><li><a href="https://mp.weixin.qq.com/s/FhWdwroo7ipN1nzgvNpshA">Spring 源码学习 15：finishBeanFactoryInitialization（重点）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 源码笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 是如何解决循环依赖的？</title>
      <link href="2021/01/23/source-spring-circular-dependence-1.html"/>
      <url>2021/01/23/source-spring-circular-dependence-1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>相信很多小伙伴在工作中都会遇到循环依赖，不过大多数它是这样显示的：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/F0EjJ0-cjS89L.png"></p><p>还会提示这么一句：</p><p><em>Requested bean is currently in creation: Is there an unresolvable circular reference?</em></p><p>老铁！这就是发生循环依赖了！</p><p>当然这里是一个异常情况。</p><p>在我的一篇文章中介绍如何避免 <a href="https://mp.weixin.qq.com/s/Hn3C5a_hNPcscB93XlFO8Q">Spring 自调用事务失效</a>，其中网友给建议，说可以在类中注入自身，然后调用，而注入自身的过程也是循环依赖的处理过程。</p><p>下面就一起看一看，什么是循环依赖，以及 Spring 是如何解决循环依赖的？</p><h3 id="什么是循环依赖"><a href="#什么是循环依赖" class="headerlink" title="什么是循环依赖"></a>什么是循环依赖</h3><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/vinf1u-ALdO65.png" alt="Circular dependencies"></p><p><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-dependency-resolution" title="Spring 官方文档">Dependency Resolution Process</a></p><blockquote><p>Spring IoC 容器会在运行时检测到<strong>构造函数注入</strong>循环引用，并抛出 BeanCurrentlyInCreationException。</p><p>所以要避免构造函数注入，可以使用 setter 注入替代。</p></blockquote><p>根据官方文档说明，Spring 会自动解决基于 setter 注入的循环依赖。</p><p>当然在咱们工作中现在都使用 <code>@Autowired</code> 注解来注入属性。</p><blockquote><p>PS: @Autowired 是通过反射进行赋值。</p></blockquote><p>这里从我们最经常使用的场景切入，看 Spring 是如何解决循环依赖的？</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="java">@Servicepublic class CircularServiceA &#123;    @Autowired    private CircularServiceB circularServiceB;&#125;@Servicepublic class CircularServiceB &#123;    @Autowired    private CircularServiceC circularServiceC;&#125;@Servicepublic class CircularServiceC &#123;    @Autowired    private CircularServiceA circularServiceA;&#125;</code></pre><p>这里有 A、B、C 三个类，可以看到发生了循环依赖：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/2G8CEa-rstD88.png" alt="循环依赖"></p><p>但是即使发生了循环依赖，我们依然可以启动 OK，使用并没有任何影响。</p><h3 id="Spring-是如何解决循环依赖的"><a href="#Spring-是如何解决循环依赖的" class="headerlink" title="Spring 是如何解决循环依赖的"></a>Spring 是如何解决循环依赖的</h3><p>在 <a href="https://mp.weixin.qq.com/s/qZ4xXlqpNzsdHkvFm02Yuw">Spring 单例 Bean 的创建</a> 中介绍介绍了使用三级缓存。</p><blockquote><p>singletonObjects： 一级缓存，存储单例对象，Bean 已经实例化，初始化完成。</p><p>earlySingletonObjects： 二级缓存，存储 singletonObject，这个 Bean 实例化了，还没有初始化。</p><p>singletonFactories： 三级缓存，存储 singletonFactory。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/KS60bs-aWqhoU.png"></p><p>当然，这里看着比较长，可以简化一下：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/1QnEIw-1agsnx.png"></p><h3 id="通过-Debug-来说明生成过程"><a href="#通过-Debug-来说明生成过程" class="headerlink" title="通过 Debug 来说明生成过程"></a>通过 Debug 来说明生成过程</h3><p>从 preInstantiateSingletons 方法开始：</p><p>添加断点 <code>beanName.equals(&quot;circularServiceA&quot;)</code></p><p>启动Debug：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/SYoDdM-0pgCsu.png" alt="Start"></p><p>会从缓存中获取单例 Bean </p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/AeMsAm-KnFiZA.png"></p><p>这里很显然获取不到，继续执行，创建单例实例</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/JRFOxl-Tsbi9H.png"></p><p>发现是单例再次获取</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/YWcgWk-90K6tS.png"></p><p>这里还会从一级缓存获取一次 <code>circularServiceA</code> ， 没有获取到，将 <code>circularServiceA</code> 添加到在创建的池子里面 （singletonsCurrentlyInCreation 是一个 set 集合）。</p><p>然后会调用工厂方法 createBean(beanName, mbd, args) 创建对象。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/MnA2Db-juxIN7.png" alt="createBean 方法"></p><p>在 createBean 中去实例化 Bean 。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/kVo7G6-DAtYGM.png"></p><p>判断是否是循环引用，是的话需要添加到三级缓存中。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/iRDZbq-4fZA5S.png" alt="添加到三级缓存"></p><p><code>circularServiceA</code> 不在一级缓存中，则将 <code>circularServiceA</code> 的 singletonFactory 添加到 三级缓存 （singletonFactories） 中，同时从二级缓存中移除。</p><p>到这一步为止，circularServiceA 已经在三级缓存中了。</p><p>开始对 Bean 的属性进行赋值。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/oZ70es-2WsKdT.png" alt="属性赋值"></p><p>在 populateBean 方法中执行到</p><p><code>PropertyValues pvsToUse = bp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);</code> </p><p>就会对属性进行赋值</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/ZjKmVC-J3xIl5.png" alt="属性赋值"></p><p>在 injet 方法中，回去解决相关依赖。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/EnkUit-T1uQvh.png" alt="解决依赖"></p><p>继续 Debug ，发现解决依赖，最后发现其实又调用回 <code>beanFactory.getBean(beanName);</code> </p><p>不过这次创建的是 <code>circularServiceB</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/WuKewa-ACO0Ae.png"></p><p>下面是调用链：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/ykN9uD-2XrZUz.png" alt="调用链"></p><p><code>circularServiceB</code> 的过程和 <code>circularServiceA</code> 的一样，也是创建了三级缓存，然后去创建 <code>circularServiceC</code></p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/VdfOIS-SUo0Fz.png" alt="singletionFactories"></p><p>这时候三级缓存里面有它们三个的 singletonFactory 。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/6px7bF-uBnMnF.png"></p><p><code>circularServiceC</code> 也调用到 doGetBean 方法去获取 <code>circularServiceA</code></p><p>不过这次 调用到 <code>Object sharedInstance = getSingleton(beanName);</code> 的时候, <code>circularServiceA</code> 已经存在了。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/EHvsaz-wEqbsG.png"></p><p>这次调用虽然没有从一级缓存 （singletonObjects） 中获取到 circularServiceA，但是 <code>circularServiceA</code> 在<strong>创建中</strong>，所以进入判断</p><p>在这里执行完之后， <code>circularServiceA</code> 从三级缓存升级到二级缓存</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/wXvq02-Ayomqs.png"></p><p>使用反射对 <code>circularServiceC</code> 中的 <code>circularServiceA</code> 进行赋值， 此时 <code>circularServiceA</code> 是在 二级缓存中。</p><p><strong>那就比较好奇了，这时候 circularServiceC 里面的 circularServiceA 已经通过反射赋值，这个赋值给的是什么值？</strong></p><p>查看代码：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/WdGk05-KZ94hA.png"></p><p>这块是从三级缓存（singletonFactories）中获取的 singletonObject，然后调用</p><p><code>singletonObject = singletonFactory.getObject();</code> </p><p>获取的一个对象</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/ZlcQGZ-tKDGNM.png"></p><p>这里获取到的是 circularServiceA 的引用，注意 circularServiceA 这时候还没创建完成，只是引用。所以这里赋值的是 circularServiceA 的引用。</p><p>到这里 <code>circularServiceC</code> 就创建完了。</p><p>然后会将 C 添加到一级缓存和已注册列表中，同时从二级三级缓存中删除 C。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/fcNkmJ-fth6DQ.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/QwK4yN-dbrlQj.png"></p><p>继续执行 B 和 A 的属性赋值以及后续的初始化流程。</p><p>至此，循环依赖解决完毕。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Spring 使用三级缓存来解决循环依赖的问题，三级缓存分别是：</p><ul><li><p><strong>singletonObjects：</strong> 一级缓存，存储单例对象，Bean 已经实例化，初始化完成。</p></li><li><p><strong>earlySingletonObjects：</strong> 二级缓存，存储 singletonObject，这个 Bean 实例化了，还没有初始化。</p></li><li><p><strong>singletonFactories：</strong> 三级缓存，存储 singletonFactory。</p></li></ul><p>本文也通过 Debug 来验证了使用三级缓存解决依赖的过程。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/1QnEIw-1agsnx.png"></p><p>不过还有一些问题没有说明：</p><ol><li>循环依赖和代理之间的关系是什么？比如 @Transactional 和 @Async 注解会对循环依赖产生什么影响？</li><li>为什么要用三级缓存？二级缓存不可以么？</li></ol><h4 id="相关推荐"><a href="#相关推荐" class="headerlink" title="相关推荐"></a>相关推荐</h4><ul><li><a href="https://mp.weixin.qq.com/s/qZ4xXlqpNzsdHkvFm02Yuw">Spring 源码学习 16：单例 Bean 创建</a></li><li><a href="https://mp.weixin.qq.com/s/MAlT1Y5MVmEclAZC6rgojQ">Spring 源码学习 15：finishBeanFactoryInitialization（重点）</a></li><li><a href="https://mp.weixin.qq.com/s/bKmqVFuLLLCquWf3tzH30g">Spring 源码学习 14：initApplicationEventMulticaster</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 源码笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 源码学习 16：单例 Bean 创建</title>
      <link href="2021/01/17/source-spring-16.html"/>
      <url>2021/01/17/source-spring-16.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在 finishBeanFactoryInitialization 中介绍了创建 Bean 的流程大概流程，这里进入单例 Bean 的创建过程。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/U1LzL3-cy2ZtW.png"></p><p>这里主要分为三个部分创建单例 Bean</p><ol><li>getSingleton</li><li>createBean</li><li>getObjectForBeanInstance</li></ol><p>下面进入源码：</p><h3 id="getSingleton"><a href="#getSingleton" class="headerlink" title="getSingleton"></a>getSingleton</h3><pre><code class="java">public Object getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) &#123;    Assert.notNull(beanName, &quot;Bean name must not be null&quot;);    // 加锁    synchronized (this.singletonObjects) &#123;        // 检查 singletonObjects 缓存中是否有        Object singletonObject = this.singletonObjects.get(beanName);        if (singletonObject == null) &#123;            // 检查是否在执行销毁            if (this.singletonsCurrentlyInDestruction) &#123;                throw new BeanCreationNotAllowedException(beanName,                        &quot;Singleton bean creation not allowed while singletons of this factory are in destruction &quot; +                        &quot;(Do not request a bean from a BeanFactory in a destroy method implementation!)&quot;);            &#125;            if (logger.isDebugEnabled()) &#123;                logger.debug(&quot;Creating shared instance of singleton bean &#39;&quot; + beanName + &quot;&#39;&quot;);            &#125;            // 将 Bean 添加到 singletonsCurrentlyInCreation 集合中, 表示正在创建            beforeSingletonCreation(beanName);            boolean newSingleton = false;            boolean recordSuppressedExceptions = (this.suppressedExceptions == null);            if (recordSuppressedExceptions) &#123;                this.suppressedExceptions = new LinkedHashSet&lt;&gt;();            &#125;            try &#123;                // 调用工厂方法                // 也就是调用 createBean(beanName, mbd, args)                singletonObject = singletonFactory.getObject();                newSingleton = true;            &#125;            catch (IllegalStateException ex) &#123;                // Has the singleton object implicitly appeared in the meantime -&gt;                // if yes, proceed with it since the exception indicates that state.                singletonObject = this.singletonObjects.get(beanName);                if (singletonObject == null) &#123;                    throw ex;                &#125;            &#125;            catch (BeanCreationException ex) &#123;                if (recordSuppressedExceptions) &#123;                    for (Exception suppressedException : this.suppressedExceptions) &#123;                        ex.addRelatedCause(suppressedException);                    &#125;                &#125;                throw ex;            &#125;            finally &#123;                if (recordSuppressedExceptions) &#123;                    this.suppressedExceptions = null;                &#125;                // 创建成功, 从 singletonsCurrentlyInCreation 移除                afterSingletonCreation(beanName);            &#125;            if (newSingleton) &#123;                // 将给定的单例对象添加到该工厂的单例缓存中                //     this.singletonObjects.put(beanName, singletonObject);                //     this.singletonFactories.remove(beanName);                //     this.earlySingletonObjects.remove(beanName);                //     this.registeredSingletons.add(beanName);                addSingleton(beanName, singletonObject);            &#125;        &#125;        return singletonObject;    &#125;&#125;</code></pre><p>返回以给定名称注册的（原始）单例对象，如果尚未注册，则创建并注册一个新对象。</p><p>这一块一共可以拆成三部分来理解：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/6KBL1X-ZvNhzi.png"></p><h4 id="1-从缓存中获取-singletonObjects"><a href="#1-从缓存中获取-singletonObjects" class="headerlink" title="1. 从缓存中获取 singletonObjects"></a>1. 从缓存中获取 singletonObjects</h4><p><code>singletonObject</code> 是什么？</p><pre><code class="java">/** Cache of singleton objects: bean name to bean instance. */private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;(256);</code></pre><p><code>singletonObjects</code> 是一个 ConcurrentHashMap， 用来缓存单例对象的实例。</p><h4 id="2-创建-singletonObject"><a href="#2-创建-singletonObject" class="headerlink" title="2. 创建 singletonObject"></a>2. 创建 singletonObject</h4><p>在从缓存中没有获取到 <code>singletonObject</code> ，创建新的对象</p><p><code>singletonObject = singletonFactory.getObject();</code> </p><p>这一步其实就是调用外边的 <code>createBean(beanName, mbd, args)</code> 方法，这是一个工厂方法。 通过 <code>createBean</code> 方法，会创建一个新的 <code>singletonObject</code>。</p><h4 id="3-将创建的-singletonObject-添加到缓存中"><a href="#3-将创建的-singletonObject-添加到缓存中" class="headerlink" title="3. 将创建的 singletonObject 添加到缓存中"></a>3. 将创建的 singletonObject 添加到缓存中</h4><pre><code class="java">protected void addSingleton(String beanName, Object singletonObject) &#123;    synchronized (this.singletonObjects) &#123;        this.singletonObjects.put(beanName, singletonObject);        this.singletonFactories.remove(beanName);        this.earlySingletonObjects.remove(beanName);        // 已经成功创建的单例        this.registeredSingletons.add(beanName);    &#125;&#125;</code></pre><p>这一步涉及到三个缓存，以及一个成功创建的单例列表。</p><pre><code class="java">/** Cache of singleton objects: bean name to bean instance. *//** 缓存单例对象， K-V -&gt; BeanName - Bean 实例 */private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;(256);/** Cache of singleton factories: bean name to ObjectFactory. *//** 缓存 Bean 工厂 */private final Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap&lt;&gt;(16);/** Cache of early singleton objects: bean name to bean instance. *//** 缓存早期单例对象 */private final Map&lt;String, Object&gt; earlySingletonObjects = new ConcurrentHashMap&lt;&gt;(16);/** Set of registered singletons, containing the bean names in registration order. *//** 已注册的单例列表，按注册顺序保存 BeanName。 */private final Set&lt;String&gt; registeredSingletons = new LinkedHashSet&lt;&gt;(256);</code></pre><p>将创建的单例对象，添加到<code>单例缓存</code>中，同时将<code>工厂缓存</code>以及<code>早期单例对象缓存</code>中的对应对象删除。</p><h3 id="createBean"><a href="#createBean" class="headerlink" title="createBean"></a>createBean</h3><pre><code class="java">protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)            throws BeanCreationException &#123;    if (logger.isTraceEnabled()) &#123;        logger.trace(&quot;Creating instance of bean &#39;&quot; + beanName + &quot;&#39;&quot;);    &#125;    RootBeanDefinition mbdToUse = mbd;    // Make sure bean class is actually resolved at this point, and    // clone the bean definition in case of a dynamically resolved Class    // which cannot be stored in the shared merged bean definition.    // 获取真实的类型    Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);    if (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null) &#123;        // 创建新的 mbd 防止 其他线程修改        mbdToUse = new RootBeanDefinition(mbd);        mbdToUse.setBeanClass(resolvedClass);    &#125;    // Prepare method overrides.    try &#123;        // 验证并准备为此bean定义的方法替代。 检查是否存在具有指定名称的方法。        mbdToUse.prepareMethodOverrides();    &#125;    catch (BeanDefinitionValidationException ex) &#123;        throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),                beanName, &quot;Validation of method overrides failed&quot;, ex);    &#125;    try &#123;        // Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.        // 应用实例化之前的后处理器，以解决指定的bean是否存在实例化快捷方式。        // InstantiationAwareBeanPostProcessor 后置处理器         // postProcessBeforeInstantiation 方法可能会已经实例化 Bean        Object bean = resolveBeforeInstantiation(beanName, mbdToUse);        if (bean != null) &#123;            return bean;        &#125;    &#125;    catch (Throwable ex) &#123;        throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,                &quot;BeanPostProcessor before instantiation of bean failed&quot;, ex);    &#125;    try &#123;        // 实例化 Bean        Object beanInstance = doCreateBean(beanName, mbdToUse, args);        if (logger.isTraceEnabled()) &#123;            logger.trace(&quot;Finished creating instance of bean &#39;&quot; + beanName + &quot;&#39;&quot;);        &#125;        return beanInstance;    &#125;    catch (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123;        // A previously detected exception with proper bean creation context already,        // or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.        throw ex;    &#125;    catch (Throwable ex) &#123;        throw new BeanCreationException(                mbdToUse.getResourceDescription(), beanName, &quot;Unexpected exception during bean creation&quot;, ex);    &#125;&#125;</code></pre><p>这个方法中涉及到：创建 Bean 实例 , 填充 Bean , 应用 PostProcessor。</p><p>其中实例化 Bean 是在 <code>doCreateBean</code> 中。现在重点看一下 <code>doCreateBean</code> 方法。</p><h4 id="doCreateBean"><a href="#doCreateBean" class="headerlink" title="doCreateBean"></a>doCreateBean</h4><pre><code class="java">protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)            throws BeanCreationException &#123;    // Instantiate the bean.    // Bean 的 对象包装    BeanWrapper instanceWrapper = null;    if (mbd.isSingleton()) &#123;        // 从缓存中获取        instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);    &#125;    if (instanceWrapper == null) &#123;        // 缓存中获取不到则直接创建, 这里创建的 BeanInstance !!!        instanceWrapper = createBeanInstance(beanName, mbd, args);    &#125;    // 获取 Bean 实例以及类型    Object bean = instanceWrapper.getWrappedInstance();    Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();    if (beanType != NullBean.class) &#123;        mbd.resolvedTargetType = beanType;    &#125;    // Allow post-processors to modify the merged bean definition.    synchronized (mbd.postProcessingLock) &#123;        if (!mbd.postProcessed) &#123;            try &#123;                // 如果允许修改 mbd                // 调用 MergedBeanDefinitionPostProcessor 后置处理器的                // postProcessMergedBeanDefinition(mbd, beanType, beanName);                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);            &#125;            catch (Throwable ex) &#123;                throw new BeanCreationException(mbd.getResourceDescription(), beanName,                        &quot;Post-processing of merged bean definition failed&quot;, ex);            &#125;            mbd.postProcessed = true;        &#125;    &#125;    // Eagerly cache singletons to be able to resolve circular references    // even when triggered by lifecycle interfaces like BeanFactoryAware.    // mbd 是单例 且 允许循环引用, (默认 true) 且在创建    boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;            isSingletonCurrentlyInCreation(beanName));    if (earlySingletonExposure) &#123;        if (logger.isTraceEnabled()) &#123;            logger.trace(&quot;Eagerly caching bean &#39;&quot; + beanName +                    &quot;&#39; to allow for resolving potential circular references&quot;);        &#125;        // 先获取 之前的 Bean 的引用, 从 beanPostProcessorCache 中 获取 SmartInstantiationAwareBeanPostProcessor        // 然后从 SmartInstantiationAwareBeanPostProcessor#getEarlyBeanReference 获取之前的引用        addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));    &#125;    // Initialize the bean instance.    Object exposedObject = bean;    try &#123;        // 属性赋值        populateBean(beanName, mbd, instanceWrapper);        // 执行 init 方法        exposedObject = initializeBean(beanName, exposedObject, mbd);    &#125;    catch (Throwable ex) &#123;        if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;            throw (BeanCreationException) ex;        &#125;        else &#123;            throw new BeanCreationException(                    mbd.getResourceDescription(), beanName, &quot;Initialization of bean failed&quot;, ex);        &#125;    &#125;    // 这里允许循环依赖    if (earlySingletonExposure) &#123;        // 获取早期的 Bean, 如果没有循环依赖 则获取不到        Object earlySingletonReference = getSingleton(beanName, false);        // 有循环依赖        if (earlySingletonReference != null) &#123;            // 创建的是不是同一个，可能会有代理对象            if (exposedObject == bean) &#123;                exposedObject = earlySingletonReference;            &#125;            else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;                // 获取依赖的 Bean 并 循环放入到 actualDependentBeans                String[] dependentBeans = getDependentBeans(beanName);                Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;&gt;(dependentBeans.length);                for (String dependentBean : dependentBeans) &#123;                    if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;                        actualDependentBeans.add(dependentBean);                    &#125;                &#125;                if (!actualDependentBeans.isEmpty()) &#123;                    throw new BeanCurrentlyInCreationException(beanName,                            &quot;Bean with name &#39;&quot; + beanName + &quot;&#39; has been injected into other beans [&quot; +                            StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +                            &quot;] in its raw version as part of a circular reference, but has eventually been &quot; +                            &quot;wrapped. This means that said other beans do not use the final version of the &quot; +                            &quot;bean. This is often the result of over-eager type matching - consider using &quot; +                            &quot;&#39;getBeanNamesForType&#39; with the &#39;allowEagerInit&#39; flag turned off, for example.&quot;);                &#125;            &#125;        &#125;    &#125;    // Register bean as disposable.    try &#123;        // 注册销毁方法        registerDisposableBeanIfNecessary(beanName, bean, mbd);    &#125;    catch (BeanDefinitionValidationException ex) &#123;        throw new BeanCreationException(                mbd.getResourceDescription(), beanName, &quot;Invalid destruction signature&quot;, ex);    &#125;    return exposedObject;&#125;</code></pre><p>同样是代码很长很长！</p><p>分步骤阅读：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/tx0C4e-zD6xG0.png"></p><p>如果这个 Bean 是单例 Bean 且允许循环引用且在创建中，则说明在有循环引用。则调用：</p><p><code>addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</code></p><p>这一行代码涉及到两个方法，分别是 <code>getEarlyBeanReference</code> 和 <code>addSingletonFactory</code></p><ul><li>getEarlyBeanReference</li></ul><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/vWP5Jt-tsa92g.png"></p><ul><li>addSingletonFactory</li></ul><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/uvUVh4-TWy5l0.png"></p><p>这一块可以看到将创建的一个单例对象的 <code>singletonFactory</code> 添加到了 <code>singletonFactories</code> 缓存中。</p><p>同时将 <code>earlySingletonObjects</code> 缓存中的单例对象移除。</p><p>那什么时候添加到 <code>earlySingletonObjects</code> 缓存中的呢？</p><p>这块可以参考 <a href="https://mp.weixin.qq.com/s/MAlT1Y5MVmEclAZC6rgojQ">Spring 源码学习 15：finishBeanFactoryInitialization</a> 在 <code>getSingleton</code> 方法中 put 进去的。</p><p>为了方便，我把这一小块代码也贴出来：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/QPVvXy-pJUe1N.png"></p><p>在这里将缓存从 <code>singletonFactories</code> 移到了 <code>earlySingletonObjects</code>。</p><p>Spring 的 Bean 实例化的时候用到的三级缓存其实是：</p><p><strong>singletonObjects：</strong> 一级缓存，存储单例对象，Bean 已经实例化，初始化完成。</p><p><strong>earlySingletonObjects：</strong> 二级缓存，存储 singletonObject，这个 Bean 实例化了，还没有初始化。 </p><p><strong>singletonFactories：</strong> 三级缓存，存储 singletonFactory</p><p><strong>下面会初始化 Bean</strong></p><p>这里关注重点关注下面一部分：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/hmZmhM-SI303W.png"></p><ul><li>populateBean</li></ul><p>对 Bean 的属性进行赋值。</p><p>这块需要注意的是，在对属性进行赋值时，发现依赖了其他 Bean，就会去先创建其他 Bean。</p><p>我这边使用的注解 @Autowired 就会执行下面一部分：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/ZjKmVC-J3xIl5.png"></p><p>在这里解析属性的时候，就会去创建内部依赖的 Bean。</p><ul><li>initializeBean</li></ul><h3 id="getObjectForBeanInstance"><a href="#getObjectForBeanInstance" class="headerlink" title="getObjectForBeanInstance"></a>getObjectForBeanInstance</h3><p>获取给定bean实例的对象，如果是FactoryBean，则为bean实例本身或其创建的对象。</p><p>这一块逻辑相对比较简单，就是根据前面你创建的 beanInstance ， 判断其类型，从而创建 Bean 实例。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文主要介绍了一个 单例 Bean 的创建，当然都是大块大块的源码，需要耐心的啃。</p><p>阅读完源码，基本上对循环依赖能有个详细的了解，知道 Spring 在初始化 Bean 的时候是使用三级缓存来处理循环依赖的额，而后面则会单独准备一篇文章对循环依赖做介绍。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/fybVmp-2dcCmU.png"></p><h4 id="相关推荐"><a href="#相关推荐" class="headerlink" title="相关推荐"></a>相关推荐</h4><ul><li><a href="https://mp.weixin.qq.com/s/MAlT1Y5MVmEclAZC6rgojQ">Spring 源码学习 15：finishBeanFactoryInitialization（重点）</a></li><li><a href="https://mp.weixin.qq.com/s/bKmqVFuLLLCquWf3tzH30g">Spring 源码学习 14：initApplicationEventMulticaster</a></li><li><a href="https://mp.weixin.qq.com/s/99IdvVkTULwTcxrxhF84Ew">Spring 源码学习 13：initMessageSource</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 源码笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 源码学习 15：finishBeanFactoryInitialization（重点）</title>
      <link href="2021/01/12/source-spring-15.html"/>
      <url>2021/01/12/source-spring-15.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>可以说前面的都是准备工作，而接下来开始的才是重点，在这一步会完成 BeanFactory 的初始化，同时实例化单例 Bean。</p><p>具体怎么操作的，那就一起阅读源码吧！</p><p>不过在阅读源码之前，还是需要了解一些知识的。</p><ol><li>什么是 FactoryBean ？</li><li>FactoryBean 是如何使用的 ？ </li><li>Bean 是如何初始化的？</li><li>常说的循环依赖是怎么解决的？</li></ol><h3 id="什么是-FactoryBean-？"><a href="#什么是-FactoryBean-？" class="headerlink" title="什么是 FactoryBean ？"></a>什么是 FactoryBean ？</h3><p>在官网的这篇文章<a href="https://spring.io/blog/2011/08/09/what-s-a-factorybean" title="What&#39;s a FactoryBean?">《What’s a FactoryBean?》</a>中有相关解答，有兴趣的小伙伴可以看一下。</p><p>由内部使用的对象实现的接口，这些对象 BeanFactory 本身就是单个对象的工厂。如果 bean 实现此接口，则它将用作对象公开的工厂，而不是直接用作将自身公开的 bean 实例。</p><p>注意：实现此接口的 bean 不能用作普通 bean。 FactoryBean以 bean 样式定义，但是为 bean 引用（getObject()）公开的对象始终是它创建的对象。</p><p>FactoryBeans 可以支持单例和原型，并且可以按需延迟创建对象，也可以在启动时急于创建对象。</p><p>当生命一个 FactoryBean 时，会存在两个类型的 Bean，分别是 FactoryBean 本身，以及它需要创建的类型的 Bean。</p><p>下面是使用示例：</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="1-PaidComponent"><a href="#1-PaidComponent" class="headerlink" title="1. PaidComponent"></a>1. PaidComponent</h4><pre><code class="java">public class PaidComponent &#123;    public PaidComponent() &#123;        System.out.println(&quot;PaidComponent 无参构造被调用&quot;);    &#125;&#125;</code></pre><h4 id="2-PaidComponentFactoryBean"><a href="#2-PaidComponentFactoryBean" class="headerlink" title="2. PaidComponentFactoryBean"></a>2. PaidComponentFactoryBean</h4><pre><code class="java">@Componentpublic class PaidComponentFactoryBean implements FactoryBean&lt;PaidComponent&gt; &#123;    @Override    public PaidComponent getObject() throws Exception &#123;        System.out.println(&quot;PaidComponentFactoryBean 的 getObject 方法被调用&quot;);        return new PaidComponent();    &#125;    @Override    public Class&lt;?&gt; getObjectType() &#123;        return PaidComponent.class;    &#125;&#125;</code></pre><h4 id="3-Test"><a href="#3-Test" class="headerlink" title="3 Test"></a>3 Test</h4><pre><code class="java">public class AnnotationConfigApplicationTest &#123;    public static void main(String[] args) &#123;        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();        context.register(JavaConfig.class);        context.refresh();        System.out.println(context.getBean(&quot;paidComponentFactoryBean&quot;));        System.out.println(context.getBean(&quot;&amp;paidComponentFactoryBean&quot;));        System.out.println(context.getBean(PaidComponent.class));    &#125;&#125;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/5Ho48G-UVQwo4.png"></p><p>可以看出注册了两个 Bean， 一个是 <code>paidComponentFactoryBean</code> ，另一个是 <code>&amp;paidComponentFactoryBean</code>。</p><p>而直接获取 <code>paidComponentFactoryBean</code> 获取到的其实是 FactoryBean 的 <code>getObject()</code> 方法返回的类型。</p><h3 id="finishBeanFactoryInitialization-源码"><a href="#finishBeanFactoryInitialization-源码" class="headerlink" title="finishBeanFactoryInitialization 源码"></a>finishBeanFactoryInitialization 源码</h3><pre><code class="java">protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) &#123;    // Initialize conversion service for this context.    // 初始化类型转换器    if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;            beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;        beanFactory.setConversionService(                beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));    &#125;    // Register a default embedded value resolver if no bean post-processor    // (such as a PropertyPlaceholderConfigurer bean) registered any before:    // at this point, primarily for resolution in annotation attribute values.    // 主要用于注释属性值的解析    if (!beanFactory.hasEmbeddedValueResolver()) &#123;        beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));    &#125;    // Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.    // 尽早初始化 LoadTimeWeaverAware Bean，以便尽早注册其转换器。    String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);    for (String weaverAwareName : weaverAwareNames) &#123;        getBean(weaverAwareName);    &#125;    // Stop using the temporary ClassLoader for type matching.    // 停止使用临时的ClassLoader进行类型匹配。    beanFactory.setTempClassLoader(null);    // Allow for caching all bean definition metadata, not expecting further changes.    // 设置 beanDefinition 元数据 不可以再修改    beanFactory.freezeConfiguration();    // Instantiate all remaining (non-lazy-init) singletons.    // 实例化单例 bean    beanFactory.preInstantiateSingletons();&#125;</code></pre><p>这里重点关注最后一行</p><p><code>beanFactory.preInstantiateSingletons();</code></p><h4 id="preInstantiateSingletons"><a href="#preInstantiateSingletons" class="headerlink" title="preInstantiateSingletons"></a>preInstantiateSingletons</h4><p>这块进入的是类  <code>DefaultListableBeanFactory</code> 类的源码。</p><pre><code class="java">public void preInstantiateSingletons() throws BeansException &#123;    if (logger.isTraceEnabled()) &#123;        logger.trace(&quot;Pre-instantiating singletons in &quot; + this);    &#125;    // Iterate over a copy to allow for init methods which in turn register new bean definitions.    // While this may not be part of the regular factory bootstrap, it does otherwise work fine.    // 将 beanDefinitionNames 放到集合中    List&lt;String&gt; beanNames = new ArrayList&lt;&gt;(this.beanDefinitionNames);    // Trigger initialization of all non-lazy singleton beans...    // 遍历    for (String beanName : beanNames) &#123;        // 获取 bd 信息, 因为可能 定义了 parentBeanDefinition        RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);        // 非抽象, 单例, 且不是懒加载        if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;            // 判断是否为 FactoryBean            if (isFactoryBean(beanName)) &#123;                // FactoryBean 需要添加前缀 &amp; ,通过 getBean(&amp;beanName) 获取的是 FactoryBean 本身                Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);                if (bean instanceof FactoryBean) &#123;                    FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;                    // 判断是否需要初始化                    boolean isEagerInit;                    if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) &#123;                        isEagerInit = AccessController.doPrivileged(                                (PrivilegedAction&lt;Boolean&gt;) ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,                                getAccessControlContext());                    &#125;                    else &#123;                        isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp;                                ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());                    &#125;                    // 需要初始化                    if (isEagerInit) &#123;                        getBean(beanName);                    &#125;                &#125;            &#125;            else &#123;                getBean(beanName);            &#125;        &#125;    &#125;    // Trigger post-initialization callback for all applicable beans...    // 如果 Bean 实现了 SmartInitializingSingleton,    // 在这里会统一调用 afterSingletonsInstantiated 方法    for (String beanName : beanNames) &#123;        Object singletonInstance = getSingleton(beanName);        if (singletonInstance instanceof SmartInitializingSingleton) &#123;            StartupStep smartInitialize = this.getApplicationStartup().start(&quot;spring.beans.smart-initialize&quot;)                    .tag(&quot;beanName&quot;, beanName);            SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;            if (System.getSecurityManager() != null) &#123;                AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;                    smartSingleton.afterSingletonsInstantiated();                    return null;                &#125;, getAccessControlContext());            &#125;            else &#123;                smartSingleton.afterSingletonsInstantiated();            &#125;            smartInitialize.end();        &#125;    &#125;&#125;</code></pre><p>上面方法中通过循环 <code>beanNames</code> 进行初始化 Bean。</p><p>其中需要区别 BeanFactory 和 普通 Bean。 这也是我开始为什么先介绍了<code>什么是 BeanFactory ?</code></p><p>下面就需要重点关注 <code>getBean(beanName)</code> 方法。</p><h4 id="getBean"><a href="#getBean" class="headerlink" title="getBean"></a>getBean</h4><pre><code class="java">public Object getBean(String name) throws BeansException &#123;    return doGetBean(name, null, null, false);&#125;</code></pre><p>在 <code>getBean</code> 方法中调用的是 <code>doGetBean</code> 方法。</p><h4 id="doGetBean"><a href="#doGetBean" class="headerlink" title="doGetBean"></a>doGetBean</h4><p>doGetBean 方法作用是：<code>返回一个实例，该实例可以是指定bean的共享或独立的</code>。 </p><p>该方法接受四个参数：</p><blockquote><p>name – 要检索的 bean 的名称<br>requiredType – 要检索的 bean 的必需类型，这个可以为空<br>args –使用显式参数创建bean实例时要使用的参数（仅在创建新实例而不是检索现有实例时才应用）<br>typeCheckOnly –是否为类型检查而不是实际使用获取实例</p></blockquote><pre><code class="java">protected &lt;T&gt; T doGetBean(        String name, @Nullable Class&lt;T&gt; requiredType, @Nullable Object[] args, boolean typeCheckOnly)        throws BeansException &#123;    // 去掉工厂引用的前缀, 同时转换别名    String beanName = transformedBeanName(name);    Object bean;    // Eagerly check singleton cache for manually registered singletons.    // 从缓存中检查单例是否已经存在    Object sharedInstance = getSingleton(beanName);    if (sharedInstance != null &amp;&amp; args == null) &#123;        if (logger.isTraceEnabled()) &#123;            if (isSingletonCurrentlyInCreation(beanName)) &#123;                logger.trace(&quot;Returning eagerly cached instance of singleton bean &#39;&quot; + beanName +                        &quot;&#39; that is not fully initialized yet - a consequence of a circular reference&quot;);            &#125;            else &#123;                logger.trace(&quot;Returning cached instance of singleton bean &#39;&quot; + beanName + &quot;&#39;&quot;);            &#125;        &#125;        // 从缓存中如果获取到了, 普通 Bean 直接返回, FactoryBean 则返回 FactoryBean 创建的 Bean        bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);    &#125;    else &#123;        // Fail if we&#39;re already creating this bean instance:        // We&#39;re assumably within a circular reference.        // 返回指定的 原型bean (prototype 类型的 Bean) 是否当前正在创建中（在当前线程内）。        if (isPrototypeCurrentlyInCreation(beanName)) &#123;            throw new BeanCurrentlyInCreationException(beanName);        &#125;        // Check if bean definition exists in this factory.        // 检查 BeanFactory 是否存在这个 Bean 的 BeanDefinition        BeanFactory parentBeanFactory = getParentBeanFactory();        if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) &#123;            // Not found -&gt; check parent.            // 检查父容器中有没有定义            String nameToLookup = originalBeanName(name);            // 返回从父容器中查询的结果            if (parentBeanFactory instanceof AbstractBeanFactory) &#123;                return ((AbstractBeanFactory) parentBeanFactory).doGetBean(                        nameToLookup, requiredType, args, typeCheckOnly);            &#125;            else if (args != null) &#123;                // Delegation to parent with explicit args.                return (T) parentBeanFactory.getBean(nameToLookup, args);            &#125;            else if (requiredType != null) &#123;                // No args -&gt; delegate to standard getBean method.                return parentBeanFactory.getBean(nameToLookup, requiredType);            &#125;            else &#123;                return (T) parentBeanFactory.getBean(nameToLookup);            &#125;        &#125;        if (!typeCheckOnly) &#123;            // 将当前 beanName 放入一个 alreadyCreated 的 Set 集合中。            // 标识本次调用方法，并非是要获取bean的类型，而是为了创建实例，将beanName存到alreadyCreated集合，代表该bean已经创建了，后面try。。catch有异常会清空该beanName            markBeanAsCreated(beanName);        &#125;        StartupStep beanCreation = this.applicationStartup.start(&quot;spring.beans.instantiate&quot;)                .tag(&quot;beanName&quot;, name);        try &#123;            if (requiredType != null) &#123;                beanCreation.tag(&quot;beanType&quot;, requiredType::toString);            &#125;            // 获取 Bean 的 BeanDefinition            RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);            checkMergedBeanDefinition(mbd, beanName, args);            // Guarantee initialization of beans that the current bean depends on.            // 确保依赖的 Bean 已经被初始化, 比如 @DependsOn 注解            String[] dependsOn = mbd.getDependsOn();            if (dependsOn != null) &#123;                for (String dep : dependsOn) &#123;                    if (isDependent(beanName, dep)) &#123;                        throw new BeanCreationException(mbd.getResourceDescription(), beanName,                                &quot;Circular depends-on relationship between &#39;&quot; + beanName + &quot;&#39; and &#39;&quot; + dep + &quot;&#39;&quot;);                    &#125;                    registerDependentBean(dep, beanName);                    try &#123;                        // 创建依赖的 Bean                        getBean(dep);                    &#125;                    catch (NoSuchBeanDefinitionException ex) &#123;                        throw new BeanCreationException(mbd.getResourceDescription(), beanName,                                &quot;&#39;&quot; + beanName + &quot;&#39; depends on missing bean &#39;&quot; + dep + &quot;&#39;&quot;, ex);                    &#125;                &#125;            &#125;            // Create bean instance.            if (mbd.isSingleton()) &#123;                // 单例 bean                sharedInstance = getSingleton(beanName, () -&gt; &#123;                    try &#123;                        return createBean(beanName, mbd, args);                    &#125;                    catch (BeansException ex) &#123;                        // Explicitly remove instance from singleton cache: It might have been put there                        // eagerly by the creation process, to allow for circular reference resolution.                        // Also remove any beans that received a temporary reference to the bean.                        destroySingleton(beanName);                        throw ex;                    &#125;                &#125;);                bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);            &#125;            // 创建原型Bean            else if (mbd.isPrototype()) &#123;                // It&#39;s a prototype -&gt; create a new instance.                Object prototypeInstance = null;                try &#123;                    beforePrototypeCreation(beanName);                    prototypeInstance = createBean(beanName, mbd, args);                &#125;                finally &#123;                    afterPrototypeCreation(beanName);                &#125;                bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);            &#125;            else &#123;                // 委托给实现类处理                String scopeName = mbd.getScope();                if (!StringUtils.hasLength(scopeName)) &#123;                    throw new IllegalStateException(&quot;No scope name defined for bean ´&quot; + beanName + &quot;&#39;&quot;);                &#125;                Scope scope = this.scopes.get(scopeName);                if (scope == null) &#123;                    throw new IllegalStateException(&quot;No Scope registered for scope name &#39;&quot; + scopeName + &quot;&#39;&quot;);                &#125;                try &#123;                    Object scopedInstance = scope.get(beanName, () -&gt; &#123;                        beforePrototypeCreation(beanName);                        try &#123;                            return createBean(beanName, mbd, args);                        &#125;                        finally &#123;                            afterPrototypeCreation(beanName);                        &#125;                    &#125;);                    bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);                &#125;                catch (IllegalStateException ex) &#123;                    throw new ScopeNotActiveException(beanName, scopeName, ex);                &#125;            &#125;        &#125;        catch (BeansException ex) &#123;            beanCreation.tag(&quot;exception&quot;, ex.getClass().toString());            beanCreation.tag(&quot;message&quot;, String.valueOf(ex.getMessage()));            cleanupAfterBeanCreationFailure(beanName);            throw ex;        &#125;        finally &#123;            beanCreation.end();        &#125;    &#125;    // Check if required type matches the type of the actual bean instance.    // 检查所需的类型是否与实际bean实例的类型匹配。    if (requiredType != null &amp;&amp; !requiredType.isInstance(bean)) &#123;        try &#123;            T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);            if (convertedBean == null) &#123;                throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());            &#125;            return convertedBean;        &#125;        catch (TypeMismatchException ex) &#123;            if (logger.isTraceEnabled()) &#123;                logger.trace(&quot;Failed to convert bean &#39;&quot; + name + &quot;&#39; to required type &#39;&quot; +                        ClassUtils.getQualifiedName(requiredType) + &quot;&#39;&quot;, ex);            &#125;            throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());        &#125;    &#125;    return (T) bean;&#125;</code></pre><p>上面代码比较长，基本上步骤已经添加相应的注释，基本上可以分为三步：</p><ol><li>从缓存中获取到 Bean，创建对应的 Bean；</li><li>没有从缓存中获取到 Bean，创建对应的 Bean；</li><li>检查所需的类型是否与实际bean实例的类型匹配。</li></ol><p>下面从这三个步骤分别介绍：</p><ul><li>从缓存中获取到 Bean，创建对应的 Bean</li></ul><p><strong><code>Object sharedInstance = getSingleton(beanName);</code></strong></p><pre><code class="java">public Object getSingleton(String beanName) &#123;    return getSingleton(beanName, true);&#125;/** * 返回以给定名称注册的（原始）单例对象。 * * 检查已经实例化的单例，并允许早期引用当前创建的单例（解析循环引用） */@Nullableprotected Object getSingleton(String beanName, boolean allowEarlyReference) &#123;    // Quick check for existing instance without full singleton lock    // private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;(256);    // 缓存了 单例 Bean    Object singletonObject = this.singletonObjects.get(beanName);    // 如果没有获取到, 并且当前 Bean 正在被创建中    if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;        // private final Map&lt;String, Object&gt; earlySingletonObjects = new ConcurrentHashMap&lt;&gt;(16);        // 早期的单例对象, 先从 earlySingletonObjects 中获取        singletonObject = this.earlySingletonObjects.get(beanName);        // 没有从 earlySingletonObjects 缓存中获取到        if (singletonObject == null &amp;&amp; allowEarlyReference) &#123;            synchronized (this.singletonObjects) &#123;                // Consistent creation of early reference within full singleton lock                // 再次获取并检查                singletonObject = this.singletonObjects.get(beanName);                if (singletonObject == null) &#123;                    singletonObject = this.earlySingletonObjects.get(beanName);                    if (singletonObject == null) &#123;                        // private final Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap&lt;&gt;(16);                        // 从 singletonFactories 缓存中获取                        ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName);                        if (singletonFactory != null) &#123;                            singletonObject = singletonFactory.getObject();                            // 添加到 earlySingletonObjects 缓存中                            this.earlySingletonObjects.put(beanName, singletonObject);                            // 从 singletonFactories 缓存中删除                            this.singletonFactories.remove(beanName);                        &#125;                    &#125;                &#125;            &#125;        &#125;    &#125;    return singletonObject;&#125;</code></pre><p>这里可以看出，获取一个 Bean ：</p><ol><li>先从 <code>singletonObjects</code> 中获取 Bean；</li><li>获取不到，从 <code>earlySingletonObjects</code> 中获取 Bean；</li><li>获取不到，从 <code>singletonFactories</code> 中获取 Bean。</li></ol><p>当然这一块涉及到循环引用，篇幅有限，后面会专门介绍循环引用。</p><ul><li>没有从缓存中获取到 Bean，创建对应的 Bean</li></ul><pre><code class="java">// Create bean instance.if (mbd.isSingleton()) &#123;    // 单例 bean    sharedInstance = getSingleton(beanName, () -&gt; &#123;        try &#123;            return createBean(beanName, mbd, args);        &#125;        catch (BeansException ex) &#123;            // Explicitly remove instance from singleton cache: It might have been put there            // eagerly by the creation process, to allow for circular reference resolution.            // Also remove any beans that received a temporary reference to the bean.            destroySingleton(beanName);            throw ex;        &#125;    &#125;);    bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);&#125; else if (mbd.isPrototype()) &#123;    // 创建原型Bean&#125; else &#123;    // 委托给实现类处理    String scopeName = mbd.getScope();&#125;</code></pre><ul><li>检查所需的类型是否与实际bean实例的类型匹配</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这里主要介绍了 Bean 的创建过程，主要是对整个过程有个大概的了解和熟悉，针对过程画图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/II1QBD-L3tiN3.png"></p><p>其中 Bean 的实例化主要关注单例 Bean 的实例化，后面准备对其进行详细研究后，再进行说明。</p><h4 id="相关推荐"><a href="#相关推荐" class="headerlink" title="相关推荐"></a>相关推荐</h4><ul><li><a href="https://mp.weixin.qq.com/s/bKmqVFuLLLCquWf3tzH30g">Spring 源码学习 14：initApplicationEventMulticaster</a></li><li><a href="https://mp.weixin.qq.com/s/99IdvVkTULwTcxrxhF84Ew">Spring 源码学习 13：initMessageSource</a></li><li><a href="https://mp.weixin.qq.com/s/QrogJIm9OaUmeRk9tGiNeg">Spring 源码学习 12：registerBeanPostProcessors</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 源码笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 源码学习 14：initApplicationEventMulticaster 、onRefresh 和 registerListeners</title>
      <link href="2021/01/05/source-spring-14.html"/>
      <url>2021/01/05/source-spring-14.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>上一篇介绍了国际化的使用以及初始化消息源的源码，接下来接着往下阅读，将进入 initApplicationEventMulticaster 、onRefresh 和 registerListeners 的相关操作逻辑。</p><p>这一部分主要是初始化事件广播器以及注册监听器。而 onRefresh 部分则需要子类去实现。 所以本文主要介绍以下几个部分：</p><ol><li>什么是 Spring 事件？</li><li>监听器是如何使用的？</li></ol><h3 id="什么是-Spring-事件？"><a href="#什么是-Spring-事件？" class="headerlink" title="什么是 Spring 事件？"></a>什么是 Spring 事件？</h3><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/7NqBIZ-8RXd1N.png"></p><p>这块的介绍在官网 <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#context-functionality-events" title="Spring 官方文档">1.15.2. Standard and Custom Events</a> 部分有介绍。</p><blockquote><p>Spring 通过 ApplicationEvent 类和 ApplicationListener 接口提供 ApplicationContext 中的事件处理。如果将实现 ApplicationListener 接口的 bean 部署到上下文中，则每次将 ApplicationEvent 发布到 ApplicationContext 时，都会通知该 bean。本质上，这是标准的观察者设计模式。</p></blockquote><p>归纳下来主要就是三个部分: 事件、事件发布者、事件监听器。</p><ol><li>事件：ApplicationEvent，要自定义事件，则需要创建一个类继承 ApplicationEvent。</li><li>事件发布者：ApplicationEventPublisher 和 ApplicationEventMulticaster，因为 ApplicationContext 实现了 ApplicationEventPublisher，所以事件发布可以直接使用 ApplicationContext。</li><li>事件监听器：ApplicationListener，通过创建一个实现了 ApplicationListener 并注册为 Spring bean 的类来接收消息。</li></ol><p>Spring 也提供了也有一些内置的监听器，可以在官网查看，这里就不做介绍了。</p><h3 id="使用监听器"><a href="#使用监听器" class="headerlink" title="使用监听器"></a>使用监听器</h3><p>简单来说主要分为以下几个部分：</p><ol><li>注册事件</li><li>注册监听器</li><li>发布事件</li></ol><p>在接口调用发布事件时，监听器就会做出相应的操作。</p><h4 id="1-注册事件"><a href="#1-注册事件" class="headerlink" title="1. 注册事件"></a>1. 注册事件</h4><p>创建 <code>MyApplicationEvent</code> 类并继承 <code>ApplicationEvent</code></p><pre><code class="java">public class MyApplicationEvent extends ApplicationEvent &#123;    private static final long serialVersionUID = 5366526231219883438L;    private String message;    /**     * Create a new &#123;@code ApplicationEvent&#125;.     *     * @param source the object on which the event initially occurred or with     *               which the event is associated (never &#123;@code null&#125;)     */    public MyApplicationEvent(Object source, String message) &#123;        super(source);        this.message = message;    &#125;    public String getMessage() &#123;        return message;    &#125;&#125;</code></pre><h4 id="2-注册监听器"><a href="#2-注册监听器" class="headerlink" title="2. 注册监听器"></a>2. 注册监听器</h4><pre><code class="java">@Componentpublic class MyApplicationListener implements ApplicationListener&lt;MyApplicationEvent&gt; &#123;    @Override    public void onApplicationEvent(MyApplicationEvent event) &#123;        System.out.println(&quot;MyApplicationListener 收到消息: &quot; + event.getMessage());    &#125;&#125;</code></pre><p>当然这里也可以使用注解 <code>@EventListener</code> 的方式来使用。</p><pre><code class="java">@Componentpublic class MyAnnotationApplicationListener &#123;    @EventListener(classes = MyApplicationEvent.class)    public void myApplicationEventListener(MyApplicationEvent event) &#123;        System.out.println(&quot;使用注解的方式, 收到事件: &quot; + event.getMessage());    &#125;&#125;</code></pre><h4 id="3-使用"><a href="#3-使用" class="headerlink" title="3. 使用"></a>3. 使用</h4><p>因为 AnnotationConfigApplicationContext 实现了 ApplicationContext ， 而 ApplicationContext 实现了 ApplicationEventPublisher，所以这块传入当前 context 是没有问题的。</p><pre><code class="java">public class AnnotationConfigApplicationTest &#123;    public static void main(String[] args) &#123;        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();        context.register(JavaConfig.class);        context.refresh();        MyApplicationEvent myApplicationEvent = new MyApplicationEvent(context, &quot;呼叫土豆,呼叫土豆!&quot;);        context.publishEvent(myApplicationEvent);    &#125;&#125;</code></pre><p>日志输出：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/6I8oSf-BcMLIj.png"></p><h3 id="源码部分"><a href="#源码部分" class="headerlink" title="源码部分"></a>源码部分</h3><h4 id="initApplicationEventMulticaster"><a href="#initApplicationEventMulticaster" class="headerlink" title="initApplicationEventMulticaster"></a>initApplicationEventMulticaster</h4><p>这块和上面初始化消息源类似，都是查找指定名称的 Bean ，如果找不到，则自己使用默认的。</p><pre><code class="java">protected void initApplicationEventMulticaster() &#123;    ConfigurableListableBeanFactory beanFactory = getBeanFactory();    // 是否包含 applicationEventMulticaster Bean    if (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123;        this.applicationEventMulticaster =                beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);        if (logger.isTraceEnabled()) &#123;            logger.trace(&quot;Using ApplicationEventMulticaster [&quot; + this.applicationEventMulticaster + &quot;]&quot;);        &#125;    &#125;    else &#123;        // 使用  SimpleApplicationEventMulticaster 创建一个 事件发布器        SimpleApplicationEventMulticaster simpleApplicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory);        simpleApplicationEventMulticaster.setApplicationStartup(getApplicationStartup());        this.applicationEventMulticaster = simpleApplicationEventMulticaster;        beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, this.applicationEventMulticaster);        if (logger.isTraceEnabled()) &#123;            logger.trace(&quot;No &#39;&quot; + APPLICATION_EVENT_MULTICASTER_BEAN_NAME + &quot;&#39; bean, using &quot; +                    &quot;[&quot; + this.applicationEventMulticaster.getClass().getSimpleName() + &quot;]&quot;);        &#125;    &#125;&#125;</code></pre><h4 id="onRefresh"><a href="#onRefresh" class="headerlink" title="onRefresh"></a>onRefresh</h4><p>这块需要子类去实现，我这里通过断电，暂时没有进去。所以就不介绍了。</p><h4 id="registerListeners"><a href="#registerListeners" class="headerlink" title="registerListeners"></a>registerListeners</h4><pre><code class="java">protected void registerListeners() &#123;    // 添加实现ApplicationListener作为侦听器的bean。    // 不会影响其他侦听器，可以将它们添加为非bean。    // Register statically specified listeners first.    // 先注册静态指定的监听器    for (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;        getApplicationEventMulticaster().addApplicationListener(listener);    &#125;    // Do not initialize FactoryBeans here: We need to leave all regular beans    // uninitialized to let post-processors apply to them!    // 只是添加 并没有执行    String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false);    for (String listenerBeanName : listenerBeanNames) &#123;        getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);    &#125;    // Publish early application events now that we finally have a multicaster...    // 发布早期的时间,并且将 earlyApplicationEvents 设置为空    Set&lt;ApplicationEvent&gt; earlyEventsToProcess = this.earlyApplicationEvents;    this.earlyApplicationEvents = null;    if (!CollectionUtils.isEmpty(earlyEventsToProcess)) &#123;        for (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123;            getApplicationEventMulticaster().multicastEvent(earlyEvent);        &#125;    &#125;&#125;</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这篇文章主要内容是介绍 Spring 事件的使用，同时简单介绍了 initApplicationEventMulticaster 、onRefresh 和 registerListeners 部分的源码。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/KgCNdp-V1Ov1L.png"></p><h4 id="相关推荐"><a href="#相关推荐" class="headerlink" title="相关推荐"></a>相关推荐</h4><ul><li><a href="https://mp.weixin.qq.com/s/99IdvVkTULwTcxrxhF84Ew">Spring 源码学习 13：initMessageSource</a></li><li><a href="https://mp.weixin.qq.com/s/QrogJIm9OaUmeRk9tGiNeg">Spring 源码学习 12：registerBeanPostProcessors</a></li><li><a href="https://mp.weixin.qq.com/s/6VrVDg4m6yi7V4rZZB-6tA">Spring 源码学习 11：invokeBeanFactoryPostProcessors</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 源码笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 源码学习 13：initMessageSource</title>
      <link href="2021/01/02/source-spring-13.html"/>
      <url>2021/01/02/source-spring-13.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在阅读完 registerBeanPostProcessors 源码之后， 下一步就进入到 initMessageSource，这一步主要作用是初始化国际化文件。</p><p>依然如之前所示，先通过官网了解到国际化的用法，然后再对源码进行研究。</p><h3 id="MessageSource-国际化"><a href="#MessageSource-国际化" class="headerlink" title="MessageSource 国际化"></a>MessageSource 国际化</h3><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/i7fXJs-MLV2A0.png"></p><p>如官网<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#context-functionality-messagesource" title="Spring 官方文档">1.15.1. Internationalization using MessageSource</a>所示，主要作用就是使用国际化，定制不同的消息。</p><p>需要注意的是 MessageSource 定义的 Bean 名字必须为 <code>messageSource</code>， 而如果找不到则会默认注册 <code>DelegatingMessageSource</code> 作为 messageSource  的  Bean。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="1-创建国际化文件"><a href="#1-创建国际化文件" class="headerlink" title="1. 创建国际化文件"></a>1. 创建国际化文件</h4><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/vbK7nm-tNoYJn.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/VKIW32-gHAVHQ.png"></p><h4 id="2-声明-MessageSource"><a href="#2-声明-MessageSource" class="headerlink" title="2. 声明 MessageSource"></a>2. 声明 MessageSource</h4><p>在 JavaConfig 中 声明 MessageSource ， 记得名字一定要叫做 <code>messageSource</code> ！</p><pre><code class="java">@Configuration@ComponentScan(&quot;com.liuzhihang&quot;)public class JavaConfig &#123;    @Bean(name = &quot;messageSource&quot;)    public MessageSource getMessageSource() &#123;        ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();        messageSource.setDefaultEncoding(&quot;UTF-8&quot;);        messageSource.addBasenames(&quot;message&quot;, &quot;message_en&quot;);        return messageSource;    &#125;&#125;</code></pre><h4 id="3-测试结果"><a href="#3-测试结果" class="headerlink" title="3. 测试结果"></a>3. 测试结果</h4><pre><code class="java">public class AnnotationConfigApplicationTest &#123;    public static void main(String[] args) &#123;        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();        context.register(JavaConfig.class);        context.refresh();        MessageSource messageSource = context.getBean(MessageSource.class);        String zhMessage = messageSource.getMessage(&quot;user.name&quot;, null, null, Locale.CHINA);        String enMessage = messageSource.getMessage(&quot;user.name&quot;, null, null, Locale.ENGLISH);        System.out.println(&quot;zhMessage = &quot; + zhMessage);        System.out.println(&quot;enMessage = &quot; + enMessage);    &#125;&#125;</code></pre><p>如上所示，执行之后输出结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/sqNm0Q-MyrhWD.png"></p><p>知道了国际化是如何使用的之后，再想一想这一步源码，就知道是什么作用了吧！</p><h3 id="initMessageSource-源码"><a href="#initMessageSource-源码" class="headerlink" title="initMessageSource 源码"></a>initMessageSource 源码</h3><pre><code class="java">protected void initMessageSource() &#123;    ConfigurableListableBeanFactory beanFactory = getBeanFactory();    // Bean 的名称必须要是 messageSource    if (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) &#123;        this.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class);        // Make MessageSource aware of parent MessageSource.        if (this.parent != null &amp;&amp; this.messageSource instanceof HierarchicalMessageSource) &#123;            HierarchicalMessageSource hms = (HierarchicalMessageSource) this.messageSource;            if (hms.getParentMessageSource() == null) &#123;                // Only set parent context as parent MessageSource if no parent MessageSource                // registered already.                hms.setParentMessageSource(getInternalParentMessageSource());            &#125;        &#125;        if (logger.isTraceEnabled()) &#123;            logger.trace(&quot;Using MessageSource [&quot; + this.messageSource + &quot;]&quot;);        &#125;    &#125;    else &#123;        // Use empty MessageSource to be able to accept getMessage calls.        // 否则则使用默认的        DelegatingMessageSource dms = new DelegatingMessageSource();        dms.setParentMessageSource(getInternalParentMessageSource());        this.messageSource = dms;        beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, this.messageSource);        if (logger.isTraceEnabled()) &#123;            logger.trace(&quot;No &#39;&quot; + MESSAGE_SOURCE_BEAN_NAME + &quot;&#39; bean, using [&quot; + this.messageSource + &quot;]&quot;);        &#125;    &#125;&#125;</code></pre><p>这块源码唯一值得关注的地方就是，Bean 的名称必须要是 messageSource 。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文通过官网，了解到什么是国际化，以及国际化的使用，并结合代码和源码，知其然，知其所以然。</p><p>当然本文需要注意的地方就是国际化 MessageSource 的 Bean 名称要必须为 messageSource。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/Ic7vnq-uIcbjr.png"></p><h4 id="相关推荐"><a href="#相关推荐" class="headerlink" title="相关推荐"></a>相关推荐</h4><ul><li><a href="https://mp.weixin.qq.com/s/QrogJIm9OaUmeRk9tGiNeg">Spring 源码学习 12：registerBeanPostProcessors</a></li><li><a href="https://mp.weixin.qq.com/s/6VrVDg4m6yi7V4rZZB-6tA">Spring 源码学习 11：invokeBeanFactoryPostProcessors</a></li><li><a href="https://mp.weixin.qq.com/s/6vTqVFC4frjhqdMirGPCnQ">Spring 源码学习 10：prepareBeanFactory 和 postProcessBeanFactory</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 源码笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 源码学习 12：registerBeanPostProcessors</title>
      <link href="2021/01/01/source-spring-12.html"/>
      <url>2021/01/01/source-spring-12.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前面通过 invokeBeanFactoryPostProcessors 这一步了解到了什么是 BeanFactoryPostProcessor ，以及 BeanFactoryPostProcessor 的使用及作用，并通过 invokeBeanFactoryPostProcessors 这一步源码，对 BeanFactoryPostProcessor 的加载流程有了进一步了解。</p><p>现在就一起进入下一个环节：</p><p><code>registerBeanPostProcessors(beanFactory);</code></p><p>这一步主要的作用是加载 BeanPostProcessor，从名字也可以看出，只是加载，并没有执行。</p><p>不过，在进入源码之前，依然是结合官网，先了解以下几个问题：</p><ol><li>什么是 BeanPostProcessor？</li><li>BeanPostProcessor 是如何使用的？</li><li>BeanPostProcessor 有什么用？</li></ol><h3 id="什么是-BeanPostProcessor-？"><a href="#什么是-BeanPostProcessor-？" class="headerlink" title="什么是 BeanPostProcessor ？"></a>什么是 BeanPostProcessor ？</h3><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/PqDpkg-Wujih5.png"></p><p>如截图所示，在官网 <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-extension-bpp" title="Spring 官方文档">1.8.1 Customizing Beans by Using a BeanPostProcessor</a> 中介绍， <code>BeanPostProcessor</code> 接口定义回调方法，可以实现这些方法，从而在 Bean 实例化期间修改 Bean 的属性。</p><h3 id="BeanPostProcessor-是如何使用的"><a href="#BeanPostProcessor-是如何使用的" class="headerlink" title="BeanPostProcessor 是如何使用的?"></a>BeanPostProcessor 是如何使用的?</h3><pre><code class="java">@Componentpublic class MyBeanPostProcessor implements BeanPostProcessor &#123;    @Override    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;        if (bean instanceof UserComponent) &#123;            System.out.println(&quot;BeanPostProcessor 开始执行 初始化前...&quot; + beanName);            UserComponent userComponent = (UserComponent) bean;            userComponent.setUserName(&quot;liuzhihang-postProcessBeforeInitialization&quot;);            return userComponent;        &#125;        return bean;    &#125;    @Override    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;        if (bean instanceof UserComponent) &#123;            System.out.println(&quot;BeanPostProcessor 开始执行 初始化后...&quot; + beanName);            UserComponent userComponent = (UserComponent) bean;            userComponent.setUserName(&quot;liuzhihang-postProcessAfterInitialization&quot;);            return userComponent;        &#125;        return bean;    &#125;&#125;</code></pre><p>如代码所示，只需要声明一个自己的 MyBeanPostProcessor 来实现 <code>BeanPostProcessor</code> 并重写其方法：</p><p>postProcessBeforeInitialization ：在 Bean 实例后调用初始化方法之前进行处理。</p><p>postProcessAfterInitialization ：在 Bean 实例化后调用初始化方法之后进行处理。</p><p>并且在测试时可以发现，BeanPostProcessor 修改的属性会覆盖 BeanFactoryPostProcessor，至于原因可以阅读下 <a href="https://mp.weixin.qq.com/s/6VrVDg4m6yi7V4rZZB-6tA">Spring 源码学习 11：invokeBeanFactoryPostProcessors</a> 这篇文章，相信对 BeanFactoryPostProcessor 有了一定的了解之后，一定会有自己的答案。</p><p>当然我个人的理解就是 BeanFactoryPostProcessor 是在 Bean 实例化之前，是通过修改元数据从而修改的 Bean 的元素信息。</p><p>这块也可以通过代码进行验证。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/mHNyKC-SBWUcw.png"></p><p>可以看出，执行顺序是</p><p><code>BeanFactoryPostProcessor#postProcessBeanFactory</code><br>-&gt;<br><code>BeanPostProcessor#postProcessBeforeInitialization</code><br>-&gt;<br><code>BeanPostProcessor#postProcessAfterInitialization</code></p><p>所以，后面修改的属性，会覆盖之前修改的属性。</p><p>至于 <code>BeanPostProcessor</code> 是如何修改属性的，在这里先不做介绍，继续进入本节的主角 <code>registerBeanPostProcessors 源码分析</code> </p><h3 id="registerBeanPostProcessors-源码"><a href="#registerBeanPostProcessors-源码" class="headerlink" title="registerBeanPostProcessors 源码"></a>registerBeanPostProcessors 源码</h3><p>在 Spring refresh 方法中，执行 registerBeanPostProcessors 主要作用是将 BeanPostProcessor 注册到容器中，源码如下:</p><pre><code class="java">protected void registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory) &#123;    PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, this);&#125;</code></pre><p>这里调用了 <code>PostProcessorRegistrationDelegate</code> 类的静态方法，继续跟进：</p><pre><code class="java">public static void registerBeanPostProcessors(        ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) &#123;    // 查找 BeanPostProcessor 类型的 Bean 的名称集合, 就是获取所有继承了 BeanPostProcessor 的类    String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);    // Register BeanPostProcessorChecker that logs an info message when    // a bean is created during BeanPostProcessor instantiation, i.e. when    // a bean is not eligible for getting processed by all BeanPostProcessors.    //  注册一个 BeanPostProcessorChecker，用来记录 bean 在 BeanPostProcessor 实例化时的信息。    int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;    beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));    // Separate between BeanPostProcessors that implement PriorityOrdered,    // Ordered, and the rest.    // 四个集合 区分实现不同接口的 BeanPostProcessors    List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;();    List&lt;BeanPostProcessor&gt; internalPostProcessors = new ArrayList&lt;&gt;();    List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;();    List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;();    for (String ppName : postProcessorNames) &#123;        if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;            BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);            priorityOrderedPostProcessors.add(pp);            if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;                internalPostProcessors.add(pp);            &#125;        &#125; else if (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;            orderedPostProcessorNames.add(ppName);        &#125; else &#123;            nonOrderedPostProcessorNames.add(ppName);        &#125;    &#125;    // First, register the BeanPostProcessors that implement PriorityOrdered.    // 排序后执行 实现 PriorityOrdered 的 BeanPostProcessors    sortPostProcessors(priorityOrderedPostProcessors, beanFactory);    registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);    // Next, register the BeanPostProcessors that implement Ordered.    List&lt;BeanPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;(orderedPostProcessorNames.size());    for (String ppName : orderedPostProcessorNames) &#123;        BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);        orderedPostProcessors.add(pp);        if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;            internalPostProcessors.add(pp);        &#125;    &#125;    sortPostProcessors(orderedPostProcessors, beanFactory);    registerBeanPostProcessors(beanFactory, orderedPostProcessors);    // Now, register all regular BeanPostProcessors.    List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size());    for (String ppName : nonOrderedPostProcessorNames) &#123;        BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);        nonOrderedPostProcessors.add(pp);        if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;            internalPostProcessors.add(pp);        &#125;    &#125;    registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);    // Finally, re-register all internal BeanPostProcessors.    sortPostProcessors(internalPostProcessors, beanFactory);    registerBeanPostProcessors(beanFactory, internalPostProcessors);    // Re-register post-processor for detecting inner beans as ApplicationListeners,    // moving it to the end of the processor chain (for picking up proxies etc).    beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));&#125;</code></pre><p>代码中添加了相应的注释，相信读过上一篇文章（invokeBeanFactoryPostProcessors 源码）的小伙伴，一定会感觉非常熟悉，这个方法的逻辑和上面基本一致，都是声明集合，排序，注册到 BeanFactory 中。</p><p>不过还是有区别的：</p><p><code>registerBeanPostProcessors 这一步仅仅将 BeanPostProcessor 注册到 BeanFactory 中，并没有执行！！！</code></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文源码部分相对比较简单，主要花费部分篇幅介绍什么是 BeanPostProcessor 以及 BeanPostProcessor 的使用方法。</p><p>一句话总结这一步就是：注册 BeanPostProcessor 到 BeanFactory 中，但是没有执行。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/dHDiOq-CxKXF8.png"></p><h4 id="相关推荐"><a href="#相关推荐" class="headerlink" title="相关推荐"></a>相关推荐</h4><ul><li><a href="https://mp.weixin.qq.com/s/6VrVDg4m6yi7V4rZZB-6tA">Spring 源码学习 11：invokeBeanFactoryPostProcessors</a></li><li><a href="https://mp.weixin.qq.com/s/6vTqVFC4frjhqdMirGPCnQ">Spring 源码学习 10：prepareBeanFactory 和 postProcessBeanFactory</a></li><li><a href="https://mp.weixin.qq.com/s/i6vdCmOO2ZMsYWfheSLc6g">Spring 源码学习 09：refresh 大概流程</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 源码笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 源码学习 11：invokeBeanFactoryPostProcessors</title>
      <link href="2020/12/28/source-spring-11.html"/>
      <url>2020/12/28/source-spring-11.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>invokeBeanFactoryPostProcessors 会执行 BeanFactory 的后置处理器。看到这里会有疑问：</p><ol><li>什么是 BeanFactoryPostProcessor ？</li><li>BeanfactoryPostProcessor 该如何使用？</li></ol><p>知道了上面两个问题的答案，对 BeanFactoryPostProcessor 有了了解之后，然后再深入源码，继续阅读 invokeBeanFactoryPostProcessors 这个方法。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>资料还是在<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-extension-factory-postprocessors" title="Customizing Configuration Metadata with a BeanFactoryPostProcessor">官网</a>可以找到答案:</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/ZCnfJ9-tR3MFK.png"></p><p>阅读了一下，大概意思是 <code>Spring IoC 容器允许 BeanFactoryPostProcessor 读取配置元数据，并有可能在容器实例化除 BeanFactoryPostProcessor 实例以外的任何 bean 之前更改它。</code></p><p>同样可以使用 Ordered 接口对 BeanFactoryPostProcessor 进行排序。</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/XmG0jo-mewyfG.png"></p><p>BeanFactoryPostProcessor 操作的是 BeanDefinition ，即元数据。但是同样可以通过获取到 BeanFactory 进行实例化 Bean，但是官网很不建议这样使用。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="使用-BeanFactoryPostProcessor"><a href="#使用-BeanFactoryPostProcessor" class="headerlink" title="使用 BeanFactoryPostProcessor"></a>使用 BeanFactoryPostProcessor</h4><pre><code class="java">@Componentpublic class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor &#123;    @Override    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;        // 修改 BeanDefinition 信息        BeanDefinition userComponentBeanDefinition = beanFactory.getBeanDefinition(&quot;userComponent&quot;);        userComponentBeanDefinition.setLazyInit(true);        // 修改 Bean 的信息        // xxx 非常不推荐 beanFactory.getBean 过早的实例化 Bean        UserComponent bean = beanFactory.getBean(UserComponent.class);        bean.setUserName(&quot;liuzhihang-01&quot;);    &#125;&#125;</code></pre><p>创建自己的 BeanFactoryPostProcessor 并实现 BeanFactoryPostProcessor 接口，添加注解即可。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/8dEPpR-aN53mU.png"></p><p>当然除了实现 BeanFactoryPostProcessor 接口，还有其他接口可以实现：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/llYeQ9-DTwOme.png"></p><h4 id="使用-BeanDefinitionRegistryPostProcessor"><a href="#使用-BeanDefinitionRegistryPostProcessor" class="headerlink" title="使用 BeanDefinitionRegistryPostProcessor"></a>使用 BeanDefinitionRegistryPostProcessor</h4><p>BeanDefinitionRegistryPostProcessor 继承了 BeanFactoryPostProcessor，同时扩展了增加了 <code>postProcessBeanDefinitionRegistry</code> 方法。可以支持在 BeanDefinition 注册之后 Bean 实例化之前对 BeanDefinition 进行操作。</p><pre><code class="java">@Componentpublic class MyBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor &#123;    @Override    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;        // 修改 BeanDefinition 信息        BeanDefinition userComponentBeanDefinition = beanFactory.getBeanDefinition(&quot;userComponent&quot;);        userComponentBeanDefinition.setLazyInit(true);        // 修改 Bean 的信息        // xxx 非常不推荐 beanFactory.getBean 过早的实例化 Bean        UserComponent bean = beanFactory.getBean(UserComponent.class);        bean.setUserName(&quot;liuzhihang-01&quot;);    &#125;    @Override    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException &#123;        // 注册一个 BeanDefinition        BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(OrderComponent.class);        AbstractBeanDefinition orderComponentBeanDefinition = builder.getBeanDefinition();        registry.registerBeanDefinition(&quot;orderComponent&quot;, orderComponentBeanDefinition);    &#125;&#125;</code></pre><p>下面是测试代码截图：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/OAsBSh-FPE9FY.png"></p><p>OrderComponent 类没有添加任何注解，然后注册为 BeanDefinition 之后，从容器中可以获取到 orderComponent。</p><h4 id="如何修改字段属性"><a href="#如何修改字段属性" class="headerlink" title="如何修改字段属性"></a>如何修改字段属性</h4><p>在 Spring 文档上说明，非常不建议在 BeanFactoryPostProcessor 中实例化 Bean，那这时候想修改 Bean 的信息，改如何操作？</p><p>其实可以通过获取到 <code>MutablePropertyValues</code> 后进行操作：</p><pre><code class="java">@Componentpublic class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor &#123;    @Override    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;        // 修改 BeanDefinition 信息        BeanDefinition userComponentBeanDefinition = beanFactory.getBeanDefinition(&quot;userComponent&quot;);        userComponentBeanDefinition.setLazyInit(true);        MutablePropertyValues userComponentPropertyValues = userComponentBeanDefinition.getPropertyValues();        userComponentPropertyValues.addPropertyValue(&quot;userName&quot;, &quot;liuzhihang-02&quot;);        // 修改 Bean 的信息        // xxx 非常不推荐 beanFactory.getBean 过早的实例化 Bean        // UserComponent bean = beanFactory.getBean(UserComponent.class);        // bean.setUserName(&quot;liuzhihang-01&quot;);    &#125;&#125;</code></pre><h3 id="invokeBeanFactoryPostProcessors"><a href="#invokeBeanFactoryPostProcessors" class="headerlink" title="invokeBeanFactoryPostProcessors"></a>invokeBeanFactoryPostProcessors</h3><p>看完前面，我想已经知道了 BeanFactoryPostProcessor 是做什么用的了，而这一步的主要作用就是实例化所有的 BeanFactoryPostProcessor。</p><p>进入源码：</p><pre><code class="java">protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) &#123;    PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());    // Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime    // (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)    if (!IN_NATIVE_IMAGE &amp;&amp; beanFactory.getTempClassLoader() == null &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;        beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));        beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));    &#125;&#125;</code></pre><p>其中 getBeanFactoryPostProcessors 方法获取的是自己添加的 BeanFactoryPostProcessor。这句话是什么意思呢？</p><pre><code class="java">public List&lt;BeanFactoryPostProcessor&gt; getBeanFactoryPostProcessors() &#123;    return this.beanFactoryPostProcessors;&#125;</code></pre><p>看源码，就是直接从 beanFactoryPostProcessors 获取的，那如何向其中添加呢？</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/jWhWAu-MicUEW.png"></p><p>其实调用容器的 <code>addBeanFactoryPostProcessor</code> 方法即可。</p><p>继续阅读重点代码 <code>invokeBeanFactoryPostProcessors</code> ：</p><p>注意注意，这块代码非常长！</p><pre><code class="java">public static void invokeBeanFactoryPostProcessors(        ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors) &#123;    // Invoke BeanDefinitionRegistryPostProcessors first, if any.    Set&lt;String&gt; processedBeans = new HashSet&lt;&gt;();    // 判断是否为 BeanDefinitionRegistry    // debug 发现 这里传入的是 DefaultListableBeanFactory    // DefaultListableBeanFactory 实现了 BeanDefinitionRegistry    if (beanFactory instanceof BeanDefinitionRegistry) &#123;        BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;        // 创建了两个 List 集合, 用来存放处理器        // BeanDefinitionRegistryPostProcessor 是 BeanFactoryPostProcessor 的子接口        // BeanDefinitionRegistryPostProcessor 还可以额外处理 BeanDefinition, 添加 BeanDefinition        // 用法可以参考示例        List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = new ArrayList&lt;&gt;();        List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = new ArrayList&lt;&gt;();        // 循环 beanFactoryPostProcessors        // beanFactoryPostProcessors 是使用 API context.addBeanFactoryPostProcessor 添加进来的        for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;            // BeanDefinitionRegistryPostProcessor 要单独添加到 registryProcessors            if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) &#123;                BeanDefinitionRegistryPostProcessor registryProcessor =                        (BeanDefinitionRegistryPostProcessor) postProcessor;                // 处理 Bean 的信息                registryProcessor.postProcessBeanDefinitionRegistry(registry);                registryProcessors.add(registryProcessor);            &#125; else &#123;                regularPostProcessors.add(postProcessor);            &#125;        &#125;        // Do not initialize FactoryBeans here: We need to leave all regular beans        // uninitialized to let the bean factory post-processors apply to them!        // Separate between BeanDefinitionRegistryPostProcessors that implement        // PriorityOrdered, Ordered, and the rest.        // 上面循环是执行的我们调用 API 添加的 BeanDefinitionRegistryPostProcessor        // 下面执行 Spring 自己的 BeanDefinitionRegistryPostProcessor 集合        // 先执行实现了 PriorityOrdered接口的，然后是 Ordered 接口的，最后执行剩下的        List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = new ArrayList&lt;&gt;();        // First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.        // 第一步先调用 BeanDefinitionRegistryPostProcessors 它实现了PriorityOrdered        // 在初始化 reader 时 在注册了 ConfigurationClassPostProcessor 到容器里面        // BeanDefinitionRegistryPostProcessor 实现了 BeanDefinitionRegistryPostProcessor        String[] postProcessorNames =                beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);        for (String ppName : postProcessorNames) &#123;            if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;                // 添加 bean                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));                // 这里只添加了名字 后面用来判断谁已经执行过了                processedBeans.add(ppName);            &#125;        &#125;        // 排序        sortPostProcessors(currentRegistryProcessors, beanFactory);        registryProcessors.addAll(currentRegistryProcessors);        // 循环执行 processors 的 postProcessBeanDefinitionRegistry 方法        // 这个得在仔细看        // debug 看到 执行完这一步我另一个加 @Component 注解的类 注册到 Registry 里面了        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());        // 清除        currentRegistryProcessors.clear();        // Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.        // 处理实现 Ordered 的 processor        postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);        for (String ppName : postProcessorNames) &#123;            // 只有不包含的才执行, 执行完之后会添加进 processedBeans            if (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));                processedBeans.add(ppName);            &#125;        &#125;        // 同上        sortPostProcessors(currentRegistryProcessors, beanFactory);        registryProcessors.addAll(currentRegistryProcessors);        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());        currentRegistryProcessors.clear();        // Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.        // 最后执行其他        boolean reiterate = true;        while (reiterate) &#123;            reiterate = false;            postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);            for (String ppName : postProcessorNames) &#123;                // 只有不包含的才执行, 执行完之后会添加进 processedBeans                if (!processedBeans.contains(ppName)) &#123;                    currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));                    processedBeans.add(ppName);                    reiterate = true;                &#125;            &#125;            sortPostProcessors(currentRegistryProcessors, beanFactory);            registryProcessors.addAll(currentRegistryProcessors);            invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());            currentRegistryProcessors.clear();        &#125;        // Now, invoke the postProcessBeanFactory callback of all processors handled so far.        // 上面处理的都是 postProcessBeanDefinitionRegistry 是在 -&gt; BeanDefinitionRegistryPostProcessor 中        // 下面开始处理 postProcessBeanFactory  -&gt; 是在 BeanFactoryPostProcessor 中        invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);        invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);    &#125; else &#123;        // Invoke factory processors registered with the context instance.        // 不是 BeanDefinitionRegistry 则是普通 BeanFactory 直接执行 beanFactoryPostProcessors 即可        invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);    &#125;    // Do not initialize FactoryBeans here: We need to leave all regular beans    // uninitialized to let the bean factory post-processors apply to them!    // 第二部分    // 上面执行的是 BeanDefinitionRegistryPostProcessor    // 下面开始执行 BeanFactoryPostProcessor    String[] postProcessorNames =            beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);    // Separate between BeanFactoryPostProcessors that implement PriorityOrdered,    // Ordered, and the rest.    // 按照顺序执行    List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;();    List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;();    List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;();    for (String ppName : postProcessorNames) &#123;        if (processedBeans.contains(ppName)) &#123;            // skip - already processed in first phase above            // 说明上面已经执行了, 下面忽略        &#125; else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;            priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));        &#125; else if (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;            orderedPostProcessorNames.add(ppName);        &#125; else &#123;            nonOrderedPostProcessorNames.add(ppName);        &#125;    &#125;    // First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.    // 执行实现 PriorityOrdered 的    sortPostProcessors(priorityOrderedPostProcessors, beanFactory);    invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);    // Next, invoke the BeanFactoryPostProcessors that implement Ordered.    List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;(orderedPostProcessorNames.size());    for (String postProcessorName : orderedPostProcessorNames) &#123;        orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));    &#125;    sortPostProcessors(orderedPostProcessors, beanFactory);    invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);    // Finally, invoke all other BeanFactoryPostProcessors.    List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size());    for (String postProcessorName : nonOrderedPostProcessorNames) &#123;        nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));    &#125;    invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);    // Clear cached merged bean definitions since the post-processors might have    // modified the original metadata, e.g. replacing placeholders in values...    // 清空不必要的元数据信息    beanFactory.clearMetadataCache();&#125;</code></pre><p>上面总体可以分为两部分：</p><ol><li>执行 BeanDefinitionRegistryPostProcessor 接口里面的两个方法：postProcessBeanDefinitionRegistry 和 postProcessBeanFactory。</li><li>执行 BeanFactoryPostProcessor 接口里面的 postProcessBeanFactory 方法。</li></ol><p>以第一部分为例：</p><ol><li>首先判断传入的 BeanFactory 是否为 BeanDefinitionRegistry<ol><li>声明两个 List 集合，regularPostProcessors 用来存储 BeanFactoryPostProcessor，registryProcessors 用来存储 BeanDefinitionRegistryPostProcessor<ol><li>循环 beanFactoryPostProcessors，这个就是我们使用 API 方式添加进来的 BeanFactoryPostProcessor。</li><li>在循环中 BeanDefinitionRegistryPostProcessor 的 postProcessBeanDefinitionRegistry 会被执行，也就是说我示例的那个添加 BeanDefinition 演示的方法会被执行。</li></ol></li><li>开始执行 Spring 自己的 BeanDefinitionRegistryPostProcessor， 处理顺序为 PriorityOrdered, Ordered, and the rest<ol><li>循环，将对应的 BeanDefinitionRegistryPostProcessor 添加到 currentRegistryProcessors 集合和processedBeans集合表示为已经处理。</li><li>排序后添加到第一步的 registryProcessors 中。</li><li>调用 invokeBeanDefinitionRegistryPostProcessors 执行所有的 Processor 里面的 postProcessBeanDefinitionRegistry 方法</li></ol></li><li>执行完 1 和 2 之后，所有的 postProcessBeanDefinitionRegistry 已经被执行完了，但是两个集合（registryProcessors、regularPostProcessors）里面的 postProcessBeanFactory 方法还没有被执行。最后会循环执行。</li></ol></li><li>如果不是 BeanDefinitionRegistry 类型，则直接执行传入的 beanFactoryPostProcessors 即可。</li></ol><p>下面是对应的代码截图</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/vc4xUC-rCOdvD.png"></p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/1A06zT-DDaqjY.png"></p><p>以上只是这个方法的前半部分，执行了 BeanDefinitionRegistryPostProcessor 里面的 postProcessBeanDefinitionRegistry 和 postProcessBeanFactory。</p><p>因为还有直接实现 BeanFactoryPostProcessor 的处理器，下面则开始处理 BeanFactoryPostProcessor 的处理器。过程和上面类似。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过以上的阅读，对 <code>invokeBeanFactoryPostProcessors(beanFactory);</code> 这一步方法进行总结。</p><h4 id="BeanFactoryPostProcessor-作用"><a href="#BeanFactoryPostProcessor-作用" class="headerlink" title="BeanFactoryPostProcessor 作用"></a>BeanFactoryPostProcessor 作用</h4><p>BeanFactoryPostProcessor 主要作用是在注册 BeanDefinition 之后，在 Bean 初始化之前，修改 BeanDefinition 的信息。</p><p>BeanFactoryPostProcessor 有个实现叫 BeanDefinitionRegistryPostProcessor，它可以额外的注册新的 BeanDefinition 到容器中。</p><h4 id="流程概述"><a href="#流程概述" class="headerlink" title="流程概述"></a>流程概述</h4><ol><li>这一步主要是处理 BeanFactoryPostProcessor，分为两步。</li><li>执行 BeanDefinitionRegistryPostProcessor 接口里面的两个方法：postProcessBeanDefinitionRegistry 和 postProcessBeanFactory。</li><li>执行 BeanFactoryPostProcessor 接口里面的 postProcessBeanFactory 方法。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/hoPCO0-yAfXNu.png"></p><h4 id="相关推荐"><a href="#相关推荐" class="headerlink" title="相关推荐"></a>相关推荐</h4><ul><li><a href="https://mp.weixin.qq.com/s/6vTqVFC4frjhqdMirGPCnQ">Spring 源码学习 10：prepareBeanFactory 和 postProcessBeanFactory</a></li><li><a href="https://mp.weixin.qq.com/s/i6vdCmOO2ZMsYWfheSLc6g">Spring 源码学习 09：refresh 大概流程</a></li><li><a href="https://mp.weixin.qq.com/s/XPljpjGBpD7t2cmPAofm7A">Spring 源码学习 08：register 注册配置类</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 源码笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 源码学习 10：prepareBeanFactory 和 postProcessBeanFactory</title>
      <link href="2020/12/27/source-spring-10.html"/>
      <url>2020/12/27/source-spring-10.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>根据 refresh 流程，当 <code>obtainFreshBeanFactory</code> 执行结束后，下一步会执行 <code>prepareBeanFactory</code> ，顾名思义，这个方法主要是<code>准备 BeanFactory</code>，下面一起看一看这部分逻辑。</p><h3 id="prepareBeanFactory"><a href="#prepareBeanFactory" class="headerlink" title="prepareBeanFactory"></a>prepareBeanFactory</h3><pre><code class="java">protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123;    // Tell the internal bean factory to use the context&#39;s class loader etc.    // 设置beanFactory的类加载器    beanFactory.setBeanClassLoader(getClassLoader());    // spring.spel.ignore 属性控制是否解析 SpEL 表达式    if (!shouldIgnoreSpel) &#123;        beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));    &#125;    // 设置属性解析器    beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));    // Configure the bean factory with context callbacks.    // 添加到后置处理器列表, 新创建的 ApplicationContextAwareProcessor 入参为当前 ApplicationContext    beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));    // 忽略自动装配    // 默认情况下 只有BeanFactoryAware 被忽略 要忽略其他类型，需要单独设置    beanFactory.ignoreDependencyInterface(EnvironmentAware.class);    beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);    beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);    beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);    beanFactory.ignoreDependencyInterface(MessageSourceAware.class);    beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);    beanFactory.ignoreDependencyInterface(ApplicationStartup.class);    // BeanFactory interface not registered as resolvable type in a plain factory.    // MessageSource registered (and found for autowiring) as a bean.    // 注册自动装配的类    beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);    beanFactory.registerResolvableDependency(ResourceLoader.class, this);    beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);    beanFactory.registerResolvableDependency(ApplicationContext.class, this);    // Register early post-processor for detecting inner beans as ApplicationListeners.    beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));    // Detect a LoadTimeWeaver and prepare for weaving, if found.    // 是否需要类加载期间织入  增加Aspectj的支持    if (!IN_NATIVE_IMAGE &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;        beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));        // Set a temporary ClassLoader for type matching.        beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));    &#125;    // Register default environment beans.    // 注册其他的 bean    if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;        beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());    &#125;    if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;        beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());    &#125;    if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;        beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());    &#125;    if (!beanFactory.containsLocalBean(APPLICATION_STARTUP_BEAN_NAME)) &#123;        beanFactory.registerSingleton(APPLICATION_STARTUP_BEAN_NAME, getApplicationStartup());    &#125;&#125;</code></pre><p>这块代码比较长，但是逻辑比较简单，就直接贴代码了。</p><p>再对代码进行分析，主要经历以下几个阶段：</p><ol><li>addBeanPostProcessor 添加 BeanPostProcessor</li><li>registerResolvableDependency 注册依赖关系</li><li>registerSingleton 注册其他的单例 Bean</li></ol><p>下面可以 Debug 看一下。</p><h3 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h3><p>方法调用前：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/NJwbIq-S5vLU0.png"></p><p>registerResolvableDependency 执行之后</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/aRpomY-pOoRdu.png"></p><p>这里发现调用 <code>registerResolvableDependency</code> 执行结束之后，<code>beanDefinitionNames</code> 中并没有多添加相关对象。</p><p>查看源码发现其实是添加到了 <code>resolvableDependencies</code> 这个 Map 中了。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/r83Zdu-IywxsL.png"></p><blockquote><p>回顾</p><p>在介绍 <code>DefaultListableBeanFactory</code> 时，说 BeanDefinition 是存储在 beanDefinitionMap 中的。<br>而这里的依赖关系是则是存储在 <code>resolvableDependencies</code> 中的。</p></blockquote><h3 id="postProcessBeanFactory"><a href="#postProcessBeanFactory" class="headerlink" title="postProcessBeanFactory"></a>postProcessBeanFactory</h3><p>在执行 prepareBeanFactory 之后，当看到 <code>postProcessBeanFactory(beanFactory);</code> 方法的时候就很疑惑， 因为这个是需要子类实现的，只是作为一个模板方法，子类实现之后，可以在里面添加自己的逻辑。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这篇文章相对比较简单，就是准备 BeanFactory 向其中添加系统的依赖以及 bean, 而 postProcessBeanFactory 则是一个模版方法用来供子类实现。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/nDmWFO-dHVLOp.png"></p><h4 id="相关推荐"><a href="#相关推荐" class="headerlink" title="相关推荐"></a>相关推荐</h4><ul><li><a href="https://mp.weixin.qq.com/s/i6vdCmOO2ZMsYWfheSLc6g">Spring 源码学习 09：refresh 大概流程</a></li><li><a href="https://mp.weixin.qq.com/s/XPljpjGBpD7t2cmPAofm7A">Spring 源码学习 08：register 注册配置类</a></li><li><a href="https://mp.weixin.qq.com/s/VnUugIxZkUcqDvt9Yv47iQ">Spring 源码学习 07：ClassPathBeanDefinitionScanner</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 源码笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 源码学习 09：refresh 大概流程</title>
      <link href="2020/12/16/source-spring-09.html"/>
      <url>2020/12/16/source-spring-09.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前面的准备工作结束之后，就是进入核心代码 refresh。</p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><pre><code class="java">public void refresh() throws BeansException, IllegalStateException &#123;    // 加锁    synchronized (this.startupShutdownMonitor) &#123;        StartupStep contextRefresh = this.applicationStartup.start(&quot;spring.context.refresh&quot;);        // 准备一些上下文        prepareRefresh();        // 获取准备后的 beanFactory  DefaultListableBeanFactory        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();        // 准备 BeanFactory        prepareBeanFactory(beanFactory);        try &#123;            // 允许在上下文子类中对bean工厂进行后处理。            postProcessBeanFactory(beanFactory);            StartupStep beanPostProcess = this.applicationStartup.start(&quot;spring.context.beans.post-process&quot;);            // 在上下文中调用注册为 beanFactory 后置处理器            // 就是实现了 BeanFactoryPostProcessor 的 bean            invokeBeanFactoryPostProcessors(beanFactory);            // 注册后置处理的Bean到容器当中            // 就是扩展了 BeanPostProcessor 的 Bean            registerBeanPostProcessors(beanFactory);            beanPostProcess.end();            // 为此上下文初始化消息源。            // 初始化国际化工具 MessageSource            initMessageSource();            // 为此上下文初始化事件广播器。            initApplicationEventMulticaster();            // 在特定上下文子类中初始化其他特殊bean。子类可以自己实现            onRefresh();            // 检查并注册监听器。            registerListeners();            // 实例化所有剩余的（非延迟初始化）单例。            finishBeanFactoryInitialization(beanFactory);            // 最后一步: 完成此上下文的刷新，调用 LifecycleProcessor 的 onRefresh（）方法并发布            finishRefresh();        &#125;        catch (BeansException ex) &#123;            if (logger.isWarnEnabled()) &#123;                logger.warn(&quot;Exception encountered during context initialization - &quot; +                        &quot;cancelling refresh attempt: &quot; + ex);            &#125;            // 销毁已创建的单例以避免资源悬挂。            destroyBeans();            // 重置活动状态            cancelRefresh(ex);            // Propagate exception to caller.            throw ex;        &#125;        finally &#123;            // Reset common introspection caches in Spring&#39;s core, since we            // might not ever need metadata for singleton beans anymore...            resetCommonCaches();            contextRefresh.end();        &#125;    &#125;&#125;</code></pre><p>源码就是密密麻麻的一大堆，源码上有相应的注释。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/qaUQQJ-l1bAsm.png"></p><p>下面就根据流程，一步一步的深入源码，了解到每一步都是做什么了。</p><h3 id="容器刷新准备"><a href="#容器刷新准备" class="headerlink" title="容器刷新准备"></a>容器刷新准备</h3><p><code>prepareRefresh</code> 这一步主要是准备一些上下文信息。就不过多介绍了。</p><h3 id="obtainFreshBeanFactory"><a href="#obtainFreshBeanFactory" class="headerlink" title="obtainFreshBeanFactory"></a>obtainFreshBeanFactory</h3><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/nD4PyL-DFi913.png"></p><p>下面关注初始化 BeanFactory 这一步：</p><p>进入源码：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/4RezAZ-ngEGKj.png"></p><p>通过 Debug 可以看出 <code>refreshBeanFactory()</code> 这一步调用的是 <code>org.springframework.context.support.GenericApplicationContext#refreshBeanFactory</code> 中实现的方法。</p><p>继续跟进</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/nhZCwD-I9EXrp.png"></p><p>发现这块判断了一个 <code>refreshed</code> 刷新状态。</p><p><code>refreshBeanFactory</code> 方法也有另一个实现是在 <code>AbstractRefreshableApplicationContext</code> 中， 只不过我的断点没有断进去，这块也一起看下。</p><pre><code class="java">protected final void refreshBeanFactory() throws BeansException &#123;    // 如果存在 BeanFactory 则销毁 Bean 并关闭 BeanFactory    if (hasBeanFactory()) &#123;        destroyBeans();        closeBeanFactory();    &#125;    try &#123;        // 创建一个默认的 BeanFactory        DefaultListableBeanFactory beanFactory = createBeanFactory();        beanFactory.setSerializationId(getId());        // 设置属性        customizeBeanFactory(beanFactory);        // 加载 Bean 信息        loadBeanDefinitions(beanFactory);        this.beanFactory = beanFactory;    &#125;    catch (IOException ex) &#123;        throw new ApplicationContextException(&quot;I/O error parsing bean definition source for &quot; + getDisplayName(), ex);    &#125;&#125;</code></pre><p>其中会创建 BeanFactory 并加载 BeanDefinition。只不过我暂时没有断到，所以等后面遇到之后再详细介绍。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/3JfDRw-4a5C5Y.png"></p><p>本文简单介绍了 refresh 的流程，并介绍了前两个部分：</p><ol><li>prepareRefresh 准备上下文信息</li><li>obtainFreshBeanFactory 初始化 BeanFactory</li></ol><h4 id="相关推荐"><a href="#相关推荐" class="headerlink" title="相关推荐"></a>相关推荐</h4><ul><li><a href="https://mp.weixin.qq.com/s/XPljpjGBpD7t2cmPAofm7A">Spring 源码学习 08：register 注册配置类</a></li><li><a href="https://mp.weixin.qq.com/s/VnUugIxZkUcqDvt9Yv47iQ">Spring 源码学习 07：ClassPathBeanDefinitionScanner</a></li><li><a href="https://mp.weixin.qq.com/s/u40NdypoO2ow2wdV293eow">Spring 源码学习 06：AnnotatedBeanDefinitionReader</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 源码笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 源码学习 08：register 注册配置类</title>
      <link href="2020/12/06/source-spring-08.html"/>
      <url>2020/12/06/source-spring-08.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>看完无参构造的源码及流程之后，后面将会执行 <code>register</code> 方法。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/iURj3q-YF3Fqe.png"></p><p>register 方法，入参是我们的配置类 <code>JavaConfig.class</code> ，下面跟着源码继续往下走！</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/72gJH7-cF6JtX.png"></p><p><code>this.reader.register(componentClasses);</code></p><p>这里执行的是 reader 的方法，入参就是传入的 <code>JavaConfig.class</code>。</p><blockquote><p>reader 在之前初始化，就是注册一些 PostProcessor。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/OL9u7q-Y6NATv.png"></p><ol><li>循环，注册所有的配置类；</li><li>doRegisterBean 开始注册。</li></ol><p><code>doRegisterBean</code> 才是真正注册 Bean 的逻辑，从名字也可以有所猜测。下面开始进入 <code>doRegisterBean</code> 的源码阅读：</p><h4 id="doRegisterBean"><a href="#doRegisterBean" class="headerlink" title="doRegisterBean"></a>doRegisterBean</h4><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/OXRMeM-cMgaGt.png"></p><p>此处代码较长，以截图代替。</p><p>通过源码可以看出，这块主要流程：</p><ol><li>校验传入的 <code>JavaConfig.class</code> 的注解（是否需要忽略）；</li><li>处理通用注解；</li><li>封装为 BeanDefinitionHolder 后，注册到容器中。</li></ol><h4 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h4><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/QfGRrs-tdXZRz.png"></p><p>通过 debug 可以看出，在执行完 <code>register</code> 之后，相当于将 JavaConfig 作为一个 Bean 注册到容器中。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/mcTElg-qWdJKu.png"></p><p>在我看来前面的部分主要涉及到准备工作，至于更深层次的研究，分析，暂时没有深入。</p><h4 id="相关推荐"><a href="#相关推荐" class="headerlink" title="相关推荐"></a>相关推荐</h4><ul><li><a href="https://mp.weixin.qq.com/s/VnUugIxZkUcqDvt9Yv47iQ">Spring 源码学习 07：ClassPathBeanDefinitionScanner</a></li><li><a href="https://mp.weixin.qq.com/s/u40NdypoO2ow2wdV293eow">Spring 源码学习 06：AnnotatedBeanDefinitionReader</a></li><li><a href="https://mp.weixin.qq.com/s/b7QhZguNTM_6C83b4IiMdg">Spring 源码学习 05：BeanDefinition 概念及其实现</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 源码笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 源码学习 07：ClassPathBeanDefinitionScanner</title>
      <link href="2020/12/05/source-spring-07.html"/>
      <url>2020/12/05/source-spring-07.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>AnnotationConfigApplicationContext 构造函数除了初始化一个 <code>reader</code> ，还有一个 <code>scanner</code>，下面来一起看看 <code>ClassPathBeanDefinitionScanner</code> 都有什么逻辑。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/aag0Mf-hC4vg6.png"></p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p><code>this.scanner = new ClassPathBeanDefinitionScanner(this);</code> 代码如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/dIkTFJ-9bYFDo.png"></p><p>其中 <code>useDefaultFilters</code> 默认设置的 true。所以最终会执行下面三部分代码：</p><ol><li>registerDefaultFilters();</li><li>setEnvironment(environment);</li><li>setResourceLoader(resourceLoader);</li></ol><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/7IpG0J-yzsRns.png"></p><p>再来看下 UML ：</p><p><code>ClassPathBeanDefinitionScanner</code> 继承了 <code>ClassPathScanningCandidateComponentProvider</code>，而上面说的这三个方法，其实都是父类 <code>ClassPathScanningCandidateComponentProvider</code> 的方法。</p><p>对应的这三个操作就是给它的参数赋值：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/P15SfZ-To57wW.png"></p><h4 id="registerDefaultFilters"><a href="#registerDefaultFilters" class="headerlink" title="registerDefaultFilters"></a>registerDefaultFilters</h4><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/EjGINh-OGlb4j.png"></p><p>本步骤主要是添加过滤器，对 includeFilters 赋值。 注册过滤器 <code>@Component</code>，<code>@Controller</code> <code>@Service</code>、 <code>@Repository</code> 也会被添加进去。</p><p>也会注册添加 JSR-250 的 @ManagedBean 和 JSR-330 的 @Named 注解。</p><h4 id="setEnvironment"><a href="#setEnvironment" class="headerlink" title="setEnvironment"></a>setEnvironment</h4><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/HLHo9N-l5MfXo.png"></p><h4 id="setResourceLoader"><a href="#setResourceLoader" class="headerlink" title="setResourceLoader"></a>setResourceLoader</h4><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/NTEYuH-nYXQTF.png"></p><p><code>setEnvironment</code> 和 <code>setResourceLoader</code> 赋值操作，基本上如代码所示。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/cWzzC7-zOZGjH.png"></p><p>这一步主要是初始化类扫描器，在它初始化的时候，会初始化一些需要被扫描的注解，以及资源加载器。</p><h4 id="相关推荐"><a href="#相关推荐" class="headerlink" title="相关推荐"></a>相关推荐</h4><ul><li><a href="https://mp.weixin.qq.com/s/u40NdypoO2ow2wdV293eow">Spring 源码学习 06：AnnotatedBeanDefinitionReader</a></li><li><a href="https://mp.weixin.qq.com/s/b7QhZguNTM_6C83b4IiMdg">Spring 源码学习 05：BeanDefinition 概念及其实现</a></li><li><a href="https://mp.weixin.qq.com/s/JwRsKHqJ0ZcJ6Cgbp5BKiw">Spring 源码学习 04：初始化容器与 DefaultListableBeanFactory</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 源码笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 源码学习 06：AnnotatedBeanDefinitionReader</title>
      <link href="2020/12/04/source-spring-06.html"/>
      <url>2020/12/04/source-spring-06.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>BeanDefinition 的概念也了解了，也知道一个 Bean 在 Spring 中定义的信息有哪些之后，继续言归正传。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/erZhOh-c50rG0.png"></p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>在初始化时会先生成一个 reader ，进入方法，其实是走的下面的逻辑：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/RPkIz4-hjaaG4.png"></p><p>其中 <code>getOrCreateEnvironment(registry)</code> 会返回一个 <code>Environment</code> 用来表示当前的运行环境之类的。</p><p><code>ConditionEvaluator</code> 是用来完成对 <code>@Conditional</code> 这个条件注解的判断。</p><p>这块可以参考官网：<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-environment">Environment Abstraction 章节</a></p><p><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java-conditional">Conditionally Include @Configuration Classes or @Bean Methods 章节</a></p><blockquote><p><strong>补充</strong></p><p>BeanDefinitionRegistry：就是对 BeanDefinition 进行注册、移除、获取等操作的一个接口。<br>比如：registerBeanDefinition、removeBeanDefinition、containsBeanDefinition 看名字也能猜个大概意思。</p></blockquote><h4 id="registerAnnotationConfigProcessors"><a href="#registerAnnotationConfigProcessors" class="headerlink" title="registerAnnotationConfigProcessors"></a>registerAnnotationConfigProcessors</h4><p>下面来看最后一行代码：</p><pre><code class="java">AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);</code></pre><p>这个代码相对较长，还是以截图代替。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/6wAV8a-8qbZoP.png"></p><p>对 beanFactory 添加依赖比较器 和 自动装配解析器 后开始添加各种处理器。</p><p>添加处理器时，下面收缩的代码和唯一展开的 <code>ConfigurationClassPostProcessor</code> 内部逻辑相同，都是调用 <code>registerPostProcessor</code> 方法，下面再介绍下这几个处理器的作用：</p><ul><li>ConfigurationClassPostProcessor 用于对 @Configuration 类进行引导处理。</li><li>AutowiredAnnotationBeanPostProcessor 处理 @Autowired @Value 和 JSR-330的@Inject 还有 @Lookup 注解</li><li>CommonAnnotationBeanPostProcessor 用来处理 @PostConstruct @PreDestroy @Resource。</li><li>PersistenceAnnotationBeanPostProcessor 当支持 JPA 时添加这个。</li><li>EventListenerMethodProcessor 支持 @EventListener。</li></ul><h4 id="registerPostProcessor"><a href="#registerPostProcessor" class="headerlink" title="registerPostProcessor"></a>registerPostProcessor</h4><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/uaUJJU-bcIdE3.png"></p><p>registerPostProcessor 方法有两个逻辑：</p><ol><li>将这几个 Processor 注册到 beanFactory；</li><li>处理器封装为 BeanDefinitionHolder 对象。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/jdTJln-hqvIeJ.png" alt="BeanDefinitionHolder"></p><p>BeanDefinitionHolder 就是封装了下 BeanDefinition ，说明这个 BeanDefinition 的持有者 name 是谁。 </p><h4 id="大胆猜测"><a href="#大胆猜测" class="headerlink" title="大胆猜测"></a>大胆猜测</h4><p>执行完这一行之后，在 AnnotationConfigApplicationContext 里面有了 这几个 BeanDefinition。</p><h4 id="小心求证"><a href="#小心求证" class="headerlink" title="小心求证"></a>小心求证</h4><p>Debug 走起！</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/wFyqjc-OROaV6.png"></p><p>额……  只有四个，假装是对的。还是一步一步看一看吧！原来是没有 JSR-250 和 JPA，那这个就正常了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/jMZmN5-GpjdYh.png"></p><p>其实简而言之，这一步就是注册了一些 Spring 自己的 PostProcessor。</p><h4 id="相关推荐"><a href="#相关推荐" class="headerlink" title="相关推荐"></a>相关推荐</h4><ul><li><a href="https://mp.weixin.qq.com/s/b7QhZguNTM_6C83b4IiMdg">Spring 源码学习 05：BeanDefinition 概念及其实现</a></li><li><a href="https://mp.weixin.qq.com/s/JwRsKHqJ0ZcJ6Cgbp5BKiw">Spring 源码学习 04：初始化容器与 DefaultListableBeanFactory</a></li><li><a href="https://mp.weixin.qq.com/s/V7SjmIFKAXyppBF_KHbxXQ">Spring 源码学习 03：创建 IoC 容器的几种方式</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 源码笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 源码学习 05：BeanDefinition 概念及其实现</title>
      <link href="2020/12/03/source-spring-05.html"/>
      <url>2020/12/03/source-spring-05.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>BeanDefinition：顾名思义，就是 Bean 的定义，是用来描述一个 Bean 都有什么信息。前面说在初始化 <code>DefaultListableBeanFactory</code> 时，会初始化一个 <code>Map&lt;String, BeanDefinition&gt;</code>，这个 Map 的功能暂且不说，（PS：查资料说的是存储 bean），所以今天就结合官方文档以及源码，一起了解一下 <code>BeanDefinition</code>！</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/RQNh7C-qiNl5V.png"></p><p>在容器内部，使用 <code>BeanDefinition</code> 对象定义一个 Bean。而定义的信息包含 类名、作用域、是否懒加载、构造参数、初始化方法、销毁方式等等。</p><p>了解了概念之后，开始阅读源码，源码部分比较长。</p><h3 id="源码介绍"><a href="#源码介绍" class="headerlink" title="源码介绍"></a>源码介绍</h3><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/BeanDefinition-pzN9Uc.png" alt="BeanDefinition"></p><p>通过 UML 可以看出 BeanDefinition 接口继承了 AttributeAccessor 和 BeanMetadataElement 两个接口。</p><h4 id="AttributeAccessor"><a href="#AttributeAccessor" class="headerlink" title="AttributeAccessor"></a>AttributeAccessor</h4><p>AttributeAccessor：定义用于将元数据附加到任意对象或从任意对象访问元数据的通用协定的接口。</p><pre><code class="java">public interface AttributeAccessor &#123;    void setAttribute(String name, @Nullable Object value);    @Nullable    Object getAttribute(String name);    @Nullable    Object removeAttribute(String name);    boolean hasAttribute(String name);    String[] attributeNames();&#125;</code></pre><p>通过接口方法可以看出，AttributeAccessor 主要定义了对元数据<code>属性</code>的增删改查。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/uZKzQo-PU9mzG.png"></p><p><code>AttributeAccessorSupport</code> 是 AttributeAccessor 接口的一个实现，通过实现可以看出，其内部使用了 Map 保存名称和属性值。</p><h4 id="BeanMetadataElement"><a href="#BeanMetadataElement" class="headerlink" title="BeanMetadataElement"></a>BeanMetadataElement</h4><p>BeanMetadataElement：由包含配置源对象的 bean 元数据元素实现的接口。</p><pre><code class="java">public interface BeanMetadataElement &#123;    @Nullable    default Object getSource() &#123;        return null;    &#125;&#125;</code></pre><p>接口内部只有一个 <code>getSource()</code> 方法，其含义为：<strong>返回此元数据元素的配置源Object （可以为null ）。</strong></p><p>其实还是不知道啥意思……</p><p>在子类（<code>BeanMetadataAttributeAccessor</code>）中加上断点，debug</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/bR6lTo-GEmj33.png"></p><p>这里 source 里面存储了 Class 类文件在磁盘的真实路径。当然姑且可以这么认为，毕竟我这也是刚开始学习源码，当前的结论只是 debug 到的，也有可能在别的实现类中存储的是别的信息。</p><h4 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h4><p>BeanDefinition 方法较多，就不贴代码，或者截图了。详细可以通过 <a href="https://github.com/liuzhihang/spring-framework/blob/master/spring-beans/src/main/java/org/springframework/beans/factory/config/BeanDefinition.java">我的 GitHub</a> 进行阅读，上面添加了相关注释。</p><p>不过还是简要介绍一下方法，大概有 Bean 的名字、作用范围、是否首选、以及 Bean 的初始化销毁方法等等。</p><p>BeanDefinition 只是一个接口，其实现又分为好几种。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/AbstractBeanDefinition-x4hCMm.png" alt="AbstractBeanDefinition"></p><h4 id="AbstractBeanDefinition"><a href="#AbstractBeanDefinition" class="headerlink" title="AbstractBeanDefinition"></a>AbstractBeanDefinition</h4><p>AbstractBeanDefinition 作为 BeanDefinition 的抽象实现类，内部定义了很多属性，以满足 BeanDefinition 定义的接口功能。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/avOyP7-LBkQNL.png"></p><p>这些属性的操作，就对应着 BeanDefinition 定义的接口方法。</p><h4 id="AbstractBeanDefinition-的三个实现类"><a href="#AbstractBeanDefinition-的三个实现类" class="headerlink" title="AbstractBeanDefinition 的三个实现类"></a>AbstractBeanDefinition 的三个实现类</h4><p>AbstractBeanDefinition 的实现又分为三个：分别是 <code>ChildBeanDefinition</code>、 <code>RootBeanDefinition</code>、 <code>GenericBeanDefinition</code>。</p><ol><li><p>ChildBeanDefinition：可以从 Parent Definition 里面继承一些公共定义（初始化方法、销毁方法、是否懒加载等等）不过</p></li><li><p>RootBeanDefinition：定义 Bean Definition 的公共属性，该定义在运行时支持Spring BeanFactory中的特定bean。 而 RootBeanDefinition 是不可以设置 parentName 指定 Parent Definition 的。</p></li><li><p>GenericBeanDefinition：是一个通用的 Bean Definition，是一站式服务，用于标准bean定义。 像任何bean定义一样，它允许指定一个类以及可选的构造函数参数值和属性值。 另外，可以通过 <code>parentName</code> 属性灵活地配置从父bean定义派生的内容。所以现在一般使用 GenericBeanDefinition。</p></li></ol><blockquote><p>从 Spring 2.5 开始，以编程方式注册 Bean Definition 的首选方法是 GenericBeanDefinition 类，该类允许通过 GenericBeanDefinition.setParentName 方法动态定义父依赖项。 </p></blockquote><p>GenericBeanDefinition 下面还有两个实现：<code>ScannedGenericBeanDefinition</code> 、<code>AnnotatedGenericBeanDefinition</code></p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/mX91iq-VpxacB.png"></p><p>二者并无太大区别，只不过 <code>AnnotatedGenericBeanDefinition</code> 比 <code>ScannedGenericBeanDefinition</code> 多了一个 <code>factoryMethodMetadata</code> 的定义。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过阅读 BeanDefinition 的源码，并对其实现类的源码进行阅读之后，大致了解 BeanDefinition 的概念及其含义。大概作图总结如下：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/lrjeS3-Mn06Yj.png"></p><h4 id="相关推荐"><a href="#相关推荐" class="headerlink" title="相关推荐"></a>相关推荐</h4><ul><li><a href="https://mp.weixin.qq.com/s/JwRsKHqJ0ZcJ6Cgbp5BKiw">Spring 源码学习 04：初始化容器与 DefaultListableBeanFactory</a></li><li><a href="https://mp.weixin.qq.com/s/V7SjmIFKAXyppBF_KHbxXQ">Spring 源码学习 03：创建 IoC 容器的几种方式</a></li><li><a href="https://mp.weixin.qq.com/s/YPDPU7ePtii0vlrynexb_w">Spring 源码学习 02：关于 Spring IoC 和 Bean 的概念</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 源码笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 源码学习 04：初始化容器与 DefaultListableBeanFactory</title>
      <link href="2020/12/02/source-spring-04.html"/>
      <url>2020/12/02/source-spring-04.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/Sf8fRH-D6nt5n.png"></p><p>在前一篇文章：<a href="https://mp.weixin.qq.com/s/V7SjmIFKAXyppBF_KHbxXQ">创建 IoC 容器的几种方式</a>中，介绍了四种方式，这里以 <code>AnnotationConfigApplicationContext</code> 为例，跟进代码，看看 IoC 的启动流程。</p><h3 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h3><p>从 JavaConfig 中加载配置的 <code>AnnotationConfigApplicationContext</code> 启动方式如下：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/NbaqT1-SIKlXs.png"></p><p>进去之后发现构造其实是调用的当前无参构造。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/dA7SqR-pnWaJ0.png"></p><p>所以在启动时也可以直接声明无参构造，改写为下面这种：</p><pre><code class="java">public class AnnotationConfigApplicationTest &#123;    public static void main(String[] args) &#123;        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();        context.register(JavaConfig.class);        context.refresh();        System.out.println(context.getBean(UserComponent.class));    &#125;&#125;</code></pre><p>今天就研究研究无参构造这一部分究竟做了什么逻辑！</p><h4 id="无参构造"><a href="#无参构造" class="headerlink" title="无参构造"></a>无参构造</h4><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/VfQDRi-qtFJay.png"></p><p>其中的 <code>StartupStep</code> 是 5.3 新增的类，看代码注释的意思是：表示用来记录启动过程中的一些指标信息等。暂时不做研究。</p><p>主要研究红框部分！注意，<strong>这一块并不代表只有红框部分</strong>！</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/jHZiO9-lClEgy.png"></p><p>因为 <code>AnnotationConfigApplicationContext</code> 继承了 <code>GenericApplicationContext</code>，所以会先执行父类的构造方法。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/T9dF4r-BeA6nA.png"></p><p>所以这里会创建一个 <code>DefaultListableBeanFactory</code> 的容器。</p><h3 id="DefaultListableBeanFactory"><a href="#DefaultListableBeanFactory" class="headerlink" title="DefaultListableBeanFactory"></a>DefaultListableBeanFactory</h3><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/DefaultListableBeanFactory-oBHX69.png" alt="DefaultListableBeanFactory UML"></p><p>虽然说 Spring 的 <code>BeanFactory</code> 定义了容器的基础概念、接口方法等，但是 <code>DefaultListableBeanFactory</code> 才是一个真正可以 new 出来的具体的容器，当然也可以暂且称之为 bean 工厂。</p><p>下面来看一下 <code>DefaultListableBeanFactory</code> 里面都有什么？</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/oUgw6b-dgE9ZX.png"></p><p>在 <code>DefaultListableBeanFactory</code> 里面会初始化很多参数，其中重点关注的是下面两个参数：</p><pre><code class="java">/** Map of bean definition objects, keyed by bean name. */// BeanDefinition 的存储 Map 其中 key 为 beanNameprivate final Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;(256);/** List of bean definition names, in registration order. */// BeanName 的集合private volatile List&lt;String&gt; beanDefinitionNames = new ArrayList&lt;&gt;(256);</code></pre><p>其中 <code>BeanDefinition</code> 描述了一个 bean 实例，该实例具有属性值，构造函数参数值以及具体实现所提供的更多信息。</p><p>对应的 <code>beanDefinitionMap</code> 就是存储的初始化的 beanName 和 BeanDefinition。</p><p>至于 BeanDefinition 具体内容，下一节再做介绍。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过上面的阅读，可以在初始化流程中增加一部分模块，即实例化 <code>DefaultListableBeanFactory</code></p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/m4P5ZW-VrZwt7.png"></p><p>再回顾一下 <code>DefaultListableBeanFactory</code> 的概念。</p><blockquote><p><strong>DefaultListableBeanFactory：</strong></p><p>Spring 的 ConfigurableListableBeanFactory 和 BeanDefinitionRegistry 接口的默认实现：基于bean定义元数据的成熟bean工厂，可通过后处理器进行扩展。<br>重点需要把握的是 DefaultListableBeanFactory 内部定义了 BeanDefinition 的 Map。</p></blockquote><h4 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h4><p>本文从入口开始，进入到构造，主要介绍了 <code>DefaultListableBeanFactory</code> 的创建，及创建时初始化了一堆参数。</p><p>考虑到文章篇幅问题，尽量避免大段大段的贴代码以及注释，有兴趣的小伙伴可以试着自己搭建源码构建环境，然后 Debug 走一走，这样也可以互相探讨，共同学习。</p><p>笔者也是刚开始阅读学习源码，不足之处，希望多多指正。</p><h4 id="相关推荐"><a href="#相关推荐" class="headerlink" title="相关推荐"></a>相关推荐</h4><ul><li><a href="https://mp.weixin.qq.com/s/V7SjmIFKAXyppBF_KHbxXQ">Spring 源码学习 03：创建 IoC 容器的几种方式</a></li><li><a href="https://mp.weixin.qq.com/s/YPDPU7ePtii0vlrynexb_w">Spring 源码学习 02：关于 Spring IoC 和 Bean 的概念</a></li><li><a href="https://mp.weixin.qq.com/s/gDhJMSPSX2vz68p5X3juow">Spring 源码学习 01：源码阅读环境的搭建</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 源码笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 源码学习 03：创建 IoC 容器的几种方式</title>
      <link href="2020/12/01/source-spring-03.html"/>
      <url>2020/12/01/source-spring-03.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/1cc7GX-1iJNvm.png" alt="创建容器"></p><p>在上一篇文章末尾画了一幅简图，现在从简图这入手，先来看看如何创建容器！</p><h3 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h3><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/GenericGroovyApplicationContext-6dwIrF.png"></p><p>在搭建 <a href="https://mp.weixin.qq.com/s/gDhJMSPSX2vz68p5X3juow">Spring 源码阅读环境</a> 时，最后举了一个例子，其实就是创建容器，并从容器中获取 Bean ，来测试环境是否 OK。</p><p>根据元数据的不同，创建容器的方式也不同，下面参考官方文档，简单介绍下创建容器的几种方式：</p><h4 id="Java-配置获取元数据"><a href="#Java-配置获取元数据" class="headerlink" title="Java 配置获取元数据"></a>Java 配置获取元数据</h4><pre><code class="java">public class AnnotationConfigApplicationTest &#123;    public static void main(String[] args) &#123;        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();        context.register(JavaConfig.class);        context.refresh();        System.out.println(context.getBean(UserComponent.class));    &#125;&#125;</code></pre><h4 id="Xml-获取元数据"><a href="#Xml-获取元数据" class="headerlink" title="Xml 获取元数据"></a>Xml 获取元数据</h4><pre><code class="java">public class XmlConfigApplicationTest &#123;    public static void main(String[] args) &#123;        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;SpringConfig.xml&quot;);        System.out.println(context.getBean(&quot;bookService&quot;));    &#125;&#125;</code></pre><h4 id="Groovy-获取元数据"><a href="#Groovy-获取元数据" class="headerlink" title="Groovy 获取元数据"></a>Groovy 获取元数据</h4><pre><code class="java">public class GroovyConfigApplicationTest &#123;    public static void main(String[] args) &#123;        GenericGroovyApplicationContext context = new GenericGroovyApplicationContext(&quot;SpringConfig.groovy&quot;);        System.out.println(context.getBean(NotesServiceImpl.class));    &#125;&#125;</code></pre><h4 id="GenericApplicationContext"><a href="#GenericApplicationContext" class="headerlink" title="GenericApplicationContext"></a>GenericApplicationContext</h4><p>也可以直接创建 <code>GenericApplicationContext</code> 然后在加载元数据配置文件。</p><pre><code class="java">public class GenericApplicationTest &#123;    public static void main(String[] args) &#123;        GenericApplicationContext context = new GenericApplicationContext();        new XmlBeanDefinitionReader(context).loadBeanDefinitions(&quot;SpringConfig.xml&quot;);        new GroovyBeanDefinitionReader(context).loadBeanDefinitions(&quot;SpringConfig.groovy&quot;);        context.refresh();        System.out.println(context.getBean(&quot;bookService&quot;));        System.out.println(context.getBean(NotesServiceImpl.class));    &#125;&#125;</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/spring03-FyUebg.jpeg"></p><p>本文主要介绍了常用的几种容器的创建，配置文件部分就没有在文章中体现了，如果想了解这部分，可以参考官方文档。</p><h3 id="相关推荐"><a href="#相关推荐" class="headerlink" title="相关推荐"></a>相关推荐</h3><ul><li><a href="https://mp.weixin.qq.com/s/gDhJMSPSX2vz68p5X3juow">Spring 源码学习 01：源码阅读环境的搭建</a></li><li><a href="https://mp.weixin.qq.com/s/YPDPU7ePtii0vlrynexb_w">Spring 源码学习 02：关于 Spring IoC 和 Bean 的概念</a></li><li><a href="https://mp.weixin.qq.com/s/BORxKatt9qs4rDgmAHbv_A">Spring 自调用事务失效，你是怎么解决的？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 源码笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 源码学习 02：关于 Spring IoC 和 Bean 的概念</title>
      <link href="2020/11/30/source-spring-02.html"/>
      <url>2020/11/30/source-spring-02.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在前一篇文章中介绍了如何构建源码阅读环境，既然构建好了源码环境，本地也可以正常运行，那就开始阅读源码吧！</p><p>在阅读源码时，会参考<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#spring-core">官方文档</a>，很多概念在官网都可以得到答案，有兴趣的小伙伴们可以继续阅读，当做复习，写的不足之处，希望多多指导。</p><h3 id="IoC-和-DI"><a href="#IoC-和-DI" class="headerlink" title="IoC 和 DI"></a>IoC 和 DI</h3><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/Cp1dfI-Yg6zuJ.png" alt="IoC 概念"></p><h4 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h4><p>IoC（Inversion of Control），即控制反转。</p><p>之前是在对象内部 new 创建其他对象，然后使用。</p><p>而现在 Spring 中有一个容器可以在创建管理这些对象，并且将对象依赖的其他对象注入到这个对象中，这些对象的创建、销毁都由 Spring 进行管理。</p><p>相比以前来说，不再由自己控制其他对象的生命周期，这个过程就叫做控制反转。而负责统一管理这些类的容器就叫做 IoC 容器。</p><h4 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h4><p><code>IoC is also known as dependency injection (DI).</code> </p><p>是不是感觉奇奇怪怪的，为什么说：<code>IoC 也称为 DI</code>。</p><p>其实 IoC 和 DI 是同一个概念的不同角度描述。</p><p>依赖注入是指组件之间的依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。</p><p>通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。</p><p>Spring 是通过 DI 实现 IoC 的。</p><h3 id="容器和-Bean"><a href="#容器和-Bean" class="headerlink" title="容器和 Bean"></a>容器和 Bean</h3><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/4xZKqx-3YpFD2.png" alt="Spring IoC container and Bean"></p><p><code>Bean 是一个由 Spring IoC 容器实例化，组装和管理的对象。</code></p><p>相信大家都写过或者见过下面的代码：</p><pre><code class="java">/** * 从容器中获取对象 * @author liuzhihang * @date 2020/4/6 19:02 */@Componentpublic class CustomBeanFactory implements ApplicationContextAware &#123;    private static ApplicationContext ctx;    @Override    public void setApplicationContext(ApplicationContext ac) throws BeansException &#123;        ctx = ac;    &#125;    public static Object getBean(String beanName) &#123;        return ctx.getBean(beanName);    &#125;&#125;</code></pre><p>代码逻辑很简单，就是从容器中获取到指定名称的 <code>Bean</code>，而其中 <code>ApplicationContext</code> 接口其实就是 Spring IoC 容器。</p><p>当然 <code>ApplicationContext</code> 是一个接口，它有很多实现，而它也继承了 <code>BeanFactory</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/4PQoiE-WQT8uR.png" alt="BeanFactory or ApplicationContext"></p><p>虽然 <code>BeanFactory</code> 是 IoC 容器的最基本的形式，但是 <code>ApplicationContext</code> 对其进行了很多扩展，并具有 <code>BeanFactory</code> 的所有功能，通常建议优先使用 <code>ApplicationContext</code>。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在通过<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#spring-core">Spring 官网</a> 了解了 IoC 、DI 、容器和 Bean 的概念后，再结合平常的使用基本上可以有个大概流程。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/0hWvfR-K15LRP.png" alt="流程猜想"></p><p>当然，这只是一个很粗略的猜想，是否正确，还有待后面继续阅读源码，然后去验证。</p><h3 id="相关推荐"><a href="#相关推荐" class="headerlink" title="相关推荐"></a>相关推荐</h3><ul><li><a href="https://mp.weixin.qq.com/s/gDhJMSPSX2vz68p5X3juow">Spring 源码学习 01：源码阅读环境的搭建</a></li><li><a href="https://mp.weixin.qq.com/s/BORxKatt9qs4rDgmAHbv_A">Spring 自调用事务失效，你是怎么解决的？</a></li><li><a href="https://mp.weixin.qq.com/s/ZJB-2WWeJFG7RQxaksNBuA">APP 莫名崩溃，开始以为是 Header 中 name 大小写的锅，最后发现原来是容器的错</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 源码笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 源码学习 01：源码阅读环境的搭建</title>
      <link href="2020/11/26/source-spring-build.html"/>
      <url>2020/11/26/source-spring-build.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>前言</strong></p><p>本文记录了 Spring 源码环境的搭建方式，以及踩过的那些坑！​ 当前版本：5.3.2-SNAPSHOT。</p></blockquote><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ol><li>Git</li><li>JDK<ol><li>master 分支需要 JDK 11</li><li>5.2.x 分支， JDK8 即可</li></ol></li><li>Gradle 6.5.1</li><li>IDEA 最新 （2020.2.3）</li></ol><p>Spring 源码仓库地址：<a href="https://github.com/spring-projects/spring-framework">https://github.com/spring-projects/spring-framework</a></p><h3 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h3><ol><li>clone 源码</li></ol><pre><code class="bash">git clone  https://github.com/spring-projects/spring-framework.git</code></pre><ol start="2"><li><p>使用 IDEA 打开</p><ol><li><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/nN2jwC-B9crax.png"></li><li><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/SmFKEX-Rikm9z.png"></li><li>等待 IDEA 加载完成即可。</li></ol></li></ol><p>注： 也可以指定 clone 的分支</p><pre><code class="bash">git clone -b 5.2.x  https://github.com/spring-projects/spring-framework.git</code></pre><p>或者先 fork 到自己的仓库，然后再 clone。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/larIO8-qFY4Fo.png"></p><p>这里我是 fork 到我的仓库，然后再 clone 的。</p><p>当前 master 分支代表的版本为 5.3.2-SNAPSHOT。</p><h3 id="执行测试"><a href="#执行测试" class="headerlink" title="执行测试"></a>执行测试</h3><ul><li>在项目右键创建 <code>module</code></li></ul><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/qkYNup-hSgF5s.png"></p><ul><li>选择 <code>Gradle</code> <code>Java</code></li></ul><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/v9YDiM-0D64W2.png"></p><ul><li>创建 module</li></ul><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/iYepMg-WRomfs.png"></p><ul><li>在 build.gradle 中添加配置</li></ul><pre><code class="text">compile(project(&quot;:spring-context&quot;))</code></pre><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/SUhEs6-2JKywY.png"></p><ul><li>创建测试类并测试</li></ul><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/O55vLL-XSueLY.png"></p><p>其中 <code>UserComponent</code> 添加了 <code>@Component</code> 注解， 程序正常执行则一切 OK。可以开始愉快的调试代码了。</p><h3 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h3><h4 id="编译失败"><a href="#编译失败" class="headerlink" title="编译失败"></a>编译失败</h4><p>有小伙伴直接下载 zip 包，可能遇到以下问题：(非常不建议直接下载 zip 包构建，想知道原因可以继续看，最后我也没有构建成功，而是直接通过 clone 构建的。)</p><ol><li>报错如下：</li></ol><pre><code class="text">fatal: not a git repository (or any of the parent directories): .gitBUILD SUCCESSFUL in 14sBuild scan background action failed.org.gradle.process.internal.ExecException: Process &#39;command &#39;git&#39;&#39; finished with non-zero exit value 128        ... 其他省略</code></pre><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/4mqrY9-o9NJO6.png"></p><p>看意思是没有 git 配置，那就添加上吧！</p><ol start="2"><li>这时候想着添加 git</li></ol><p><code>VCS</code> -&gt; <code>Enable Version Control Integration...</code> -&gt; 右上角 <code>Reload All Gradle Projects</code></p><p>依然报错</p><pre><code class="text">fatal: Needed a single revision</code></pre><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/zLWbqb-rkJFw4.png"></p><ol start="3"><li>查询问题</li></ol><p>issues 地址：<a href="https://github.com/spring-projects/spring-framework/issues/24467">https://github.com/spring-projects/spring-framework/issues/24467</a></p><p>建议使用</p><pre><code class="bash">$ git clone git@github.com:spring-projects/spring-framework.git</code></pre><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/siVXre-hle4kw.png"></p><p>意思就是 zip 发行版主要是用来共享源代码，但不一定用于构建它。</p><ol start="4"><li>最后我选择了使用 clone 的方式，直接 clone 下来，然后 build 通过。</li></ol><h4 id="缺少-cglib-和-objenesis-包"><a href="#缺少-cglib-和-objenesis-包" class="headerlink" title="缺少 cglib 和 objenesis 包"></a>缺少 cglib 和 objenesis 包</h4><pre><code class="text">Kotlin: warnings found and -Weeror specified</code></pre><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/Xnip-2020-11-24-06-DhRwoS.png"></p><p>没有 <code>spring-cglib-repack</code> 和 <code>spring-objenesis-repack</code> 包</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/2fNVjI-71xWmS.png"></p><p>执行这两个即可。</p><h4 id="找不到包-jdk-jfr"><a href="#找不到包-jdk-jfr" class="headerlink" title="找不到包 jdk.jfr"></a>找不到包 jdk.jfr</h4><pre><code class="java">import jdk.jfr.Category;import jdk.jfr.Description;import jdk.jfr.Event;import jdk.jfr.Label;</code></pre><p>JDK 升级为 11。因为我本地使用的是 JDK8，发现报错，jfr 包需要升级 JDK 11 才有。</p><p>如果不生效，可以通过：</p><p>IDEA -&gt; <code>File</code> -&gt; <code>Project Structure</code> -&gt; <code>Project</code> 检查下是否修改为 JDK 11</p><p>快捷键：<code>⌘ + ;</code></p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/ost9dI-pTohuz.png"></p><h4 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h4><ol><li>Spring 仓库：<a href="https://github.com/spring-projects/spring-framework">https://github.com/spring-projects/spring-framework</a></li><li>Spring 构建文档：<a href="https://github.com/spring-projects/spring-framework/wiki/Build-from-Source">https://github.com/spring-projects/spring-framework/wiki/Build-from-Source</a></li></ol><h4 id="历史文章"><a href="#历史文章" class="headerlink" title="历史文章"></a>历史文章</h4><ul><li><a href="https://mp.weixin.qq.com/s/_z4KaFip3qz2fynviMYiRQ">ReentrantLock 源码、画图一起看一看！</a></li><li><a href="https://mp.weixin.qq.com/s/yIzAe3kb0HCphzm1Evv-Tw">ReentrantReadWriteLock 的原理！</a></li><li><a href="https://mp.weixin.qq.com/s/BORxKatt9qs4rDgmAHbv_A">Spring 自调用事务失效，你是怎么解决的？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 源码笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【工具册】- DocView 现在支持自定义 Markdown 模版了！</title>
      <link href="2020/11/23/doc-view-template.html"/>
      <url>2020/11/23/doc-view-template.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>前言</strong></p><p>有小伙伴反馈说希望可以自定义 Markdown 模版，这样就可以导出自己想要的样式了！这个功能可以有，毕竟大家不可能都生成一模一样的文档。现在来一起看看如何实现自定义模版吧！</p></blockquote><h4 id="设置模版"><a href="#设置模版" class="headerlink" title="设置模版"></a>设置模版</h4><p><code>Settings</code> -&gt; <code>Other Settings</code> -&gt; <code>Doc View</code> -&gt; <code>Markdown Template</code></p><p>打开之后内容如下：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/Xnip-2020-11-23-59-asNWSp.png" alt="Xnip-2020-11-23-59-asNWSp"></p><p>模版这里分两个 <code>Tab</code> 分别是 <code>Spring</code> 、 <code>Dubbo</code> 。</p><p>这两个模版内容就稍微有些区别，如果自定义模版，直接修改保存即可。</p><h4 id="模版变量"><a href="#模版变量" class="headerlink" title="模版变量"></a>模版变量</h4><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/d3VlSJ-Hxz8Tj.png"></p><p>关于模版变量，这里使用的是 <code>velocity</code> 将变量替换为文本，如果有其他方式，或者说是 <code>IDEA</code> 用的那种方式，希望可以告诉我。最好可以提供源码。 </p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>非常感谢 <a href="https://github.com/lvgocc">lvgo</a> 小伙伴的参与。</p><p>如果小伙伴们在使用过程中发现一些 bug 或者有好的意见建议，可以在 GitHub 提交 Issues 留言指出来。</p><p>Doc View GitHub：<a href="https://github.com/liuzhihang/doc-view">https://github.com/liuzhihang/doc-view</a></p><p>最后，记得要 <code>一键三连</code>， 来个 <code>【分享、点赞、在看】</code>！</p><h4 id="推荐文章"><a href="#推荐文章" class="headerlink" title="推荐文章"></a>推荐文章</h4><ul><li><a href="https://mp.weixin.qq.com/s/rOTm9Kv02xLZZVFzQXf7IA">Dubbo 生成文档，导出 Markdown，这些功能 DocView 现在都有了！</a></li><li><a href="https://mp.weixin.qq.com/s/VgOHLQ_f4E8UlV9sQhyFpQ">头大！写文档太麻烦了！快来试试这款 IDEA 插件啊！爽到飞起~</a></li><li><a href="https://mp.weixin.qq.com/s/G8h5lg-d8SHZ2_ILBE04sQ">小伙伴想写个 IDEA 插件么？这些 API 了解一下！</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具册 </category>
          
          <category> Doc View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具册 </tag>
            
            <tag> Doc View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【工具册】- Dubbo 接口，导出 Markdown ，这些功能 DocView 现在都有了！</title>
      <link href="2020/11/19/doc-view-dubbo.html"/>
      <url>2020/11/19/doc-view-dubbo.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>前言</strong></p><br><p>自从 DocView 发布了简陋的第一版之后，就不断地有小伙伴提建议意见等等，希望扩展各种功能。这不，时隔两周，DocView 又发布了新版本，本次的更新主要涉及到支持 Dubbo，以及支持导出单个文档为 Markdown 文件。来一起看看新功能吧！</p></blockquote><h4 id="支持导出-Markdown-文件"><a href="#支持导出-Markdown-文件" class="headerlink" title="支持导出 Markdown 文件"></a>支持导出 Markdown 文件</h4><p>DocView 原版本已经支持复制到剪贴板的功能。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/uRAtpo-AJ2kyV.png" alt="原版本"></p><p>而在新版本中增加了 <code>Export</code> 按钮，可以将单个文档导出为 Markdown 文件。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/KLmzHE-Sxlxc6.png" alt="新版本"></p><p>来一张动图，大家看看效果：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/1111-l7NaTW.gif" alt="1111-l7NaTW"></p><p>导出的 Markdown 文本内容如下：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/DJCp6X-saP6nE.png" alt="DJCp6X-saP6nE"></p><h4 id="支持-Dubbo-接口"><a href="#支持-Dubbo-接口" class="headerlink" title="支持 Dubbo 接口"></a>支持 Dubbo 接口</h4><p>之前的版本是不支持 Dubbo 接口的，而现在的版本可以在 Dubbo 接口里面使用。</p><p>当然这里并没有校验接口是否为 Dubbo 接口，只是校验了下是否为接口。所以说即使其他接口也是可以生成的。</p><p><strong>这块还是需要完善的!</strong></p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/S8M4fB-3ecWbP.png" alt="S8M4fB-3ecWbP"></p><h4 id="DocView-文档地址"><a href="#DocView-文档地址" class="headerlink" title="DocView 文档地址"></a>DocView 文档地址</h4><p>在面板左下角的 <code>help</code> 按钮修改了跳转地址为：<a href="http://docview.liuzhihang.com/">http://docview.liuzhihang.com/</a></p><p>只是粗略搭建了一个 DocView 的说明文档网站，小伙伴们可以发现这个网站连 logo 都没有。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/IQNatL-uWWCqO.png" alt="IQNatL-uWWCqO"></p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>当然也有一些其他的小改动，比如设置页面（依然不支持自定义设置）。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/MJjOX4-pRQhfK.png" alt="MJjOX4-pRQhfK"></p><p>DocView 虽然支持了一部分功能，但是距离小伙伴们期望中的文档插件还有很多很多需要迭代的功能。</p><p>比如：</p><ul><li>批量生成（当前仅支持单个类或者方法）</li><li>批量导出</li><li>面板支持查看 Markdown 源文本</li><li>支持从 Swagger 注解获取字段相关信息</li><li>支持 Setting 设置</li><li>支持自定义模版</li><li>支持上传的 YApi</li><li>支持导出其他类型</li><li>…</li></ul><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/cx5PxU-gVxBmM.jpg" alt="cx5PxU-gVxBmM"></p><p>嗯~ 可能大概也许应该会需要迭代很久……</p><p>也确实是个人能力和精力有限，如果小伙伴们有兴趣，可以提交 PR。</p><p>当然如果小伙伴们发现一些 bug 或者有好的意见建议，也可以留言指出来。</p><p>留言推荐大家在 GitHub 提 Issues。</p><p>最后如果小伙伴们觉得插件不错，可以推荐给周围的朋友同事，也记得 <code>一键三连</code>， 来个 <code>【分享、点赞、再看】</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 工具册 </category>
          
          <category> Doc View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具册 </tag>
            
            <tag> Doc View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Warning: Calling `brew list` to only list formulae is deprecated! Use `brew list --formula` instead.</title>
      <link href="2020/11/15/brew-list-warning.html"/>
      <url>2020/11/15/brew-list-warning.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>最近终端总是弹出这么一句话，咱也不懂怎么解决。</p><p>Google baidu 也查不到问题。</p><p>小伙伴帮忙看一下。</p><p>每次新打开终端都会有这个 Warning 。</p><pre><code>Warning: Calling `brew list` to only list formulae is deprecated! Use `brew list --formula` instead.</code></pre><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/5eDhZb-ptj6gr.png" alt="5eDhZb-ptj6gr"></p><p>最后被逼无奈，在 V 站 发帖求助小伙伴， 结果还真找到了答案</p><h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/HvJSlT-Q0oUVr.png" alt="HvJSlT-Q0oUVr"></p><p>最后找到问题所在，是因为按照网上的教程安装的 <code>Coreutils</code></p><p><code>~/.zshrc </code>里改一下即可。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/hAFz8B-HWsVNg.png" alt="hAFz8B-HWsVNg"></p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>写到这里，很多小伙伴应该已经知道问题所在了，可能有的小伙伴还不知道怎么解决：</p><ol><li><code>vim ~/.zshrc</code></li><li>找到使用 <code>brew list</code> 的地方</li><li>将 <code>brew list</code> 改为 <code>brew list --formula</code></li></ol><p>如果还不知道怎么弄，那可以用编辑工具打开<code> .zshrc</code> 文件，然后搜索找到 <code>brew list</code> ，然后替换。</p>]]></content>
      
      
      <categories>
          
          <category> issue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> issue </tag>
            
            <tag> mac </tag>
            
            <tag> brew </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【工作笔记】- Spring 自调用事务失效，你是怎么解决的？</title>
      <link href="2020/11/08/spring-self-call.html"/>
      <url>2020/11/08/spring-self-call.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>前言</strong></p><br><p>相信大家都遇到一种事务失效场景，那就是 Spring 自调用，就是在 Service 方法内，调用另一个加 <code>@Transactional</code> 注解的方法，发现事务失效，这时候你是怎么解决的呢？</p></blockquote><h3 id="事情回顾"><a href="#事情回顾" class="headerlink" title="事情回顾"></a>事情回顾</h3><p>那是一个我忘了天气咋样的下午，突然蹦出一个小红点，嗯~ 挺着急的小红点。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/3E8q0W-3Cg65u.png" alt="3E8q0W-3Cg65u"></p><p>原来是事务失效了！</p><p>莫慌！莫慌！</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/kRoqUW-MKbcBj.png" alt="kRoqUW-MKbcBj"></p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/KVdtlZ-F3jW3p.png" alt="KVdtlZ-F3jW3p"></p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/T4poZK-qyiLEV.png" alt="T4poZK-qyiLEV"></p><p>最后小伙伴选择了抽走，是我的工具类不香了么？</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/zVf6LC-tLzseS.png" alt="zVf6LC-tLzseS"></p><p>当然故事的结果是完美的，问题解决了。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/v3W8tg-VJEgZS.jpg" alt="v3W8tg-VJEgZS"></p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>在开发中涉及到同时操作多个表的时候，要保证两个操作要么一起成功，要么一起失败，这时候就需要用到事务。</p><p>现在一般使用的都是基于 <code>@Transactional</code> 注解的<strong>声明式事务</strong>。</p><p>而事务使用过程中有以下几个注意事项：</p><ol><li>事务只能应用到 public 方法上才会有效；</li><li>事务需要从外部调用，Spring 自调用会失效；</li><li>建议事务注解 @Transactional 一般添加在实现类上。</li></ol><p>当然这几句话不是说我的，人家官方文档可是明确说明的！</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/IlNXVn-uemNYF.png" alt="IlNXVn-uemNYF"></p><p>这里可是说明了<code>应仅将 @Transactional 注解应用于具有公开可见性的方法。如果对受 protected, private o或 package-visible 修饰的方法使用，则不会引发任何错误，但是被注解的方法不会显示已配置的事务设置。</code></p><p>说白了，就是你用了，不会报错，但是不生效！</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/M5XTck-YnrPiu.png" alt="M5XTck-YnrPiu"></p><p>至于建议加在实现类上，这个只是建议，不过如果加在接口类或接口方法上时，只有配置基于接口的代理才会生效。所以这块还是老老实实的<code>加在实现类或实现类方法上</code>吧。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/P28Ciu-4YvetS.png" alt="P28Ciu-4YvetS"></p><p>因为代理模式只拦截通过代理传入的外部方法调用，所以自调用事务是不生效的。</p><p>官方的解释还是比较简单明了的，虽然我看不懂，但是不影响我截图。</p><p>那我还是再截一个吧……</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/sBkeIz-80K1UE.png" alt="sBkeIz-80K1UE"></p><h3 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h3><p>但是在开发中，小伙伴们往往会遇到这种情况！</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/g1BG6s-BgQfOw.png" alt="g1BG6s-BgQfOw"></p><p>本来<strong>自己写的</strong>代码就一坨坨的又臭又长，里面有各种验签、验参、查询、验证等等，就想着来个事务，让事务包裹的范围最小，仅仅在同时更新的时候加上事务吧！</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/38SYyX-gEXV58.png" alt="38SYyX-gEXV58"></p><p>这么写，咦~ IDEA 报错了，好像不能 <code>private</code> 修饰，那我改成 <code>public</code>。</p><p>很显然事务是不生效的。</p><p>把更新的代码放到<code>又臭又长</code>的代码里面，让它变得更臭更长，然后用 <code>@Transactional</code> 注解一加。完美解决！</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/9r8ioC-W6kSbv.jpg" alt="9r8ioC-W6kSbv"></p><p>请放过那坨代码吧！来看看下面的办法。</p><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案 1"></a>解决方案 1</h4><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/08fPAy-ee1X6A.png" alt="08fPAy-ee1X6A"></p><p>那我改成外部调用不就行了么？</p><p>再声明一个 Service，把更新表的逻辑放过去。</p><p>我一般就喜欢使用这个办法。</p><h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案 2"></a>解决方案 2</h4><p>使用<code>编程式事务</code>，前面说了，使用<code>声明式事务</code>时，又这又那，我换一种总可以吧！</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/yuJKad-LGJuVt.png" alt="yuJKad-LGJuVt"></p><p>你看，我还把方法改成 <code>private</code> 修饰了，事务也生效。完美解决！</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/8orQs4-tgtQts.jpg" alt="8orQs4-tgtQts"></p><p>其实这个方法也很不错哦！</p><h4 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案 3"></a>解决方案 3</h4><p>又想用注解，又想自调用怎么办？</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/MBSeHo-E5RDuC.jpg" alt="MBSeHo-E5RDuC"></p><p>不过… 麻烦一点还是可以的。</p><p>咱们可以参考<code>编程式事务</code>的方式，不就是不让自调用么，我调外部方法，然后外部方法再给我调回来不就可以了。</p><pre><code class="java">@Componentpublic class TransactionalComponent &#123;    public interface Cell &#123;        void run() throws Exception;    &#125;    @Transactional(propagation = Propagation.REQUIRED, rollbackFor = Exception.class)    public void required(Cell cell) throws Exception &#123;        cell.run();    &#125;&#125;</code></pre><p>这样的话不就可以通过 <code>TransactionalComponent</code> 调用了么，并且还可以使用 <code>lambda</code> 表达式。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/y5bnw5-TMtjKN.png" alt="y5bnw5-TMtjKN"></p><p>当然基于这个版本也可以做一个迭代，就是使用静态方法调用，不用每次都用 <code>@Autowired</code> 注入一次。</p><pre><code class="java">public class TransactionalUtils &#123;    private static volatile TransactionalComponent transactionalComponent;    private static synchronized TransactionalComponent getTransactionalComponent() &#123;        if (transactionalComponent == null) &#123;            // 从容器中获取 transactionalComponent            transactionalComponent = ApplicationContextUtils.getBean(TransactionalComponent.class);        &#125;        return transactionalComponent;    &#125;    public static void required(TransactionalComponent.Cell cell) throws Exception &#123;        getTransactionalComponent().required(cell);    &#125;&#125;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/awzH4i-JjJNp4.png" alt="awzH4i-JjJNp4"></p><p>这样通过工具类 <code>TransactionalUtils</code> 便可以直接调用静态方法的方式执行事务操作。</p><h4 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案 4"></a>解决方案 4</h4><blockquote><p>这是一个补充方案：</p></blockquote><p>其实小伙伴完全可以注入自己。 比如 自己是 ServiceA</p><p>然后再代码中声明一个 </p><pre><code class="java">@Autowiredprivate ServiceA serviceA</code></pre><p>这样再用 serviceA，调用自己的其他事务方法就可以开启事务了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h4><p>本文主要介绍为什么会遇到事务失效，以及事务失效的避免方式，同时提供了三种方式来解决自调用事务失效的问题。不足之处，欢迎指正。</p><h4 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h4><ol><li>Spring 文档：<a href="https://docs.spring.io/spring-framework/docs/5.3.0/reference/html/data-access.html#transaction-declarative-annotations">https://docs.spring.io/spring-framework/docs/5.3.0/reference/html/data-access.html#transaction-declarative-annotations</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【工具册】- 写文档太麻烦，试试这款 IDEA 插件吧！</title>
      <link href="2020/11/01/doc-view.html"/>
      <url>2020/11/01/doc-view.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>前言</strong></p><br><p>每次开发完新项目或者新接口功能等，第一件事就是提供接口文档。说到接口文档，当然是用 Markdown 了。各种复制粘贴字段，必填非必填，字段备注，请求返回示例等等。简直是浪费时间哇。所以想到了开发一款插件来解决重复复制文档的问题。下面来看我介绍介绍这款插件。</p><p>PS：插件比较简陋，还需要不断迭代。</p></blockquote><h2 id="为什么开发插件"><a href="#为什么开发插件" class="headerlink" title="为什么开发插件"></a>为什么开发插件</h2><p>每次在对外提供接口时都要写文档，各种麻烦，并且文档耗费了很大一部分时间。也使用了一些文档工具，在线写作工具，最终还是比较喜欢自己手写文档。</p><h3 id="使用过的生成工具"><a href="#使用过的生成工具" class="headerlink" title="使用过的生成工具"></a>使用过的生成工具</h3><ol><li>Swagger ： 添加依赖，配置类及描述信息，然后在方法及实体上添加注解，启动项目便可以通过访问 <code>xxxx/swagger-ui.html</code> 查看接口文档；</li><li>API Doc ：添加配置文件及注释，安装 <code>npm</code> 并通过执行命令生成文档；</li><li>SmartDoc ：添加依赖及注释后执行测试类生成文档；</li><li>API2DOC ：添加依赖，开启注解，通过注解配置生成文档。</li></ol><p>上面四种方法，无疑都需要添加依赖，使用注解等方式，可以说有一定的代码侵入性。</p><h3 id="使用过的接口文档工具"><a href="#使用过的接口文档工具" class="headerlink" title="使用过的接口文档工具"></a>使用过的接口文档工具</h3><ol><li>ShowDoc ：曾经一段时间很喜欢用这个， Markdown 语法，方便直观。不过就是要自己手写；</li><li>YApi ：现在在使用 YApi，可以通过 Swagger 导入；</li><li>VS Code 写 Markdown ：直接离线写 Markdown ，可以导出 PDF、Word、Html。</li></ol><p>自己写文档比较重复，繁琐，不过个人比较喜欢 Markdown 格式。简洁直观。并且配合着我之前写的 IDEA 插件 <code>copy-as-json</code> 和 <code>Tookit</code> 将实体复制为 json 字符串，用来快速生成请求样例和返回样例，还是可以减少一定的工作量的。</p><h3 id="其他使用方式"><a href="#其他使用方式" class="headerlink" title="其他使用方式"></a>其他使用方式</h3><p>使用各种在线协作工具，腾讯文档、语雀、石墨文档。使用离线版本 PDF、Word、Excel 等等。也有一些其他的文档工具，不过自己都没有使用过或者调研过了。</p><p>基本上这些文档工具要么通过代码侵入的方式生成文档，要么自己手撸文档。总体来说各有千秋。</p><h3 id="个人手写更方便"><a href="#个人手写更方便" class="headerlink" title="个人手写更方便"></a>个人手写更方便</h3><p><strong>个人比较喜欢的就是手写 Markdown 。</strong></p><p>下面是两幅图：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/fWC7q0-bt3RuN.png" alt="ShowDoc 官方样例"></p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/Yh68js-evYsQS.png" alt="VS Code 手写文档"></p><p>有时候文档比较多的时候，就写的累了。尤其是最近使用了 <code>YApi</code> ， 个人感觉使用 <code>Swagger</code> 然后导入到 <code>YApi</code> 里面还是挺方便的，省时省力。</p><p>后来就想，既然 <code>YApi</code> 提供接口，那我是不是可以自己生成，然后传到 <code>YApi</code> 中呢？</p><p>所以就开始着手这个插件的开发。</p><h2 id="使用及功能"><a href="#使用及功能" class="headerlink" title="使用及功能"></a>使用及功能</h2><p>既然已经开发好最基础版本了，当然也得介绍下，首先看图：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/B9FzFw-9M24Py.png" alt="Doc View 样例"></p><p>通过图简单介绍下使用以及功能：</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>使用方式很简单，直接在 <code>Controller</code> 类或者 <code>Controller</code> 类的公共非静态方法内右键唤出菜单，单机 <code>Doc View</code> 即可。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/Gq0gn6-XnAfto.png"></p><p>只能在 <code>Controller</code> 类或者 <code>Controller</code> 类的公共非静态方法内使用。至于两者的区别，后续会介绍。</p><p>这里可能会有小伙伴们发出疑问：Dubbo 接口也要写文档，难道不可以么？</p><p>嗯~ 可以！但是现在不支持~</p><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>基本功能就是截图展示的那样。</p><ol><li>左侧显示接口名及列表，右侧展示接口信息；</li><li>点击 <code>Copy 按钮</code> 就会将展示的信息原本对应的 Markdown 文本复制到剪贴板；</li><li>在 Class 内部点击，生成的如图所示的列表，而在方法内右键生成的是只有本方法的。</li></ol><h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><p>Dubbo 接口，当前版本不支持，所以下面介绍的全都是在 Class 上的使用：</p><h4 id="要生成文档，需要满足什么条件？"><a href="#要生成文档，需要满足什么条件？" class="headerlink" title="要生成文档，需要满足什么条件？"></a>要生成文档，需要满足什么条件？</h4><ol><li>目标类内部有方法；</li><li>类必须有相关 <code>Spring</code> 注解。<ol><li><code>org.springframework.stereotype.Controller</code> </li><li><code>org.springframework.web.bind.annotation.RestController</code></li></ol></li></ol><h4 id="生成文档，接口方法需要满足什么条件？"><a href="#生成文档，接口方法需要满足什么条件？" class="headerlink" title="生成文档，接口方法需要满足什么条件？"></a>生成文档，接口方法需要满足什么条件？</h4><p>文档的方法：<code>Public</code> 修饰且非静态方法（<code>static</code> 修饰），方法上包含以下注解：</p><ol><li><code>org.springframework.web.bind.annotation.GetMapping</code></li><li><code>org.springframework.web.bind.annotation.PostMapping</code></li><li><code>org.springframework.web.bind.annotation.GetMapping</code></li><li><code>org.springframework.web.bind.annotation.DeleteMapping</code></li><li><code>org.springframework.web.bind.annotation.PatchMapping</code></li><li><code>org.springframework.web.bind.annotation.RequestMapping</code></li></ol><h4 id="文档模版是否可以设置？"><a href="#文档模版是否可以设置？" class="headerlink" title="文档模版是否可以设置？"></a>文档模版是否可以设置？</h4><p>当前版本文档模版只有展示的这个，不支持自定义模版。</p><h4 id="接口名称是如何设置的？"><a href="#接口名称是如何设置的？" class="headerlink" title="接口名称是如何设置的？"></a>接口名称是如何设置的？</h4><ol><li><p>接口名称默认取值如图截图所示 <code>类名#方法名</code>；</p><p> <img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/7LRtm9-LzXotO.png" alt="7LRtm9-LzXotO"></p></li><li><p>支持在注释上使用 <code>@name</code> 设置接口名。</p><p> <img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/zdw5TG-QtZFyB.png" alt="zdw5TG-QtZFyB"></p></li></ol><h4 id="接口描述是从哪里获取的？"><a href="#接口描述是从哪里获取的？" class="headerlink" title="接口描述是从哪里获取的？"></a>接口描述是从哪里获取的？</h4><ol><li><p>接口描述直接取的方法注释；</p></li><li><p>如果有 <code>@description</code> 标签，则会优先使用标签对应的描述。</p><p> <img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/pcZB5V-Tn33bX.png" alt="pcZB5V-Tn33bX"></p></li></ol><h4 id="请求路径是如何生成的？"><a href="#请求路径是如何生成的？" class="headerlink" title="请求路径是如何生成的？"></a>请求路径是如何生成的？</h4><p>取 <code>Class</code> 和  <code>Method</code> 上的 path 进行拼装组成。</p><h4 id="请求方式如何设置？"><a href="#请求方式如何设置？" class="headerlink" title="请求方式如何设置？"></a>请求方式如何设置？</h4><p>根据 <code>Method</code> 上的注解生成。</p><h4 id="请求参数及请求示例的需要设置什么？"><a href="#请求参数及请求示例的需要设置什么？" class="headerlink" title="请求参数及请求示例的需要设置什么？"></a>请求参数及请求示例的需要设置什么？</h4><ol><li><p>根据是否有 <code>@RequestBody</code> 注解，生成请求 Header 是否为 json 还是 form。同时会检测请求参数中是否有 <code>@RequestHeader</code> 注解；</p><p> <img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/pQHnXo-C4oPfT.png" alt="Header"></p></li><li><p>对象生成列表；</p></li><li><p>根据请求是 json 还是 form 生成对应的请求示例。</p></li></ol><h4 id="返回参数及返回示例怎么生成？"><a href="#返回参数及返回示例怎么生成？" class="headerlink" title="返回参数及返回示例怎么生成？"></a>返回参数及返回示例怎么生成？</h4><p>支持对象，返回空，返回带泛型方式。这里的泛型仅支持单个泛型且名称为 <code>T</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/9ML932-RbqIqV.png" alt="返回带泛型"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><p><strong>Q: <code>Doc View</code> 插件去哪里下载？</strong></p><p><strong>A:</strong> </p><ol><li>可以直接通过 IDEA 插件仓库，直接搜索名称即可；</li><li>在 GitHub 通过 Releases 下载；</li><li>关注公众号并发送 <code>Doc View</code> 相关关键字（doc/doc view）获取。</li></ol><p><strong>Q: <code>Doc View</code> 是否开源？</strong></p><p><strong>A:</strong> 是的。开源地址为：<a href="https://github.com/liuzhihang/doc-view">https://github.com/liuzhihang/doc-view</a>，有兴趣的小伙伴，可以给个 Star ，如果想增加一些功能，也可以提 PR。</p><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>插件开发从最开始开发到今天发布第一版，中间经历了很长一段时间，毕竟只是业余时间开发，就断断续续的写，不过现在最简单版本已经可以使用了。</p><p>目前来看，只有一个 <code>Copy</code> 功能，不过基本上可以满足使用。至于其他的需求，比如：自定义模版、支持 Dubbo 接口、预览导出等功能就需要后续不断迭代了。</p><p>个人开发精力有限，小伙伴在使用过程中遇到肯定会遇到 bug，或者是有其他的功能及使用建议，都可以通过以下方式反馈：</p><ol><li>关注公众号：『 刘志航 』 通过读者讨论进行留言；</li><li>在 GitHub 上提 Issues；</li><li>在插件帮助页面留言；</li><li>文章结尾留言；</li></ol><p>最后，感谢小伙伴们的支持。欢迎下载体验，并提出相关建议及意见。</p>]]></content>
      
      
      <categories>
          
          <category> 工具册 </category>
          
          <category> Doc View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具册 </tag>
            
            <tag> Doc View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JDK源码笔记】- 写时复制集合 —— CopyOnWriteArrayList</title>
      <link href="2020/10/31/copyonwritearraylist.html"/>
      <url>2020/10/31/copyonwritearraylist.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>前言</strong></p><br><p>JUC 下面还有一个系列的类，都是 CopyOnWriteXXX ，意思是写时复制，这个究竟是怎么回事？那就以 CopyOnWriteArrayList 为切入点，一起了解写时复制是怎么回事？</p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>ArrayList 的一个线程安全的变体，其中所有可变操作（add、set 等等）都是通过对底层数组进行一次新的复制来实现的。</p><p>像名字一样，每次进行操作的时候，都会进行一次复制，当然会有很大的性能消耗，但是在某些使用场景下，又会提高性能。具体是怎么操作的，那就一步一步阅读源码，然后再做总结归纳。</p><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><pre><code class="java">public class CopyOnWriteArrayListTest &#123;    public static void main(String[] args) &#123;        CopyOnWriteArrayList&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();        // 添加元素        list.add(&quot;liuzhihang&quot;);        // 移除元素        list.remove(&quot;liuzhihang&quot;);        // 查看元素        String value0 = list.get(0);        // 遍历        Iterator&lt;String&gt; iterator = list.iterator();        while (iterator.hasNext()) &#123;            String next = iterator.next();        &#125;    &#125;&#125;</code></pre><h4 id="问题疑问"><a href="#问题疑问" class="headerlink" title="问题疑问"></a>问题疑问</h4><ol><li>为什么要叫写时复制集合？</li><li>CopyOnWriteArrayList 实现原理是什么？</li><li>CopyOnWriteArrayList 和 ArrayList 有什么区别？</li><li>CopyOnWriteArrayList 复制是怎么进行复制的？</li></ol><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/PRT4mY-DDwfkF.png" alt="PRT4mY-DDwfkF"></p><h4 id="参数介绍"><a href="#参数介绍" class="headerlink" title="参数介绍"></a>参数介绍</h4><pre><code class="java">public class CopyOnWriteArrayList&lt;E&gt;    implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123;    private static final long serialVersionUID = 8673264195747942595L;    /** 数据有变动时使用 */    final transient ReentrantLock lock = new ReentrantLock();    /** 数组 只能通过 getArray/setArray 访问 */    private transient volatile Object[] array;    final Object[] getArray() &#123;        return array;    &#125;    // 将数组指向传入的新数组    final void setArray(Object[] a) &#123;        array = a;    &#125;&#125;</code></pre><p>通过参数可以了解到以下内容：</p><ol><li>基于数组实现；</li><li>使用了 ReentrantLock 互斥锁。</li></ol><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><pre><code class="java">public CopyOnWriteArrayList() &#123;    setArray(new Object[0]);&#125;</code></pre><p>在初始化 CopyOnWriteArrayList 时，就是创建了一个 Object 的数组。</p><h4 id="add"><a href="#add" class="headerlink" title="add"></a>add</h4><pre><code class="java">public boolean add(E e) &#123;    // 加锁    final ReentrantLock lock = this.lock;    lock.lock();    try &#123;        // 获取当前数组        Object[] elements = getArray();        int len = elements.length;        // 创建一个新数组，并将原数组数据复制到新数组        Object[] newElements = Arrays.copyOf(elements, len + 1);        // 添加的新元素到数组尾部        newElements[len] = e;        // 将数组指向新数组        setArray(newElements);        return true;    &#125; finally &#123;        lock.unlock();    &#125;&#125;</code></pre><p>add 方法逻辑很简单：</p><ol><li>通过加互斥锁（ReentrantLock）从而保证在写的时候只有一个线程可以写。</li><li>新增元素时，先使用 <code>Arrays.copyOf(elements, len + 1)</code> 复制出一个长度 +1 的新数组。</li><li>添加元素到新数组。</li><li>然后再将原数组对象指向新数组。</li></ol><p>画图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/KCTNMP-kLOtFP.png" alt="KCTNMP-kLOtFP"></p><h4 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h4><pre><code class="java">public E remove(int index) &#123;    // 加锁    final ReentrantLock lock = this.lock;    lock.lock();    try &#123;        // 原数组        Object[] elements = getArray();        int len = elements.length;        // 移除的值        E oldValue = get(elements, index);        int numMoved = len - index - 1;        if (numMoved == 0)            // 如果移除最后一个元素            // 直接复制前面的元素即可            setArray(Arrays.copyOf(elements, len - 1));        else &#123;            // 移除中间的元素，进行两次复制            Object[] newElements = new Object[len - 1];            System.arraycopy(elements, 0, newElements, 0, index);            System.arraycopy(elements, index + 1, newElements, index,                                numMoved);            setArray(newElements);        &#125;        return oldValue;    &#125; finally &#123;        lock.unlock();    &#125;&#125;</code></pre><p>remove 方法相对多了一些判断：</p><ol><li>通过加互斥锁（ReentrantLock）从而保证在写的时候只有一个线程可以移除元素。</li><li>如果移除的是最后一个元素，则直接复制前面的元素到新数组，并指向新数组即可。</li><li>如果移除的是中间的元素，则需要进行两次复制，然后指向新数组。</li></ol><p>画图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/q3iE0c-AGgXfP.png" alt="q3iE0c-AGgXfP"></p><h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><pre><code class="java">public E get(int index) &#123;    return get(getArray(), index);&#125;</code></pre><p>get 方法可以看出：</p><ol><li>获取元素并没有进行加锁。</li><li>从原数组获取的元素。</li></ol><p>所以并发情况下，并不能保证很及时的读取的刚插入或者移除的元素。</p><h4 id="数组复制"><a href="#数组复制" class="headerlink" title="数组复制"></a>数组复制</h4><p>通过阅读 add 和 remove 相关代码，可以看到在数组复制时使用了 <code>Arrays.copyOf</code> 和 <code>System.arraycopy</code>，这相当于一个优化方面吧。</p><p>毕竟数组复制总不能把原数组遍历一遍，挨着赋值到新数组里面吧。</p><p>那接下来看一下内部是如何实现的：</p><pre><code class="java">public class Arrays &#123;    // 其他方法省略 ...    /**     * original 要复制的数组     * newLength 新数组的长度     */    public static &lt;T&gt; T[] copyOf(T[] original, int newLength) &#123;        return (T[]) copyOf(original, newLength, original.getClass());    &#125;    /**     * original 要复制的数组     * newLength 新数组的长度     */    public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123;        // 创建一个新数组，长度是指定的长度        @SuppressWarnings(&quot;unchecked&quot;)        T[] copy = ((Object)newType == (Object)Object[].class)            ? (T[]) new Object[newLength]            // 创建具有指定的组件类型和长度的新数组            : (T[]) Array.newInstance(newType.getComponentType(), newLength);        // 调用 System.arraycopy 复制数组        System.arraycopy(original, 0, copy, 0,                         Math.min(original.length, newLength));        return copy;    &#125;&#125;</code></pre><p>通过阅读 <code>Arrays.copyOf</code> 相关源码，发现其实 <code>Arrays.copyOf</code> 底层也是调用的 <code>System.arraycopy</code></p><pre><code class="java">public final class System &#123;    // 其他方法省略 ...    /**     * src 源数组     * srcPos 源数组起始位置     * dest 目标数组     * destPos 目标数组的起始位置     * length 要复制的元素数量     */    public static native void arraycopy(Object src,  int  srcPos,                                        Object dest, int destPos,                                        int length);&#125;</code></pre><p>可以看到 <code>System.arraycopy</code> 是一个 <code>native</code> 方法，这个是 JVM 内部实现的，具体可以阅读相关资料。而使用这种方式要比 <code>for</code> 循环和 <code>clone</code> 要高效很多。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h4><p><strong>Q: 为什么要叫写时复制集合？</strong></p><p><strong>A:</strong> 因为在 add、remove 操作时会复制出来一个新数组。</p><p><strong>Q: CopyOnWriteArrayList 实现原理是什么？</strong></p><p><strong>A:</strong> 在 add、remove 操作时会进行加锁，然后复制出来一个新数组，操作的都是新数组，而此时原数组是可以提供查询的。当操作结束之后，会将对象指针指向新数组。</p><p><strong>Q: CopyOnWriteArrayList 和 ArrayList 有什么区别？</strong></p><p><strong>A:</strong> CopyOnWriteArrayList 在读多写少的场景下可以提高效率，而 ArrayList 只是普通数组集合，并不适用于并发场景，而如果对 ArrayList 加锁，则会影响一部分性能。</p><p>同样对 CopyOnWriteArrayList 而言，仅能保证最终一致性。因为刚写入的数据，是写到的复制的数组中，此时并不能立即查询到。如果要保证实时性可以尝试使用 <code>Collections.synchronizedList</code> 或者加锁等方式。</p><p><strong>Q: CopyOnWriteArrayList 复制是怎么进行复制的？</strong></p><p><strong>A:</strong> 内部使用的是本地方法 <code>System.arraycopy</code> 进行数组的复制。</p><h4 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h4><p>通过阅读 CopyOnWriteArrayList 源码，了解到写时复制是的原理。同时了解到可以使用 <code>System.arraycopy</code> 的方式提高数组复制的效率。</p><p>同样 CopyOnWriteArrayList 适合读多写少的场景，满足最终一致性，但是并不能保证数据修改及时查询到。</p>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码笔记 </tag>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JDK源码笔记】- 非阻塞的无界线程安全队列 —— ConcurrentLinkedQueue</title>
      <link href="2020/10/25/source-code-concurrentlinkedqueue.html"/>
      <url>2020/10/25/source-code-concurrentlinkedqueue.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>前言</strong></p><br><p>JUC 下面的相关源码继续往下阅读，这就看到了非阻塞的无界线程安全队列 —— ConcurrentLinkedQueue，来一起看看吧。</p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>基于链接节点的无界线程安全队列，对元素FIFO（先进先出）进行排序。 队列的头部是队列中最长时间的元素，队列的尾部是队列中最短时间的元素。 在队列的尾部插入新元素，队列检索操作获取队列头部的元素。</p><p>当许多线程共享对公共集合的访问 ConcurrentLinkedQueue 是一个合适的选择。 与大多数其他并发集合实现一样，此类不允许使用null元素。</p><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><pre><code class="java">public class ConcurrentLinkedQueueTest &#123;    public static void main(String[] args) &#123;        ConcurrentLinkedQueue&lt;String&gt; queue = new ConcurrentLinkedQueue&lt;String&gt;();        // 将指定元素插入此队列的尾部。        queue.add(&quot;liuzhihang&quot;);        // 将指定元素插入此队列的尾部。        queue.offer(&quot;liuzhihang&quot;);        // 获取但不移除此队列的头，队列为空返回 null。        queue.peek();        // 获取并移除此队列的头，此队列为空返回 null。        queue.poll();    &#125;&#125;</code></pre><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/LNKjGH-iwlqrt.png" alt="LNKjGH-iwlqrt"></p><h4 id="参数介绍"><a href="#参数介绍" class="headerlink" title="参数介绍"></a>参数介绍</h4><pre><code class="java">private static class Node&lt;E&gt; &#123;    // 节点中的元素    volatile E item;    // 下一个节点    volatile Node&lt;E&gt; next;    Node(E item) &#123;        UNSAFE.putObject(this, itemOffset, item);    &#125;    // CAS 的方式设置节点元素    boolean casItem(E cmp, E val) &#123;        return UNSAFE.compareAndSwapObject(this, itemOffset, cmp, val);    &#125;    // 设置下一个节点    void lazySetNext(Node&lt;E&gt; val) &#123;        UNSAFE.putOrderedObject(this, nextOffset, val);    &#125;    // CAS 的方式设置下一个节点    boolean casNext(Node&lt;E&gt; cmp, Node&lt;E&gt; val) &#123;        return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val);    &#125;    // 省略 ……&#125;</code></pre><p>在 ConcurrentLinkedQueue 内部含有一个内部类 Node，如上所示，这个内部类用来标识链表中的一个节点，通过代码可以看出，在 ConcurrentLinkedQueue 中的链表为<code>单向链表</code>。</p><pre><code class="java">public class ConcurrentLinkedQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;        implements Queue&lt;E&gt;, java.io.Serializable &#123;    // 其他省略    // 头结点    private transient volatile Node&lt;E&gt; head;          // 尾节点    private transient volatile Node&lt;E&gt; tail;&#125;</code></pre><p>头尾节点使用 <code>volatile</code> 修饰，保证内存可见性。</p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><pre><code class="java">public ConcurrentLinkedQueue() &#123;    head = tail = new Node&lt;E&gt;(null);&#125;</code></pre><p>当创建对象时，头尾节点都是指向一个空节点。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/ZzpJTa-lOE9g4.png" alt="ZzpJTa-lOE9g4"></p><h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><pre><code class="java">public boolean add(E e) &#123;    return offer(e);&#125;public boolean offer(E e) &#123;    // 验证是否为空    checkNotNull(e);    // 创建节点    final Node&lt;E&gt; newNode = new Node&lt;E&gt;(e);    // 循环入队列    // t 是当前尾节点，p 初始为 t    for (Node&lt;E&gt; t = tail, p = t;;) &#123;        // q 为尾节点的下一个节点        Node&lt;E&gt; q = p.next;        if (q == null) &#123;            // 为空，说明后面没有节点，则 CAS 设置尾节点            if (p.casNext(null, newNode)) &#123;                // 此时 p.next 是 newNode                // 如果 p ！= t 说明有并发                if (p != t)                     // 其他线程已经更新了 tail                    // q = p.next 所以 q == null 不正确了                    // q 取到了 t.next                    // 此时将 tail 更新为 新节点                    casTail(t, newNode);  // Failure is OK.                return true;            &#125;            // Lost CAS race to another thread; re-read next        &#125;        // 多线程情况下， poll ，操作移除元素，可能会导致 p == q         // 此时要重新查找        else if (p == q)            //             p = (t != (t = tail)) ? t : head;        else            // 检查 tail 并更新            p = (p != t &amp;&amp; t != (t = tail)) ? t : q;    &#125;&#125;</code></pre><p>画图说明：</p><ul><li>单线程情况下：</li></ul><ol><li>当执行到 <code>Node&lt;E&gt; q = p.next;</code> 时，当前情况如图所示：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/QJ5fjB-QtmN7F.png" alt="QJ5fjB-QtmN7F"></p><ol start="2"><li>判断 <code>q == null</code>，满足条件，此时便会执行 <code>p.casNext(null, newNode)</code> 使用 CAS 设置 p.next。</li><li>设置成功之后，<code>p == t</code> 没有变动，所以程序退出。</li></ol><ul><li>多线程情况下：</li></ul><ol><li>当执行到 <code>Node&lt;E&gt; q = p.next;</code> 时，当前情况如图所示：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/QJ5fjB-QtmN7F.png" alt="QJ5fjB-QtmN7F"></p><ol start="2"><li>多个线程执行 <code>p.casNext(null, newNode)</code> 使用 CAS 设置 p.next。</li><li>A 线程 CAS 设置成功：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/u4O6mX-yQeaI6.png" alt="u4O6mX-yQeaI6"></p><ol start="4"><li>B 线程 CAS 执行失败， 重新循环，会执行到 <code>p = (p != t &amp;&amp; t != (t = tail)) ? t : q</code>。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/vkP5tp-jaUZOc.png" alt="vkP5tp-jaUZOc"></p><ol start="5"><li>再次循环就可以成功设置上了。</li></ol><h4 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h4><pre><code class="java">public E poll() &#123;    restartFromHead:    // 无限循环    for (;;) &#123;        for (Node&lt;E&gt; h = head, p = h, q;;) &#123;            // 头结点的 iterm            E item = p.item;            // 当前节点如果不为 null CAS 设置为 null            if (item != null &amp;&amp; p.casItem(item, null)) &#123;                // CAS 成功 则标记移除                if (p != h) // hop two nodes at a time                    updateHead(h, ((q = p.next) != null) ? q : p);                return item;            &#125;            // 当前队列未空 返回 null            else if ((q = p.next) == null) &#123;                updateHead(h, p);                return null;            &#125;            // 自引用了， 重新进行循环            else if (p == q)                continue restartFromHead;            else                p = q;        &#125;    &#125;&#125;</code></pre><p>画图过程如下：</p><ol><li>在执行内层循环时，如果队列为空：<code>E item = p.item;</code> 此时，iterm 为 null，会 <code>updateHead(h, p)</code> 并返回 null。</li><li>假设同时有并发插入操作，添加了一个元素，此时如图所示：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/zGeE4p-Udb3x0.png" alt="zGeE4p-Udb3x0"></p><p>这时会执行最后的 else 将 <code>p = q</code></p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/KkcsgS-8RvW4W.png" alt="KkcsgS-8RvW4W"></p><ol start="3"><li>继续循环获取 item，并执行 <code>p.casItem(item, null)</code> ， 然后判断 <code>p != h</code>，更新 head 并返回 item。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/mBNd6o-RS2hU0.png" alt="mBNd6o-RS2hU0"></p><p>这里的情况比较复杂，这里只是列举一种，如果需要可以自己多列举几种。</p><p>而查看元素的代码和获取元素代码类似就不多介绍了。</p><h4 id="size-操作"><a href="#size-操作" class="headerlink" title="size 操作"></a>size 操作</h4><pre><code class="java">public int size() &#123;    int count = 0;    for (Node&lt;E&gt; p = first(); p != null; p = succ(p))        if (p.item != null)            // Collection.size() spec says to max out            if (++count == Integer.MAX_VALUE)                break;    return count;&#125;</code></pre><p>CAS 没有加锁，所以 size 是不准确的。并且 size 会遍历一遍列表，比较耗费性能。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>ConcurrentLinkedQueue 在工作中使用的相对较少，所以阅读相关源码的时候也只是大概看了一下，了解常用 API，以及底层原理。</p><p>简单总结就是使用<strong>单向链表</strong>来保存队列元素，内部使用非阻塞的 CAS 算法，没有加锁。所以计算 size 时可能不准确，同样 size 会遍历链表，所以并不建议使用。</p>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码笔记 </tag>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【工作笔记】- APP 莫名崩溃，开始以为是 Header 中 name 大小写的锅，最后发现原来是容器的错！</title>
      <link href="2020/10/19/header-name-case.html"/>
      <url>2020/10/19/header-name-case.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>前言</strong></p><br><p>部署测试，部署预发布，一切测试就绪，上生产。</p><p>发布生产</p><p>闪退</p><p>What？？？</p><p>马上回滚</p><p>开始排查</p><p>后端一模一样的代码，不是 APP 端的问题吧。可 APP 端没有发版啊。</p><p>…… 一番排查</p><p>原来是 APP 端打包，测试和预发布包 Header 传的都是 <code>Authorization</code> ，生产传的是 <code>authorization</code> 。就是大小写问题，那赶紧改。</p></blockquote><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>首页接口只有登录才可以进入，因为首页要展示获取用户账户的一些信息。这里使用的是统一拦截，从 Header 中获取 token 后，使用 token 获取用户信息。</p><p>而现在要改为用户未登录也可以查看首页信息中的宣传文案等等，只不过账户信息不显示。</p><h4 id="原流程"><a href="#原流程" class="headerlink" title="原流程"></a>原流程</h4><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/FiwOie-8ZLjgv.png" alt="FiwOie-8ZLjgv"></p><p>整个过程代码在 <a href="https://mp.weixin.qq.com/s/8qY94y3w0Q2RRhkG7iUfOg">ThreadLocal底层原理</a> 里面有所介绍。这里省略一部分代码。</p><pre><code class="java">@Componentpublic class TokenInterceptor implements HandlerInterceptor &#123;    @Override    public void afterCompletion(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception arg3)            throws Exception &#123;        LocalUserUtils.remove();    &#125;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        // 请求方法是否存在注解        boolean assignableFrom = handler.getClass().isAssignableFrom(HandlerMethod.class);        if (!assignableFrom) &#123;            return true;        &#125;        CheckToken checkToken = null;        if (handler instanceof HandlerMethod) &#123;            checkToken = ((HandlerMethod) handler).getMethodAnnotation(CheckToken.class);        &#125;        // 没有加注解 直接放过        if (checkToken == null) &#123;            return true;        &#125;        // 从Header中获取Authorization        String authorization = request.getHeader(&quot;Authorization&quot;);        log.info(&quot;header authorization : &#123;&#125;&quot;, authorization);        if (StringUtils.isBlank(authorization)) &#123;            log.error(&quot;从Header中获取Authorization失败&quot;);            throw CustomExceptionEnum.NOT_HAVE_TOKEN.throwCustomException();        &#125;        // 其他代码省略        return true;    &#125;&#125;</code></pre><p>从代码中可以看出这里大概过程如下：</p><ol><li>是使用拦截器拦截请求</li><li>如果方法没有 CheckToken 注解直接放过</li><li>有 CheckToken 注解，则从 request 的 header 中获取 Authorization</li></ol><h4 id="新需求"><a href="#新需求" class="headerlink" title="新需求"></a>新需求</h4><p>这里想到只需要把注解去掉，然后从请求参数中获取 token 即可。获取到走原逻辑，获取不到则只返回宣传文案等信息。</p><h3 id="从-Header-中获取信息"><a href="#从-Header-中获取信息" class="headerlink" title="从 Header 中获取信息"></a>从 Header 中获取信息</h3><h4 id="直接获取请求头某一个-headerName"><a href="#直接获取请求头某一个-headerName" class="headerlink" title="直接获取请求头某一个 headerName"></a>直接获取请求头某一个 headerName</h4><pre><code class="java">@PostMapping(&quot;/getAuthorizationByKey&quot;)public String getAuthorizationByKey(@RequestHeader(&quot;Authorization&quot;) String authorization) &#123;    log.info(&quot;获取 Authorization ---&gt;&#123;&#125;&quot;, authorization);    return authorization;&#125;</code></pre><h4 id="使用-Map-获取所有请求头"><a href="#使用-Map-获取所有请求头" class="headerlink" title="使用 Map 获取所有请求头"></a>使用 Map 获取所有请求头</h4><pre><code class="java">@PostMapping(&quot;/getAuthorizationByMap&quot;)public String getAuthorizationByMap(@RequestHeader Map&lt;String, String&gt; map) &#123;    String authorization = map.get(&quot;Authorization&quot;);    log.info(&quot;获取 Authorization ---&gt;&#123;&#125;&quot;, authorization);    return authorization;&#125;</code></pre><h4 id="使用-MultiValueMap-获取请求头"><a href="#使用-MultiValueMap-获取请求头" class="headerlink" title="使用 MultiValueMap 获取请求头"></a>使用 MultiValueMap 获取请求头</h4><pre><code class="java">@PostMapping(&quot;/getAuthorizationByMultiValueMap&quot;)public String getAuthorizationByMultiValueMap(@RequestHeader MultiValueMap&lt;String, String&gt; map) &#123;    List&lt;String&gt; authorization = map.get(&quot;Authorization&quot;);    log.info(&quot;获取 Authorization ---&gt;&#123;&#125;&quot;, authorization);    return &quot;SUCCESS&quot;;&#125;</code></pre><h4 id="使用-HttpHeaders-获取请求头"><a href="#使用-HttpHeaders-获取请求头" class="headerlink" title="使用 HttpHeaders 获取请求头"></a>使用 HttpHeaders 获取请求头</h4><pre><code class="java">@PostMapping(&quot;/getAuthorizationByHeaders&quot;)public String getAuthorizationByHeaders(@RequestHeader HttpHeaders headers) &#123;    List&lt;String&gt; authorization = headers.get(&quot;Authorization&quot;);    log.info(&quot;获取 Authorization ---&gt;&#123;&#125;&quot;, authorization);    return &quot;SUCCESS&quot;;&#125;</code></pre><h4 id="使用-HttpServletRequest-获取"><a href="#使用-HttpServletRequest-获取" class="headerlink" title="使用 HttpServletRequest 获取"></a>使用 HttpServletRequest 获取</h4><pre><code class="java">@PostMapping(&quot;/getAuthorizationByServlet&quot;)public String getAuthorizationByServlet(HttpServletRequest request) &#123;    String authorization = request.getHeader(&quot;Authorization&quot;);    log.info(&quot;获取 Authorization ---&gt;&#123;&#125;&quot;, authorization);    return authorization;&#125;</code></pre><h4 id="测试文件"><a href="#测试文件" class="headerlink" title="测试文件"></a>测试文件</h4><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/dqAEES-LSudFy.png" alt="dqAEES-LSudFy"></p><p>经过测试这些都是可以的，最终选择使用 Map 接收 Header ，然后从 Map 中获取 Authorization。</p><blockquote><p>PS: 可能有小伙伴测试不过，发现接受的 header 里的 name 全都是小写了，可以继续阅读。<br>源码在文末，也可以关注公众号，发送 headerName/4 获取。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/rXC2fS-cVftVR.jpg" alt="rXC2fS-cVftVR"></p><p>你以为事情如果到这里就结束了，那真是太天真了。</p><p>这不，出现了文章开头的描述的场景，赶紧回滚，然后排查问题，最后定位到是 Header 的 name 大小写问题。</p><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><ol><li>之前 APP 端也是这么传的，那为什么使用拦截器是正常的呢？</li><li>上面的那几种方式是不是都是这样？</li><li>不排除 tomcat 发现原来都会转换为小写，又是为什么？</li></ol><h3 id="模拟排查"><a href="#模拟排查" class="headerlink" title="模拟排查"></a>模拟排查</h3><h4 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h4><p>模拟生产首先使用相同的容器配置，这里排除了内置的 tomcat 容器，并且使用 undertow 容器。</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;exclusions&gt;        &lt;exclusion&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;        &lt;/exclusion&gt;        &lt;!-- Exclude the Tomcat dependency --&gt;        &lt;exclusion&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;        &lt;/exclusion&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h4 id="使用拦截器传小写为什么没有问题"><a href="#使用拦截器传小写为什么没有问题" class="headerlink" title="使用拦截器传小写为什么没有问题"></a>使用拦截器传小写为什么没有问题</h4><ul><li>修改使用小写 <code>authorization</code></li></ul><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/BnwZnf-7AvYYg.png" alt="BnwZnf-7AvYYg"></p><ul><li>debug 断点</li></ul><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/OOjOyV-54K6Na.png" alt="OOjOyV-54K6Na"></p><p>神奇的一幕出现了，收到的确实是小写，但是 <strong>request.getHeader(“Authorization”);</strong> 却可以获取到 <code>authorization</code></p><ul><li>F7 继续往里跟</li></ul><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/JwgnFS-cW3pJY.png" alt="JwgnFS-cW3pJY"></p><p><code>io.undertow.servlet.spec.HttpServletRequestImpl#getHeader</code> 第 190 行，从 HeaderMap 中获取第一个元素</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/DnRSum-crs0Mb.png" alt="DnRSum-crs0Mb"></p><p><code>io.undertow.util.HeaderMap#getFirst</code> 第 297 行， 通过 getEntry 方法获取 header</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/C8lSGw-XxKDPW.png" alt="C8lSGw-XxKDPW"></p><p>继续追踪，发现在 <code>io.undertow.util.HeaderMap#getEntry(java.lang.String)</code> 方法 77~79 行的时候获取到了 header 信息。那就看一下这块的源码吧。</p><p>在仔细看一下发现是 77 行 <code>final int hc = HttpString.hashCodeOf(headerName);</code> 在获取 name 的 hashCode 时，这里无论大小写，都是同一个 hashCode。这块代码如下</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/3v1FVJ-MuPXUA.png" alt="3v1FVJ-MuPXUA"></p><p>higher 方法：</p><pre><code class="java">private static int higher(byte b) &#123;    return b &amp; (b &gt;= &#39;a&#39; &amp;&amp; b &lt;= &#39;z&#39; ? 0xDF : 0xFF);&#125;</code></pre><p>这块的含义</p><ol><li>如果 b 是小写字符则 <code>b &amp; 0xDF</code></li><li>如果 b 是大写字符则 <code>b &amp; 0xFF</code></li></ol><p>对照 ASCII 表，大小写字母相差 32 而 0xFF(255) 和 0xDF(223) 同样相差 32，所以问题定位到了。header 的 name 无论是大写还是小写，都会查出同一个值。</p><p>当然你也可以这么传</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/VOOF8k-LoGjAf.png" alt="VOOF8k-LoGjAf"></p><p>这样的话谁在上面，Header 中使用的 name 就是那个。</p><h4 id="使用-Map-为什么会区分大小写"><a href="#使用-Map-为什么会区分大小写" class="headerlink" title="使用 Map 为什么会区分大小写"></a>使用 Map 为什么会区分大小写</h4><p>传入的是大写</p><pre><code class="text">HttpServlet -&gt; DispatcherServlet#doDispatch -&gt; AbstractHandlerMethodAdapter#handle -&gt; RequestMappingHandlerAdapter#handleInternal -&gt; RequestMappingHandlerAdapter#invokeHandlerMethod -&gt; ServletInvocableHandlerMethod#invokeAndHandle-&gt; InvocableHandlerMethod#invokeForRequest (解析参数值)-&gt; InvocableHandlerMethod#getMethodArgumentValues-&gt; RequestHeaderMapMethodArgumentResolver#resolveArgument</code></pre><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/dqAEES-LSudFy.png" alt="dqAEES-LSudFy"></p><p>如图所示 <code>String headerName = iterator.next();</code> name 被区分大小写放到了 LinkedHashMap 中，后续会反射调用对应的 Controller 方法。</p><p>所以也就出现了我所遇到的问题。 </p><p>当然理论上 APP 客户端不应该测试和预发布使用大写，而生产使用小写。</p><p>上面阅读的源码只是 Spring 对 Header 的处理，Spring 在 <code>HttpServlet</code> 收到请求时，Spring 没有对请求 Header 的 name 大小写进行转换，只是在获取对应 value 的时候，没有区分大小写进行获取。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/mpl3PK-m7dKAb.jpg"></p><h3 id="容器对-header-的处理"><a href="#容器对-header-的处理" class="headerlink" title="容器对 header 的处理"></a>容器对 header 的处理</h3><h5 id="undertow-容器的处理"><a href="#undertow-容器的处理" class="headerlink" title="undertow 容器的处理"></a>undertow 容器的处理</h5><ul><li>请求参数的处理</li></ul><p>这里发现 undertow 并没有对请求参数进行大小写转换处理操作。</p><ul><li>从 HttpServletRequest 获取 header</li></ul><p>debug 发现调用的是 <code>io.undertow.servlet.spec.HttpServletRequestImpl#getHeader</code>，这个过程就是上面的排查过程。</p><ul><li>从 Headers 中获取 header</li></ul><p>通过 debug 发现 jetty 调用的是 <code>org.springframework.http.HttpHeaders#get</code>，然后调用 <code>org.springframework.util.MultiValueMapAdapter#get</code>，然后调用 <code>org.springframework.util.LinkedCaseInsensitiveMap#get</code></p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/nRw6xN-GkUqAN.png" alt="nRw6xN-GkUqAN"></p><p>这里会不区分大小写</p><ul><li>从 MultiValueMap 获取 header</li></ul><p>这块 debug 发现是直接从 <code>LinkedHashMap</code> 获取的，所以区分了大小写。</p><h4 id="tomcat-容器的处理"><a href="#tomcat-容器的处理" class="headerlink" title="tomcat 容器的处理"></a>tomcat 容器的处理</h4><ul><li>请求参数的处理</li></ul><p>而如果没有排除的话，即使用内嵌的 tomcat 容器无论传递大写还是小写，接收到的全部都是小写，又是怎么个情况呢？</p><p>通过 debug 发现没有排除 tomcat 使用的是，在接收请求时使用的是 <code>org.apache.coyote.http11.Http11Processor</code>。</p><p>在 <code>Http11Processor#service</code> 方法中</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/303mmp-6TczCR.png" alt="303mmp-6TczCR"></p><p>类 284 行负责处理解析 header </p><p>进入 <code>org.apache.coyote.http11.Http11InputBuffer#parseHeaders</code> 方法</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/cqHTEZ-1E9mH7.png" alt="cqHTEZ-1E9mH7"></p><p>第 589 行 （Download Sources 后），阅读 <code>parseHeader</code> 方法</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/oEEbej-rMulR7.png" alt="oEEbej-rMulR7"></p><p>发现会将请求 header 的 name 转换为小写</p><ul><li>从 HttpServletRequest 获取 header</li></ul><p>当使用 tomcat 容器时，调用 <code>org.apache.catalina.connector.RequestFacade#getHeader</code>， <code>org.apache.catalina.connector.Request#getHeader</code>， <code>org.apache.coyote.Request#getHeader</code> <code>org.apache.tomcat.util.http.MimeHeaders#getHeader</code> 最后调用 <code>org.apache.tomcat.util.http.MimeHeaders#getValue</code> 获取 header </p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/qDJXXn-z6hTjZ.png" alt="qDJXXn-z6hTjZ"></p><p>这里也会忽略大小写判断</p><ul><li>从 Headers 获取 header</li></ul><p>通过 debug 发现 tomcat 容器下调用的是 <code>org.springframework.http.HttpHeaders#get</code>，然后调用 <code>org.springframework.util.MultiValueMapAdapter#get</code>，然后调用 <code>org.springframework.util.LinkedCaseInsensitiveMap#get</code></p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/nRw6xN-GkUqAN.png" alt="nRw6xN-GkUqAN"></p><p>这里会不区分大小写</p><ul><li>从 MultiValueMap 获取 header</li></ul><p>这块 debug 发现是直接从 <code>LinkedHashMap</code> 获取的，所以区分了大小写。</p><h4 id="jetty-容器的处理"><a href="#jetty-容器的处理" class="headerlink" title="jetty 容器的处理"></a>jetty 容器的处理</h4><ul><li>请求参数的处理</li></ul><p>如果换成 jetty 容器的话</p><p>在 <code>org.eclipse.jetty.server.HttpConnection</code> 中又会发现无论传入大写还是小写都会被转换为驼峰。</p><p>源码可以阅读 <code>org.eclipse.jetty.http.HttpParser#parseFields</code></p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/Q9KjmT-HSRusz.png" alt="Q9KjmT-HSRusz"></p><p>会转换为驼峰命名法。</p><ul><li>从 HttpServletRequest 获取 header</li></ul><p>通过 debug 发现 jetty 调用的是 <code>org.eclipse.jetty.server.Request#getHeader</code></p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/H9onCc-uyaMMn.png" alt="H9onCc-uyaMMn"></p><p>jetty 在获取 header 时，会调用 <code>org.eclipse.jetty.http.HttpFields#get</code></p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/BOkxFw-op6ZIV.png" alt="BOkxFw-op6ZIV"></p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/ioe7pS-uNuRU6.png" alt="ioe7pS-uNuRU6"></p><p>原来在获取的时候忽略了大小写</p><ul><li>从 Headers 获取 header</li></ul><p>通过 debug 发现 jetty 容器下调用的是 <code>org.springframework.http.HttpHeaders#get</code>，然后调用 <code>org.springframework.util.MultiValueMapAdapter#get</code>，然后调用 <code>org.springframework.util.LinkedCaseInsensitiveMap#get</code></p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/nRw6xN-GkUqAN.png" alt="nRw6xN-GkUqAN"></p><p>这里会不区分大小写</p><ul><li>从 MultiValueMap 获取</li></ul><p>也是调用的 <code>org.springframework.util.MultiValueMapAdapter#get</code> 然后不区分大小写。和从 Headers 中获取相同。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h4><p><strong>Q: 为什么拦截器获取 Authorization 可以不区分大小写？</strong></p><p><strong>A:</strong> 从拦截器获取 Authorization 其实就是从 <code>HttpServletRequest</code> 中获取，这里无论使用 tomcat 还是使用 undertow 或者 jetty 获取 Header 是都是忽略 headerName 的大小写的。具体可以阅读上面的源码分析。</p><p><strong>Q: 这么多获取 Header 的方式有什么区别？</strong><br><strong>A:</strong></p><p>不同的容器下实现方式不同，这里列表说明</p><table><thead><tr><th align="center"></th><th align="center">undertow</th><th align="center">tomcat</th><th align="center">jetty</th></tr></thead><tbody><tr><td align="center">请求参数大小写转换</td><td align="center">不变</td><td align="center">小写</td><td align="center">驼峰</td></tr><tr><td align="center">直接获取请求头某一个 headerName</td><td align="center">忽略大小写，不能为空</td><td align="center">忽略大小写，不能为空</td><td align="center">忽略大小写，不能为空</td></tr><tr><td align="center">使用 Map 获取所有请求头</td><td align="center">Map 的 key 和传入 headerName 大小写的一致，保持一致可获取到</td><td align="center">Map 的 key 全是小写，需要使用小写headerName 获取</td><td align="center">Map 的 key 是驼峰命名法，要使用驼峰命名才可以获取到</td></tr><tr><td align="center">使用 MultiValueMap 获取请求头</td><td align="center">实际是从 LinkedHashMap 中获取，区分大小写</td><td align="center">实际是从 LinkedHashMap 中获取，区分大小写</td><td align="center">从 LinkedCaseInsensitiveMap 获取，不区分大小写</td></tr><tr><td align="center">使用 HttpHeaders 获取请求头</td><td align="center">从 LinkedCaseInsensitiveMap 获取，不区分大小写</td><td align="center">从 LinkedCaseInsensitiveMap 获取，不区分大小写</td><td align="center">从 LinkedCaseInsensitiveMap 获取，不区分大小写</td></tr><tr><td align="center">使用 HttpServletRequest 获取</td><td align="center">使用 HttpString.hashCodeOf(headerName) 忽略了大小写</td><td align="center">调用 MimeHeaders#getValue 忽略了大小写</td><td align="center">HttpFields#get 忽略了大小写</td></tr></tbody></table><p>通过表格发现，即使是不同的容器在使用 HttpHeaders 获取请求头是都是调用了 Spring 的 <code>LinkedCaseInsensitiveMap</code> 获取 header，并且内部忽略了大小写，这里比较推荐使用。</p><p>同样使用 HttpServletRequest 的方式获取也比较推荐。</p><h4 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h4><p>本文主要是分析生产遇到的一个问题，然后开始探究原因，开始的时候发现是 Spring 的原因，因为使用 Map 接收时， headerName 什么格式就是什么格式。</p><p>在自己写 demo 时又发现，原来和 Spring 的关系并不大，是容器的原因。不同的容器处理方式不同。所以总结出来相关文章，供大家参考，不足之处，欢迎指正。</p><h4 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h4><ol><li>本文源码地址：<a href="https://github.com/liuzhihang/header-demo">https://github.com/liuzhihang/header-demo</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【工作笔记】- 几行代码轻松实现跨系统传递 traceId，再也不用担心对不上日志了！</title>
      <link href="2020/10/18/log-trace-id.html"/>
      <url>2020/10/18/log-trace-id.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>前言</strong></p><br><p>新项目查日志太麻烦，多台机器之间查来查去，还不知道是不是同一个请求的。打印日志时使用 MDC 在日志上添加一个 traceId，那这个 traceId 如何跨系统传递呢？</p></blockquote><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>同样是新项目开发的笔记，因为使用的是分布式架构，涉及到各个系统之间的交互</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/hHJYwn-b0KzBU.png" alt="hHJYwn-b0KzBU"></p><p>这时候就会遇到一个很常见的问题：</p><ol><li>单个系统是集群部署，日志分布在多台服务器上；</li><li>多个系统的日志在多台机器，但是一次请求，查日志更是难上加难。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/53_b91a8fc194febf0f3d3edf032e6cf78d-dSqBDj.jpg" alt="53_b91a8fc194febf0f3d3edf032e6cf78d-dSqBDj"></p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ol><li>使用 SkyWalking traceid 进行链路追踪；</li><li>使用 Elastic APM 的 trace.id 进行链路追踪；</li><li>自己生成 traceId 并 put 到 MDC 里面。</li></ol><h3 id="MDC"><a href="#MDC" class="headerlink" title="MDC"></a>MDC</h3><p>MDC（Mapped Diagnostic Context）是一个映射，用于存储运行上下文的特定线程的上下文数据。因此，如果使用log4j进行日志记录，则每个线程都可以拥有自己的MDC，该MDC对整个线程是全局的。属于该线程的任何代码都可以轻松访问线程的MDC中存在的值。</p><h4 id="如何使用-MDC"><a href="#如何使用-MDC" class="headerlink" title="如何使用 MDC"></a>如何使用 MDC</h4><ol><li>在 <strong>log4j2-spring.xml</strong> 的日志格式中添加 <code>%X&#123;traceId&#125;</code> 配置。</li></ol><pre><code class="xml">&lt;Property name=&quot;LOG_PATTERN&quot;&gt;    [%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;]-[%t]-[%X&#123;traceId&#125;]-[%-5level]-[%c&#123;36&#125;:%L]-[%m]%n&lt;/Property&gt;&lt;Property name=&quot;LOG_PATTERN_ERROR&quot;&gt;    [%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;]-[%t]-[%X&#123;traceId&#125;]-[%-5level]-[%l:%M]-[%m]%n&lt;/Property&gt;&lt;!-- 省略 --&gt;&lt;!--这个输出控制台的配置--&gt;&lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot; follow=&quot;true&quot;&gt;    &lt;!--输出日志的格式--&gt;    &lt;PatternLayout charset=&quot;UTF-8&quot;  pattern=&quot;$&#123;LOG_PATTERN&#125;&quot;/&gt;&lt;/Console&gt;</code></pre><ol start="2"><li>新增拦截器</li></ol><p>拦截所有请求，从 header 中获取 traceId 然后放到 MDC 中，如果没有获取到，则直接用 UUID 生成一个。</p><pre><code class="java">@Slf4j@Componentpublic class LogInterceptor implements HandlerInterceptor &#123;    private static final String TRACE_ID = &quot;traceId&quot;;    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception arg3) throws Exception &#123;    &#125;    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView arg3) throws Exception &#123;    &#125;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        String traceId = request.getHeader(TRACE_ID);        if (StringUtils.isEmpty(traceId)) &#123;            MDC.put(TRACE_ID, UUID.randomUUID().toString());        &#125; else &#123;            MDC.put(TRACE_ID, traceId);        &#125;        return true;    &#125;&#125;</code></pre><ol start="3"><li>配置拦截器</li></ol><pre><code class="java">@Configurationpublic class WebConfig implements WebMvcConfigurer &#123;    @Resource    private LogInterceptor logInterceptor;    @Override    public void addInterceptors(InterceptorRegistry registry) &#123;        registry.addInterceptor(logInterceptor)                .addPathPatterns(&quot;/**&quot;);    &#125;&#125;</code></pre><h4 id="跨服务之间如何传递-traceId"><a href="#跨服务之间如何传递-traceId" class="headerlink" title="跨服务之间如何传递 traceId"></a>跨服务之间如何传递 traceId</h4><ul><li>FeignClient</li></ul><p>因为这边使用的是 FeignClient 进行服务之间的调用，只需要新增请求拦截器即可</p><pre><code class="java">@Configurationpublic class FeignInterceptor implements RequestInterceptor &#123;    private static final String TRACE_ID = &quot;traceId&quot;;    @Override    public void apply(RequestTemplate requestTemplate) &#123;        requestTemplate.header(TRACE_ID, MDC.get(TRACE_ID));    &#125;&#125;</code></pre><ul><li>Dubbo</li></ul><p>如果是 Dubbo 可以通过扩展 Filter 的方式传递 traceId</p><ol><li>编写 filter</li></ol><pre><code class="java">@Activate(group = &#123;&quot;provider&quot;, &quot;consumer&quot;&#125;)public class TraceIdFilter implements Filter &#123;    @Override    public Result invoke(Invoker&lt;?&gt; invoker, Invocation invocation) throws RpcException &#123;        RpcContext rpcContext = RpcContext.getContext();        String traceId;        if (rpcContext.isConsumerSide()) &#123;            traceId = MDC.get(&quot;traceId&quot;);            if (traceId == null) &#123;                traceId = UUID.randomUUID().toString();            &#125;            rpcContext.setAttachment(&quot;traceId&quot;, traceId);        &#125;        if (rpcContext.isProviderSide()) &#123;            traceId = rpcContext.getAttachment(&quot;traceId&quot;);            MDC.put(&quot;traceId&quot;, traceId);        &#125;        return invoker.invoke(invocation);    &#125;&#125;</code></pre><ol start="2"><li>指定 filter</li></ol><pre><code class="text">src |-main    |-java        |-com            |-xxx                |-XxxFilter.java (实现Filter接口)    |-resources        |-META-INF            |-dubbo                |-org.apache.dubbo.rpc.Filter (纯文本文件，内容为：xxx=com.xxx.XxxFilter)</code></pre><p>截图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/STZ8hr-q8AmQ6.png" alt="STZ8hr-q8AmQ6"></p><p>测试结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/FKroew-oE1qSz.png" alt="FKroew-oE1qSz"></p><blockquote><p>dubbo filter 相关源码地址在文末<br>也可以关注公众号，发送 traceid 获取</p></blockquote><h4 id="其他方式"><a href="#其他方式" class="headerlink" title="其他方式"></a>其他方式</h4><p>当然如果小伙伴们有使用 SkyWalking 或者 Elastic APM 也可以通过以下方式进行注入：</p><ol><li>SkyWalking</li></ol><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.apache.skywalking&lt;/groupId&gt;    &lt;artifactId&gt;apm-toolkit-log4j-2.x&lt;/artifactId&gt;    &lt;version&gt;&#123;project.release.version&#125;&lt;/version&gt;&lt;/dependency</code></pre><p>然后将 <code>[%traceId]</code> 配置在 log4j2.xml 文件的 pattern 中即可</p><ol start="2"><li><p>Elastic APM</p><ol><li>在启动时指定 enable_log_correlation 为 true</li><li>将 <code>%X&#123;trace.id&#125;</code> 配置在 log4j2.xml 文件的 pattern 中</li></ol></li></ol><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><h4 id="统一日志采集"><a href="#统一日志采集" class="headerlink" title="统一日志采集"></a>统一日志采集</h4><p>虽然有了 traceId 可以进行全链路追踪查询日志，但是毕竟也是在多台服务器上，为了提高查询效率，可以考虑将日志汇总到一起。</p><p>常用的使用方法就是基于 ELK 的日志系统：</p><ol><li>使用 filebeat 采集日志报送到 logstash</li><li>logstash 进行分词过滤等处理，输出到 Elasticsearch</li><li>使用 Kinbana 或者自己开发的可视化工具从 Elasticsearch 查询日志</li></ol><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/aBn5LF-utuTLx.png" alt="aBn5LF-utuTLx"></p><h4 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h4><p>本文主要记录近期开发过程中的遇到的一点问题，希望对小伙伴也有所帮助。不足之处，欢迎指正。如果小伙伴有其他的建议或者观点欢迎留言讨论，共同进步。</p><h4 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h4><ol><li>Log4j 2 API：<a href="https://logging.apache.org/log4j/2.x/manual/thread-context.html">https://logging.apache.org/log4j/2.x/manual/thread-context.html</a></li><li>SkyWalking：<a href="https://github.com/apache/skywalking/tree/master/docs/en/setup/service-agent/java-agent">https://github.com/apache/skywalking/tree/master/docs/en/setup/service-agent/java-agent</a></li><li>Elastic APM：<a href="https://www.elastic.co/guide/en/apm/agent/java/current/log-correlation.html">https://www.elastic.co/guide/en/apm/agent/java/current/log-correlation.html</a></li><li>Dubbo filter：<a href="http://dubbo.apache.org/zh-cn/docs/dev/impls/filter.html">http://dubbo.apache.org/zh-cn/docs/dev/impls/filter.html</a></li><li>本文 Dubbo filter demo：<a href="https://github.com/liuzhihang/trace">https://github.com/liuzhihang/trace</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
          <category> 链路追踪 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作笔记 </tag>
            
            <tag> 链路追踪 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【工作笔记】- 老大问我：“建表为啥还设置个自增 id ？用流水号当主键不正好么？”</title>
      <link href="2020/10/11/work-trans-why-table-id.html"/>
      <url>2020/10/11/work-trans-why-table-id.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>又要开始新项目了，一顿操作猛如虎，梳理流程加画图。这不，开始对流程及表结构了。<br><br><br>我：吧啦吧啦吧啦 ……<br>老大：这个建表为啥还设置个自增 id ？直接用流水号（用户号/产品号）当主键不就行了？<br>我：这个是 DBA 规定的，创建表 id、create_time、update_time 这三个字段都要有。《Java 开发规范》也是这么规定的。<br>小伙伴：（附和）是的，规定的是这样的！<br>老大：流水号在你这是唯一索引吧？设置成主键，这样就不用 id 了，还减少一次回表查询？<br>我：…… （说的好像很有道理，咱也不敢说话。）<br>老大：既然他们规定了，那你回去查一下为什么要设计个自增 id ？<br>我：掏出小本本（回去查资料~）。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/why-id-8ZFv04.jpg" alt="why-id-8ZFv04"></p><h3 id="建表规约"><a href="#建表规约" class="headerlink" title="建表规约"></a>建表规约</h3><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/create-db-id-Gv58zQ.png" alt="Java 开发手册-嵩山版"></p><p>在工作中，创建表的时候，DBA 也会审核一下建表 SQL，检查是否符合规范以及常用字段是否设置索引。</p><pre><code class="sql">CREATE TABLE `xxxx` (  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;自增主键&#39;,  `create_time` datetime(3) NOT NULL DEFAULT current_timestamp(3) COMMENT &#39;创建时间&#39;,  `update_time` datetime(3) NOT NULL DEFAULT current_timestamp(3) ON UPDATE current_timestamp(3) COMMENT &#39;更新时间&#39;,  PRIMARY KEY (`id`) USING BTREE,  KEY `idx_create_time` (`create_time`) USING BTREE,  KEY `idx_update_time` (`update_time`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8mb4 COMMENT=&#39;表注释&#39;;</code></pre><p>所以在我使用的过程中，流水号都是单独设置了一个字段，比如叫 trans_no，但是这次就遇到了疑问：trans_no 既然是唯一的，那为什么不直接用 trans_no 当做 id 呢？</p><p>下面开始通过查阅相关资料，一步一步的了解是为什么？</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/why-id-2-pMeutc.jpg" alt="why-id-2-pMeutc"></p><h3 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h3><h4 id="什么是主键"><a href="#什么是主键" class="headerlink" title="什么是主键"></a>什么是主键</h4><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/MySQL-primary-key-z64UFB.png" alt="MySQL-primary-key-z64UFB"></p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_primary_key">https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_primary_key</a></p><p>这段定义咱们主要关注最后一句：</p><blockquote><p>When choosing primary key values, consider using arbitrary values (a <strong>synthetic key</strong>) rather than relying on values derived from some other source (a <strong>natural key</strong>).</p></blockquote><p>意思是创建主键的时候尽量使用 MySQL 自增主键而不是使用业务生成的值当做主键。</p><h4 id="主键的特征"><a href="#主键的特征" class="headerlink" title="主键的特征"></a>主键的特征</h4><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/MySQL-primary-key-1-QDuU4H.png" alt="MySQL-primary-key-1-QDuU4H"></p><p>简而言之：</p><p>非空、唯一、少更改或不更改 。</p><h4 id="如何添加主键"><a href="#如何添加主键" class="headerlink" title="如何添加主键"></a>如何添加主键</h4><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/hfPeDL-r5M5YU.png" alt="hfPeDL-r5M5YU"></p><p>可以在 create 创建表的时候指定，也可以使用 alter 语句后面添加主键，不过官方建议在创建表时就指定。</p><h4 id="为什么要添加主键"><a href="#为什么要添加主键" class="headerlink" title="为什么要添加主键"></a>为什么要添加主键</h4><ol><li>主键可以唯一标识这一行数据，从而保证在删除更新操作时，只是操作这一行数据。</li><li>索引需要，每个 InnoDB 表又有一个特殊的索引，即聚簇索引，用来存储行数据。通常，聚簇索引和主键同义。<ol><li>声明主键，InnoDB 会将主键作为聚簇索引。</li><li>未声明时，会在 UNIQUE 所有键列所在位置找到第一个索引，NOT NULL 并将其作为聚簇索引</li><li>未声明且找不到合适的 UNIQUE 索引，则内部生成一个隐藏的聚簇索引 GEN_CLUST_INDEX，这个隐藏的行 ID 是 6 字节且单调增加。</li></ol></li></ol><p>图 -&gt; 那什么是索引</p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>这里仅介绍 InnoDB 引擎，具体可以参考官方文档，并且介绍的相对比较简单。</p><h4 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h4><ol><li>聚簇索引：表存储是根据主键列的值组织的，以加快涉及主键列的查询和排序。在介绍主键时也对聚簇索引进行了介绍。</li><li>二级索引：也可以叫辅助索引，在辅助索引中会记录对应的主键列以及辅助索引列。根据辅助索引进行搜索的时候，会先根据辅助索引获取到对应的主键列，然后再根据主键去聚簇索引里面搜索。<strong>一般不建议主键很长，因为主键很长辅助索引就会使用更多的空间。</strong></li></ol><blockquote><p><strong>补充：</strong></p><p>回表：先在二级索引查询到对应的主键值，然后根据主键再去聚簇索引里面取查询。<br>索引覆盖：二级索引记录了主键列和二级索引列，如果我只查询主键列的值和二级索引列的值，那就不需要回表了。</p></blockquote><h4 id="索引的物理结构"><a href="#索引的物理结构" class="headerlink" title="索引的物理结构"></a>索引的物理结构</h4><p>InnoDB 使用的 B+ 数数据结构，根据聚簇索引值（主键/UNQIUE/或者自己生成）构建一颗 B+ 树，叶子节点中存放行记录数据，所以每个叶子节点也可以叫数据页。每个数据页大小默认为 16k，支持自定义。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/B+Tree-UgFQjS.png" alt="B+Tree-UgFQjS"></p><h4 id="数据的插入"><a href="#数据的插入" class="headerlink" title="数据的插入"></a>数据的插入</h4><p>当数据插入时，InnoDB 会使页面 1/16 空闲，以备将来插入和更新索引记录。</p><ol><li>顺序插入（升序或降序）：会将索引页剩余的大约 15/16 装满</li><li>随机插入：只会使用容量的 1/2 到 15/16</li></ol><p>在随机插入中，会频繁的移动、分页，从而造成大量的碎片，并且使索引树不够紧凑。而使用顺序插入的方式，则数据比较紧凑，有更高的空间利用率。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h4><p><strong>Q: 什么是回表和索引覆盖？</strong></p><p><strong>A:</strong></p><ol><li>回表：先在二级索引查询到对应的主键值，然后根据主键再去聚簇索引里面取查询。</li><li>索引覆盖：二级索引记录了主键列和二级索引列，如果我只查询主键列的值和二级索引列的值，那就不需要回表了。</li></ol><p><strong>Q: 为什么要设置自增主键 id ？</strong></p><p><strong>A:</strong></p><ol><li>可以唯一标识一行数据，在 InnoDB 构建索引树的时候会使用主键。</li><li>自增 id 是顺序的，可以保证索引树上的数据比较紧凑，有更高的空间利用率以及减少数据页的分裂合并等操作，提高效率。</li><li>一般使用手机号、身份证号作为主键等并不能保证顺序性。</li><li>流水号一般相对较长，比如 28 位，32 位等，过长的话会二级索引占用空间较多。同时为了业务需求，流水号具有一定的随机性。</li></ol><h4 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h4><p>本文主要通过查阅资料，了解为什么要设置一个和业务无关的自增 id 用来当做主键，很多内容比较浅显，比如 InnoDB 的 B+ 树，页分裂及页合并，插入过程等都没有进行深入研究，有兴趣的小伙伴可以更深入的研究下。</p><p>同时在建表时除了要设置一个自增 id 用来当做主键，小伙伴们在业务开发过程中是否也会遇到一种情况：用户的注销，数据的删除等都是进行的逻辑删除，而不是物理删除。</p><p>本篇文章介绍比较简陋，不足之处，希望大家多多指正。</p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JDK源码笔记】- 基于链表的有界阻塞队列 —— LinkedBlockingQueue</title>
      <link href="2020/10/04/source-code-linkedblockingqueue.html"/>
      <url>2020/10/04/source-code-linkedblockingqueue.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>前言</strong></p><br><p>上一节看了基于数据的有界阻塞队列 ArrayBlockingQueue 的源码，通过阅读源码了解到在 ArrayBlockingQueue 中入队列和出队列操作都是用了 ReentrantLock 来保证线程安全。下面咱们看另一种有界阻塞队列：LinkedBlockingQueue。</p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>一个基于链接节点的，可选绑定的 BlockingQueue 阻塞队列。</p><p>对元素 FIFO（先进先出）进行排序。队列的头部是已在队列中停留最长时间的元素。队列的尾部是最短时间出现在队列中的元素。将新元素插入队列的尾部，并检索队列操作获取队列开头的元素。</p><p>基于连表的队列通常具有比基于数组的队列有更高的吞吐量，但是大多数并发应用程序中的可预测性较差。</p><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><pre><code class="java">public class LinkedBlockingQueueTest &#123;    private static final LinkedBlockingQueue&lt;String&gt; QUEUE = new LinkedBlockingQueue&lt;&gt;(10);    public static void main(String[] args) throws InterruptedException &#123;        // 入队列        QUEUE.put(&quot;put 入队列, 队列满则会阻塞等待&quot;);        QUEUE.add(&quot;add 入队列, 队列满则会抛出异常&quot;);        QUEUE.offer(&quot;offer 入队列, 队列满会返回 false&quot;);        // 出队列        // 队列空返回 null        String poll = QUEUE.poll();        // 队列空会阻塞等待        String take = QUEUE.take();        // 仅仅看一下最早入队列的元素        String peek = QUEUE.peek();    &#125;&#125;</code></pre><h4 id="问题疑问"><a href="#问题疑问" class="headerlink" title="问题疑问"></a>问题疑问</h4><ol><li>LinkedBlockingQueue 的实现原理是什么？</li><li>LinkedBlockingQueue 和 ArrayBlockingQueue 的区别是什么？</li></ol><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/LinkedBlockingQueue-uml-Ma14n3.png" alt="LinkedBlockingQueue-uml-Ma14n3"></p><h4 id="参数介绍"><a href="#参数介绍" class="headerlink" title="参数介绍"></a>参数介绍</h4><pre><code class="java">static class Node&lt;E&gt; &#123;    E item;    /**    * One of:    * - 真正的后继节点    * - 有值，表示后继者是head.next    * - null，表示没有后继（这是最后一个节点）    */    Node&lt;E&gt; next;    Node(E x) &#123; item = x; &#125;&#125;</code></pre><p>首先在 LinkedBlockingQueue 中有一个静态内部类 Node<E> 支持泛型，下面看下其他字段：</p><pre><code class="java">/** 初始容量，如果没有，则为Integer.MAX_VALUE */private final int capacity;/** 当前元素数 */private final AtomicInteger count = new AtomicInteger();/*** 链表头* 不变的是: head.item == null*/transient Node&lt;E&gt; head;/*** 链表尾* 不变的是: last.next == null*/private transient Node&lt;E&gt; last;/** 执行 take, poll 等操作需要获取到 takeLock */private final ReentrantLock takeLock = new ReentrantLock();/** 等待执行 take 操作的线程，会放入这个条件队列 */private final Condition notEmpty = takeLock.newCondition();/** 执行 put, offer 等操作需要获取到 putLock */private final ReentrantLock putLock = new ReentrantLock();/** 等待执行 put 操作的线程，会被放入这个条件队列 */private final Condition notFull = putLock.newCondition();</code></pre><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><pre><code class="java">public LinkedBlockingQueue() &#123;    this(Integer.MAX_VALUE);&#125;// 创建时指定容量public LinkedBlockingQueue(int capacity) &#123;    if (capacity &lt;= 0) throw new IllegalArgumentException();    this.capacity = capacity;    last = head = new Node&lt;E&gt;(null);&#125;</code></pre><p>通过构造函数可以看出，在初始化 LinkedBlockingQueue 时，如果不传入容量则会默认指定 Integer.MAX_VALUE。</p><h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><p>add 方法是直接调用的父类 AbstractQueue 的方法，内部调用的 LinkedBlockingQueue 自己实现的 offer 方法</p><pre><code class="java">public boolean add(E e) &#123;    if (offer(e))        return true;    else        throw new IllegalStateException(&quot;Queue full&quot;);&#125;</code></pre><p>主要阅读的还是 LinkedBlockingQueue 的 put 和 offer 方法：</p><pre><code class="java">public void put(E e) throws InterruptedException &#123;    // 插入元    if (e == null) throw new NullPointerException();    // Note: 所有put / take / etc中的约定是预设本地变量    // 保持计数为负表示失败，除非置位。    int c = -1;    Node&lt;E&gt; node = new Node&lt;E&gt;(e);    final ReentrantLock putLock = this.putLock;    final AtomicInteger count = this.count;    putLock.lockInterruptibly();    try &#123;        // 如果已经到最大容量，则等待         while (count.get() == capacity) &#123;            notFull.await();        &#125;        enqueue(node);        // 总数进行增加， 返回的是先前的容量        c = count.getAndIncrement();        // 判断是否需要唤醒入队列阻塞的线程        if (c + 1 &lt; capacity)            notFull.signal();    &#125; finally &#123;        putLock.unlock();    &#125;    if (c == 0)        // 唤醒因调用 notEmpty 的 await 方法而被阻塞的线程        signalNotEmpty();&#125;</code></pre><pre><code class="java">public boolean offer(E e) &#123;    // 为空抛出异常    if (e == null) throw new NullPointerException();    final AtomicInteger count = this.count;    // 如果已经到最大容量，返回 false    if (count.get() == capacity)        return false;    int c = -1;    Node&lt;E&gt; node = new Node&lt;E&gt;(e);    final ReentrantLock putLock = this.putLock;    putLock.lock();    try &#123;        if (count.get() &lt; capacity) &#123;            enqueue(node);            c = count.getAndIncrement();            if (c + 1 &lt; capacity)                notFull.signal();        &#125;    &#125; finally &#123;        putLock.unlock();    &#125;    if (c == 0)        signalNotEmpty();    return c &gt;= 0;&#125;</code></pre><p>通过上面两段代码可以看出 put 和 offer 的最大区别在于是否阻塞。 put 方法当队列达到指定容量时，会阻塞，等待有元素出队列。而 offer 方法会直接返回 false。</p><p>同时两个方法操作元素入队列都是调用的 enqueue(node) 方法，下面一起看下 enqueue 方法。</p><pre><code class="java">private void enqueue(Node&lt;E&gt; node) &#123;    // assert putLock.isHeldByCurrentThread();    // assert last.next == null;    last = last.next = node;&#125;</code></pre><p>在 enqueue 方法中，直接指定当前尾节点的 next 为传入的元素即可。</p><h4 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h4><pre><code class="java">public E poll() &#123;    final AtomicInteger count = this.count;    // 队列为空返回 null    if (count.get() == 0)        return null;    E x = null;    int c = -1;    // 加锁    final ReentrantLock takeLock = this.takeLock;    takeLock.lock();    try &#123;        if (count.get() &gt; 0) &#123;            x = dequeue();            // 减少队列元素计数，返回的是旧值            c = count.getAndDecrement();            if (c &gt; 1)            // 旧值大于 1 ，就是当前大于 0            // 唤醒调用 notEmpty.await 等待的线程                notEmpty.signal();        &#125;    &#125; finally &#123;        takeLock.unlock();    &#125;    if (c == capacity)        // 如果旧值等于 capacity 说明当前空了一个位置        signalNotFull();    return x;&#125;</code></pre><pre><code class="java">public E take() throws InterruptedException &#123;    E x;    int c = -1;    final AtomicInteger count = this.count;    final ReentrantLock takeLock = this.takeLock;    takeLock.lockInterruptibly();    try &#123;        // 阻塞等待        while (count.get() == 0) &#123;            notEmpty.await();        &#125;        x = dequeue();        c = count.getAndDecrement();        if (c &gt; 1)            notEmpty.signal();    &#125; finally &#123;        takeLock.unlock();    &#125;    if (c == capacity)        signalNotFull();    return x;&#125;</code></pre><p>通过上面代码可以看出 poll 和 take 方法逻辑大致相同。区别就是在当前队列为空时的处理逻辑。poll 在当前队列为空时返回 null，take 会阻塞等待，知道当前队列中有元素。</p><p>poll 和 take 都试用 dequeue() 方法从队列中获取元素。</p><pre><code class="java">private E dequeue() &#123;    // assert takeLock.isHeldByCurrentThread();    // assert head.item == null;    Node&lt;E&gt; h = head;    Node&lt;E&gt; first = h.next;    h.next = h; // help GC    head = first;    E x = first.item;    first.item = null;    return x;&#125;</code></pre><p>dequeue() 方法逻辑就是获取头节点，并将 head 指向下一个节点。</p><h4 id="查看元素"><a href="#查看元素" class="headerlink" title="查看元素"></a>查看元素</h4><pre><code class="java">public E peek() &#123;    if (count.get() == 0)        return null;    final ReentrantLock takeLock = this.takeLock;    takeLock.lock();    try &#123;        Node&lt;E&gt; first = head.next;        if (first == null)            return null;        else            return first.item;    &#125; finally &#123;        takeLock.unlock();    &#125;&#125;</code></pre><p>peek() 方法比较简单，直接获取 head 的元素值即可。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h4><p><strong>Q: LinkedBlockingQueue 的实现原理？</strong></p><p><strong>A:</strong> LinkedBlockingQueue 是基于链表实现的，内部使用 ReentrantLock 互斥锁，防止并发放置元素或者取出元素的冲突问题。</p><ol><li>take、poll、peek 等从队列中获取元素的操作共用 takeLock 锁。</li><li>add、put、offer 等向队列中添加元素的操作共同 putLock 锁。</li><li>notEmpty 和 notFull 是 Condition 类型，在 take 和 put 操作时，如果如果队列为空或者队列已满，会调用相应的 await 将线程放入条件队列。</li></ol><p><strong>Q: 入队列和出队列方法之间的区别是什么？</strong></p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>add</td><td>添加元素，队列满了，添加失败抛出遗产</td></tr><tr><td>offer</td><td>添加元素， 队列满了，添加失败，返回 false</td></tr><tr><td>put</td><td>添加元素，队列满了，阻塞等待</td></tr><tr><td></td><td></td></tr><tr><td>poll</td><td>弹出元素，队列为空则返回 null</td></tr><tr><td>take</td><td>弹出元素，队列为空则等待队列中有元素</td></tr><tr><td></td><td></td></tr><tr><td>peek</td><td>查看队列中放入最早的一个元素</td></tr></tbody></table><h4 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h4><p>LinkedBlockingQueue 使用和 ArrayBlockingQueue 并没有什么区别，内部实现都是使用的 ReentrantLock，可以对照着阅读。同时 Condition 这块也需要着重了解一下。</p>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码笔记 </tag>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JDK源码笔记】- AQS 都看完了，Condition 原理可不能少！</title>
      <link href="2020/10/01/source-code-condition.html"/>
      <url>2020/10/01/source-code-condition.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>前言</strong></p><br><p>在介绍 AQS 时，其中有一个内部类叫做 ConditionObject，当时并没有进行介绍，并且在后续阅读源码时，会发现很多地方用到了 Condition ，这时就会很诧异，这个 Condition 到底有什么作用？那今天就通过阅读 Condition 源码，从而弄清楚 Condition 到底是做什么的？当然阅读这篇文章的时候希望你已经阅读了 AQS、ReentrantLock 以及 LockSupport 的相关文章或者有一定的了解（<del>当然小伙伴也可以直接跳到文末看总结</del>）。</p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Object 的监视器方法：wait、notify、notifyAll 应该都不陌生，在多线程使用场景下，必须先使用 synchronized 获取到锁，然后才可以调用 Object 的 wait、notify。</p><p>Condition 的使用，相当于用 Lock 替换了 synchronized，然后用 Condition 替换 Object 的监视器方法。</p><p>Conditions（也称为条件队列或条件变量）为一种线程提供了一种暂停执行（等待），直到另一线程通知被阻塞的线程，某些状态条件现在可能为真。</p><p>因为访问到此共享状态信息发生在不同的线程中，因此必须对其进行保护，所以会使用某种形式的锁。等待条件提供的关键属性是它以原子地释放了关联的锁，并且挂起当前线程，就像 Object.wait 一样。</p><p>Condition 实例本质上要绑定到锁。 为了获得 Condition 实例，一般使用 Lock 实例的 newCondition() 方法。</p><pre><code class="java">Lock lock = new ReentrantLock();Condition con = lock.newCondition();</code></pre><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><pre><code class="java">class BoundedBuffer &#123;    final Lock lock = new ReentrantLock();    // condition 实例依赖于 lock 实例    final Condition notFull = lock.newCondition();    final Condition notEmpty = lock.newCondition();    final Object[] items = new Object[100];    int putPtr, takePtr, count;    public void put(Object x) throws InterruptedException &#123;        lock.lock();        try &#123;            //  put 时判断是否已经满了            // 则线程在 notFull 条件上排队阻塞            while (count == items.length) &#123;                notFull.await();            &#125;            items[putPtr] = x;            if (++putPtr == items.length) &#123;                putPtr = 0;            &#125;            ++count;            // put 成功之后，队列中有元素            // 唤醒在 notEmpty 条件上排队阻塞的线程            notEmpty.signal();        &#125; finally &#123;            lock.unlock();        &#125;    &#125;    public Object take() throws InterruptedException &#123;        lock.lock();        try &#123;            // take 时，发现为空            // 则线程在 notEmpty 的条件上排队阻塞            while (count == 0) &#123;                notEmpty.await();            &#125;            Object x = items[takePtr];            if (++takePtr == items.length) &#123;                takePtr = 0;            &#125;            --count;            // take 成功，队列不可能是满的            // 唤醒在 notFull 条件上排队阻塞的线程            notFull.signal();            return x;        &#125; finally &#123;            lock.unlock();        &#125;    &#125;&#125;</code></pre><p>上面是官方文档的一个例子，实现了一个简单的 BlockingQueue ，看懂这里，会发现在<strong>同步队列</strong>中很多地方都是用的这个逻辑。必要的代码说明都已经在代码中进行注释。</p><h4 id="问题疑问"><a href="#问题疑问" class="headerlink" title="问题疑问"></a>问题疑问</h4><ol><li>Condition 和 AQS 有什么关系？</li><li>Condition 的实现原理是什么？</li><li>Condition 的等待队列和 AQS 的同步队列有什么区别和联系？</li></ol><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/condition-uml-rMKuf3.png" alt="condition-uml-rMKuf3"></p><p>通过 UML 可以看出，Condition 只是一个抽象类，它的主要实现逻辑是在 AQS 的内部类 ConditionObject 实现的。下面主要从 await 和 signal 两个方法入手，从源码了解 ConditionObject。</p><h4 id="创建-Condition"><a href="#创建-Condition" class="headerlink" title="创建 Condition"></a>创建 Condition</h4><pre><code class="java">Lock lock = new ReentrantLock();Condition con = lock.newCondition();</code></pre><p>一般使用 lock.newCondition() 创建条件变量。</p><pre><code class="java">public class ReentrantLock implements Lock, java.io.Serializable &#123;    private final Sync sync;    public Condition newCondition() &#123;        return sync.newCondition();    &#125;    // Sync 集成 AQS    abstract static class Sync extends AbstractQueuedSynchronizer &#123;        final ConditionObject newCondition() &#123;            return new ConditionObject();        &#125;    &#125;&#125;</code></pre><p>这里使用的是 ReentrantLock 的源码，里面调用的 sync.newCondition()，Sync 继承 AQS，其实就是创建了一个 AQS 内部类的 ConditionObject 的实例。</p><p>这里需要注意的是 lock 每调用一次 <code>lock.newCondition()</code> 都会有一个新的 ConditionObject 实例生成，就是说一个 lock 可以创建多个 Condition 实例。</p><h4 id="Condition-参数"><a href="#Condition-参数" class="headerlink" title="Condition 参数"></a>Condition 参数</h4><pre><code class="java">/** 条件队列的第一个节点 */private transient Node firstWaiter;/** 条件队列的最后一个节点 */private transient Node lastWaiter;</code></pre><h4 id="await-方法"><a href="#await-方法" class="headerlink" title="await 方法"></a>await 方法</h4><p>await 方法，会造成当前线程在等待，直到收到信号或被中断。</p><p>与此 Condition 相关联的锁被原子释放，并且出于线程调度目的，当前线程被禁用，并且处于休眠状态，直到发生以下四种情况之一：</p><ol><li>其他一些线程调用此 Condition 的 signal 方法，而当前线程恰好被选择为要唤醒的线程；</li><li>其他一些线程调用此 Condition 的 signalAll 方法；</li><li>其他一些线程中断当前线程，并支持中断线程挂起；</li><li>发生虚假唤醒。</li></ol><p>在所有情况下，在此方法可以返回之前，当前线程必须重新获取与此条件关联的锁。当线程返回时，可以保证保持此锁。</p><p>现在来看 AQS 内部的实现逻辑：</p><pre><code class="java">public final void await() throws InterruptedException &#123;    // 响应中断    if (Thread.interrupted())        throw new InterruptedException();    // 添加到条件队列尾部（等待队列）    // 内部会创建 Node.CONDITION 类型的 Node    Node node = addConditionWaiter();    // 释放当前线程获取的锁（通过操作 state 的值）    // 释放了锁就会被阻塞挂起    int savedState = fullyRelease(node);    int interruptMode = 0;    // 节点已经不在同步队列中，则调用 park 让其在等待队列中挂着    while (!isOnSyncQueue(node)) &#123;        // 调用 park 阻塞挂起当前线程        LockSupport.park(this);        // 说明 signal 被调用了或者线程被中断，校验下唤醒原因        // 如果因为终端被唤醒，则跳出循环        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)            break;    &#125;    // while 循环结束， 线程开始抢锁    if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)        interruptMode = REINTERRUPT;    if (node.nextWaiter != null) // clean up if cancelled        unlinkCancelledWaiters();    // 统一处理中断的    if (interruptMode != 0)        reportInterruptAfterWait(interruptMode);&#125;</code></pre><p>await 方法步骤如下：</p><ol><li>创建 Node.CONDITION 类型的 Node 并添加到条件队列（ConditionQueue）的尾部；</li><li>释放当前线程获取的锁（通过操作 state 的值）</li><li>判断当前线程是否在同步队列（SyncQueue）中，不在的话会使用 park 挂起。</li><li>循环结束之后，说明已经已经在同步队列（SyncQueue）中了，后面等待获取到锁，继续执行即可。</li></ol><p>在这里一定要把条件队列和同步队列进行区分清楚！！</p><p>条件队列/等待队列：即 Condition 的队列<br>同步队列：AQS 的队列。</p><p>下面对 await 里面重要方法进行阅读：</p><ul><li>addConditionWaiter() 方法</li></ul><pre><code class="java">private Node addConditionWaiter() &#123;    Node t = lastWaiter;    // If lastWaiter is cancelled, clean out.    // 判断尾节点状态，如果被取消，则清除所有被取消的节点    if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) &#123;        unlinkCancelledWaiters();        t = lastWaiter;    &#125;    // 创建新节点，类型为 Node.CONDITION    Node node = new Node(Thread.currentThread(), Node.CONDITION);    // 将新节点放到等待队列尾部    if (t == null)        firstWaiter = node;    else        t.nextWaiter = node;    lastWaiter = node;    return node;&#125;</code></pre><p>addConditionWaiter 方法可以看出，只是创建一个类型为 Node.CONDITION 的节点并放到条件队列尾部。同时通过这段代码还可以得出其他结论：</p><ol><li>条件队列内部的 Node，只用到了 thread、waitStatus、nextWaiter 属性；</li><li>条件队列是单向队列。</li></ol><p>作为对比，这里把条件队列和同步队列做出对比：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/condition-node-7yUQjE.png" alt="condition-node-7yUQjE"></p><p><a href="https://mp.weixin.qq.com/s/u-0aRcTTsQNzkkMhoJP0lQ">AQS</a> 同步队列如下：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/condition-aqs-n5Fs85.png" alt="condition-aqs-n5Fs85"></p><p>再来看下 Condition 的条件队列</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/condition-condition-A97bUS.png" alt="condition-condition-A97bUS"></p><p>waitStatus 在 AQS 中已经进行了介绍：</p><blockquote><ol><li>默认状态为 0；</li><li>waitStatus &gt; 0 (CANCELLED 1) 说明该节点超时或者中断了，需要从队列中移除；</li><li>waitStatus = -1 SIGNAL 当前线程的前一个节点的状态为 SIGNAL，则当前线程需要阻塞（unpark）；</li><li>waitStatus = -2 CONDITION -2 ：该节点目前在条件队列；</li><li>waitStatus = -3 PROPAGATE -3 ：releaseShared 应该被传播到其他节点，在共享锁模式下使用。</li></ol></blockquote><ul><li>fullyRelease 方法 （AQS）</li></ul><pre><code class="java">final int fullyRelease(Node node) &#123;    boolean failed = true;    try &#123;        // 获取当前节点的 state        int savedState = getState();        // 释放锁        if (release(savedState)) &#123;            failed = false;            return savedState;        &#125; else &#123;            throw new IllegalMonitorStateException();        &#125;    &#125; finally &#123;        if (failed)            node.waitStatus = Node.CANCELLED;    &#125;&#125;</code></pre><p>fullyRelease 方法是由 AQS 提供的，首先获取当前的 state，然后调用 release 方法进行释放锁。</p><pre><code class="java">public final boolean release(int arg) &#123;    if (tryRelease(arg)) &#123;        Node h = head;        if (h != null &amp;&amp; h.waitStatus != 0)            unparkSuccessor(h);        return true;    &#125;    return false;&#125;</code></pre><p>release 方法在 <a href="https://mp.weixin.qq.com/s/u-0aRcTTsQNzkkMhoJP0lQ">AQS</a> 中做了详细的介绍。它的主要作用就是释放锁，并且需要注意的是：</p><ol><li>fullyRelease 会一次性释放所有的锁，所以说不管重入多少次，在这里都会全部释放的。</li><li>这里会抛出异常，主要是在释放锁失败时，这时就会在 finally 里面将节点状态置为 Node.CANCELLED。</li></ol><ul><li>isOnSyncQueue(node)</li></ul><p>通过上面的流程，节点已经放到了<strong>条件队列</strong>并且释放了持有的<strong>锁</strong>，而后就会挂起阻塞，直到 signal 唤醒。但是在挂起时要保证节点已经不在同步队列（SyncQueue）中了才可以挂起。</p><pre><code class="java">final boolean isOnSyncQueue(Node node) &#123;    // 当前节点是条件队列节点，或者上一个节点是空    if (node.waitStatus == Node.CONDITION || node.prev == null)        return false;    if (node.next != null) // If has successor, it must be on queue        return true;    return findNodeFromTail(node);&#125;// 从尾部开始遍历private boolean findNodeFromTail(Node node) &#123;    Node t = tail;    for (;;) &#123;        if (t == node)            return true;        if (t == null)            return false;        t = t.prev;    &#125;&#125;</code></pre><p>如果一个节点（总是一个最初放置在条件队列中的节点）现在正等待在同步队列上重新获取，则返回true。</p><p>这段代码的主要作用判断节点是不是在同步队列中，如果不在同步队列中，后面才会调用 park 进行阻塞当前线程。这里就会有一个疑问：AQS 的同步队列和 Condition 的条件队列应该是无关的，这里为什么会要保证节点不在同步队列之后才可以进行阻塞？因为 signal 或者 signalAll 唤醒节点之后，节点就会被放到同步队列中。</p><p>线程到这里已经被阻塞了，当有其他线程调用 signal 或者 signalAll 时，会唤醒当前线程。</p><p>而后会验证是否因中断唤醒当前线程，这里假设没有发生中断。那 while 循环的 isOnSyncQueue(Node node) 必然会返回 true ，表示当前节点已经在同步队列中了。</p><p>后续会调用 <strong>acquireQueued(node, savedState)</strong> 进行获取锁。</p><pre><code class="java">final boolean acquireQueued(final Node node, int arg) &#123;    // 是否拿到资源    boolean failed = true;    try &#123;        // 中断状态        boolean interrupted = false;        // 无限循环        for (;;) &#123;            // 当前节点之前的节点            final Node p = node.predecessor();            // 前一个节点是头节点， 说明当前节点是 头节点的 next 即真实的第一个数据节点 （因为 head 是虚拟节点）            // 然后再尝试获取资源            if (p == head &amp;&amp; tryAcquire(arg)) &#123;                // 获取成功之后 将头指针指向当前节点                setHead(node);                 p.next = null; // help GC                failed = false;                return interrupted;            &#125;            // p 不是头节点， 或者 头节点未能获取到资源 （非公平情况下被别的节点抢占）             // 判断 node 是否要被阻塞，获取不到锁就会一直阻塞            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())                interrupted = true;        &#125;    &#125; finally &#123;        if (failed)            cancelAcquire(node);    &#125;&#125;</code></pre><p>这里就是 AQS 的逻辑了，同样可以阅读 <a href="https://mp.weixin.qq.com/s/u-0aRcTTsQNzkkMhoJP0lQ">AQS</a> 的相关介绍。</p><blockquote><ol><li>不断获取本节点的上一个节点是否为 head，因为 head 是虚拟节点，如果当前节点的上一个节点是 head 节点，则当前节点为 <code>第一个数据节点&gt;</code>；</li><li>第一个数据节点不断的去获取资源，获取成功，则将 head 指向当前节点；</li><li>当前节点不是头节点，或者 <code>tryAcquire(arg)</code> 失败（失败可能是非公平锁）。这时候需要判断前一个节点状态决定<code>当前节点是否要被阻塞</code>（前一个节点状态是否为 SIGNAL）。</li></ol></blockquote><p>值得注意的是，当节点放到 AQS 的同步队列时，也是进行争抢资源，同时设置 <code>savedState</code> 的值，这个值则是代表当初释放锁的时候释放了多少重入次数。</p><p>总体流程画图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/condition-await-q4EBQx.png" alt="condition-await-q4EBQx"></p><h4 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h4><pre><code class="java">public final void signal() &#123;    // 是否为当前持有线程    if (!isHeldExclusively())        throw new IllegalMonitorStateException();    Node first = firstWaiter;    if (first != null)        doSignal(first);&#125;private void doSignal(Node first) &#123;    do &#123;        // firstWaiter 头节点指向条件队列头的下一个节点        if ( (firstWaiter = first.nextWaiter) == null)            lastWaiter = null;        // 将原来的头节点和同步队列断开        first.nextWaiter = null;    &#125; while (!transferForSignal(first) &amp;&amp;                (first = firstWaiter) != null);&#125;final boolean transferForSignal(Node node) &#123;    // 判断节点是否已经在之前被取消了    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))        return false;    // 调用 enq 添加到 同步队列的尾部    Node p = enq(node);    int ws = p.waitStatus;    // node 的上一个节点 修改为 SIGNAL 这样后续就可以唤醒自己了    if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))        LockSupport.unpark(node.thread);    return true;&#125;</code></pre><p>enq 同样可以阅读 <a href="https://mp.weixin.qq.com/s/u-0aRcTTsQNzkkMhoJP0lQ">AQS</a> 的代码 </p><pre><code class="java">private Node enq(final Node node) &#123;    for (;;) &#123;        Node t = tail;        // 尾节点为空 需要初始化头节点，此时头尾节点是一个        if (t == null) &#123; // Must initialize            if (compareAndSetHead(new Node()))                tail = head;        &#125; else &#123;            // 不为空 循环赋值            node.prev = t;            if (compareAndSetTail(t, node)) &#123;                t.next = node;                return t;            &#125;        &#125;    &#125;&#125;</code></pre><p>通过 enq 方法将节点放到 AQS 的同步队列之后，要将 node 的前一个节点的 waitStatus 设置为 Node.SIGNAL。signalAll 的代码也是类似。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h4><p><strong>Q: Condition 和 AQS 有什么关系？</strong></p><p><strong>A:</strong> Condition 是基于 AQS 实现的，Condition 的实现类 ConditionObject 是 AQS 的一个内部类，在里面共用了一部分 AQS 的逻辑。</p><p><strong>Q: Condition 的实现原理是什么？</strong></p><p><strong>A:</strong> Condition 内部维护一个条件队列，在获取锁的情况下，线程调用 await，线程会被放置在条件队列中并被阻塞。直到调用 signal、signalAll 唤醒线程，此后线程唤醒，会放入到 AQS 的同步队列，参与争抢锁资源。</p><p><strong>Q: Condition 的等待队列和 AQS 的同步队列有什么区别和联系？</strong><br><strong>A:</strong> Condition 的等待队列是单向链表，AQS 的是双向链表。二者之间并没有什么明确的联系。仅仅在节点从阻塞状态被唤醒后，会从等待队列挪到同步队列中。</p><h4 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h4><p>本文主要是阅读 Condition 的相关代码，不过省略了线程中断等逻辑。有兴趣的小伙伴。可以更深入的研究相关的源码。</p>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码笔记 </tag>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JDK源码笔记】- 基于数组的有界阻塞队列 —— ArrayBlockingQueue</title>
      <link href="2020/09/27/source-code-arrayblockingqueue.html"/>
      <url>2020/09/27/source-code-arrayblockingqueue.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>前言</strong></p><br><p>在阅读完和 AQS 相关的锁以及同步辅助器之后，来一起阅读 JUC 下的和队列相关的源码。先从第一个开始：ArrayBlockingQueue。</p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>由数组支持的有界BlockingQueue阻塞队列。</p><p>这个队列的命令元素FIFO（先入先出）。 队列的头是元素一直在队列中时间最长。 队列的尾部是该元素已经在队列中的时间最短。 新元素插入到队列的尾部，并且队列检索操作获取在队列的头部元素。</p><p>这是一个典型的“有界缓冲区”，在其中一个固定大小的数组保持由生产者插入并受到消费者的提取的元素。 一旦创建，容量不能改变。 试图put 一个元素到一个满的队列将导致操作阻塞; 试图 take 从空队列一个元素将类似地阻塞。</p><p>此类支持订购等待生产者和消费者线程可选的公平政策。 默认情况下，这个顺序不能保证。 然而，队列公平设置为构建 true 保证线程以FIFO的顺序进行访问。 公平性通常会降低吞吐量，但减少了可变性和避免饥饿。</p><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><pre><code class="java">public class ArrayBlockingQueueTest &#123;    private static final ArrayBlockingQueue&lt;String&gt; QUEUE = new ArrayBlockingQueue&lt;&gt;(10);    private static final CountDownLatch LATCH = new CountDownLatch(2);    public static void main(String[] args) &#123;        ExecutorService pool = new ThreadPoolExecutor(2, 2, 0L, TimeUnit.MILLISECONDS,                new LinkedBlockingQueue&lt;&gt;(1024),                new ThreadFactoryBuilder().setNameFormat(&quot;Thread-pool-%d&quot;).build(),                new ThreadPoolExecutor.AbortPolicy());        pool.submit(() -&gt; &#123;            for (int i = 0; i &lt; 100; i++) &#123;                try &#123;                    Thread.sleep(1000L);                    QUEUE.put(&quot;鸡蛋&quot; + Thread.currentThread().getName());                    System.out.println(&quot;put 放入元素&quot;);                &#125; catch (InterruptedException ignored) &#123;                &#125;            &#125;            LATCH.countDown();        &#125;);        pool.submit(() -&gt; &#123;            for (int i = 0; i &lt; 100; i++) &#123;                try &#123;                    Thread.sleep(500L);                    String take = QUEUE.take();                    System.out.println(&quot;take = &quot; + take);                &#125; catch (InterruptedException ignored) &#123;                &#125;            &#125;            LATCH.countDown();        &#125;);        try &#123;            LATCH.await();        &#125; catch (InterruptedException ignored) &#123;        &#125;        pool.shutdown();    &#125;&#125;</code></pre><p>demo 只是临时写的一个，很简单的版本。</p><h4 id="问题疑问"><a href="#问题疑问" class="headerlink" title="问题疑问"></a>问题疑问</h4><ol><li>ArrayBlockingQueue 的实现原理是什么？</li><li>入队列和出队列方法之间的区别是什么？</li></ol><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/ArrayBlockingQueue-uml-37BHBp.png" alt="ArrayBlockingQueue-uml-37BHBp"></p><h4 id="参数介绍"><a href="#参数介绍" class="headerlink" title="参数介绍"></a>参数介绍</h4><pre><code class="java">/** 数组 - 存储队列中的元素 */final Object[] items;/** 下一个 take, poll, peek or remove 的索引 */int takeIndex;/** 下一个 put, offer, or add 的索引 */int putIndex;/** 队列中的元素数 */int count;/** Main lock guarding all access */final ReentrantLock lock;/** take 操作时是否等待 */private final Condition notEmpty;/** put 操作时是否等待 */private final Condition notFull;</code></pre><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><pre><code class="java">public ArrayBlockingQueue(int capacity) &#123;    this(capacity, false);&#125;// 指定容量，及是否公平public ArrayBlockingQueue(int capacity, boolean fair) &#123;    if (capacity &lt;= 0)        throw new IllegalArgumentException();    this.items = new Object[capacity];    lock = new ReentrantLock(fair);    notEmpty = lock.newCondition();    notFull =  lock.newCondition();&#125;// 初始化的时候放入元素public ArrayBlockingQueue(int capacity, boolean fair,                            Collection&lt;? extends E&gt; c) &#123;    this(capacity, fair);    final ReentrantLock lock = this.lock;    lock.lock(); // Lock only for visibility, not mutual exclusion    try &#123;        int i = 0;        try &#123;            for (E e : c) &#123;                checkNotNull(e);                items[i++] = e;            &#125;        &#125; catch (ArrayIndexOutOfBoundsException ex) &#123;            throw new IllegalArgumentException();        &#125;        count = i;        putIndex = (i == capacity) ? 0 : i;    &#125; finally &#123;        lock.unlock();    &#125;&#125;</code></pre><h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><pre><code class="java">public boolean add(E e) &#123;    return super.add(e);&#125;// 父类的方法，其实调用的也是 offerpublic boolean add(E e) &#123;    if (offer(e))        return true;    else        throw new IllegalStateException(&quot;Queue full&quot;);&#125;// 使用锁public boolean offer(E e) &#123;    checkNotNull(e);    // 加锁    final ReentrantLock lock = this.lock;    lock.lock();    try &#123;        if (count == items.length)            return false;        else &#123;            enqueue(e);            return true;        &#125;    &#125; finally &#123;        lock.unlock();    &#125;&#125;// 放入元素， 如果队列满了，则等待public void put(E e) throws InterruptedException &#123;    checkNotNull(e);    final ReentrantLock lock = this.lock;    lock.lockInterruptibly();    try &#123;        while (count == items.length)            notFull.await();        enqueue(e);    &#125; finally &#123;        lock.unlock();    &#125;&#125;</code></pre><ol><li>add 方法：调用的是父类 AbstractQueue 的 add 方法，内部调用的是 offer 方法，如果 offer 返回 false，则抛出异常。</li><li>offer 方法：校验元素非空，加互斥锁，如果队列满了，则返回 false，如果队列未满，则调用 enqueue 方法，添加元素。</li><li>put 方法：校验元素非空，加互斥锁，如果队列满了，则一直自旋等待，队列未满则调用 enqueue 方法，添加元素。</li></ol><p>所以下面还是需要看一下 enqueue 方法：</p><pre><code class="java">// 只有在获取锁的时候才可以调用private void enqueue(E x) &#123;    // assert lock.getHoldCount() == 1;    // assert items[putIndex] == null;    final Object[] items = this.items;    // putIndex 下一个 put, offer, or add 的索引    // 对其进行赋值，然后进行 ++putIndex 操作    items[putIndex] = x;    // 如果等于长度，则指定为开始    if (++putIndex == items.length)        putIndex = 0;    // 对元素数进行 ++    count++;    // 有元素入队列，唤醒在等待获取元素的线程    notEmpty.signal();&#125;</code></pre><h4 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h4><pre><code class="java">public E poll() &#123;    final ReentrantLock lock = this.lock;    lock.lock();    try &#123;        return (count == 0) ? null : dequeue();    &#125; finally &#123;        lock.unlock();    &#125;&#125;public E take() throws InterruptedException &#123;    final ReentrantLock lock = this.lock;    lock.lockInterruptibly();    try &#123;        while (count == 0)            notEmpty.await();        return dequeue();    &#125; finally &#123;        lock.unlock();    &#125;&#125;</code></pre><p>通过源码可以看出：</p><ol><li>pool 和 take 都是从队列中获取元素，二者不同的是，当队列中没有元素时，poll 方法返回 null，而 take 方法会一直阻塞等待，直到从队列中获取到元素。</li><li>poll 和 take 方法获取元素都是调用的 dequeue 方法。</li></ol><pre><code class="java">private E dequeue() &#123;    // assert lock.getHoldCount() == 1;    // assert items[takeIndex] != null;    final Object[] items = this.items;    @SuppressWarnings(&quot;unchecked&quot;)    // 获取元素并将元素置为 null    E x = (E) items[takeIndex];    items[takeIndex] = null;    // takeIndex 下一个 take, poll, peek or remove 的索引    // 指向下一个元素，并且 元素数减少    if (++takeIndex == items.length)        takeIndex = 0;    count--;    // 更新迭代器状态    if (itrs != null)        itrs.elementDequeued();    // 唤醒等待放入元素的线程    notFull.signal();    return x;&#125;</code></pre><h4 id="查看元素"><a href="#查看元素" class="headerlink" title="查看元素"></a>查看元素</h4><pre><code class="java">public E peek() &#123;    final ReentrantLock lock = this.lock;    lock.lock();    try &#123;        return itemAt(takeIndex); // null when queue is empty    &#125; finally &#123;        lock.unlock();    &#125;&#125;</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h4><p><strong>Q: ArrayBlockingQueue 的实现原理？</strong></p><p><strong>A:</strong> ArrayBlockingQueue 是基于数组实现的，内部使用 ReentrantLock 互斥锁，防止并发放置元素或者取出元素的冲突问题。</p><p><strong>Q: 入队列和出队列方法之间的区别是什么？</strong></p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>add</td><td>添加元素，队列满了，添加失败抛出遗产</td></tr><tr><td>offer</td><td>添加元素， 队列满了，添加失败，返回 false</td></tr><tr><td>put</td><td>添加元素，队列满了，阻塞等待</td></tr><tr><td></td><td></td></tr><tr><td>poll</td><td>弹出元素，队列为空则返回 null</td></tr><tr><td>take</td><td>弹出元素，队列为空则等待队列中有元素</td></tr><tr><td></td><td></td></tr><tr><td>peek</td><td>查看队列中放入最早的一个元素</td></tr></tbody></table><h4 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h4><p>ArrayBlockingQueue 中使用了 ReentrantLock 互斥锁，在元素入队列和出队列的时候都进行了加锁，所以同时只会有一个线程进行入队列或者出队列，从而保证线程安全。</p>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码笔记 </tag>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JDK源码笔记】- 使用递增计数器的线程同步工具 —— 信号量，它的原理是什么样子的？</title>
      <link href="2020/09/21/source-code-semaphore.html"/>
      <url>2020/09/21/source-code-semaphore.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>前言</strong></p><br><p>在 JUC 中线程同步器除了 CountDownLatch 和 CycleBarrier ，还有一个叫做 Semaphore （信号量），同样是基于 AQS 实现的。下面来看看信号量的内部原理。</p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>一个计数信号量。 从概念上讲，信号量维护了一组许可。 如果有必要，在许可可用之前调用 acquire 方法会被阻塞，直到许可证可用。 调用 release 方法会增加了一个许可证，从而释放被阻塞的线程。 </p><ol><li>声明时指定初始许可数量。</li><li>调用 acquire(int permits) 方法，指定目标许可数量。</li><li>调用 release(int permits) 方法，发布指定的许可数量。</li></ol><p>在许可数量没有到达指定目标数量时，调用 acquire 方法的线程会被阻塞。</p><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><pre><code class="java">public class SemaphoreTest1 &#123;    private static final Semaphore SEMAPHORE = new Semaphore(0);    public static void main(String[] args) throws InterruptedException &#123;        ExecutorService pool = new ThreadPoolExecutor(5, 5, 0L, TimeUnit.MILLISECONDS,                new LinkedBlockingQueue&lt;&gt;(1024),                new ThreadFactoryBuilder().setNameFormat(&quot;Thread-pool-%d&quot;).build(),                new ThreadPoolExecutor.AbortPolicy());        for (int i = 0; i &lt; 5; i++) &#123;            pool.submit(() -&gt; &#123;                try &#123;                    Thread.sleep(1000 + new Random().nextInt(1000));                &#125; catch (InterruptedException ignored) &#123;                &#125;                System.out.println(&quot;当前线程: &quot; + Thread.currentThread().getName() + &quot; 发布一个许可&quot;);                SEMAPHORE.release(1);            &#125;);        &#125;        System.out.println(&quot;-----&gt; 这里是主线程&quot;);        SEMAPHORE.acquire(5);        System.out.println(&quot;-----&gt; 主线程执行完毕&quot;);        pool.shutdown();    &#125;&#125;</code></pre><pre><code class="bash">-----&gt; 这里是主线程当前线程: Thread-pool-2 发布一个许可当前线程: Thread-pool-4 发布一个许可当前线程: Thread-pool-1 发布一个许可当前线程: Thread-pool-0 发布一个许可当前线程: Thread-pool-3 发布一个许可-----&gt; 主线程执行完毕</code></pre><p>上面这个方法也是模拟了类似 CountDownLatch 的用法， 在子线程执行完毕之后，主线程继续执行。只不过 Semaphore 和 CountDownLatch 区别最大的是：</p><p>Semaphore 是从指定数值开始增加，直到到达许可数量，然后被阻塞线程开始继续执行。</p><p>CountDownLatch 是从指定数量的线程开始减少，直到为 0 时，被阻塞的线程开始继续执行。</p><p>当然这只是最简单的用法，除此让主线程等待，同样也可以让其他线程等待，然后再开始执行。</p><h4 id="问题疑问"><a href="#问题疑问" class="headerlink" title="问题疑问"></a>问题疑问</h4><ol><li>Semaphore 和 AQS 有什么关系？</li><li>Semaphore 和 CountDownLatch 有什么区别？</li></ol><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/Semaphore-cover-iGaTzJ.png" alt="Semaphore-cover-iGaTzJ"></p><p>通过类图可以看出在 Semaphore 里面有一个静态内部类 Sync 继承了 AQS，同时为了区分公平和非公平的情况，Sync 分别有两个子类：NonfairSync 、FairSync。</p><p>下面根据案例分别从构造函数、acquire()、release() 入手，从而了解内部实现原理。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><pre><code class="java">public Semaphore(int permits) &#123;    sync = new NonfairSync(permits);&#125;</code></pre><p>初始化默认非公平锁， 同时需要传入指定许可数， 可以看到这块代码是调用的 AQS 的 setState(permits) 方法。代码如下：</p><pre><code class="java">static final class NonfairSync extends Sync &#123;    private static final long serialVersionUID = -2694183684443567898L;    NonfairSync(int permits) &#123;        super(permits);    &#125;&#125;abstract static class Sync extends AbstractQueuedSynchronizer &#123;        private static final long serialVersionUID = 1192457210091910933L;        Sync(int permits) &#123;            setState(permits);        &#125; &#125;</code></pre><p>setState 方法其实就是对 AQS 的 state 进行赋值。</p><blockquote><p>补充</p><ol><li>在 ReentrantLock 中 state 代表加锁状态，0 没有线程获得锁，大于等于 1 已经有线程获得锁，大于 1 说明该获得锁的线程多次重入。</li><li>在 ReentrantReadWriteLock 中 state 代表锁的状态。state 为 0 ，没有线程持有锁，state 的高 16 为代表读锁状态，低 16 为代表写锁状态。通过位运算可以获取读写锁的实际值。</li><li>而在这里 （CountDownLatch）则代表门闩或者说计数的值。</li></ol></blockquote><p>如果对 state 有所遗忘，可以阅读前面的 AQS 、CAS 相关代码。 state 在这里代表的是信号量的许可数量。</p><h4 id="acquire"><a href="#acquire" class="headerlink" title="acquire()"></a>acquire()</h4><pre><code class="java">public void acquire() throws InterruptedException &#123;    sync.acquireSharedInterruptibly(1);&#125;public void acquire(int permits) throws InterruptedException &#123;    if (permits &lt; 0) throw new IllegalArgumentException();    sync.acquireSharedInterruptibly(permits);&#125;</code></pre><p>acquire() 和 acquire(int permits) 调用的都是 sync.acquireSharedInterruptibly(permits) 方法，只不过一个支持传递参数，一个默认为 1。</p><p>acquireSharedInterruptibly 方法，其实就是 Sync 继承自 AQS 的。</p><p>这块可以阅读 AQS 的文章，这里简单介绍下：</p><pre><code class="java">private void doAcquireSharedInterruptibly(int arg)    throws InterruptedException &#123;    final Node node = addWaiter(Node.SHARED);    boolean failed = true;    try &#123;        for (;;) &#123;            final Node p = node.predecessor();            if (p == head) &#123;                int r = tryAcquireShared(arg);                if (r &gt;= 0) &#123;                    setHeadAndPropagate(node, r);                    p.next = null; // help GC                    failed = false;                    return;                &#125;            &#125;            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;                parkAndCheckInterrupt())                throw new InterruptedException();        &#125;    &#125; finally &#123;        if (failed)            cancelAcquire(node);    &#125;&#125;</code></pre><ol><li>在失败后会使用 <code>doAcquireSharedInterruptibly(arg);</code> 不断获取资源；</li><li><code>final Node node = addWaiter(Node.SHARED);</code> 会创建节点以共享模式放到队列里；</li><li>在循环中不断判断前一个节点，如果是 head，则尝试获取共享资源；</li><li>在共享模式下获取到资源后会使用 <code>setHeadAndPropagate(node, r);</code> 设置头节点，同时唤醒后续节点。</li></ol><p>tryAcquireShared 是需要子类实现，也就是在 Semaphore.Sync 的实现类中实现了，这里以 FairSync 做讲解：</p><pre><code class="java">static final class FairSync extends Sync &#123;    private static final long serialVersionUID = 2014338818796000944L;    FairSync(int permits) &#123;        super(permits);    &#125;    protected int tryAcquireShared(int acquires) &#123;        for (;;) &#123;            // 如果前面有节点，则直接返回 -1 表示失败            if (hasQueuedPredecessors())                return -1;            // 获取当前信号量            int available = getState();            // 获取当前剩余量            int remaining = available - acquires;            // 如果小于 0 或者 CAS 设置信号量成功 则直接返回            if (remaining &lt; 0 ||                compareAndSetState(available, remaining))                return remaining;        &#125;    &#125;&#125;</code></pre><p>而这段代码的含义：</p><ol><li>如果前面有节点，则直接阻塞；</li><li>如果当前剩余信号量小于 0 ，则返回负值，直接阻塞；</li><li>如果当前剩余量大于等于 0 ，会 CAS 更新信号量，并返回非负数。</li></ol><blockquote><p>这块数值的含义，在 AQS 中定义了，含义如下：</p></blockquote><blockquote><ol><li>小于 0: 表示失败；</li><li>等于 0: 表示共享模式获取资源成功，但后续的节点不能以共享模式获取成功; </li><li>大于 0: 表示共享模式获取资源成功，后续节点在共享模式获取也可能会成功，在这种情况下，后续等待线程必须检查可用性。</li></ol></blockquote><h4 id="release"><a href="#release" class="headerlink" title="release()"></a>release()</h4><pre><code class="java">public void release() &#123;    sync.releaseShared(1);&#125;public void release(int permits) &#123;    if (permits &lt; 0) throw new IllegalArgumentException();    sync.releaseShared(permits);&#125;</code></pre><p>发布许可证的给定数量，该数量增加可用的许可数量。 看其内部调用的是 Sync 的 releaseShared， 其实就是 AQS 的对应方法：</p><pre><code class="java">public final boolean releaseShared(int arg) &#123;    if (tryReleaseShared(arg)) &#123;        doReleaseShared();        return true;    &#125;    return false;&#125;</code></pre><p>如果实现tryReleaseShared返回true，以共享模式释放资源。 其中的 tryReleaseShared 部分由 Semaphore.Sync 中实现，逻辑如下：</p><pre><code class="java">protected final boolean tryReleaseShared(int releases) &#123;    for (;;) &#123;        // 获取当前 state        int current = getState();        // 对 state 进行增加        int next = current + releases;        if (next &lt; current) // overflow            throw new Error(&quot;Maximum permit count exceeded&quot;);        // 使用 CAS 赋值        if (compareAndSetState(current, next))            return true;    &#125;&#125;</code></pre><p>通过上面代码可以看出，在 Semaphore 的 release 方法中主要就是对 state 进行增加，增加成功后会调用 AQS 的 doReleaseShared 方法唤醒头节点。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h4><p><strong>Q: 既然 Semaphore 也是基于 AQS， 那在 Semaphore 中 state 的含义代表什么？</strong><br><strong>A:</strong> 在 Semaphore 中 state 代表许可数量，acquire 方法当许可小于指定数量会阻塞线程，release 方法增加许可当许可增加成功则唤醒阻塞节点。</p><p><strong>Q: Semaphore 基于 AQS 具体是怎么实现的呢？</strong><br><strong>A:</strong> </p><ol><li>初始设置 state 的初始值，即初始许可数量。</li><li>acquire 方法设置目标数量，当目标数量大于当前数量时，会阻塞线程并将其放到阻塞队列中。此处基于 AQS 实现。</li><li>release 对 state 进行增加，成功后会调用 AQS 的 doReleaseShared 唤醒头结点。同样是基于 AQS 实现。</li></ol><p><strong>Q: Semaphore 和 CountDownLatch 有什么区别？</strong><br><strong>A:</strong> Semaphore 的计数器是递加的，而 CountDownLatch 是递减的。相同点就是计数器都不可以重置。</p><h4 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h4><p>在阅读 Semaphore 源码过程中，发现其主要功能都是基于 AQS 实现的，可以回顾阅读 AQS 的相关笔记。同样 Semaphore 也支持公平和非公平模式，这块就需要小伙伴自己去阅读啦。</p>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码笔记 </tag>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【工作笔记】- 你有没有想过为什么交易和退款要拆开不同的表？</title>
      <link href="2020/09/19/work-trans-refund-table.html"/>
      <url>2020/09/19/work-trans-refund-table.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>前言</strong></p><br><p>近期做新项目，在设计表结构的时候，突然想起来之前面试的时候遇到的一个问题，那时候也是初出茅庐，对很多东西一知半解（当然现在也是），当时那个小哥哥问我为什么交易和退款要拆成两个表？是基于什么考虑？有什么好处和优点么？</p></blockquote><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>那是一个风和日丽的下午，当然，风和日丽的下午应该配点其他的形容词，实在是我才疏学浅，只能用这个词充当了下开头…… （此处省略小五千字）</p><p>赶紧进入正文！</p><p>因为之前一直做<strong>聚合支付</strong>，而在使用过程中，也是支付和退款表拆开的，一直这么用，并没有觉得不妥。</p><p>比如一个交易表基本就是这样的：</p><table><thead><tr><th>字段</th><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>id</td><td>bigint</td><td>主键 id</td></tr><tr><td>trans_id</td><td>varchar</td><td>交易订单号</td></tr><tr><td>trans_amount</td><td>bigint</td><td>订单金额</td></tr><tr><td>trans_status</td><td>tinyint</td><td>交易状态</td></tr><tr><td>……</td><td>……</td><td>……</td></tr><tr><td>create_time</td><td>datetime</td><td>创建时间</td></tr><tr><td>update_time</td><td>datetime</td><td>更新时间</td></tr></tbody></table><p>退款表是这样子的：</p><table><thead><tr><th>字段</th><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>id</td><td>bigint</td><td>主键 id</td></tr><tr><td>refund_id</td><td>varchar</td><td>退款订单号</td></tr><tr><td>origin_trans_id</td><td>varchar</td><td>原始交易订单号</td></tr><tr><td>refund_status</td><td>tinyint</td><td>退款状态</td></tr><tr><td>refund_amount</td><td>bigint</td><td>退款金额</td></tr><tr><td>……</td><td>……</td><td>……</td></tr><tr><td>create_time</td><td>datetime</td><td>创建时间</td></tr><tr><td>update_time</td><td>datetime</td><td>更新时间</td></tr></tbody></table><p>大概两个表就是这样子的吧！像一些其他字段就先省略了，平常用着也觉得没什么。</p><p>但是恰好那次那个小哥哥就问了这个问题，支付和退款为什么要分开记录？</p><p>当时也是确实是实力不允许，我只是说了就是这么用的，把正向流程和逆向流程拆开，分开实现逻辑，比较方便。</p><h3 id="个人见解"><a href="#个人见解" class="headerlink" title="个人见解"></a>个人见解</h3><p>这里说的不仅仅是交易和退款，同时泛指正向交易和逆向交易，比如充值和消费，借款和贷款，账户出账入账等等，下面仅说说个人见解，<strong>只做讨论</strong>，如果小伙伴有更好的说法，希望可以留言指出，共同学习。</p><h4 id="对账需要"><a href="#对账需要" class="headerlink" title="对账需要"></a>对账需要</h4><p>对账户而言，出款表和入款表最后两方的金额是能对的上的，也就是说<strong>收支平衡</strong>。</p><p>当然这个记在一个表里也是完全可以的。毕竟对出入账只是流水没有状态变化，比如出账中，入账中，等等，流水表完全可以记在一个里面，然后用字段进行标识是出账还是入账。</p><h4 id="拆表需要"><a href="#拆表需要" class="headerlink" title="拆表需要"></a>拆表需要</h4><p>在网上看资料经常会说<strong>分库分表</strong>，而像订单这种（交易/退款）完全两种业务，使用两张表相对而言比较合适，毕竟<strong>交易</strong>的订单相比退款订单要多的多。</p><h4 id="字段设计"><a href="#字段设计" class="headerlink" title="字段设计"></a>字段设计</h4><p>交易和退款是完全不同的两种业务，不像账户流水就是资金记录。</p><p>交易除了订单状态还有一些交易信息比如商户号、优惠金额、实付金额、交易渠道、商品 id 名称、备注等各种信息。</p><p>退款则是根据原单进行退款，需要记录原始订单号、退款金额（部分退款）、退款信息等。</p><p>虽然交易和退款总体上都包含 订单号、状态、金额等，但是如果强行放在一个表，就会导致以下问题：</p><ol><li>很多字段为空的情况，比如交易不需要原始订单号，退款需要存储原始订单号。本来可以设置索引来提高查询效率的字段也不太合适设置了。</li><li>状态也不一定可以完全兼容，像交易状态和退款状态就很难互相兼容。</li></ol><h4 id="开发效率"><a href="#开发效率" class="headerlink" title="开发效率"></a>开发效率</h4><p>交易和退款分开之后，两个人负责不同的业务进行开发，包括业务逻辑和查询展示。如果放在一起，就很多字段不能保证别人知道有还是没有，是存储还是不存储，毕竟表里设置的都可以为空。这种情况下需要很多沟通，或者干脆一个人进行开发。</p><h4 id="设计模式及原则"><a href="#设计模式及原则" class="headerlink" title="设计模式及原则"></a>设计模式及原则</h4><p>其他从设计模式及原则的角度上来说，可以说是职责单一，当然再高大上偏理论的我这就扯不出来了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h4><p><strong>Q: 那前端要将两种甚至多种在一个列表展示该如何处理？</strong></p><p><strong>A:</strong> 在很多 APP 中大家看到的多种订单都是在一个列表里面展示出来的，比如：支付宝的账单页面。</p><p>当然，如果前端分 tab 页，分开展示不同的业务，那对后端来说简直不要太友好。不过实际往往不是这样，这时候就需要将订单统一存储。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/LDZJYc-IFUqcP.png" alt="LDZJYc-IFUqcP"></p><p>在订单成功的时候存储到一个公共存储中，可以通过 MQ 等，将数据保送到另一张表/库，或者 ES 中用来存储。这样订单查询还可以和业务逻辑的表/库分开。也可以通过 binlog 进行处理，这里的方案只做参考。</p><h4 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h4><p>之所以写这篇文章，也是为了总结一下最近工作中遇到的问题，以及处理方法。同时一瞬间想起来了很久前遇到的相同的问题。</p><p>如果小伙伴们还有别的看法，欢迎留言，发表自己的意见及看法，共同讨论。</p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JDK源码笔记】- CyclicBarrier 不就是比 CountDownLatch 多了个回环么？</title>
      <link href="2020/09/13/source-code-cyclicbarrier.html"/>
      <url>2020/09/13/source-code-cyclicbarrier.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>前言</strong></p><br><p>看完 CountDownLatch 正准备表示一番，突然看到了一个 CyclicBarrier —— 回环屏障。沃特？回环还屏障？说比 CountDownLatch 要多一个回环，那咱可得瞧一瞧，看一看了！</p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>一个同步辅助，它允许一组线程的所有等待彼此达成共同屏障点。 </p><p>CyclicBarrier 在涉及固定线程数且必须等待彼此的程序非常有用。 </p><p>该屏障被称为回环屏障 ，因为它在等待的线程被释放后可以被重新利用。</p><p>CyclicBarrier 支持一个可选的 Runnable 命令，该命令在障碍中的最后一个线程到达之后，但在释放任何线程之前，每个屏障点运行一次。</p><p>此屏障操作对于在任何一方继续之前更新共享状态很有用。</p><p>通过上面的源码注释基本可以得出以下结论：</p><ol><li>CyclicBarrier 和 CountDownLatch 类似，但它是一组线程等待，直到在其他线程中执行的一组操作完成为止。</li><li>CountDownLatch 是计数递减，结束后再调用 await 或者 countdown 都会立即返回，但是 CyclicBarrier 可以重置屏障。</li><li>CyclicBarrier 还可以传入参数 Runnable ，Runnable 会在释放线程之前执行。</li></ol><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>既然上面总结了三个结论，下面当然从三个方面演示如何使用的：</p><p><strong>- 屏障功能</strong> </p><pre><code class="java">public class CyclicBarrierTest &#123;    private static final CyclicBarrier CYCLIC_BARRIER = new CyclicBarrier(11);    public static void main(String[] args) throws BrokenBarrierException, InterruptedException &#123;        ExecutorService pool = new ThreadPoolExecutor(10, 10, 0L, TimeUnit.MILLISECONDS,                new LinkedBlockingQueue&lt;&gt;(1024),                new ThreadFactoryBuilder().setNameFormat(&quot;Thread-pool-%d&quot;).build(),                new ThreadPoolExecutor.AbortPolicy());        for (int i = 0; i &lt; 10; i++) &#123;            pool.submit(() -&gt; &#123;                try &#123;                    System.out.println(Thread.currentThread().getName() + &quot; 开始执行&quot;);                    Thread.sleep(5000);                    System.out.println(Thread.currentThread().getName() + &quot; 执行结束，准备调用 await&quot;);                    CYCLIC_BARRIER.await();                &#125; catch (InterruptedException | BrokenBarrierException e) &#123;                    e.printStackTrace();                &#125;            &#125;);        &#125;        System.out.println(&quot;主线程执行 —————————————— &gt;&gt;&gt;&quot;);        CYCLIC_BARRIER.await();        System.out.println(&quot;主线程继续执行 —————————————— &gt;&gt;&gt;&quot;);        pool.shutdown();    &#125;&#125;</code></pre><p>通过上面代码其实模拟了个类似 CountDownLatch 的功能，让所有线程等待，直到都调用 await 之后，各个线程继续执行，同时主线程也继续往下执行。</p><p>不过相对 CountDownLatch 的指定一个线程或多个等待，直到其他线程执行结束，等待的线程才继续执行来说，CyclicBarrier 相对来说还是逊色。</p><p>差别总结如下：</p><ol><li>CountDownLatch 是指定等待的线程，其他线程进行 countDown，等计数为 0 时，等待的线程继续执行。</li><li>CyclicBarrier 是一组线程调用 await 进行等待，当所有的都进入等待的时候，这一组就会一起冲破屏障继续执行。</li></ol><p><strong>- 回环功能</strong></p><pre><code class="java">public class CyclicBarrierTest2 &#123;    private static final CyclicBarrier CYCLIC_BARRIER = new CyclicBarrier(5);    public static void main(String[] args) throws BrokenBarrierException, InterruptedException &#123;        ExecutorService pool = new ThreadPoolExecutor(5, 5, 0L, TimeUnit.MILLISECONDS,                new LinkedBlockingQueue&lt;&gt;(1024),                new ThreadFactoryBuilder().setNameFormat(&quot;Thread-pool-%d&quot;).build(),                new ThreadPoolExecutor.AbortPolicy());        for (int i = 0; i &lt; 5; i++) &#123;            pool.submit(() -&gt; &#123;                try &#123;                    System.out.println(Thread.currentThread().getName() + &quot; 开始执行&quot;);                    CYCLIC_BARRIER.await();                    System.out.println(Thread.currentThread().getName() + &quot; 冲破屏障 &gt;&gt;&gt; 1&quot;);                    CYCLIC_BARRIER.await();                    System.out.println(Thread.currentThread().getName() + &quot; 冲破屏障 &gt;&gt;&gt;&gt;&gt; 2&quot;);                    CYCLIC_BARRIER.await();                &#125; catch (InterruptedException | BrokenBarrierException e) &#123;                    e.printStackTrace();                &#125;            &#125;);        &#125;        pool.shutdown();    &#125;&#125;</code></pre><p><img src="https://liuzhihang.com/oss/pic/article/carbon-gzpBD4.png" alt="carbon-gzpBD4"></p><p>上面演示的回环的用法。</p><p><strong>- 回环 Runnable</strong></p><p>这块只需要在声明的 CyclicBarrier 修改为以下即可：</p><pre><code class="java">private static final CyclicBarrier CYCLIC_BARRIER = new CyclicBarrier(5, new Runnable() &#123;    @Override    public void run() &#123;        System.out.println(&quot;执行一次 Runnable &quot;);    &#125;&#125;);</code></pre><p>打印结果如下：</p><p><img src="https://liuzhihang.com/oss/pic/article/carbon1-lHnKnA.png" alt="carbon1-lHnKnA"></p><p>可以看出只是在下一个计数开始之前，先执行 Runnable 。至于是不是在释放屏障之前，那很容易，直接 Debug 走一遭就知道了！专门录制了个视频：</p><p><img src="https://liuzhihang.com/oss/pic/article/cyclicBarrier-vl-5Bz3Xa.mov" alt="cyclicBarrier-vl-5Bz3Xa"></p><p>通过 debug 可以看出<strong>Runnable 会在释放线程之前执行</strong>。</p><h4 id="问题疑问？"><a href="#问题疑问？" class="headerlink" title="问题疑问？"></a>问题疑问？</h4><ol><li>CyclicBarrier 和 AQS 有什么关系？</li><li>CyclicBarrier 的实现原理是什么？</li><li>CyclicBarrier 是如何实现回环的？</li></ol><p>下面就带着疑问去源码阅读，一探究竟！</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><p><img src="https://liuzhihang.com/oss/pic/article/CleanShot-2020-09-12-KFzaCR0G@2x-seVhre.png" alt="CleanShot-2020-09-12-KFzaCR0G@2x-seVhre"></p><p>通过 UML 乍一看，CyclicBarrier 和 AQS 并无什么关系，那下面开始从<strong>参数</strong>、<strong>构造器</strong>、<strong>await()方法</strong>分别看源码。</p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><pre><code class="java">public class CyclicBarrier &#123;    /**     * 屏障的每次使用都表示为一个生成实例。     * broken 表示屏障是否被打破。     */    private static class Generation &#123;        boolean broken = false;    &#125;    /** 锁 */    private final ReentrantLock lock = new ReentrantLock();    /** 条件等待，直到屏障 */    private final Condition trip = lock.newCondition();    /** 等待计数 */    private final int parties;    /* The command to run when tripped */    private final Runnable barrierCommand;    /** 当前 generation 新创建的*/    private Generation generation = new Generation();    /** 仍在等待的 parties 数量，递减 为 0 会重置 */    private int count; &#125;</code></pre><p>通过上面可以看出：</p><p>内部使用了一个静态类 Generation ，它有什么功能呢？通过注释了解到，每次使用屏障的时候都会生成，具体有什么用，其实就是用来标示屏障是否被打破。</p><p>内部还有一个 parties 表示等待计数，count 表示仍在等待的计数。</p><p>那就继续往下看吧！</p><h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><pre><code class="java">public CyclicBarrier(int parties, Runnable barrierAction) &#123;    if (parties &lt;= 0) throw new IllegalArgumentException();    this.parties = parties;    this.count = parties;    this.barrierCommand = barrierAction;&#125;</code></pre><p>这里的入参有两个：</p><ul><li>parties（等待计数）：记录多少个线程调用 await 之后，才会一起打破屏障。</li><li>barrierAction：冲破屏障前执行的行为。</li><li>但是会同时对 parties 和 count 赋值为传入的 parties。</li></ul><p>单参数构造，其实就是将 barrierAction 赋值为 null。</p><h4 id="await-方法"><a href="#await-方法" class="headerlink" title="await() 方法"></a>await() 方法</h4><p>在示例中用的 <strong>await()</strong> 方法， 那就从 <strong>await()</strong> 方法入手：</p><pre><code class="java">public int await() throws InterruptedException, BrokenBarrierException &#123;    try &#123;        return dowait(false, 0L);    &#125; catch (TimeoutException toe) &#123;        throw new Error(toe); // cannot happen    &#125;&#125;</code></pre><p>await() 才是重头戏， 先来根据源码注释，了解是干嘛的，看看作者怎么讲：</p><ol><li>等到所有各方都在此障碍上调用await。</li><li>如果当前线程不是最后到达的线程，则出于线程调度目的将其禁用，并使其处于休眠状态，直到发生以下情况之一：<ol><li>最后一个线程到达；</li><li>其他一些线程中断当前线程；</li><li>其他一些线程中断其他正在等待的线程之一；</li><li>等待屏障的时候其他线程超时；</li><li>其他一些线程在此屏障上调用 reset。</li></ol></li></ol><p>看到这些，咱们最想看的当然是 2.1 ，等待最后一个线程到达屏障，之后所有的线程一起继续执行。</p><pre><code class="java">private int dowait(boolean timed, long nanos)    throws InterruptedException, BrokenBarrierException,            TimeoutException &#123;    // 加锁    final ReentrantLock lock = this.lock;    lock.lock();    try &#123;        // 在这里用到了这个代        final Generation g = generation;        if (g.broken)            throw new BrokenBarrierException();        // 线程终中断标示        if (Thread.interrupted()) &#123;            breakBarrier();            throw new InterruptedException();        &#125;        // 对计数进行递减        int index = --count;        // 如果是 0 则        if (index == 0) &#123;  // tripped            boolean ranAction = false;            try &#123;                final Runnable command = barrierCommand;                // 不是 null 先执行行为                if (command != null)                    // 这里不是新开线程                    command.run();                ranAction = true;                // 下一代                nextGeneration();                return 0;            &#125; finally &#123;                // 任务未成功时，即 ranAction 还是 false 打破屏障                if (!ranAction)                    breakBarrier();            &#125;        &#125;        // loop until tripped, broken, interrupted, or timed out        // 自旋        for (;;) &#123;            try &#123;                // 没有设置超时时间                if (!timed)                // 进入等待                    trip.await();                else if (nanos &gt; 0L)                    nanos = trip.awaitNanos(nanos);            &#125; catch (InterruptedException ie) &#123;                if (g == generation &amp;&amp; ! g.broken) &#123;                    breakBarrier();                    throw ie;                &#125; else &#123;                    Thread.currentThread().interrupt();                &#125;            &#125;            if (g.broken)                throw new BrokenBarrierException();            // 已经下一代了            if (g != generation)                return index;            if (timed &amp;&amp; nanos &lt;= 0L) &#123;                breakBarrier();                throw new TimeoutException();            &#125;        &#125;    &#125; finally &#123;        lock.unlock();    &#125;&#125;</code></pre><p>这一大坨代码，完全没有看的欲望，直接划过去吧！</p><p>所以…… 直接看到了这里吧。</p><p>代码还是要阅读的，分开来看（异常流程省略）：</p><ol><li>使用了 ReentrantLock 互斥锁，因此对 count、broken 的修改是原子性的。</li><li>对 count 进行 –count 操作，这样就理解为什么说 count 是仍在等待的计数，或者说还有多少才能到达屏障点。</li><li>当 count 为 0 ，表示到达屏障点了<ol><li><img src="https://liuzhihang.com/oss/pic/article/cyclicbarrier-amQMu4.png" alt="cyclicbarrier-amQMu4"></li><li>command 不为 null，会先执行 **command.run()**， 值得注意的是这里并不是新开了个线程。</li><li>**nextGeneration()**开始新的下一代，即重置 count 为 parties。</li><li>在 finally 里面使用 <strong>breakBarrier()</strong> 打破屏障。</li></ol></li><li>当 count 不是 0<ol><li>自旋，直到是 0.</li></ol></li></ol><p>这后面还有两个方法不能少：</p><pre><code class="java">private void nextGeneration() &#123;    // 唤醒线程    trip.signalAll();    // 更新 count 为 parties    count = parties;    // 更新 Generation    generation = new Generation();&#125;</code></pre><pre><code class="java">// 打破屏障，并唤醒全部private void breakBarrier() &#123;    generation.broken = true;    count = parties;    trip.signalAll();&#125;</code></pre><h4 id="reset"><a href="#reset" class="headerlink" title="reset()"></a>reset()</h4><pre><code class="java">public void reset() &#123;    final ReentrantLock lock = this.lock;    lock.lock();    try &#123;        breakBarrier();   // break the current generation        nextGeneration(); // start a new generation    &#125; finally &#123;        lock.unlock();    &#125;&#125;</code></pre><p>将屏障重置为其初始状态，reset() 方法其实还是调用的 breakBarrier() 和 nextGeneration()，前者时打破当前代，后者是开始新的一轮。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>Q: CyclicBarrier 和 AQS 有什么关系？</strong><br><strong>A:</strong> 通过阅读源码，其实发现是使用了 ReentrantLock 互斥锁 以及 Condition 的等待唤醒功能。</p><p><strong>Q: CyclicBarrier 的实现原理是什么？</strong><br><strong>A:</strong> 内部含有两个计数，分别是 parties 和 count ，初始是二者相等，当有线程调用 await() 时，count 递减，只要 count 不为 0 ， 就会阻塞线程，直到 count 递减为 0 时，此时会所有线程一起释放，同时将 count 重置为 parties。</p><p><strong>Q: CyclicBarrier 是如何实现回环的？</strong><br><strong>A:</strong> 使用两个计数，count 递减，当 count 为 0 时，会重置为 parties，从而达到回环效果。</p><p><strong>Q: 为什么 count 的 –count 操作没有使用 CAS？</strong><br><strong>A:</strong> 因为已经 lock.lock() 了，使用了 ReentrantLock 锁能够保证 count 的原子性。</p><h4 id="CyclicBarrier-和-CountDownLatch-的区别"><a href="#CyclicBarrier-和-CountDownLatch-的区别" class="headerlink" title="CyclicBarrier 和 CountDownLatch 的区别"></a>CyclicBarrier 和 CountDownLatch 的区别</h4><ol><li>回环：CyclicBarrier 可以回环，重新计数。CountDownLatch 只能一轮。</li><li>计数器：CyclicBarrier 的计数器自己维护递减， CountDownLatch 的计数器维护则是交给使用者。</li><li>阻塞线程：CyclicBarrier 阻塞的是自身，当到达屏障后，所有被阻塞的线程一起释放。CountDownLatch 可以指定阻塞线程。</li></ol><h4 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h4><p>本文主要介绍了 CyclicBarrier 的常用方式，通过源码方式，分析如何达到屏障以及回环的效果。不对之处，请多指正。</p>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码笔记 </tag>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【工具册】- 给大家介绍下，这是我的流程图软件 —— draw.io</title>
      <link href="2020/09/06/source-tool-drawio.html"/>
      <url>2020/09/06/source-tool-drawio.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>前言</strong></p><br><p>之前推了一篇文章《<a href="https://mp.weixin.qq.com/s/Ktjcc_7XCPx6fU4Zn8Tmlg">十张图带大家看懂 ES 原理 ！明白为什么说：ES 是准实时的！</a>》，很多小伙伴都比较好奇在文章中的图是用的什么画图软件？看那么明显的手绘风格，当然是手画的啦！（开玩笑），其实我用的是 draw.io ，下面分享我的画图软件 —— draw.io 。</p></blockquote><h3 id="为什么需要画图？"><a href="#为什么需要画图？" class="headerlink" title="为什么需要画图？"></a>为什么需要画图？</h3><p>俗话说：“一图顶百字！”，好吧！这是我现想的俗话。</p><p>在新项目开发，技术分享，阅读代码笔记，或者面试的时候，画个流程图，架构图等等，比较直观，便于理解等。优点啥的就不多介绍了，这里主要介绍我的画图软件。</p><h4 id="基本要求"><a href="#基本要求" class="headerlink" title="基本要求"></a>基本要求</h4><ol><li>免费</li><li>使用方便</li><li>支持离线使用</li></ol><h4 id="用过的其他软件"><a href="#用过的其他软件" class="headerlink" title="用过的其他软件"></a>用过的其他软件</h4><ol><li>Visio：使用方便，在最开始的时候就是使用 Visio，不过只能在 Win 系统上使用。</li><li>ProcessOn：在线版，使用方便，很简洁。个人免费，不过限制文件数量。</li><li>OmniGraffle：Mac 客户端，收费，有很多功能，不过对我来说有点玩不熟练。</li><li>语雀：语雀也支持画简单的流程图。</li><li>其他一些，暂时没想起来的。</li></ol><p>体验了很多画图软件，最后还是（暂时）选择了 draw.io 。 原因很简单，支持多平台（网页/Win/Mac/Linux），开源免费，文件存储在本地，也可以选择存储位置。</p><p>下面简单介绍下 draw.io</p><h3 id="draw-io"><a href="#draw-io" class="headerlink" title="draw.io"></a>draw.io</h3><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>在线版可以直接访问 <a href="https://draw.io/">https://draw.io</a> 或者 <a href="https://app.diagrams.net/">https://app.diagrams.net/</a> 使用，进去之后如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/draw-web-FlEHBo.png" alt="draw-web-FlEHBo"></p><p>可以选择存储，当然也有离线版本，即 drawio-desktop ，下载地址：<a href="https://github.com/jgraph/drawio-desktop">https://github.com/jgraph/drawio-desktop</a></p><p>选择对应的平台下载安装即可：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/drawio-desktop-nj8Mpy.png" alt="drawio-desktop-nj8Mpy"></p><h4 id="设置语言"><a href="#设置语言" class="headerlink" title="设置语言"></a>设置语言</h4><p>打开 app 或者 进入 app 之后可以设置语言，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/drawio-desktop-1-sIyT2d.png" alt="drawio-desktop-1-sIyT2d"></p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/drawio-desktop-2-qmJ3XA.png" alt="drawio-desktop-2-qmJ3XA"></p><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p>都已经到这里了，就不用说怎么使用的了吧！下面展示之前画的图：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/draw-1-slJldy.png" alt="draw-1-slJldy"></p><h4 id="手绘风格"><a href="#手绘风格" class="headerlink" title="手绘风格"></a>手绘风格</h4><p>那手绘风格是怎么画的呢？</p><p>秘籍就在右侧工具栏，选中 Sketch 选项，之后图片就会变为手绘风格的了！</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/draw-2-smWIKE.png" alt="draw-2-smWIKE"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本篇文章主要分享我常用的画图软件，有兴趣的小伙伴可以使用试一下。软件万万千，自己用的顺手的才是最重要的。不过 draw.io 还是比较推荐的。</p><p>后续我也会分享一些其他软件工具等，有兴趣的小伙伴可以关注以下。如果有什么比较有趣或生产力软件都可以给推荐下。</p>]]></content>
      
      
      <categories>
          
          <category> 工具册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具册 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JDK源码笔记】- 快来看看！AQS 和  CountDownLatch 有怎么样的关系？</title>
      <link href="2020/09/06/source-code-countdownlatch.html"/>
      <url>2020/09/06/source-code-countdownlatch.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>前言</strong></p><br><p>CountDownLatch 一个同步辅助工具，同样是基于 AQS 实现，本篇文件主要是介绍 CountDownLatch 的使用，以及源码。</p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>一个同步辅助工具，允许一个或多个线程等待，直到在其他线程中执行的一组操作完成为止</p><p>一个 CountDownLatch 初始化为给定计数。 在 await 方法阻塞，调用 countDown 方法会减少计数直到达到零，此后所有等待的线程被释放，任何后续调用 await 都会立即返回。 这是一次性的现象 - 计数不能复位。 如果你需要一个版本重置计数，请考虑使用CyclicBarrier 。</p><p>CountDownLatch 是一种通用的同步工具，可用于多种用途。 </p><ol><li>用作一个简单的开/关锁存器，或者门：所有线程调用await在门口等待，直到被调用 countDown 的线程打开。 </li><li>初始化计数为 N ，用一个线程等待，直到 N 个线程完成某项操作，或某些动作已经完成 N 次。</li></ol><p>CountDownLatch 一个有用的属性是，它不要求调用 countDown 线程等待计数到达零之前继续，它只是阻止任何线程通过await ，直到所有线程可以通过。</p><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>在我之前 CAS 那篇文章《<a href="https://mp.weixin.qq.com/s/nSZW-bZ_snQ0ZYyzeEBJiw">从JUC源码看CAS，我做了个笔记 ……</a>》中介绍 CAS 举例时使用了 CountDownLatch，其代码如下：</p><pre><code class="java">public class CasTest &#123;    private static final CountDownLatch LATCH = new CountDownLatch(10);    private static int NUM_I = 0;    private static volatile int NUM_J = 0;    private static final AtomicInteger NUM_K = new AtomicInteger(0);    public static void main(String[] args) throws InterruptedException &#123;        ExecutorService threadPool = Executors.newFixedThreadPool(10);        for (int i = 0; i &lt; 10; i++) &#123;            threadPool.execute(new Runnable() &#123;                public void run() &#123;                    for (int j = 0; j &lt; 10000; j++) &#123;                        NUM_I++;                        NUM_J++;                        NUM_K.incrementAndGet();                    &#125;                    LATCH.countDown();                &#125;            &#125;);        &#125;        LATCH.await();        System.out.println(&quot;NUM_I = &quot; + NUM_I);        System.out.println(&quot;NUM_J = &quot; + NUM_J);        System.out.println(&quot;NUM_K = &quot; + NUM_K.get());        threadPool.shutdown();    &#125;&#125;</code></pre><p>简单介绍下这段代码的主要逻辑及功能：</p><ol><li>CountDownLatch 初始化计数为 10 。</li><li>开 10 个线程去处理业务逻辑，业务逻辑结束会调用 LATCH.countDown() 对计数进行 -1 操作。</li><li>在 LATCH.await() 处会阻塞等待，直到 LATCH 的值为 0 ，即 10 个线程业务都处理结束。</li><li>然后主线程继续执行。</li></ol><h4 id="问题疑问"><a href="#问题疑问" class="headerlink" title="问题疑问"></a>问题疑问</h4><ol><li>CountDownLatch 和 AQS 有什么关系？</li><li>CountDownLatch 的实现原理是什么？</li></ol><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/uml-VAGlMb.png" alt="uml-VAGlMb"></p><p>通过类图可以看出，CountDownLatch 内部存在一个静态类 Sync，而 Sync 继承了 AbstractQueuedSynchronizer。具体内部是如何实现的，则下面通过源码和画图一步一步的进行介绍。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><pre><code class="java">public CountDownLatch(int count) &#123;    if (count &lt; 0) throw new IllegalArgumentException(&quot;count &lt; 0&quot;);    this.sync = new Sync(count);&#125;</code></pre><p>通过初始化构造器可以看出，在 new 创建对象时必须传递一个 int 类型的非负数。实现逻辑可以看出，是创建了一个 Sync 对象。</p><pre><code class="java">private static final class Sync extends AbstractQueuedSynchronizer &#123;    private static final long serialVersionUID = 4982264981922014374L;    Sync(int count) &#123;        setState(count);    &#125;    int getCount() &#123;        return getState();    &#125;&#125;   </code></pre><p>之前在介绍 AQS 源码中已经介绍了 state 的含义，state 在不同子类中代表不同的含义。</p><ol><li>在 ReentrantLock 中 state 代表加锁状态，0 没有线程获得锁，大于等于 1 已经有线程获得锁，大于 1 说明该获得锁的线程多次重入。</li><li>在 ReentrantReadWriteLock 中 state 代表锁的状态。state 为 0 ，没有线程持有锁，state 的高 16 为代表读锁状态，低 16 为代表写锁状态。通过位运算可以获取读写锁的实际值。</li><li>而在这里 （CountDownLatch）则代表门闩或者说计数的值。</li></ol><h4 id="countDown"><a href="#countDown" class="headerlink" title="countDown"></a>countDown</h4><pre><code class="java">public void countDown() &#123;    sync.releaseShared(1);&#125;</code></pre><p>递减锁存器的计数：</p><ul><li>如果当前计数大于零，则递减。 </li><li>如果计数到达零，则释放所有等待的线程。</li><li>如果那么当前计数等于零没有任何反应。</li></ul><p>此处调用的是 AQS 的 releaseShard() 方法，释放共享资源。</p><pre><code class="java">// AQS 代码public final boolean releaseShared(int arg) &#123;    if (tryReleaseShared(arg)) &#123;        doReleaseShared();        return true;    &#125;    return false;&#125;</code></pre><p>在 AQS 释放共享资源方法中 <strong>tryReleaseShared(arg)</strong> 部分是在 CountDownLatch 的内部类 Sync 中实现的，代码部分如下：</p><pre><code class="java">protected boolean tryReleaseShared(int releases) &#123;    // Decrement count; signal when transition to zero    for (;;) &#123;        int c = getState();        if (c == 0)            return false;        int nextc = c-1;        if (compareAndSetState(c, nextc))            return nextc == 0;    &#125;&#125;</code></pre><p>递减更新 state ，如果 state 为 0 则返回 false，否则返回 true 。</p><p>此时再对照上面 AQS 代码，发现：如果 tryReleaseShared 返回 true ，则会唤醒后续节点开始执行操作。所以也就是说，如果 state 不为 0，则不会唤醒后续节点，直到 state 为 0 。</p><h4 id="await"><a href="#await" class="headerlink" title="await"></a>await</h4><pre><code class="java">public void await() throws InterruptedException &#123;    sync.acquireSharedInterruptibly(1);&#125;</code></pre><p>导致当前线程等待，直到锁存器倒计数至零，除非线程被中断。</p><ul><li><p>如果当前计数为零，则此方法立即返回。</p></li><li><p>如果当前计数大于零，则当前线程用于线程调度目的，禁用并一直处于休眠状态的两件事情之一发生：</p><ul><li>因调用countDown方法使计数达到0; </li><li>其他某些线程中断当前线程。</li></ul></li></ul><pre><code class="java">public final void acquireSharedInterruptibly(int arg)        throws InterruptedException &#123;    if (Thread.interrupted())        throw new InterruptedException();    if (tryAcquireShared(arg) &lt; 0)        doAcquireSharedInterruptibly(arg);&#125;</code></pre><p>AQS 定义了 tryAcquireShared 返回值分为 3 种：</p><ol><li>小于 0: 表示失败；</li><li>等于 0: 表示共享模式获取资源成功，但后续的节点不能以共享模式获取成功; </li><li>大于 0: 表示共享模式获取资源成功，后续节点在共享模式获取也可能会成功，在这种情况下，后续等待线程必须检查可用性。</li></ol><p>其中 tryAcquireShared 同样由 CountDownLatch 的内部类 Sync 中实现，内部逻辑主要是判断 state 的值，进行返回。</p><p>在内部实现中返回的值只有 1 和 -1 ，说明在 state == 0 时，返回 1 ，即唤醒后续节点。不等于 0 时，会阻塞。</p><pre><code class="java">protected int tryAcquireShared(int acquires) &#123;    return (getState() == 0) ? 1 : -1;&#125;</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>Q: CountDownLatch 和 AQS 有什么关系？</strong></p><p><strong>A:</strong> CountDownLatch 是基于 AQS 的共享模式实现的。</p><p><strong>Q: CountDownLatch 的实现原理是什么？</strong></p><p><strong>A:</strong> 可以参考上面的源码解析，进行总结介绍。 CountDownLatch 是基于 AQS 共享模式实现的，在初始化时必须传入计数，该计数实际上是 AQS 的 state 值。在 countDown 时对 state 进行递减，在 当 state 为 0 时 会唤醒 AQS 队列中的所有等待的节点 （因为是共享模式）。而 await 方法是判断 state 的值，如果不是 0 ，则所有线程在队列中阻塞，等待唤醒。</p><p><strong>Q: state 在代表的含义是什么？</strong><br><strong>A:</strong> </p><ol><li>在 ReentrantLock 中 state 代表加锁状态，0 没有线程获得锁，大于等于 1 已经有线程获得锁，大于 1 说明该获得锁的线程多次重入。</li><li>在 ReentrantReadWriteLock 中 state 代表锁的状态。state 为 0 ，没有线程持有锁，state 的高 16 为代表读锁状态，低 16 为代表写锁状态。通过位运算可以获取读写锁的实际值。</li><li>而在这里 （CountDownLatch）则代表门闩或者说计数的值。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码笔记 </tag>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Elasticsearch 技术分享】—— 十张图带大家看懂 ES 原理 ！明白为什么说：ES 是准实时的！</title>
      <link href="2020/08/29/technology-sharing-es-5.html"/>
      <url>2020/08/29/technology-sharing-es-5.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>前言</strong></p><br><p>说到 Elasticsearch ，其中最明显的一个特点就是 <em>near real-time</em> 准实时 —— 当文档存储在Elasticsearch中时，将在1秒内以几乎实时的方式对其进行索引和完全搜索。那为什么说 ES 是准实时的呢？</p></blockquote><h3 id="Lucene-和-ES"><a href="#Lucene-和-ES" class="headerlink" title="Lucene 和 ES"></a>Lucene 和 ES</h3><h4 id="Lucene"><a href="#Lucene" class="headerlink" title="Lucene"></a>Lucene</h4><p>Lucene 是 Elasticsearch所基于的 Java 库，它引入了按段搜索的概念。</p><p>Segment： 也叫段，类似于倒排索引，相当于一个数据集。</p><p>Commit point：提交点，记录着所有已知的段。</p><p>Lucene index： “a collection of segments plus a commit point”。由一堆 Segment 的集合加上一个提交点组成。</p><p>对于一个 Lucene index 的组成，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/lucene-woYwZZ.png" alt="lucene-woYwZZ"></p><h4 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h4><p>一个 Elasticsearch Index 由一个或者多个 shard （分片） 组成。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/es-shard-TjHfGE.png" alt="es-shard-TjHfGE"></p><p>而 Lucene 中的 Lucene index 相当于 ES 的一个 shard。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/es-shard-lucene-5CpsYR.png" alt="es-shard-lucene-5CpsYR"></p><h3 id="写入过程"><a href="#写入过程" class="headerlink" title="写入过程"></a>写入过程</h3><h4 id="写入过程-1-0-（不完善）"><a href="#写入过程-1-0-（不完善）" class="headerlink" title="写入过程 1.0 （不完善）"></a>写入过程 1.0 （不完善）</h4><ol><li>不断将 Document 写入到 In-memory buffer （内存缓冲区）。</li><li>当满足一定条件后内存缓冲区中的 Documents 刷新到磁盘。</li><li>生成新的 segment 以及一个 Commit point 提交点。</li><li>这个 segment 就可以像其他 segment 一样被读取了。</li></ol><p>画图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/es-write-1-L60ip2.png" alt="es-write-1-L60ip2"></p><p>将文件刷新到磁盘是非常耗费资源的，而且在内存缓冲区和磁盘中间存在一个高速缓存（cache），一旦文件进入到 cache 就可以像磁盘上的 segment 一样被读取了。</p><h4 id="写入过程-2-0"><a href="#写入过程-2-0" class="headerlink" title="写入过程 2.0"></a>写入过程 2.0</h4><ol><li>不断将 Document 写入到 In-memory buffer （内存缓冲区）。</li><li>当满足一定条件后内存缓冲区中的 Documents 刷新到 高速缓存（<strong>cache</strong>）。</li><li>生成新的 segment ，这个 segment 还在 cache 中。</li><li>这时候还没有 commit ，但是已经可以被读取了。</li></ol><p>画图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/es-write-2-CW97xV.png" alt="es-write-2-CW97xV"></p><p>数据从 buffer 到 cache 的过程是定期每秒刷新一次。所以新写入的 Document 最慢 1 秒就可以在 cache 中被搜索到。</p><p>而 Document 从 buffer 到 cache 的过程叫做 <strong>?refresh</strong> 。一般是 1 秒刷新一次，不需要进行额外修改。当然，如果有修改的需要，可以参考文末的相关资料。这也就是为什么说 Elasticsearch 是<strong>准实时</strong>的。</p><p>使文档立即可见：</p><pre><code class="Json">PUT /test/_doc/1?refresh&#123;&quot;test&quot;: &quot;test&quot;&#125;// 或者PUT /test/_doc/2?refresh=true&#123;&quot;test&quot;: &quot;test&quot;&#125;</code></pre><h4 id="Translog-事务日志"><a href="#Translog-事务日志" class="headerlink" title="Translog 事务日志"></a>Translog 事务日志</h4><p>此处可以联想 Mysql 的 binlog， ES 中也存在一个 translog 用来失败恢复。</p><ol><li>Document 不断写入到 In-memory buffer，此时也会追加 translog。</li><li>当 buffer 中的数据每秒 refresh 到 cache 中时，translog 并没有进入到刷新到磁盘，是持续追加的。</li><li>translog 每隔 5s 会 fsync 到磁盘。</li><li>translog 会继续累加变得越来越大，当 translog 大到一定程度或者每隔一段时间，会执行 flush。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/es-write-translog-1-L8RWwm.png" alt="es-write-translog-1-L8RWwm"></p><p>flush 操作会分为以下几步执行：</p><ol><li>buffer 被清空。</li><li>记录 commit point。</li><li>cache 内的 segment 被 fsync 刷新到磁盘。</li><li>translog 被删除。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/es-write-translog-2-BWnz3P.png" alt="es-write-translog-2-BWnz3P"></p><p>值得注意的是：</p><ol><li>translog 每 5s 刷新一次磁盘，所以故障重启，可能会丢失 5s 的数据。</li><li>translog 执行 flush 操作，默认 30 分钟一次，或者 translog 太大 也会执行。</li></ol><p>手动执行flush：</p><pre><code class="json">POST /my-index-000001/_flush</code></pre><h3 id="删除和更新"><a href="#删除和更新" class="headerlink" title="删除和更新"></a>删除和更新</h3><p>segment 不可改变，所以 docment 并不能从之前的 segment 中移除或更新。</p><p>所以每次 commit， 生成 commit point 时，会有一个 .del 文件，里面会列出被删除的 document（逻辑删除）。<br>而查询时，获取到的结果在返回前会经过 .del 过滤。</p><p>更新时，也会标记旧的 docment 被删除，写入到 .del 文件，同时会写入一个新的文件。此时查询会查询到两个版本的数据，但在返回前会被移除掉一个。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/es-del-1-nc0mKK.png" alt="es-del-1-nc0mKK"></p><h3 id="segment-合并"><a href="#segment-合并" class="headerlink" title="segment 合并"></a>segment 合并</h3><p>每 1s 执行一次 refresh 都会将内存中的数据创建一个 segment。</p><p>segment 数目太多会带来较大的麻烦。 每一个 segment 都会消耗文件句柄、内存和cpu运行周期。更重要的是，每个搜索请求都必须轮流检查每个 segment ；所以 segment 越多，搜索也就越慢。</p><p>在 ES 后台会有一个线程进行 segment 合并。</p><ol><li>refresh操作会创建新的 segment 并打开以供搜索使用。</li><li>合并进程选择一小部分大小相似的 segment，并且在后台将它们合并到更大的 segment 中。这并不会中断索引和搜索。</li><li>当合并结束，老的 segment 被删除 说明合并完成时的活动：<ol><li>新的 segment 被刷新（flush）到了磁盘。  写入一个包含新 segment 且排除旧的和较小的 segment的新 commit point。</li><li>新的 segment 被打开用来搜索。</li><li>老的 segment 被删除。</li></ol></li></ol><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/segment-merge-55A1b6.png" alt="segment-merge-55A1b6"></p><p>物理删除：</p><p>在 segment merge 这块，那些被逻辑删除的 document 才会被真正的物理删除。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>主要介绍了内部写入和删除的过程，需要了解 refresh、fsync、flush、.del、segment merge 等名词的具体含义。</p><p>完整画图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/all-FMAPTS.png" alt="all-FMAPTS"></p><p>以上就是个人分享的 ES 相关的内容，主要目的是组内技术分享，进行扫盲。不对之处，希望大家留言指正。</p><h4 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h4><ol><li>准实时搜索： <a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.9/near-real-time.html">https://www.elastic.co/guide/en/elasticsearch/reference/7.9/near-real-time.html</a></li><li>Refresh API：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.9/indices-refresh.html">https://www.elastic.co/guide/en/elasticsearch/reference/7.9/indices-refresh.html</a></li><li>Flush API：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.9/indices-flush.html">https://www.elastic.co/guide/en/elasticsearch/reference/7.9/indices-flush.html</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
          <category> ELK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作笔记 </tag>
            
            <tag> ELK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Elasticsearch 技术分享】—— ES 查询检索数据的过程，是什么样子的？</title>
      <link href="2020/08/26/technology-sharing-es-4.html"/>
      <url>2020/08/26/technology-sharing-es-4.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>前言</strong></p><br><p>ES 使用过程中常用的就是查询以及检索，那查询和检索的过程，什么样的呢？</p></blockquote><h3 id="查询流程"><a href="#查询流程" class="headerlink" title="查询流程"></a>查询流程</h3><pre><code class="json">GET my-index/_doc/0</code></pre><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/fJmmvi-T7hz9J.png" alt="fJmmvi-T7hz9J"></p><ol><li>Client 将请求发送到任意节点 node，此时 node 节点就是<strong>协调节点</strong>（coordinating node）。</li><li>协调节点对 id 进行路由，从而判断该数据在哪个shard。</li><li>在 primary shard 和 replica shard 之间 随机选择一个，请求获取 doc。</li><li>接收请求的节点会将数据返回给<strong>协调节点</strong>，协调节点会将数据返回给Client。</li></ol><p>可以通过 preference 参数指定执行操作的节点或分片。默认为随机。</p><h3 id="检索流程"><a href="#检索流程" class="headerlink" title="检索流程"></a>检索流程</h3><pre><code class="json">GET /my-index/_search </code></pre><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/w1lGEZ-TgHyvN.png" alt="w1lGEZ-TgHyvN"></p><ol><li>Client 将请求发送到任意节点 node，此时 node 节点就是<strong>协调节点</strong>（coordinating node）</li><li>协调节点进行分词等操作后，去查询所有的 shard （primary shard 和 replica shard 选择一个）</li><li>所有 shard 将满足条件的数据 id 排序字段 等信息返回给路由节点</li><li>路由节点重新进行排序，截取数据后，获取到真正需要返回的数据的 id</li><li>路由节点再次请求对应的 shard （此时有 id 了，可以直接定位到对应shard）</li><li>获取到全量数据，返回给 Client</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>主要介绍了 ES 查询以及检索的流程，不足及错误之处欢迎指正。</p><h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><ol><li>协调节点：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.9/modules-node.html#coordinating-node">https://www.elastic.co/guide/en/elasticsearch/reference/7.9/modules-node.html#coordinating-node</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
          <category> ELK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作笔记 </tag>
            
            <tag> ELK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Elasticsearch 技术分享】—— Elasticsearch 存储一条数据， put 过程是什么样子的？</title>
      <link href="2020/08/26/technology-sharing-es-3.html"/>
      <url>2020/08/26/technology-sharing-es-3.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>前言</strong></p><br><p>在前面已经介绍了 ES 中常用的一些名词，知道了数据是存储在 shard 中的，而 index 会映射一个或者多个 shard 。那这时候我要存储一条数据到某个索引下，这条数据是在哪个 index 下的呢？</p></blockquote><h3 id="ES-演示"><a href="#ES-演示" class="headerlink" title="ES 演示"></a>ES 演示</h3><p>一切按照官方教程使用 三条命令，在本机启动三个节点组装成伪集群。</p><pre><code class="bash">~  % &gt; ./elasticsearch~  % &gt; ./elasticsearch -Epath.data=data2 -Epath.logs=log2~  % &gt; ./elasticsearch -Epath.data=data3 -Epath.logs=log3</code></pre><h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><pre><code class="bash">curl -X PUT &quot;localhost:9200/my-index-000001?pretty&quot; -H &#39;Content-Type: application/json&#39; -d&#39;&#123;  &quot;settings&quot;: &#123;    &quot;index&quot;: &#123;      &quot;number_of_shards&quot;: 3,        &quot;number_of_replicas&quot;: 2     &#125;  &#125;&#125;&#39;</code></pre><p>当前版本 7.9</p><p>文档地址：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-create-index.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-create-index.html</a></p><p>ES 默认 number_of_shards 为 1<br>默认 number_of_replicas 为 1，即一个分片只有一个副本</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/put-index-0-dyP7ph.png" alt="put-index-0-dyP7ph"></p><p>下面命令可以查看索引信息</p><pre><code class="bash">curl -X GET &quot;localhost:9200/_cat/indices/my-index-000001?v&amp;s=index&amp;pretty&quot;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/put-index-1-VKKT73.png" alt="put-index-1-VKKT73"></p><h4 id="存放数据"><a href="#存放数据" class="headerlink" title="存放数据"></a>存放数据</h4><pre><code class="bash">curl -X PUT &quot;localhost:9200/my-index-000001/_doc/0825?pretty&quot; -H &#39;Content-Type: application/json&#39; -d&#39;&#123;  &quot;name&quot;: &quot;liuzhihang&quot;&#125;&#39;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/put-1-vJVlLn.png" alt="put-1-vJVlLn"></p><h4 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h4><pre><code class="bash">curl -X GET &quot;localhost:9200/my-index-000001/_doc/0825?pretty&quot;</code></pre><p>文档地址：<br><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-get.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-get.html</a></p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/put-2-JwDffk.png" alt="put-2-JwDffk"></p><h3 id="一条数据该存放在哪个-shard"><a href="#一条数据该存放在哪个-shard" class="headerlink" title="一条数据该存放在哪个 shard"></a>一条数据该存放在哪个 shard</h3><p>通过命令可以看出：在存放数据时并没有指定到哪个 shard，那数据是存在哪里的呢？</p><p>当一条数据进来，会默认会根据 id 做路由</p><pre><code>shard = hash(routing) % number_of_primary_shards</code></pre><p>从而确定存放在哪个 shard。 routing 默认是 _id， 也可以设置其他。</p><p>这个 id 可以自己指定也可以系统给生成, 如果不指定则会系统自动生成。</p><h3 id="put-一条数据的过程是什么样的？"><a href="#put-一条数据的过程是什么样的？" class="headerlink" title="put 一条数据的过程是什么样的？"></a>put 一条数据的过程是什么样的？</h3><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/OxOQ9V-S0Wt6P.png" alt="OxOQ9V-S0Wt6P"></p><p>写入过程主要分为三个阶段</p><ol><li>协调阶段：Client 客户端选择一个 node 发送 put 请求，此时当前节点就是<strong>协调节点</strong>（coordinating node）。协调节点根据 document 的 id 进行路由，将请求转发给对应的 node。这个 node 上的是 primary shard 。</li><li>主要阶段：对应的 primary shard 处理请求，写入数据 ，然后将数据同步到 replica shard。<ol><li>primary shard 会验证传入的数据结构</li><li>本地执行相关操作</li><li>将操作转发给 replica shard</li><li>当数据写入 primary shard 和 replica shard 成功后，路由节点返回响应给 Client。</li></ol></li><li>副本阶段：每个 replica shard 在转发后，会进行本地操作。</li></ol><p>在写操作时，默认情况下，只需要 primary shard 处于活跃状态即可进行操作。</p><p>在索引设置时可以设置这个属性</p><p>index.write.wait_for_active_shards</p><p>默认是 1，即 primary shard 写入成功即可返回。 </p><p>如果设置为 all 则相当于 number_of_replicas+1  就是 primary shard 数量 + replica shard 数量。 就是需要等待 primary shard 和 replica shard 都写入成功才算成功。</p><p>可以通过索引设置动态覆盖此默认设置。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="如何查看数据在哪个-shard-上呢？"><a href="#如何查看数据在哪个-shard-上呢？" class="headerlink" title="如何查看数据在哪个 shard 上呢？"></a>如何查看数据在哪个 shard 上呢？</h4><pre><code class="bash">curl -X GET &quot;localhost:9200/my-index-000001/_search_shards?routing=0825&amp;pretty&quot;</code></pre><p>通过上面命令可以查到数据 0825 的所在 shard。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/put-index-3-JIP0zD.png" alt="put-index-3-JIP0zD"></p><h4 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h4><ol><li>ES 创建索引：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-create-index.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-create-index.html</a></li><li>ES 查询数据：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-get.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-get.html</a></li><li>ES 检索 shard：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-shards.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/search-shards.html</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
          <category> ELK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作笔记 </tag>
            
            <tag> ELK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Elasticsearch 技术分享】—— ES 常用名词及结构</title>
      <link href="2020/08/23/technology-sharing-es-2.html"/>
      <url>2020/08/23/technology-sharing-es-2.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>前言</strong></p><br><p>看完什么是 Elasticsearch 以及了解到了倒排索引的概念，下面就熟悉下 ES 中常用的一些名词。</p></blockquote><h3 id="常用术语"><a href="#常用术语" class="headerlink" title="常用术语"></a>常用术语</h3><table><thead><tr><th><strong>名词</strong></th><th><strong>解释</strong></th></tr></thead><tbody><tr><td><strong>cluster</strong></td><td>一个或者多个 node 指定相同的 cluster name，则它们会组成集群，并且自动选举 master，以及在故障时自动选举。</td></tr><tr><td><strong>node</strong></td><td>节点是属于集群的Elasticsearch的运行实例 。在启动时，节点将使用单播来发现具有相同集群名称的现有集群，并将尝试加入该集群。</td></tr><tr><td><strong>index</strong></td><td>类似关系数据库的表，映射一个或者多个主分片，同时拥有零个或多个副本分片。</td></tr><tr><td><strong>index alias</strong></td><td>索引别名是用于引用一个或多个现有索引的辅助名称。大多数Elasticsearch API接受索引别名代替索引名称。</td></tr><tr><td><strong>mapping</strong></td><td>每个 index 都有一个 mapping ，定义一个 type 以及许多索引范围的设置。mapping 可以明确定义，也可以在为文档建立索引后自动生成。</td></tr><tr><td><strong>shard</strong></td><td>分片是单个Lucene实例。最小的工作单位，由Elasticsearch自动管理。索引是指向主分片和副本分片的逻辑命名空间。</td></tr><tr><td><strong>primary shard</strong></td><td>每个文档都存储在一个主分片中。当您为文档建立索引时，将首先在主 shard 上建立索引，然后在主 shard 的所有副本上建立索引。默认情况下，索引具有一个主分片。您可以指定更多的主要分片来扩展 索引可以处理的文档数量。创建索引后，您将无法更改索引中的主要分片数量。但是，可以使用split API将索引拆分为新索引 。</td></tr><tr><td><strong>replica shard</strong></td><td>每个主分片可以具有零个或多个副本。副本是 primary shard 的副本。</td></tr><tr><td><strong>document</strong></td><td>document 是存储在 Elasticsearch 中的 JSON 文档。每个 document 都存储在索引中，并且有 type 和 id。被索引的 JSON 文档 将存储在 _source 字段中，该字段在获取或搜索文档时默认返回。</td></tr><tr><td><strong>id</strong></td><td>每个 document 都有不同的 id，没有指定的话，会自动生成。</td></tr><tr><td><strong>field</strong></td><td>一个 document 包含字段或键值对的列表。字段类似于关系数据库中表中的列。</td></tr><tr><td><strong>source field</strong></td><td>默认情况下，索引的JSON文档存储在 _source 字段中，并且将由所有 get 和 search 请求返回。这样，可以直接从搜索结果中访问原始对象，而无需执行第二步来从 ID 中检索对象。</td></tr></tbody></table><p>画图出来就是下面这个样子</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/CWbmcX-mPCKR6.png" alt="CWbmcX-mPCKR6"></p><h3 id="replica-shard-有什么用？"><a href="#replica-shard-有什么用？" class="headerlink" title="replica shard 有什么用？"></a>replica shard 有什么用？</h3><ol><li><p>增加故障转移：如果主副本发生故障，副本副本可以提升为主副本</p></li><li><p>提高性能：获取和搜索请求可以由主或副本分片处理。</p><p> 默认情况下，每个主分片都有一个副本，但是可以在现有索引上动态更改副本的数量。副本分片永远不会与其主分片在同一节点上启动。</p></li></ol><p>除了定义索引应具有的主分片和副本分片的数量外，您无需直接引用分片。相反，您的代码应仅处理索引。</p><p>Elasticsearch 在 集群中的所有节点之间分配分片，并且在节点发生故障或添加新节点的情况下，可以自动将分片从一个节点移动到另一个节点。</p><p>分片 默认是 5个，副本默认为 1个。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这篇文章简单介绍了 ES 的常用名词，因为只有了解到这些名词，在小伙伴讨论 ES 的时候，才不会一脸懵逼。</p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
          <category> ELK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作笔记 </tag>
            
            <tag> ELK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Elasticsearch 技术分享】—— Elasticsearch ？倒排索引？这都是什么？</title>
      <link href="2020/08/18/technology-sharing-es-1.html"/>
      <url>2020/08/18/technology-sharing-es-1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>前言</strong></p><br><p>革命同志是块砖，哪里需要哪里搬！这不，老大发话，要我在组内做一个 Elasticsearch 技术分享。这不话题一转，开始看起来 ES 了。虽然很久之前用过 ELK 做过日志监控系统，但是毕竟时隔已久，还是得从头看起。当然手头的活也不能停，话不多说，开始分享。先看看什么是 ES？</p></blockquote><h3 id="什么是ES"><a href="#什么是ES" class="headerlink" title="什么是ES"></a>什么是ES</h3><p>Elasticsearch 是分布式搜索和分析引擎。</p><p>Elasticsearch 为所有类型的数据提供<strong>近实时（near real-time）</strong>的搜索和分析。</p><p>常用场景：</p><ol><li>网站搜索</li><li>ELK 日志采集，存储，分析</li><li>地理信息系统分析</li></ol><p>像下图中使用的设计：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/HiP4n4-mnRdVv.png" alt="HiP4n4-mnRdVv"></p><p>特点：</p><ol><li>ES是一个分布式文档存储，存储的数据都是序列化为 JSON documents 。</li><li>使用<strong>倒排索引</strong>存储数据，倒排索引比较适合全文本搜索。</li><li>基于<strong>Apache Lucene</strong>搜索引擎库，可以存储，检索文档及元数据。</li><li>支持 JSON 样式的查询语言——Query DSL，也支持 SQL 样式的查询。</li><li>集群部署，易于扩展。节点（node）分片（shard），将新的 node 添加到集群时，ES 会自动迁移 shard 到新 node 上，重新平衡集群。<ol><li>shard 分为两种 主分片（primary shard）和 副本分片 （replica shard）</li><li>replica shard 存放的是 primary shard 的冗余副本 —— 可以防止集群故障，数据丢失，同时可以提高搜索或检索速度。</li><li>在创建索引时 primary shard 数量是固定的，而replica shard 数量是可以更改的。</li><li>分片由索引配置，分片越多，维护索引则开销则越大，分片大小越大，则 ES 在增减节点重新平衡集群时，分片移动时间越长。</li></ol></li><li>集群恢复： 跨集群复制 （CCR），可以自动将索引从主集群同步到热备份的辅助远程集群。</li></ol><h3 id="什么是倒排索引？"><a href="#什么是倒排索引？" class="headerlink" title="什么是倒排索引？"></a>什么是倒排索引？</h3><p>倒排索引也可以成为反向索引。</p><p>作为开发咱们经常接触到的就是 MySql，假设有一堆技术书籍，并且已经编上号。</p><ol><li>Java 并发编程之美</li><li>Java 开发手册</li><li>深入分布式缓存</li><li>Java 并发程序设计</li><li>算法</li><li>数据结构与算法</li></ol><ul><li>如果放在 MySql 里面就是这样</li></ul><table><thead><tr><th>id</th><th>book_name</th></tr></thead><tbody><tr><td>1</td><td>Java 并发编程之美</td></tr><tr><td>2</td><td>Java 开发手册</td></tr><tr><td>3</td><td>深入分布式缓存</td></tr><tr><td>4</td><td>Java 并发程序设计</td></tr><tr><td>5</td><td>算法</td></tr><tr><td>6</td><td>数据结构与算法</td></tr></tbody></table><p>此时我想查询所有关于 <strong>并发</strong> 的书籍。</p><pre><code class="sql">select * from table_book where book_name like %并发%;</code></pre><p>然后会开始遍历表格，查找到 1和4两条记录。</p><ul><li>如果是倒排索引处理的话</li></ul><p>首先会将每个名称进行分词，比如 <code>Java 并发编程之美</code> 会被分为 <code>Java</code> <code>并发</code> <code>编程</code> <code>之</code> <code>美</code>。<br>分词结束之后按照词关联书籍的编号。</p><table><thead><tr><th>term</th><th>ids</th></tr></thead><tbody><tr><td>Java</td><td>1、2、4</td></tr><tr><td>并发</td><td>1、4</td></tr><tr><td>编程</td><td>1</td></tr><tr><td>算法</td><td>5、6</td></tr><tr><td>分布式</td><td>3</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><p>在倒排索引中搜索<strong>并发</strong>，然后进行检索，就很容易定位到关于<strong>并发</strong>书籍的编号。</p><h3 id="那什么是-Lucene？"><a href="#那什么是-Lucene？" class="headerlink" title="那什么是 Lucene？"></a>那什么是 Lucene？</h3><p>Lucene 可以理解为一个开源的、高性能、可伸缩的信息搜索库。使用 Java 开发，封装了各种倒排索引和搜索的API。相当于一个组件。</p><p>而 ES 就是在 Lucene 之上进行的开发，从而可以<strong>高可用</strong>、<strong>集群部署</strong>、<strong>故障迁移</strong>、<strong>备份容灾</strong>等。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>就这么多，先知道个 ES 是干嘛的。后续再慢慢看、慢慢总结。</p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
          <category> ELK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作笔记 </tag>
            
            <tag> ELK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JDK源码笔记】- 除了读写锁，JUC 下面还有个 StampedLock！还不过来了解一下么？</title>
      <link href="2020/08/09/source-code-stamped-lock.html"/>
      <url>2020/08/09/source-code-stamped-lock.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>前言</strong></p><br><p>在了解完 ReentrantLock 和 ReentrantReadWriteLock 之后，惊奇的发现 JUC 下还有一个 StampedLock 。 查阅资料发现是 JDK8 新增的一个锁。现在已经 JDK15 了，原谅我的孤陋寡闻，实在是业务开发中用的太少。那行吧，赶紧来看一下 StampedLock 到底是什么？为什么有了 ReentrantLock 和 ReentrantReadWriteLock 之后还要设计一个 StampedLock ？</p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><h4 id="往期回顾"><a href="#往期回顾" class="headerlink" title="往期回顾"></a>往期回顾</h4><p>在介绍 StampedLock 之前还是先看一下 ReentrantLock 和 ReentrantReadWriteLock。</p><p>ReentrantLock：互斥锁，同时只有一个线程可以持有。支持锁重入。</p><p>ReentrantReadWriteLock：读写锁，分为读锁和写锁，支持重入。其中读读共享，写写独占，读写互斥，写读互斥。支持锁降级，线程获取写锁后可以降级为读锁。适合读多写少的场景。</p><p>那为什么要设计 StampedLock 呢？先来看一下源码上的注释：</p><h4 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h4><p>基于功能的锁，具有三种模式来控制读/写访问。StampedLock的状态由版本和模式组成。锁获取方法返回一个 stamp 用来表示并控制锁状态的访问；这些方法的“try”版本可能会返回特殊值零，以表示无法获取访问权限。<br>锁的释放和转换方法需要使用 stamp 作为参数，如果它们与锁的状态不匹配，则会失败。</p><p>三种模式是：写锁、读锁、乐观读锁。</p><p>并且具有以下特征：</p><ol><li>获取锁的时候（无论读锁还是写锁或者乐观读锁）都会返回一个 stamp，在释放锁的时候需要使用这个 stamp；</li><li>支持三种模式转换；</li><li>不是可重入的，所以获得锁的时候，不要尝试再次获取。</li></ol><h4 id="使用样例"><a href="#使用样例" class="headerlink" title="使用样例"></a>使用样例</h4><pre><code class="java">/** * @author liuzhihang * @date 2020/8/6 15:27 */public class Count &#123;    private int num;    private final StampedLock stampedLock = new StampedLock();    // 使用写锁，在对 num 进行写入的时候加锁    void write(int x) &#123;        long stamp = stampedLock.writeLock();        try &#123;            num += x;        &#125; finally &#123;            stampedLock.unlockWrite(stamp);        &#125;    &#125;    // 乐观读    int read() &#123;        // 获取乐观读锁；返回 stamp        long stamp = stampedLock.tryOptimisticRead();        try &#123;            // validate 验证是否被写锁持有            // 没有被写锁持有，可以直接返回            if (!stampedLock.validate(stamp)) &#123;                // 被写锁持有，那只能获取读锁                stamp = stampedLock.readLock();            &#125;            return num;        &#125; finally &#123;            stampedLock.unlockRead(stamp);        &#125;    &#125;    void convertWrite(int x) &#123;        // 读        long stamp = stampedLock.readLock();        try &#123;            while (num == x) &#123;                // 满足条件，转换为写锁                long ws = stampedLock.tryConvertToWriteLock(stamp);                // 转为写锁成功                if (ws != 0L) &#123;                    stamp = ws;                    num = x;                    break;                &#125; else &#123;                    // 转换失败，释放读锁                    stampedLock.unlockRead(stamp);                    // 再次获取写锁                    stamp = stampedLock.writeLock();                &#125;            &#125;        &#125; finally &#123;            stampedLock.unlock(stamp);        &#125;    &#125;&#125;</code></pre><ol><li>写锁使用方法一样；</li><li>乐观读，可以先去读数据，发现没有改变可以返回，发现改变了，则重新获取读锁，然后再返回；</li><li>读锁可以升级为写锁，通过 tryConvertToWriteLock 方法。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h4><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/StampedLock-uml-Wq0Jz2.png" alt="StampedLock-uml-Wq0Jz2"></p><p>通过 UML 可以看出 StampedLock 和 AQS 并无任何关系。</p><h4 id="StampedLock-和-ReentrantReadWriteLock-的区别？"><a href="#StampedLock-和-ReentrantReadWriteLock-的区别？" class="headerlink" title="StampedLock 和 ReentrantReadWriteLock 的区别？"></a>StampedLock 和 ReentrantReadWriteLock 的区别？</h4><ol><li>StampedLock 也是读写锁，但是和 AQS 没有关系</li><li>StampedLock 除了 读锁和写锁，还有一个乐观读。</li><li>StampedLock 的读锁可以升级为写锁。</li><li>StampedLock 不支持锁重入。</li></ol><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>本文主要介绍 StampedLock 的相关使用及和 ReentrantReadWriteLock 的区别。</p><p>因为工作确实很少使用，阅读源码，内部自旋逻辑等有很多。如果介绍的话会篇幅特别长，这里就省略了。有兴趣的小伙伴可以自己阅读源码。</p><p>因为 StampedLock 提供的乐观读锁支持，所以在多线程多读情况下，性能比 ReentrantReadWriteLock 要更好，但是需要注意的是 StampedLock 是不支持锁重入的。</p><p>另一个需要记住的就是 StampedLock 和 AQS 并没有什么关系，它是在自己内部维护了一个双向阻塞队列。</p>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码笔记 </tag>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA插件开发常用API</title>
      <link href="2020/08/01/idea-plugin-development-common-api.html"/>
      <url>2020/08/01/idea-plugin-development-common-api.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>在开发Toolkit过程中查阅相关资料和阅读其他开源项目总结的一些常用API.<br>整体内容来源于网络, 以及自己使用开发Toolkit过程中使用到的.<br>总结的不到位的地方欢迎指正.</p></blockquote><h3 id="AnAction操作"><a href="#AnAction操作" class="headerlink" title="AnAction操作"></a>AnAction操作</h3><ol><li>创建Action集成<code>AnAction</code>并实现其<code>actionPerformed</code>方法. 在方法中可以获取到<code>AnActionEvent</code>对象. 代码如下:</li></ol><pre><code class="java">public class JsonFormatAction extends AnAction &#123;    @Override    public void actionPerformed(AnActionEvent event) &#123;        // 获取当前project对象        Project project = event.getData(PlatformDataKeys.PROJECT);        // 获取当前编辑的文件, 可以进而获取 PsiClass, PsiField 对象        PsiFile psiFile = event.getData(CommonDataKeys.PSI_FILE);        Editor editor = event.getData(CommonDataKeys.EDITOR);        // 获取Java类或者接口        PsiClass psiClass = getTargetClass(editor, psiFile);        // 创建并调起 DialogWrapper        DialogWrapper dialog = new JsonFormat(project, psiFile, editor, psiClass);        dialog.show();    &#125;</code></pre><ol start="2"><li>其他方式</li></ol><pre><code class="java">// 获取project. 内部调用 getData(CommonDataKeys.PROJECT) = getDataContext().getData(CommonDataKeys.PROJECT)Project project = e.getProject();// 获取数据上下文DataContext dataContext = e.getDataContext();// context可以也获取到其他信息, 入参为 PlatformDataKeys 定义的字段Project project1 = dataContext.getData(PlatformDataKeys.PROJECT);Editor editor = dataContext.getData(PlatformDataKeys.EDITOR);PsiFile psiFile = dataContext.getData(PlatformDataKeys.PSI_FILE);PsiElement psiElement = dataContext.getData(PlatformDataKeys.PSI_ELEMENT);// 虚拟文件VirtualFile virtualFile = dataContext.getData(PlatformDataKeys.VIRTUAL_FILE);</code></pre><h3 id="获取PsiClass"><a href="#获取PsiClass" class="headerlink" title="获取PsiClass"></a>获取PsiClass</h3><p>PsiClass为java类或者接口</p><pre><code class="java">@Nullableprotected PsiClass getTargetClass(Editor editor, PsiFile file) &#123;    int offset = editor.getCaretModel().getOffset();    PsiElement element = file.findElementAt(offset);    if (element == null) &#123;        return null;    &#125; else &#123;        PsiClass target = PsiTreeUtil.getParentOfType(element, PsiClass.class);        return target instanceof SyntheticElement ? null : target;    &#125;&#125;</code></pre><h3 id="Psixxx操作"><a href="#Psixxx操作" class="headerlink" title="Psixxx操作"></a>Psixxx操作</h3><h4 id="PsiClass操作API"><a href="#PsiClass操作API" class="headerlink" title="PsiClass操作API"></a>PsiClass操作API</h4><p>源码有注释且比较清楚, 此处仅记录我用到的一部分</p><pre><code class="java">// 获取全类名String qualifiedName = aClass.getQualifiedName();// 获取所有字段PsiField[] fields = aClass.getFields();</code></pre><h4 id="PsiField操作"><a href="#PsiField操作" class="headerlink" title="PsiField操作"></a>PsiField操作</h4><pre><code class="java">// 获取字段名String name = psiField.getName()</code></pre><h4 id="PsiElement操作"><a href="#PsiElement操作" class="headerlink" title="PsiElement操作"></a>PsiElement操作</h4><p>PsiClass和PsiField都实现了PsiElement</p><pre><code class="java">// 删除element.delete()// 添加元素, 向一个类中添加方法, 字段等, 也可以调用 addBefore, addAfteradd(PsiElement element)</code></pre><h4 id="PsiType操作"><a href="#PsiType操作" class="headerlink" title="PsiType操作"></a>PsiType操作</h4><p>PsiType支持常用基本类型, 但是当创建对象时则不支持.需要自己创建</p><pre><code class="java">PsiElementFactory psiElementFactory = JavaPsiFacade.getElementFactory(project);// String 类型PsiType stringPsiType = psiElementFactory.createTypeFromText(&quot;java.lang.String&quot;, null)// listPsiType listPsiType = psiElementFactory.createTypeFromText(&quot;java.util.List&lt;String&gt;&quot;, null);// 自定义listPsiType typeFromText = psiElementFactory.createTypeFromText(&quot;java.util.List&lt;&quot; + className + &quot;&gt;&quot;, null);</code></pre><h3 id="其他API"><a href="#其他API" class="headerlink" title="其他API"></a>其他API</h3><h4 id="XML-文件操作"><a href="#XML-文件操作" class="headerlink" title="XML 文件操作"></a>XML 文件操作</h4><p>参考地址：<a href="https://jetbrains.org/intellij/sdk/docs/reference_guide/frameworks_and_external_apis/xml_dom_api.html">https://jetbrains.org/intellij/sdk/docs/reference_guide/frameworks_and_external_apis/xml_dom_api.html</a></p><p>以 Mapper.xml 举例声明接口，继承 DomElement，并配合 @Attribute、@SubTag 、@SubTagsList 注解定义一个 xml model，其中需要注意 @SubTagsList 方法要使用复数形式。</p><pre><code class="java">public interface Mapper extends DomElement &#123;    /**     * namespace     *     * @return     */    @Attribute(&quot;namespace&quot;)    GenericAttributeValue&lt;String&gt; getNamespace();    /**     *     * 增删改查对应的节点     *     * @return     */    @SubTagsList(&#123;&quot;select&quot;, &quot;insert&quot;, &quot;update&quot;, &quot;delete&quot;&#125;)    List&lt;Statement&gt; getStatements();​    @SubTagList(&quot;select&quot;)    List&lt;Select&gt; getSelects();    @SubTagList(&quot;insert&quot;)    List&lt;Insert&gt; getInserts();    @SubTagList(&quot;update&quot;)    List&lt;Update&gt; getUpdates();    @SubTagList(&quot;delete&quot;)    List&lt;Delete&gt; getDeletes();&#125;</code></pre><h4 id="搜索文件"><a href="#搜索文件" class="headerlink" title="搜索文件"></a>搜索文件</h4><p>比如想搜索项目中的所有 xml 文件，上面使用 Mapper 接口定义了 Mapper.xml 的结构，就可以利用 DomService 搜索所有的 Mapper.xml：</p><pre><code class="java">// 当前项目的所有元素 mapper, 分别填入类型, 作用域 GlobalSearchScopeList&lt;DomFileElement&lt;Mapper&gt;&gt; fileElements = DomService.getInstance().getFileElements(Mapper.class, project, GlobalSearchScope.allScope(project));</code></pre><h3 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h3><p>需要调用<code>WriteCommandAction</code>进行异步写入.</p><pre><code class="java">WriteCommandAction.runWriteCommandAction(project, () -&gt; &#123;    doGenerate(psiClass, jsonObject);&#125;);</code></pre><h3 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h3><p>在操作成功之后，在 IDEA 右下角通知用户，使用 NotificationGroup 类即可。</p><pre><code class="java">// 静态属性private static final NotificationGroup NOTIFICATION_GROUP = new NotificationGroup(&quot;Java2Json.NotificationGroup&quot;, NotificationDisplayType.BALLOON, true);public void actionPerformed(@NotNull AnActionEvent e) &#123;    // 在方法中调用    Notification success = NOTIFICATION_GROUP.createNotification(message, NotificationType.INFORMATION);    Notifications.Bus.notify(success, project);&#125;</code></pre><p>也可以定义为工具类，如下</p><pre><code class="java">/** * * 进行消息通知工具类 * * @author liuzhihang * @date 2020/2/28 18:52 */public class NotificationUtils &#123;    private static NotificationGroup notificationGroup = new NotificationGroup(&quot;ApiDoc.NotificationGroup&quot;, NotificationDisplayType.BALLOON, true);    public static void warnNotify(String message, Project project) &#123;        Notifications.Bus.notify(notificationGroup.createNotification(message, NotificationType.WARNING), project);    &#125;    public static void infoNotify(String message, Project project) &#123;        Notifications.Bus.notify(notificationGroup.createNotification(message, NotificationType.INFORMATION), project);    &#125;    public static void errorNotify(String message, Project project) &#123;        Notifications.Bus.notify(notificationGroup.createNotification(message, NotificationType.ERROR), project);    &#125;&#125;</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>基本上常用的就是这些了，也可以查找官方文档，官方文档现在还是比较全面的，地址在相关资料中。也可以 Clone Toolkit 这个插件源码，源码中有一些注释。在其他优秀的插件中，同样可有相关使用方法。</p><h4 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h4><ul><li>Toolkit: <a href="https://github.com/liuzhihang/toolkit">https://github.com/liuzhihang/toolkit</a></li><li>copy-as-json: <a href="https://github.com/liuzhihang/copy-as-json">https://github.com/liuzhihang/copy-as-json</a></li><li>IntelliJ Platform SDK: <a href="https://jetbrains.org/intellij/sdk/docs/intro/welcome.html">https://jetbrains.org/intellij/sdk/docs/intro/welcome.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> IDEA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> plugin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【工具册】- IDEA 插件找不到？看这里！那就自己敲一个！</title>
      <link href="2020/07/29/tool-book-copy-as-json.html"/>
      <url>2020/07/29/tool-book-copy-as-json.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>前言</strong></p><br><p>大家都经常使用 IDEA 进行开发，肯定会使用一些 IDEA 插件，我之前也写过两个插件，不过已经很久没有更新了，就让它先放着吧！</p><p>那小伙伴你是否想亲手写一个插件，或者你是否有一些插件的想法，但是找不到插件。那就自己实现一个吧！</p></blockquote><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><h4 id="使用-Gradle-创建"><a href="#使用-Gradle-创建" class="headerlink" title="使用 Gradle 创建"></a>使用 Gradle 创建</h4><p>写插件，先从创建项目开始：</p><p><code>File</code> -&gt; <code>New</code> -&gt; <code>Project...</code></p><ul><li>这里使用 Gradle，其中 Java 已经默认选中，咱们再额外选择 <strong>IntelliJ Platform Plugin</strong>。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/create-CS5lN3.png" alt="create-CS5lN3"></p><ul><li>点击 <strong>Next</strong> ，然后填写项目名称，路径等选项。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/create2-rBTM8z.png" alt="create2-rBTM8z"></p><ul><li>项目结构</li></ul><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/structure-oKmDur.png" alt="structure-oKmDur"></p><p><strong>build.gradle</strong> 为项目配置文件。<br><strong>resources/META-INF/plugin.xml</strong> 为插件配置文件。</p><h4 id="使用-GitHub-模版"><a href="#使用-GitHub-模版" class="headerlink" title="使用 GitHub 模版"></a>使用 GitHub 模版</h4><ol><li>访问 <a href="https://github.com/JetBrains/intellij-platform-plugin-template">https://github.com/JetBrains/intellij-platform-plugin-template</a></li><li>点击 <strong>Use this template</strong> 创建模版。<img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/use-this-template-Z9tfjX.png" alt="use-this-template-Z9tfjX"></li><li>Clone 项目到自己本地。</li></ol><p>注：模版生成的项目是使用的 <strong>Kotlin</strong>，所以这里使用的第一种方式创建。</p><h3 id="开始开发"><a href="#开始开发" class="headerlink" title="开始开发"></a>开始开发</h3><h4 id="修改-build-gradle-配置文件"><a href="#修改-build-gradle-配置文件" class="headerlink" title="修改 build.gradle 配置文件"></a>修改 build.gradle 配置文件</h4><p>原内容如下：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/build-gradle-K0gj4a.png" alt="build-gradle-K0gj4a"></p><p>修改后：</p><pre><code class="java">plugins &#123;    id &#39;java&#39;    id &#39;org.jetbrains.intellij&#39; version &#39;0.4.15&#39;&#125;group &#39;com.liuzhihang.toolkit&#39;version &#39;1.0.2&#39;sourceCompatibility = 1.8repositories &#123;    mavenLocal()    maven &#123; url &quot;https://maven.aliyun.com/repository/public&quot; &#125;    mavenCentral()    jcenter()&#125;dependencies &#123;    testCompile group: &#39;junit&#39;, name: &#39;junit&#39;, version: &#39;4.12&#39;&#125;// See https://github.com/JetBrains/gradle-intellij-plugin/intellij &#123;    version &#39;2019.1.1&#39;    pluginName &#39;Copy as Json&#39;    updateSinceUntilBuild false    sameSinceUntilBuild false&#125;patchPluginXml &#123;    pluginDescription(file(descriptionFile).text)    changeNotes(file(changesFile).text)&#125;</code></pre><ol><li>修改 <strong>repositories</strong> 使用阿里云</li><li>修改 <strong>patchPluginXml</strong> 使用外置文件</li><li>在<strong>根目录</strong>下创建 parts 路径，并创建 <strong>changeNotes.html</strong>、<strong>pluginDescription.html</strong></li></ol><h4 id="修改-resources-META-INF-plugin-xml-插件信息"><a href="#修改-resources-META-INF-plugin-xml-插件信息" class="headerlink" title="修改 resources/META-INF/plugin.xml 插件信息"></a>修改 resources/META-INF/plugin.xml 插件信息</h4><p>原内容如下：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/plugin-xml-AuzOSc.png" alt="plugin-xml-AuzOSc"></p><p>修改后：</p><pre><code class="xml">&lt;idea-plugin&gt;    &lt;id&gt;com.liuzhihang.toolkit.copyasjson&lt;/id&gt;    &lt;name&gt;Copy as Json&lt;/name&gt;    &lt;vendor email=&quot;liuzhihangs@qq.com&quot; url=&quot;https://liuzhihang.com&quot;&gt;Liu ZhiHang&lt;/vendor&gt;    &lt;description&gt;&lt;![CDATA[ Description will be added by gradle build]]&gt;&lt;/description&gt;    &lt;!-- please see http://www.jetbrains.org/intellij/sdk/docs/basics/getting_started/plugin_compatibility.html         on how to target different products --&gt;    &lt;depends&gt;com.intellij.modules.java&lt;/depends&gt;    &lt;idea-version since-build=&quot;181.00&quot;/&gt;    &lt;extensions defaultExtensionNs=&quot;com.intellij&quot;&gt;        &lt;!-- Add your extensions here --&gt;    &lt;/extensions&gt;    &lt;actions&gt;    &lt;/actions&gt;&lt;/idea-plugin&gt;</code></pre><p>plugin.xml 说明：<a href="https://jetbrains.org/intellij/sdk/docs/basics/plugin_structure/plugin_configuration_file.html">https://jetbrains.org/intellij/sdk/docs/basics/plugin_structure/plugin_configuration_file.html</a></p><h4 id="创建-Action"><a href="#创建-Action" class="headerlink" title="创建 Action"></a>创建 Action</h4><ol><li><p>先在 main 下 创建 java 目录，及包路径。</p></li><li><p><code>New</code> -&gt; <code>Plugin DevKit</code> -&gt; <code>Action</code>  <img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/new-action-Pbv61Y.png" alt="new-action-Pbv61Y"></p></li><li><p>设置 Action 的 <strong>id</strong> 、<strong>Class Name</strong> 、 <strong>description</strong> 、 <strong>group</strong> 及<strong>快捷键</strong>等<img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/create-action-5rIhur.png" alt="create-action-5rIhur"></p></li><li><p>这时候会发现在 plugin.xml 也插入了 <strong>action</strong>。</p></li></ol><pre><code class="xml">&lt;actions&gt;    &lt;action id=&quot;Toolkit.Json.CopyAsJsonAction&quot; class=&quot;com.liuzhihang.toolkit.action.CopyAsJsonAction&quot;            text=&quot;CopyAsJsonAction&quot; description=&quot;Copy As Json&quot;&gt;        &lt;add-to-group group-id=&quot;EditorTabsGroup&quot; anchor=&quot;first&quot;/&gt;        &lt;keyboard-shortcut keymap=&quot;$default&quot; first-keystroke=&quot;shift meta J&quot;/&gt;    &lt;/action&gt;&lt;/actions&gt;</code></pre><p>到这里已经结构完全创建完毕了，下面将演示插件 <strong>copy-as-json</strong> 的内部逻辑。当然这块也可以直接跳过，阅读源码即可。</p><p>源码地址：文末相关资料或公众号发送 <strong>copy-as-json</strong> 获取。</p><p>插件效果：将 JavaBean 复制为 Json 字符串。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/demo-gNnhR9.gif" alt="demo-gNnhR9"></p><h4 id="开发笔记"><a href="#开发笔记" class="headerlink" title="开发笔记"></a>开发笔记</h4><p>首先需要知道一些常用的 API，常用 API 可以阅读官方文档或者关注公众号后面会推送，这里仅介绍一些在这里用到的。</p><ul><li>打开 <strong>CopyAsJsonAction</strong> </li></ul><p>该类继承并需要实现 <strong>actionPerformed</strong> 方法。在 <strong>actionPerformed</strong> 方法中可以通过以下三个方法获取到项目相关信息：</p><pre><code class="java">// 获取项目Project project = e.getData(PlatformDataKeys.PROJECT);// 获取Psi文件PsiFile psiFile = e.getData(CommonDataKeys.PSI_FILE);// 获取当前编辑的文件Editor editor = e.getData(CommonDataKeys.EDITOR);</code></pre><ul><li>获取到当前编辑的文件</li></ul><pre><code class="java">@Nullablepublic static PsiClass getTargetClass(@NotNull Editor editor, @NotNull PsiFile file) &#123;    int offset = editor.getCaretModel().getOffset();    PsiElement element = file.findElementAt(offset);    if (element != null) &#123;        // 当前类        PsiClass target = PsiTreeUtil.getParentOfType(element, PsiClass.class);        return target instanceof SyntheticElement ? null : target;    &#125;    return null;&#125;</code></pre><ul><li>从当前编辑的文件里面获取到字段</li></ul><p>将当前编辑的 JavaBean 中的字段提取，并转换为 Map。</p><pre><code class="java">Map&lt;String, Object&gt; fieldsMap = getFields(selectedClass);</code></pre><p>getFields 方法篇幅较长，请参考源码。</p><ul><li>将字段转化成 Json 字符串，并格式化</li></ul><p>使用 Gson 将 Map 转换为 Json 字符串，并格式化。其中格式化自定义了缩进。</p><p>见代码：<code>com.liuzhihang.toolkit.utils.GsonFormatUtil</code></p><pre><code class="java">Gson gson = new GsonBuilder().create();String json = GsonFormatUtil.gsonFormat(gson, fieldsMap);// 使用自定义缩进格式 String json = new GsonBuilder().setPrettyPrinting().create().toJson(fieldsMap);StringSelection selection = new StringSelection(json);</code></pre><ul><li>将 Json 字符串拷贝到剪贴板</li></ul><pre><code class="java">StringSelection selection = new StringSelection(json);Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();clipboard.setContents(selection, selection);</code></pre><ul><li>发出提示 success</li></ul><pre><code class="java">String message = &quot;Convert &quot; + selectedClass.getName() + &quot; to JSON success, copied to clipboard.&quot;;Notification success = NOTIFICATION_GROUP.createNotification(message, NotificationType.INFORMATION);Notifications.Bus.notify(success, project);</code></pre><h4 id="测试运行"><a href="#测试运行" class="headerlink" title="测试运行"></a>测试运行</h4><p>右侧 <code>Gradle</code> -&gt; <code>选择 intellij</code> -&gt; <code>点击 runlde</code></p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/run-GfscZn.png" alt="run-GfscZn"></p><h4 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h4><p>右侧 <code>Gradle</code> -&gt; 选择 <code>intellij</code> -&gt; <code>点击 buildPlugin</code></p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/build-epNxlA.png" alt="build-epNxlA"></p><p>此时在项目路径下会生成插件，把这个插件包发给小兄弟安装使用就行了。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/build-1-2aX8za.png" alt="build-1-2aX8za"></p><h4 id="上传到-IDEA-插件库"><a href="#上传到-IDEA-插件库" class="headerlink" title="上传到 IDEA 插件库"></a>上传到 IDEA 插件库</h4><p>访问 <a href="https://plugins.jetbrains.com/">https://plugins.jetbrains.com/</a> 创建账号，将插件包上传到仓库即可。当然也有其他的方式，这块就没有研究了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过上面的方式已经简单开发一个插件了，要问这个插件有什么用？</p><p>其实就是在写文档，或者接口调用的时候，直接将 Java Bean 复制为 Json 串，省过一个一个敲，然后手写 Json 了。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/postman-7trAcJ.gif" alt="postman-7trAcJ"></p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/req111-JvWo5q.gif" alt="req111-JvWo5q"></p><h4 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h4><p>[1] IntelliJ Platform SDK DevGuide：<a href="https://jetbrains.org/intellij/sdk/docs/intro/intellij_platform.html">https://jetbrains.org/intellij/sdk/docs/intro/intellij_platform.html</a><br>[2] JetBrains Plugins Repository：<a href="https://plugins.jetbrains.com/">https://plugins.jetbrains.com/</a><br>[3] Toolkit： <a href="https://github.com/liuzhihang/toolkit">https://github.com/liuzhihang/toolkit</a><br>[4] copy-as-json：<a href="https://github.com/liuzhihang/copy-as-json">https://github.com/liuzhihang/copy-as-json</a><br>[5] copy-as-json 插件地址：<a href="https://plugins.jetbrains.com/plugin/13606-copy-as-json">https://plugins.jetbrains.com/plugin/13606-copy-as-json</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具册 </category>
          
          <category> IDEA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具册 </tag>
            
            <tag> IDEA </tag>
            
            <tag> plugin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JDK源码笔记】- 快进来！花几分钟看一下 ReentrantReadWriteLock 的原理！</title>
      <link href="2020/07/27/source-code-reentrant-read-write-lock.html"/>
      <url>2020/07/27/source-code-reentrant-read-write-lock.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>前言</strong></p><br><p>在看完 ReentrantLock 之后，在高并发场景下 ReentrantLock 已经足够使用，但是因为 ReentrantLock 是独占锁，同时只有一个线程可以获取该锁，而很多应用场景都是读多写少，这时候使用 ReentrantLock 就不太合适了。读多写少的场景该如何使用？在 JUC 包下同样提供了读写锁 ReentrantReadWriteLock 来应对读多写少的场景。</p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>支持类似 ReentrantLock 语义的 ReadWriteLock 的实现。</p><p>具有以下属性：</p><ul><li><strong>获取顺序</strong></li></ul><p>此类不会将读取优先或写入优先强加给锁访问的排序。但是，它确实支持可选的<em>公平</em> 策略。</p><p>支持<strong>公平模式</strong>和<strong>非公平模式</strong>，默认为<strong>非公平模式</strong>。</p><ul><li><strong>重入</strong></li></ul><p>允许 reader 和 writer 按照 <code>ReentrantLock</code> 的样式重新获取读锁或写锁。在写线程释放持有的所有写锁后，reader 才允许重入使用它们。此外，writer 可以获取读锁，但反过来则不成立。</p><ul><li><strong>锁降级</strong></li></ul><p>重入还允许从写锁降级为读锁，通过先获取写锁，然后获取读锁，最后释放写锁的方式降级。但是，从读锁升级到写锁是<strong>不可能的</strong>。</p><ul><li><strong>锁获取的中断</strong></li></ul><p>读锁和写锁都支持锁获取期间的中断。</p><ul><li><strong><code>Condition</code> 支持</strong></li></ul><p>写锁提供了一个 <code>Condition</code> 实现，对于写锁来说，该实现的方式与 <code>ReentrantLock.newCondition()</code> 提供的 <code>Condition</code> 实现对 <code>ReentrantLock</code> 所做的行为相同。当然，此 <code>Condition</code> 只能用于写锁。读锁不支持 <code>Condition</code>。</p><ul><li><strong>监测</strong></li></ul><p>此类支持一些确定是保持锁还是争用锁的方法。这些方法设计用于监视系统状态，而不是同步控制。</p><p>锁最多支持 65535 个递归写锁和 65535 个读锁</p><p>以上为 <em>Java Api 官方文档</em><sup>[1]</sup> 的解释，总结一下内容如下：</p><ol><li>支持非公平和公平模式，默认为非公平模式。</li><li>支持重入，读锁可以重入获取读锁，写锁可以重入获取写锁，写锁可以获取读锁，读锁不可以获取写锁。</li><li>锁可以降级，从写锁降级为读锁，但是不可能从读锁升级到写锁。</li></ol><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><pre><code class="java">class CachedData &#123;    Object data;    volatile boolean cacheValid;    final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();    void processCachedData() &#123;        // 读锁加锁        rwl.readLock().lock();        if (!cacheValid) &#123;            // 获取写锁之前必须释放读锁            rwl.readLock().unlock();            // 写锁加锁            rwl.writeLock().lock();            try &#123;                // 重新检查状态，因为另一个线程可能                // 在执行操作之前获取了写锁定并更改了状态                if (!cacheValid) &#123;                    data = ...                    cacheValid = true;                &#125;                // 通过在释放写锁之前获取读锁来降级                rwl.readLock().lock();            &#125; finally &#123;                rwl.writeLock().unlock(); // Unlock write, still hold read            &#125;        &#125;        try &#123;            use(data);        &#125; finally &#123;            rwl.readLock().unlock();        &#125;    &#125;&#125;</code></pre><p>上面只是官方文档提供的一个 demo。</p><h4 id="问题疑问"><a href="#问题疑问" class="headerlink" title="问题疑问"></a>问题疑问</h4><ol><li>在 ReentrantReadWriteLock 中 state 代表什么？</li><li>线程获取锁的流程是怎么样的？</li><li>读锁和写锁的可重入性是如何实现的？</li><li>当前线程获取锁失败，被阻塞的后续操作是什么？</li><li>锁降级是怎么降级的？</li></ol><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h4><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/ReentrantReadWriteLock-uml-SQCZqu.png" alt="ReentrantReadWriteLock-uml-SQCZqu"></p><pre><code class="java">public class ReentrantReadWriteLock implements ReadWriteLock, java.io.Serializable &#123;    private static final long serialVersionUID = -6992448646407690164L;    /** 提供读锁的内部类 */    private final ReentrantReadWriteLock.ReadLock readerLock;    /** 提供写锁的内部类 */    private final ReentrantReadWriteLock.WriteLock writerLock;    /** 执行所有同步机制 */    final Sync sync;&#125;</code></pre><h4 id="state"><a href="#state" class="headerlink" title="state"></a>state</h4><p>之前在阅读 ReentrantLock 源码的时候 state 代表了锁的状态，0 表示没有线程持有锁，大于 1 表示已经有线程持有锁及其重入的次数。而在 ReentrantReadWriteLock 是读写锁，那就需要保存<strong>读锁</strong>和<strong>写锁</strong>两种状态的，那是怎么样表示的呢？</p><p>在 ReentrantReadWriteLock 中同样存在一个 Sync 继承了 AbstractQueuedSynchronizer，也是 FairSync、NonfairSync 的父类。内部定义了 state 的一些操作。</p><pre><code class="java">abstract static class Sync extends AbstractQueuedSynchronizer &#123;    private static final long serialVersionUID = 6317671515068378041L;    // 移位数    static final int SHARED_SHIFT   = 16;    // 单位    static final int SHARED_UNIT    = (1 &lt;&lt; SHARED_SHIFT);    // 最大数量 1 &lt;&lt; 16 -&gt; 65536    static final int MAX_COUNT      = (1 &lt;&lt; SHARED_SHIFT) - 1;    // 计算独占数使用 1 &lt;&lt; 16 -&gt; 65536    static final int EXCLUSIVE_MASK = (1 &lt;&lt; SHARED_SHIFT) - 1;    // 返回共享保留数    static int sharedCount(int c)    &#123; return c &gt;&gt;&gt; SHARED_SHIFT; &#125;    // 返回独占保留数     static int exclusiveCount(int c) &#123; return c &amp; EXCLUSIVE_MASK; &#125;&#125;</code></pre><p>在 AQS 中定义 state 为 int 类型，而在 ReentrantReadWriteLock 中，将 state 的 高 16 位和低 16 位拆开表示读写锁。其中高 16 位表示读锁，低 16 位表示写锁。分别使用 sharedCount 和 exclusiveCount 方法获取读锁和写锁的当前状态。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/ReentrantReadWriteLock-state-JusW2l.png" alt="ReentrantReadWriteLock-state-JusW2l"></p><p>下面分别从读锁和写锁的角度来看如何进行加锁和释放锁的？</p><h4 id="ReadLock-lock"><a href="#ReadLock-lock" class="headerlink" title="ReadLock.lock"></a>ReadLock.lock</h4><pre><code class="java">public static class ReadLock     implements Lock, java.io.Serializable &#123;    /**     * 获取读取锁。     * 如果写锁没有被另一个线程持有，则获取读锁并立即返回。     * 如果写锁由另一个线程持有，则出于线程调度目的，     * 当前线程将被禁用，并处于休眠状态，直到获取读锁为止。     */    public void lock() &#123;        // 调用 AQS 获取共享资源        sync.acquireShared(1);    &#125;&#125;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/ReentrantReadWriteLock-AQS-Share-gTrD2e.png" alt="ReentrantReadWriteLock-AQS-Share-gTrD2e"></p><p>获取共享资源，这块使用的 AQS 的逻辑，其中 tryAcquireShared(arg) 是在 ReentrantReadWriteLock.Sync 中实现的。并且 AQS 中有规定，tryAcquireShared 分为三种返回值：</p><ol><li>小于 0: 表示失败；</li><li>等于 0: 表示共享模式获取资源成功，但后续的节点不能以共享模式获取成功; </li><li>大于 0: 表示共享模式获取资源成功，后续节点在共享模式获取也可能会成功，在这种情况下，后续等待线程必须检查可用性。</li></ol><pre><code class="java">abstract static class Sync extends AbstractQueuedSynchronizer &#123;    protected final int tryAcquireShared(int unused) &#123;        Thread current = Thread.currentThread();        // 获取 state 值        int c = getState();        // 独占计数不为 0 且 不是当前线程， 说明已经有写锁        if (exclusiveCount(c) != 0 &amp;&amp; getExclusiveOwnerThread() != current)            return -1;        // 获取共享计数（读锁计数）        int r = sharedCount(c);        // 不需要阻塞读锁 &amp;&amp; 共享计数小于最大值 &amp;&amp; state 更新成功        if (!readerShouldBlock() &amp;&amp; r &lt; MAX_COUNT &amp;&amp;            compareAndSetState(c, c + SHARED_UNIT)) &#123;            if (r == 0) &#123;                // 当前读锁计数为 0                // firstReader是获得读锁的第一个线程                // firstReaderHoldCount是firstReader的保持计数                firstReader = current;                firstReaderHoldCount = 1;            &#125; else if (firstReader == current) &#123;                // 读锁重入                firstReaderHoldCount++;            &#125; else &#123;                // 当前缓存计数                HoldCounter rh = cachedHoldCounter;                // 当前线程没有计数 或者 没有创建计数器                if (rh == null || rh.tid != getThreadId(current))                    // 创建计数，基于 ThreadLocal                    cachedHoldCounter = rh = readHolds.get();                else if (rh.count == 0)                     readHolds.set(rh);                // 计数累加                rh.count++;            &#125;            return 1;        &#125;        // 完整地获取共享锁方法，作为tryAcquireShared方法因CAS获取锁失败后的处理。        // 因为前面可能失败 CAS 失败， 队列策略失败等原因。        return fullTryAcquireShared(current);    &#125;&#125;</code></pre><ol><li>先获取 state ，通过 exclusiveCount 方法获取到写锁的计数值，不为 0 且 不是当前线程， 说明已经有写锁。返回 -1 失败。</li><li>通过 sharedCount 获取读锁计数，判断是否需要阻塞以及是否超过上限后，使用 CAS 更新 读锁计数。</li><li>设置或更新 firstReader、firstReaderHoldCount、 cachedHoldCounter。</li><li>最后会进行完整的获取共享锁方法，作为之前获取失败的后续处理方法。</li></ol><p>firstReader：firstReader是获得读锁的第一个线程；<br>firstReaderHoldCount：firstReaderHoldCount是firstReader的保持计数。即获得读锁的第一个线程的重入次数。<br>cachedHoldCounter：最后一个获得读锁的线程获得读锁的重入次数。</p><pre><code class="java">final int fullTryAcquireShared(Thread current) &#123;    HoldCounter rh = null;    // 无限循环    for (;;) &#123;        int c = getState();        // 是否有写锁        if (exclusiveCount(c) != 0) &#123;            // 有写锁，但是不是当前线程，直接返回失败            if (getExclusiveOwnerThread() != current)                return -1;        &#125; else if (readerShouldBlock()) &#123;            // 需要阻塞            // 没有写锁，确保没有重新获取读锁            if (firstReader == current) &#123;                // assert firstReaderHoldCount &gt; 0;            &#125; else &#123;                // 当前线程的读锁计数 ThreadLocal 中                if (rh == null) &#123;                    rh = cachedHoldCounter;                    if (rh == null || rh.tid != getThreadId(current)) &#123;                        rh = readHolds.get();                        // 计数结束，remove 掉                        if (rh.count == 0)                            readHolds.remove();                    &#125;                &#125;                // 为 0 直接失败                if (rh.count == 0)                    return -1;            &#125;        &#125;        // 到达上限 抛出异常        if (sharedCount(c) == MAX_COUNT)            throw new Error(&quot;Maximum lock count exceeded&quot;);        // CAS 设置读锁        if (compareAndSetState(c, c + SHARED_UNIT)) &#123;            if (sharedCount(c) == 0) &#123;                firstReader = current;                firstReaderHoldCount = 1;            &#125; else if (firstReader == current) &#123;                firstReaderHoldCount++;            &#125; else &#123;                if (rh == null)                    rh = cachedHoldCounter;                if (rh == null || rh.tid != getThreadId(current))                    rh = readHolds.get();                else if (rh.count == 0)                    readHolds.set(rh);                rh.count++;                cachedHoldCounter = rh; // cache for release            &#125;            return 1;        &#125;    &#125;&#125;</code></pre><ol><li>首先会一直循环</li><li>有写锁，但是不是当前线程，直接返回失败。<strong>但是，有写锁，如果是当前线程，是会继续执行的。</strong></li><li>设置或更新 firstReader、firstReaderHoldCount、 cachedHoldCounter。</li></ol><p>当存在写锁（独占锁）时，方法会返回 -1 失败，后续会调用 AQS 的 doAcquireShared 方法，循环获取资源。doAcquireShared 方法会不断循环，尝试获取读锁，一旦获取到读锁，当前节点会立即唤醒后续节点，后续节点开始尝试获取读锁，依次传播。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/ReentrantReadWriteLock-1-rl0DjC.png" alt="ReentrantReadWriteLock-1-rl0DjC"></p><h4 id="ReadLock-unlock"><a href="#ReadLock-unlock" class="headerlink" title="ReadLock.unlock"></a>ReadLock.unlock</h4><pre><code class="java">public static class ReadLock     implements Lock, java.io.Serializable &#123;    public void unlock() &#123;        sync.releaseShared(1);    &#125;&#125;</code></pre><p>调用 AQS 的 releaseShared 释放共享资源方法。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/ReadLock-unlock-LE7vUH.png" alt="ReadLock-unlock-LE7vUH"></p><p>其中 tryReleaseShared 有 ReadLock 实现。</p><pre><code class="java">protected final boolean tryReleaseShared(int unused) &#123;    Thread current = Thread.currentThread();    if (firstReader == current) &#123;        // 第一个线程是当前线程        if (firstReaderHoldCount == 1)            firstReader = null;        else            firstReaderHoldCount--;    &#125; else &#123;        // 第一个线程不是当前线程，更新自己的 ThreadLocal 里面的计数        HoldCounter rh = cachedHoldCounter;        if (rh == null || rh.tid != getThreadId(current))            rh = readHolds.get();        int count = rh.count;        if (count &lt;= 1) &#123;            readHolds.remove();            if (count &lt;= 0)                throw unmatchedUnlockException();        &#125;        --rh.count;    &#125;    // 循环    for (;;) &#123;        int c = getState();        int nextc = c - SHARED_UNIT;        // 使用 CAS 更新 state        if (compareAndSetState(c, nextc))            // 但是如果现在读和写锁都已释放，            // 它可能允许等待的写程序继续进行。            return nextc == 0;    &#125;&#125;</code></pre><ol><li>如果是第一个线程，直接更新技术，不是则更新自己 ThreadLocal 里面保存的计数。</li><li>循环，使用 CAS 更新 state 的值。</li><li>如果 state 更新后的值为 0，说明没有线程持有读锁或者写锁了。</li><li>当 state 为 0，此时会调用 AQS 的 doReleaseShared 方法。此时队列如果有写锁，那就会被写锁获取的锁。</li></ol><h4 id="WriteLock-lock"><a href="#WriteLock-lock" class="headerlink" title="WriteLock.lock"></a>WriteLock.lock</h4><pre><code class="java">public static class WriteLock     implements Lock, java.io.Serializable &#123;    /**     * 获取写入锁。     * 如果没有其他线程持有读锁或写锁，会直接返回，并将写锁计数设置为1。     * 如果当前线程持有写锁，则将写锁计数 +1，然后返回。     * 如果锁正在被其他线程持有，则当前线程用于线程调度目的，     * 当前线程将被禁用，并处于休眠状态，直到获取读锁并将写锁计数设置为1。     */    public void lock() &#123;        sync.acquire(1);    &#125;&#125;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/WriteLock.lock-wBuvUA.png" alt="WriteLock.lock-wBuvUA"></p><p>tryAcquire 方法由 Write 自己实现，方式和 ReentrantLock 类似。</p><pre><code class="java">protected final boolean tryAcquire(int acquires) &#123;    // 如果读锁计数为非零或写锁计数为非零，并且所有者是另一个线程，则失败。    // 如果计数饱和，则失败。只有在count不为零时，才可能发生这种情况。    // 否则，如果该线程是可重入获取或队列策略允许的话，则有资格进行锁定。    // 如果是这样，请更新状态并设置所有者。    Thread current = Thread.currentThread();    int c = getState();    // 写锁计数    int w = exclusiveCount(c);    // c ！= 0 说明有有线程获取锁了    if (c != 0) &#123;        // (Note: if c != 0 and w == 0 then shared count != 0)        // 判断是不是自己，不是自己 返回 false        if (w == 0 || current != getExclusiveOwnerThread())            return false;        // 判断有没有超过上限        if (w + exclusiveCount(acquires) &gt; MAX_COUNT)            throw new Error(&quot;Maximum lock count exceeded&quot;);        // 重入        setState(c + acquires);        return true;    &#125;    // 不需要阻塞，或者 CAS 更新 state 失败    if (writerShouldBlock() || !compareAndSetState(c, c + acquires))        return false;    setExclusiveOwnerThread(current);    return true;&#125;</code></pre><ol><li>获取 state ， 如果 state 不为 0 则判断是否为当前线程重入获取。</li><li>state 为 0 ，则当前线程 CAS 更新 state，获取锁。</li><li>更新成功之后绑定当前线程。</li><li>如果失败会继续调用 AQS 的 acquireQueued，将当前阻塞放在 AQS 队列中。AQS 会不断循环，等待上一个锁释放后，尝试获得锁。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/ReentrantReadWriteLock-2-mQAgGL.png" alt="ReentrantReadWriteLock-2-mQAgGL"></p><h4 id="WriteLock-unlock"><a href="#WriteLock-unlock" class="headerlink" title="WriteLock.unlock"></a>WriteLock.unlock</h4><pre><code class="java">public static class WriteLock     implements Lock, java.io.Serializable &#123;    // 如果当前线程是此锁的持有者，则保持计数递减。     // 如果保持现在的计数为零，则解除锁定。     // 如果当前线程不是此锁的持有者则IllegalMonitorStateException异常。    public void unlock() &#123;        sync.release(1);    &#125;&#125;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/Write-unlock-bwHAcw.png" alt="Write-unlock-bwHAcw"></p><p>同样这块代码是使用 AQS 的逻辑，tryRelease 部分由 WriteLock 自己实现。</p><pre><code class="java">protected final boolean tryRelease(int releases) &#123;    if (!isHeldExclusively())        throw new IllegalMonitorStateException();    int nextc = getState() - releases;    boolean free = exclusiveCount(nextc) == 0;    if (free)        setExclusiveOwnerThread(null);    setState(nextc);    return free;&#125;</code></pre><ol><li>如果是当前线程重入，扣减重入次数。</li><li>扣减后如果为 0，则设置锁持有线程为 null，更新 state 值。AQS 会唤醒后续节点获取锁。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p><strong>Q：</strong>在 ReentrantReadWriteLock 中 state 代表什么？</p><p><strong>A：</strong>state 代表锁的状态。state 为 0 ，没有线程持有锁，state 的高 16 为代表读锁状态，低 16 为代表写锁状态。通过位运算可以获取读写锁的实际值。</p><p><strong>Q：</strong>线程获取锁的流程是怎么样的？</p><p><strong>A：</strong>可以参考上面的源码笔记，以及后面的流程图。</p><p><strong>Q：</strong>读锁和写锁的可重入性是如何实现的？</p><p><strong>A：</strong>在加锁的时候，判断是否为当前线程，如果是当前线程，则直接累加计数。值得注意的是：读锁重入计数使用的 ThreadLocal 在线程中缓存计数，而写锁则直接用的 state 进行累加（其实和 state 低 16 位进行累加一样）。</p><p><strong>Q：</strong>当前线程获取锁失败，被阻塞的后续操作是什么？</p><p><strong>A：</strong>获取失败，会放到 AQS 等待队列中，在队列中不断循环，监视前一个节点是否为 head ，是的话，会重新尝试获取锁。</p><p><strong>Q：</strong>锁降级是怎么降级的？</p><p><strong>A：</strong> <img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/write-to-read-koAuqm.png" alt="write-to-read-koAuqm"><br>如图，在圈出部分 fullTryAcquireShared 代码中，可以看出来，在获取读锁的时候，如果当前线程持有写锁，是可以获取读锁的。这块就是指锁降级，比如线程 A 获取到了写锁，当线程 A 执行完毕时，它需要获取当前数据，假设不支持锁降级，就会导致 A 释放写锁，然后再次请求读锁。而在这中间是有可能被其他阻塞的线程获取到写锁的。从而导致线程 A 在一次执行过程中数据不一致。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li>ReentrantReadWriteLock 读写锁，内部实现是 ReadLock 读锁 和 WriteLock 写锁。读锁，允许共享；写锁，是独占锁。</li><li>读写锁都支持重入，读锁的重入次数记录在线程维护的 ThreadLocal 中，写锁维护在 state 上（低 16 位）。</li><li>支持锁降级，从写锁降级为读锁，防止脏读。</li><li>ReadLock 和 WriteLock 都是通过 AQS 来实现的。获取锁失败后会放到 AQS 等待队列中，后续不断尝试获取锁。区别在读锁只有存在写锁的时候才放到等待队列，而写锁是只要存在非当前线程锁（无论写锁还是读锁）都会放到等待队列。<img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/read-write-different-gzNdCo.png" alt="read-write-different-gzNdCo"></li><li>通过源码分析，可以得出读写锁适合在<strong>读多写少</strong>的场景中使用。</li></ol><h4 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h4><p>[1] Java Api：<a href="https://docs.oracle.com/javase/8/docs/api/overview-summary.html">https://docs.oracle.com/javase/8/docs/api/overview-summary.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码笔记 </tag>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JDK源码笔记】- 不能再被问住了！ReentrantLock 源码、画图一起看一看！</title>
      <link href="2020/07/25/source-code-reentrant-lock.html"/>
      <url>2020/07/25/source-code-reentrant-lock.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>在阅读完 JUC 包下的 AQS 源码之后，其中有很多疑问，最大的疑问就是 state 究竟是什么含义？并且 AQS 主要定义了队列的出入，但是获取资源、释放资源都是交给子类实现的，那子类是怎么实现的呢？下面开始了解 ReentrantLock。 </p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>一个可重入的互斥锁与隐式监视器锁synchronized具有相同的基本行为和语义，但功能更强大。</p><p>具有以下特征：</p><ol><li>互斥性：同时只有一个线程可以获取到该锁，此时其他线程请求获取锁，会被阻塞，然后被放到该锁内部维护的一个 AQS 阻塞队列中。</li><li>可重入性：维护 state 变量，初始为 0，当一个线程获取到锁时，state 使用 cas 更新为 1，本线程再次申请获取锁，会对 state 进行 CAS 递增，重复获取次数即 state，最多为 2147483647 。试图超出此限制会从锁定方法抛出 Error。</li><li>公平/非公平性：在初始化时，可以通过构造器传参，指定是否为公平锁，还是非公平锁。当设置为 true 时，为公平锁，线程争用锁时，会倾向于等待时间最长的线程。</li></ol><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><pre><code class="java">class X &#123;    private final ReentrantLock lock = new ReentrantLock();    // ...    public void m() &#123;        lock.lock();  // block until condition holds        try &#123;        // ... method body        &#125; finally &#123;        lock.unlock()        &#125;&#125;&#125;</code></pre><h4 id="问题疑问？"><a href="#问题疑问？" class="headerlink" title="问题疑问？"></a>问题疑问？</h4><p>首先在阅读本文时，对 AQS 有了一定的了解，如果不了解的话，可以看以下之前的文章。<a href="">图文讲解 AQS</a></p><ol><li>在 AQS 中介绍 state 时，说 state 含义由子类进行定义，那在 ReentrantLock 中 state 代表什么？</li><li>ReentrantLock 和 AQS 有什么关系？</li><li>线程是如何获取到锁的？</li><li>锁的可重入性是如何实现的？</li><li>当前线程获取锁失败，被阻塞的后续操作是什么？</li><li>公平锁和非公平锁是如何体现的？</li><li>锁是如何释放的？</li></ol><p>将通过源码及画图的方式，围绕上面几个问题，展开阅读和分析。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/ReentrantLock-uml-DDnlDW.png" alt="ReentrantLock-uml-DDnlDW"></p><p>基本结构如图所示，ReentrantLock 类实现了接口 Lock，在接口 Lock 中定义了使用锁时的方法，方法及含义如下：</p><pre><code class="java">public interface Lock &#123;    // 获取锁，如果没有获取到，会阻塞。    void lock();    // 获取锁，如果没有获取到，会阻塞。响应中断。    void lockInterruptibly() throws InterruptedException;    // 尝试获取锁，如果获取到，返回 true，没有获取到 返回 false    boolean tryLock();    // 尝试获取锁，没有有获取到，会等待指定时间，响应中断。    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;    // 释放锁    void unlock();&#125;</code></pre><p>而 ReentrantLock 也只是实现了 Lock 接口，并实现了这些方法，那 ReentrantLock 和 AQS 到底有什么关系呢？这就需要看内部具体如何实现的了。</p><p>通过上面类图可以看出，在 ReentrantLock 中含有两个内部类，分别是 NonfairSync FairSync 而它俩又实现了 抽象类 Sync，抽象类 Sync 继承了 AbstractQueuedSynchronizer 即 AQS。具体代码如下：</p><pre><code class="java">public class ReentrantLock implements Lock, java.io.Serializable &#123;    private final Sync sync;    // 锁的同步控制基础类。 子类具体到公平和非公平的版本。 使用AQS状态来表示持有该锁的数量。    abstract static class Sync extends AbstractQueuedSynchronizer &#123;         // 省略 ...    &#125;    static final class NonfairSync extends Sync &#123;         // 非公平锁逻辑 省略 ...    &#125;    static final class FairSync extends Sync &#123;         // 公平锁逻辑 省略 ...    &#125;    // 默认非公平锁    public ReentrantLock() &#123;        sync = new NonfairSync();    &#125;    // 根据传参指定公平锁还是非公平锁，true 公平锁，false 非公平锁    public ReentrantLock(boolean fair) &#123;        sync = fair ? new FairSync() : new NonfairSync();    &#125;&#125;</code></pre><p>通过上面代码可以看出：</p><ol><li>锁的基本控制是由 NonfairSync 和 FairSync 进行控制的，而它俩的父类 Sync 继承了 AQS (AbstractQueuedSynchronizer)，这也就是说明 ReentrantLock 的实现和 AQS 是有关的。</li><li>NonfairSync 代表非公平锁实现逻辑，FairSync 代表公平锁实现逻辑。</li><li>构造器传参可以看出，初始化时，默认为 NonfairSync 非公平锁。也可以指定声明为公平锁或非公平锁，传参 true 为 公平锁，false 为非公平锁。</li></ol><p>具体 ReentrantLock 和 AQS 的关系是怎样的，就需要通过加锁的过程来分析了。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/878c841a671f102ddc2cdeae35faa4cc-pKLxAS.gif" alt="878c841a671f102ddc2cdeae35faa4cc-pKLxAS"></p><h4 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h4><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/ReentrantLock-lock-4apftk.png" alt="ReentrantLock-lock-4apftk"></p><p>如图所示，默认声明非公平锁，lock 方法内部调用 <code>sync.lock();</code> 此时应该是使用的非公平锁内部的 lock 加锁操作。</p><pre><code class="java">final void lock() &#123;    // 通过 CAS 设置 state 值 0 -&gt; 1    if (compareAndSetState(0, 1))        // 设置成功当前线程获取到了锁        setExclusiveOwnerThread(Thread.currentThread());    else        // 设置失败，则调用 AQS 的方法，尝试获取锁。        acquire(1);&#125;</code></pre><ol><li>首先会 使用 CAS 更新 state 的值， 此时就会发现， state 在这里代表的锁的状态。 0 未加锁，1 加锁。</li><li>设置失败，会调用 AQS 的 acquire(1); 方法。</li></ol><p>再看下 AQS 的 acquire 代码</p><pre><code class="java">public final void acquire(int arg) &#123;    // tryAcquire 尝试获取 state，获取失败则会加入到队列    if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))        selfInterrupt();&#125;</code></pre><p>在之前分析 AQS 源码时，已经介绍 tryAcquire 是尝试获取 state 的值，AQS 中并不提供可用的方法，此处是由子类实现的。所以这块代码还是在 NonfairSync 类中自己实现的业务逻辑。</p><pre><code class="java">static final class NonfairSync extends Sync &#123;    // NonfairSync 实现    protected final boolean tryAcquire(int acquires) &#123;        // 调用父类的方法        return nonfairTryAcquire(acquires);    &#125;&#125;abstract static class Sync extends AbstractQueuedSynchronizer &#123;    // NonfairSync 的父类 Sync 中有实现    // state 传参是 1    final boolean nonfairTryAcquire(int acquires) &#123;        // 获取当前线程        final Thread current = Thread.currentThread();        // 获取 state        int c = getState();        // 如果 c 是 0         if (c == 0) &#123;            // 使用 cas 更新为 1            if (compareAndSetState(0, acquires)) &#123;                // 设置持有线程为当前                setExclusiveOwnerThread(current);                return true;            &#125;        &#125; else if (current == getExclusiveOwnerThread()) &#123;            // 如果是当前线程持有            // 对 state 进行累加            int nextc = c + acquires;            // 不允许超过 int 的最大值 2147483647 + 1 = -2147483648            if (nextc &lt; 0) // overflow                throw new Error(&quot;Maximum lock count exceeded&quot;);            // 设置 state 的值            setState(nextc);            return true;        &#125;        return false;    &#125;&#125;</code></pre><ol><li>当前线程加锁，直接使用 CAS 方式对 state 从 0 更新为 1，更新成功，则获得锁，更新失败，则获取失败。</li><li>更新失败后会调用 AQS 的 <code>acquire(1);</code> 方法， 此处传参为 1。</li><li>tryAcquire 再次尝试获取锁。<ol><li>state 是 0，尝试获取。获取成功返回 true；</li><li>state 不是 0，判断是否为当前线程持有，是当前线程持有则对 state 进行累加。</li></ol></li><li>tryAcquire 获取锁失败，则走 AQS 的 acquireQueued 逻辑，创建节点，并加入到等待队列中。</li></ol><p>流程画图如下：</p><ul><li>初始为单个线程</li></ul><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/ReentrantLock-1-1ozuSU.png" alt="ReentrantLock-1-1ozuSU"></p><ul><li>此时其他线程来请求获取锁</li></ul><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/ReentrantLock-2-zO9REa.png" alt="ReentrantLock-2-zO9REa"></p><ul><li>加锁流程图</li></ul><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/ReentrantLock-nonfair-LcRGc7.png" alt="ReentrantLock-nonfair-LcRGc7"></p><h4 id="再来看下公平锁是如何体现的？"><a href="#再来看下公平锁是如何体现的？" class="headerlink" title="再来看下公平锁是如何体现的？"></a>再来看下公平锁是如何体现的？</h4><pre><code class="java">static final class FairSync extends Sync &#123;    private static final long serialVersionUID = -3000897897090466540L;    final void lock() &#123;        acquire(1);    &#125;    protected final boolean tryAcquire(int acquires) &#123;        final Thread current = Thread.currentThread();        int c = getState();        if (c == 0) &#123;            // 判断有无节点排队            if (!hasQueuedPredecessors() &amp;&amp;                compareAndSetState(0, acquires)) &#123;                setExclusiveOwnerThread(current);                return true;            &#125;        &#125;        else if (current == getExclusiveOwnerThread()) &#123;            int nextc = c + acquires;            if (nextc &lt; 0)                throw new Error(&quot;Maximum lock count exceeded&quot;);            setState(nextc);            return true;        &#125;        return false;    &#125;&#125;</code></pre><p>拉出来代码比较一下：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/compare-UFOHD0.png" alt="compare-UFOHD0"></p><p>可以看出在公平锁（FairSync）中多了一个判断条件</p><p><strong><code>!hasQueuedPredecessors()</code></strong></p><p>hasQueuedPredecessors 方法在 AQS 中，如果有当前线程前面的线程排队返回true，如果当前线程是在队列的头部或队列为空，返回false。</p><p>代码如下：</p><pre><code class="java">public final boolean hasQueuedPredecessors() &#123;    Node t = tail;     Node h = head;    Node s;    return h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread());&#125;</code></pre><p>如果当前加锁时已经有节点在排队，那就去节点尾部排队，否则才会去抢占锁。</p><p>到这里基本上已经知道公平锁和非公平锁的区别了：</p><p>非公平锁：不管有没有节点在排队，都会试图去获取锁，如果获取失败，进入 acquire 方法，还是会试图获取一次，之后才会进入队列中。<br>公平锁：已经有节点在排队，那就自己去节点后面排队。</p><h4 id="tryLock"><a href="#tryLock" class="headerlink" title="tryLock"></a>tryLock</h4><pre><code class="java">public boolean tryLock() &#123;    return sync.nonfairTryAcquire(1);&#125;</code></pre><p>直接调用的 Sync 中的 nonfairTryAcquire， 尝试获取锁，获取失败，就返回 false，获取到锁或者是当前线程持有锁则对 state 累加后都返回 true。</p><h4 id="unlock"><a href="#unlock" class="headerlink" title="unlock"></a>unlock</h4><pre><code class="java">public void unlock() &#123;    sync.release(1);&#125;</code></pre><p>发现 unlock 直接调用的 AQS 的 release 方法，进行释放资源。</p><pre><code class="java">public final boolean release(int arg) &#123;    if (tryRelease(arg)) &#123;        Node h = head;        if (h != null &amp;&amp; h.waitStatus != 0)            unparkSuccessor(h);        return true;    &#125;    return false;&#125;</code></pre><p>这块在 AQS 中有介绍，也说明 tryRelease 由子类进行实现，现在在 ReentrantLock 重点关注 tryRelease 的实现。</p><pre><code class="java">// 释放资源，传入值为 1protected final boolean tryRelease(int releases) &#123;    int c = getState() - releases;    if (Thread.currentThread() != getExclusiveOwnerThread())        throw new IllegalMonitorStateException();    boolean free = false;    if (c == 0) &#123;        free = true;        setExclusiveOwnerThread(null);    &#125;    setState(c);    return free;&#125;</code></pre><ol><li>获取当前的 state 进行 -1 操作；</li><li>判断了下当前线程是否为持有线程；</li><li>如果释放完之后 state 为 0 ，则设置持有线程为 null；</li><li>更新并返回 state 的值。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过上面的源码及画图，基本上对开始的问题已经有了答案：</p><p><strong>Q</strong>：在 AQS 中介绍 state 时，说 state 含义由子类进行定义，那在 ReentrantLock 中 state 代表什么？<br><strong>A</strong>：在 ReentrantLock 中 state 代表加锁状态，0 没有线程获得锁，大于等于 1 已经有线程获得锁，大于 1 说明该获得锁的线程多次重入。</p><p><strong>Q</strong>：ReentrantLock 和 AQS 有什么关系？<br><strong>A</strong>：ReentrantLock 内部基于 AQS 实现，无论是锁状态，还是进入等待队列，锁释放等都是基于 AQS 实现。ReentrantLock 的公平锁和非公平锁都是 NonfairSync、FairSync 来实现的，而他们的父类 Sync 继承了 AQS。</p><p><strong>Q</strong>：线程是如何获取到锁的？<br><strong>A</strong>：线程通过修改 state 字段的状态来获取到锁。</p><p><strong>Q</strong>：锁的可重入性是如何实现的？<br><strong>A</strong>：当前线程发现 state 不是 0 ，则说明有锁已经被获取了，此时会判断当前获取到锁的线程是不是自己，如果是，则对 state 进行累加。</p><p><strong>Q</strong>：当前线程获取锁失败，被阻塞的后续操作是什么？<br><strong>A</strong>：获取失败，会放到 AQS 等待队列中，在队列中不断循环，监视前一个节点是否为 head ，是的话，会重新尝试获取锁。</p><p><strong>Q</strong>：公平锁和非公平锁是如何体现的？<br><strong>A</strong>：公平锁主要体现在如果当前队列中已经有排队的线程了，则自己直接排在后面。非公平锁是不管当前队列都没有线程排队，都会直接尝试修改 state 获取锁。</p><p><strong>Q</strong>：锁是如何释放的？<br><strong>A</strong>：锁释放资源，即将 state 进行 -1 操作，如果 -1 后 state 为 0，则释放节点，后续节点尝试获取锁。此处可以看 AQS 相关逻辑。</p>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码笔记 </tag>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【工作笔记】- 老大说新项目的结构和 xxx 项目一样就可以了，我 ……</title>
      <link href="2020/07/18/work-archetype.html"/>
      <url>2020/07/18/work-archetype.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>又要开发新项目了，还是创建新项目，怎么办？老大说按照 xxx 项目的结构创建一个新项目就可以了。</p></blockquote><p>在工作中经常有新项目需要创建，此时就会有三种常用的方式</p><p><strong>CC 大法</strong> 新建项目，然后找到之前的各种工具类，复制粘贴进来，此时还不一定能跑起来，然后再进行各种调试。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/archetype-cc-45VBU1.png" alt="archetype-cc-45VBU1"></p><p><strong>CD 大法</strong> 复制老项目，然后改 module 名字，依赖名字，删除老代码，当然也不一定能跑起来，此时再进行各种调试。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/archetype-cc1-SPx1ct.png" alt="archetype-cc1-SPx1ct"></p><p>当然，这里肯定不是使用这两种办法，下面咱们介绍一种更简洁的方式，使用 maven archetype 生成项目模版，一键创建项目。</p><p>Action！！！</p><h3 id="什么是-Archetype-？"><a href="#什么是-Archetype-？" class="headerlink" title="什么是 Archetype ？"></a>什么是 Archetype ？</h3><p>简而言之，Archetype 是 Maven 项目模板工具箱。</p><p><em>An archetype is defined as an original pattern or model from which all other things of the same kind are made.</em> </p><p>原型被定义为原始样式或模型，从中可以制成所有其他同类项目。</p><p>官方解释，简洁明了，就是使用已有的项目，生成一个模版。以后使用这个模版就可以快速生成结构相同的项目了。在团队开发中很有用。</p><p>其实就是官方解释，地址贴上来：<a href="http://maven.apache.org/archetype/maven-archetype-plugin/index.html">http://maven.apache.org/archetype/maven-archetype-plugin/index.html</a></p><p>下面使用 IDEA 作为演示工具，一步一步开始介绍。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/8e83e6d78b16698fb19762806acadd1c-ZXYM5I.jpg" alt="8e83e6d78b16698fb19762806acadd1c-ZXYM5I"></p><h3 id="准备模版项目"><a href="#准备模版项目" class="headerlink" title="准备模版项目"></a>准备模版项目</h3><p>这里还是要有一个模版项目，比如这样：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/archetype1-lZkrqX.png" alt="archetype1-lZkrqX"></p><p>这是一个多 module 项目，一个简单的 demo</p><ol><li>使用了 nacos 作为注册中心；</li><li>fegin 作为调用工具；</li><li>有通用校验 token 工具类；</li><li>假设里面也有一些公司的公共配置（MQ，链路监控，统一日志等）。</li></ol><p>当然这个项目是可以跑起来的。新创建的项目也是这个模版。</p><h3 id="进入主题"><a href="#进入主题" class="headerlink" title="进入主题"></a>进入主题</h3><h4 id="使用命令"><a href="#使用命令" class="headerlink" title="使用命令"></a>使用命令</h4><p>**archetype:generate **</p><p>这样是基于当前项目生成，你也可以使用官网的用法分别指定参数</p><ol><li><strong>mvn archetype:generate</strong> 然后一步一步按照提示输入；</li><li>一次性输入，其中 <code>DarchetypeGroupId</code> <code>、DarchetypeArtifactId</code> <code>、DarchetypeVersion</code> 为生成的 Archetype 项目的组织版本。</li></ol><pre><code class="bash">mvn archetype:generate                                  \  -DarchetypeGroupId=&lt;archetype-groupId&gt;                \  -DarchetypeArtifactId=&lt;archetype-artifactId&gt;          \  -DarchetypeVersion=&lt;archetype-version&gt;                \  -DgroupId=&lt;my.groupid&gt;                                \  -DartifactId=&lt;my-artifactId&gt;</code></pre><p>高级用法 <strong>mvn clean archetype:create-from-project</strong></p><p>执行图示如下：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/archetype-iterm-GONbvt.png" alt="archetype-iterm-GONbvt"></p><p>执行后返回 IDEA 查看项目，在 <code>target/generated-sources</code> 目录下的 <code>archetype</code> 即生成的项目模版。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/archetype-afer-term-vP3Tz3.png" alt="archetype-afer-term-vP3Tz3"></p><p>结构如图所示：</p><ol><li>main/resources/archetype-resources：项目的模版，生成新项目，就是根据这块的代码进行生成的。<ol><li>.idea 无用，删除掉。</li><li>__rootArtifactId__xxx 项目的各个 module</li></ol></li><li>main/resources/META-INF/maven/archetype-metadata.xml：模版工程的元数据配置。</li></ol><p>可以把 archetype 拷出去，这是一个单独的工程模版，拷出去之后，使用 IDEA 打开。</p><p>下面开始介绍 archetype 里面都有什么。</p><h3 id="archetype-模版项目介绍"><a href="#archetype-模版项目介绍" class="headerlink" title="archetype 模版项目介绍"></a>archetype 模版项目介绍</h3><p>使用 IDEA 打开之后发现，还是一个 Maven 项目。</p><h4 id="archetype-resources"><a href="#archetype-resources" class="headerlink" title="archetype-resources"></a>archetype-resources</h4><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/archetype-structure-xUdYE2.png" alt="archetype-structure-xUdYE2"></p><p>打开 pom 文件，可以看到里面 <code>$&#123;groupId&#125;</code> 、 <code>$&#123;artifactId&#125;</code> 、<code>$&#123;version&#125;</code> 使用占位符指定的组织版本，这些就是新创建项目时指定的。</p><h4 id="archetype-metadata-xml"><a href="#archetype-metadata-xml" class="headerlink" title="archetype-metadata.xml"></a>archetype-metadata.xml</h4><p>archetype-metadata.xml 里面为元数据配置。</p><ul><li>fileSet：用来生成一些项目中的文件。如果文件或目录名称包含 <code>__property__</code> 模式，则将其替换为相应的属性值。</li></ul><table><thead><tr><th>属性</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>filtered</td><td>boolean</td><td>过滤文集，将指定文件直接复制不需要修改。<strong>默认值为：false。</strong></td></tr><tr><td>packaged</td><td>boolean</td><td>打包文件，指定文件将在package属性之前的目录结构中生成/复制。它们可以是非打包的，这意味着所选文件将在没有该前缀的情况下生成/复制。<strong>默认值为：false。</strong></td></tr><tr><td>encoding</td><td>String</td><td>过滤内容时使用的编码。</td></tr></tbody></table><p>fileSet 包含以下元素：</p><table><thead><tr><th>元素</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>directory</td><td>String</td><td>生成项目文件的目录</td></tr><tr><td>includes/include*</td><td>List<String></td><td>包含文件</td></tr><tr><td>excludes/exclude*</td><td>List<String></td><td>排除文件</td></tr></tbody></table><p>因为生成项目不需要 .idea *.iml 文件，所以直接删除：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/archetype-metadata1-iVIvLq.png" alt="archetype-metadata1-iVIvLq"></p><ul><li>module 就是要生成的项目一共几个 module</li></ul><table><thead><tr><th>属性</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>String</td><td>The module’s artifactId.</td></tr><tr><td>dir</td><td>String</td><td>The module’s directory.</td></tr><tr><td>name</td><td>String</td><td>The module’s name.</td></tr></tbody></table><table><thead><tr><th>元素</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>fileSets/fileSet*</td><td>List<FileSet></td><td>文件</td></tr><tr><td>modules/module*</td><td>List<ModuleDescriptor></td><td>模块</td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/archetype-metadata2-HCnJqd.png" alt="archetype-metadata2-HCnJqd"></p><p>可以看出里面就是自己的项目模版。</p><p><code>__rootArtifactId__-controller</code> 在生成的时候，就会根据传入的 artifactId 生成指定的 module 名字。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol><li>clean install </li></ol><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/archetype-clean-install-zbua0z.png" alt="archetype-clean-install-zbua0z"></p><ol start="2"><li>IDEA Add Archetype</li></ol><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/archetype-maven-b3sZ6a.png" alt="archetype-maven-b3sZ6a"></p><ol start="3"><li>选择使用 Archetype 生成新项目</li></ol><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/archetype-maven2-HDnFc4.png" alt="archetype-maven2-HDnFc4"></p><ol start="4"><li>填写新生成项目的名字等</li></ol><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/archetype-maven3-sbJlI1.png" alt="archetype-maven3-sbJlI1"></p><ol start="5"><li>生成新项目</li></ol><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/archetype-generate-5GUrpu.png" alt="archetype-generate-5GUrpu"></p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p><strong>Q:</strong> 如何自定义包路径？</p><p><strong>A:</strong> 可以使用 <code>requiredProperties</code> 自定义参数。通过传入自定义的参数，来生成自定的包路径。</p><p>比如发现新生成项目的包路径都是 <code>com.liuzhihang.archetype</code>，这样肯定是不行的，每个项目有每个项目自己的包路径。只需要做以下修改：</p><ol><li>将 <code>requiredProperties</code> 添加到项目中，然后添加新变量 <code>middlePackage</code>。</li></ol><pre><code class="xml">&lt;requiredProperties&gt;    &lt;!--使用archetype时候必须要求输入的参数--&gt;    &lt;requiredProperty key=&quot;groupId&quot;&gt;        &lt;!--可以设置默认值，使用archetype会使用默认值--&gt;        &lt;defaultValue&gt;com.liuzhihang&lt;/defaultValue&gt;    &lt;/requiredProperty&gt;    &lt;requiredProperty key=&quot;package&quot;&gt;        &lt;defaultValue&gt;com.liuzhihang&lt;/defaultValue&gt;    &lt;/requiredProperty&gt;    &lt;requiredProperty key=&quot;middlePackage&quot;&gt;        &lt;defaultValue&gt;$&#123;rootArtifactId&#125;&lt;/defaultValue&gt;    &lt;/requiredProperty&gt;&lt;/requiredProperties&gt;</code></pre><ol start="2"><li>修改模版的文件名</li></ol><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/archetype-middle-mH0Gzf.png" alt="archetype-middle-mH0Gzf"></p><p>如果文件或目录名称包含 <code>__property__</code> 模式，则将其替换为相应的属性值。到这里还不行，因为生成的包名还没改。</p><ol start="3"><li>修改内部文件的包路径。包括 <strong>.java</strong> 、** .xml** 、** .properties** 等。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/archetype-change-middle-3C0Msb.png" alt="archetype-change-middle-3C0Msb"></p><ol start="4"><li>重新 clean install</li></ol><p>注：此时可能会报错，需要在 <code>src/test/resources/projects/basic/archetype.properties</code> 下添加 <code>middlePackage=basic</code> 再重新尝试下。</p><p>在生成时注意指定 <code>middlePackage</code> 属性。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/archetype-middle-1-r8qOco.png" alt="archetype-middle-1-r8qOco"></p><p><strong>Q:</strong> 我想自定义 Application 的名字怎么弄？</p><p><strong>A:</strong> 同样使用 <code>requiredProperties</code> 自定义参数。</p><pre><code class="xml">&lt;requiredProperty key=&quot;appName&quot;&gt;&lt;/requiredProperty&gt;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/archetype-app-name-Vt9Xj3.png" alt="archetype-app-name-Vt9Xj3"></p><p>当然也可以起一个通用的名字。</p><p><strong>Q:</strong> 别的小伙伴怎么用？</p><p><strong>A:</strong> 当然是 deploy 到私服了， 在 pom 里面添加如下配置，指定自己公司的私服。deploy ，这样就可以和小伙伴一起愉快的使用啦。</p><pre><code class="xml">&lt;!-- 远程仓库 --&gt;&lt;distributionManagement&gt;    &lt;repository&gt;        &lt;id&gt;releases&lt;/id&gt;        &lt;name&gt;Nexus Release Repository&lt;/name&gt;        &lt;url&gt;http://liuzhihang.com:xxxx/repository/maven-releases/&lt;/url&gt;    &lt;/repository&gt;    &lt;snapshotRepository&gt;        &lt;id&gt;snapshots&lt;/id&gt;        &lt;name&gt;Nexus Snapshot Repository&lt;/name&gt;        &lt;url&gt;http://liuzhihang.com:xxxx/repository/maven-snapshots/&lt;/url&gt;    &lt;/snapshotRepository&gt;&lt;/distributionManagement&gt;</code></pre><p><strong>Q:</strong> 我要怎么从 IDEA 删除 Archetype ​？</p><p><strong>A:</strong> 这么好用怎么舍得删除​呢？只要找到以下路径</p><pre><code class="bash">liuzhihang % &gt; pwd/Users/liuzhihang/Library/Caches/JetBrains/IntelliJIdea2020.1/Maven/Indices</code></pre><p>里面有一个 <code>UserArchetypes.xml​</code>， 打开，删除掉里面的 archetype 就行。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/archetype-delete-ZyQULu.png" alt="archetype-delete-ZyQULu"></p><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>Maven Archetype 文档：<a href="http://maven.apache.org/archetype/maven-archetype-plugin/index.html">http://maven.apache.org/archetype/maven-archetype-plugin/index.html</a></p><p>代码地址：<a href="https://github.com/liuzhihang/archetype-demo">https://github.com/liuzhihang/archetype-demo</a></p>]]></content>
      
      
      <categories>
          
          <category> 工作笔记 </category>
          
          <category> Archetype </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作笔记 </tag>
            
            <tag> Archetype </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JDK源码笔记】- 别走！这里有个笔记：图文讲解 AQS ，一起看看 AQS 的源码……(图文较长)</title>
      <link href="2020/07/12/source-code-aqs.html"/>
      <url>2020/07/12/source-code-aqs.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>AbstractQueuedSynchronizer 抽象队列同步器，简称 AQS 。是在 JUC 包下面一个非常重要的基础组件，JUC 包下面的并发锁 <code>ReentrantLock</code> <code>CountDownLatch</code> 等都是基于 AQS 实现的。所以想进一步研究锁的底层原理，非常有必要先了解 AQS 的原理。</p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>先看下 AQS 的类图结构，以及源码注释，有一定的大概了解之后再从源码入手，一步一步研究它的底层原理。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/aqs.png" alt="aqs"></p><p>“ 源码注释</p><p>提供了实现阻塞锁和相关同步器依靠先入先出（FIFO）等待队列（信号量，事件等）的框架。 此类中设计了一个对大多数基于 AQS 的同步器有用的原子变量来表示状态（state）。 子类必须定义 protected 方法来修改这个 state，并且定义 state 值在对象中的具体含义是 acquired 或 released。 考虑到这些，在这个类中的其他方法可以实现所有排队和阻塞机制。 子类可以保持其他状态字段，但只能使用方法 getState 、setState 和 compareAndSetState 以原子方式更新 state 。</p><p>子类应被定义为用于实现其封闭类的同步性能的非公共内部辅助类。 类AbstractQueuedSynchronizer没有实现任何同步接口。 相反，它定义了一些方法，如 acquireInterruptibly 可以通过具体的锁和相关同步器来调用适当履行其公共方法。</p><p>此类支持独占模式和共享模式。 在独占模式下，其他线程不能获取成功，共享模式下可以（但不一定）获取成功。 此类不“理解”，在机械意义上这些不同的是，当共享模式获取成功，则下一个等待的线程（如果存在）也必须确定它是否能够获取。 线程在不同模式下的等待共享相同的FIFO队列。 通常情况下，实现子类只支持其中一种模式，但同时使用两种模式也可以，例如ReadWriteLock 。 仅共享模式不需要定义支持未使用的模式的方法的子类。</p><p>这个类中定义了嵌套类 AbstractQueuedSynchronizer.ConditionObject ，可用于作为一个 Condition 由子类实现，并使用 isHeldExclusively 方法说明当前线程是否以独占方式进行，release()、 getState() acquire() 方法用于操作 state 原子变量。</p><p>此类提供检查和监视内部队列的方法，以及类似方法的条件对象。 根据需要进使用以用于它们的同步机制。</p><p>要使用这个类用作同步的基础上，需要重新定义以下方法，如使用，通过检查和或修改 getState 、setState 或 compareAndSetState 方法：</p><p>tryAcquire<br>tryRelease<br>tryAcquireShared<br>tryReleaseShared<br>isHeldExclusively</p><p>“</p><p>通过上面的注释可以得出大概的印象：</p><ol><li>内部依靠先入先出（FIFO） 等待队列。</li><li>存在 state 表示状态信息。state 值只能用 getState 、setState 和 compareAndSetState 方法以原子方式更新。</li><li>支持独占模式和共享模式，但具体需要子类实现具体支持哪种模式。</li><li>嵌套 AbstractQueuedSynchronizer.ConditionObject 可以作为 Condition 由子类实现。</li><li>子类需要重新定义  tryAcquire、tryRelease、tryAcquireShared、tryReleaseShared、isHeldExclusively 方法。</li></ol><h3 id="队列节点-Node"><a href="#队列节点-Node" class="headerlink" title="队列节点 Node"></a>队列节点 Node</h3><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/node-1P32mR.png" alt="node-1P32mR"></p><p>Node节点，包含以下元素：</p><table><thead><tr><th>元素</th><th>含义</th></tr></thead><tbody><tr><td>prev</td><td>上一个节点</td></tr><tr><td>next</td><td>下一个节点</td></tr><tr><td>thread</td><td>持有线程</td></tr><tr><td>waitStatus</td><td>节点状态</td></tr><tr><td>nextWaiter</td><td>下一个处于 CONDITION 状态的节点</td></tr></tbody></table><p>组合成等待队列则如下：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/node-fifo.png" alt="node-fifo"></p><p>下面是等待队列节点的 Node 属性：</p><pre><code class="java">static final class Node &#123;    // 节点正在共享模式下等待的标记    static final Node SHARED = new Node();    // 指示节点正在以独占模式等待的标记    static final Node EXCLUSIVE = null;    // 指示线程已取消    static final int CANCELLED =  1;    // 指示后续线程需要唤醒    static final int SIGNAL    = -1;    // 指示线程正在等待条件    static final int CONDITION = -2;    // 指示下一次acquireShared应该无条件传播    static final int PROPAGATE = -3;    /**     * 状态字段，仅使用以下值     * SIGNAL -1 ：当前节点释放或者取消时，必须 unpark 他的后续节点。     * CANCELLED 1 ：由于超时（timeout）或中断（interrupt），该节点被取消。节点永远不会离开此状态。特别是，具有取消节点的线程永远不会再次阻塞。     * CONDITION -2 ：该节点目前在条件队列。 但它不会被用作同步队列节点，直到转移，转移时的状态将被设置为 0 。     * PROPAGATE -3 ：releaseShared 应该被传播到其他节点。      * 0：都不是     * 值以数字表示以简化使用，大多数时候可以检查符号（是否大于0）以简化使用     */    volatile int waitStatus;    // 上一个节点    volatile Node prev;    // 下一个节点    volatile Node next;    // 节点持有线程    volatile Thread thread;    // 链接下一个等待条件节点，或特殊值共享    Node nextWaiter;    // 节点是否处于 共享状态 是， 返回 true    final boolean isShared() &#123;        return nextWaiter == SHARED;    &#125;    // 返回前一个节点， 使用时 前一个节点不能为空    final Node predecessor() throws NullPointerException &#123;        Node p = prev;        if (p == null)            throw new NullPointerException();        else            return p;    &#125;    Node() &#123;    // Used to establish initial head or SHARED marker    &#125;    Node(Thread thread, Node mode) &#123;     // Used by addWaiter        this.nextWaiter = mode;        this.thread = thread;    &#125;    Node(Thread thread, int waitStatus) &#123; // Used by Condition        this.waitStatus = waitStatus;        this.thread = thread;    &#125;&#125;</code></pre><p>在 Node 节点中需要重点关注 waitStatus</p><ol><li>默认状态为 0；</li><li>waitStatus &gt; 0 (CANCELLED 1) 说明该节点超时或者中断了，需要从队列中移除；</li><li>waitStatus = -1 SIGNAL 当前线程的前一个节点的状态为 SIGNAL，则当前线程需要阻塞（unpark）；</li><li>waitStatus = -2 CONDITION -2 ：该节点目前在条件队列；</li><li>waitStatus = -3 PROPAGATE -3 ：releaseShared 应该被传播到其他节点，在共享锁模式下使用。</li></ol><p>了解完 Node 的结构之后，再了解下 AQS 结构，并从常用方法入手，逐步了解具体实现逻辑。</p><h3 id="AbstractQueuedSynchronizer"><a href="#AbstractQueuedSynchronizer" class="headerlink" title="AbstractQueuedSynchronizer"></a>AbstractQueuedSynchronizer</h3><pre><code class="java">public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer implements java.io.Serializable &#123;    // 等待队列的头，延迟初始化。 除了初始化，它是仅经由方法setHead修改。 注意：如果头存在，其waitStatus保证不会是 CANCELLED 状态    private transient volatile Node head;    // 等待队列的尾部，延迟初始化。 仅在修改通过方法ENQ添加新节点等待。    private transient volatile Node tail;    // 同步状态     private volatile int state;    // 获取状态    protected final int getState() &#123;        return state;    &#125;    // 设置状态值    protected final void setState(int newState) &#123;        state = newState;    &#125;    // 原子更新状态值    protected final boolean compareAndSetState(int expect, int update) &#123;        // See below for intrinsics setup to support this        return unsafe.compareAndSwapInt(this, stateOffset, expect, update);    &#125;&#125;</code></pre><p>在 AQS 中主要参数为：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>head</td><td>等待队列头</td></tr><tr><td>tail</td><td>等待队列尾</td></tr><tr><td>state</td><td>同步状态</td></tr></tbody></table><p>通过注释了解到，在 AQS 里主要分为两种操作模式，分别是：独占模式、共享模式，下面分别从两个不同的角度去分析源码。</p><table><thead><tr><th>操作</th><th>含义</th></tr></thead><tbody><tr><td>acquire</td><td>以独占模式获取，忽略中断。 通过调用至少一次实施tryAcquire ，在成功时返回。 否则，线程排队，可能重复查封和解封，调用tryAcquire直到成功为止。 这种方法可以用来实现方法Lock.lock 。</td></tr><tr><td>release</td><td>以独占模式释放。 通过疏通一个或多个线程，如果实现tryRelease返回true。 这种方法可以用来实现方法Lock.unlock 。</td></tr><tr><td>acquireShared</td><td>获取在共享模式下，忽略中断。 通过至少一次第一调用实现tryAcquireShared ，在成功时返回。 否则，线程排队，可能重复查封和解封，调用tryAcquireShared直到成功为止。</td></tr><tr><td>releaseShared</td><td>以共享模式释放。 通过疏通一个或多个线程，如果实现tryReleaseShared返回true。</td></tr></tbody></table><p>无论是共享模式还是独占模式在这里面都会用到 addWaiter 方法，将当前线程及模式创建排队节点。</p><h4 id="独占模式"><a href="#独占模式" class="headerlink" title="独占模式"></a>独占模式</h4><h5 id="获取独占资源-acquire"><a href="#获取独占资源-acquire" class="headerlink" title="获取独占资源 acquire"></a>获取独占资源 acquire</h5><pre><code class="java">public final void acquire(int arg) &#123;    // tryAcquire 尝试获取 state，获取失败则会加入到队列    if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))        selfInterrupt();&#125;</code></pre><p>在独占模式下会尝试获取 state，当获取失败时会调用 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)。</p><ol><li>tryAcquire(arg)，尝试获取 state 这块由子类自己实现，不同的子类逻辑不同，这块在介绍子类代码时会说明。</li><li>获取 state 失败后，会进行 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)，这块代码可以拆分为两块：addWaiter(Node.EXCLUSIVE)，acquireQueued(node, arg)。</li><li>addWaiter(Node.EXCLUSIVE) 返回的是当前新创建的节点。</li><li>acquireQueued(node, arg) 线程获取锁失败，使用 addWaiter(Node.EXCLUSIVE) 放入等待队列，而 acquireQueued(node, arg) 使用循环，不断的为队列中的节点去尝试获取资源，直到获取成功或者被中断。</li></ol><p>总结获取资源主要分为三步：</p><ol><li>尝试获取资源</li><li>入队列</li><li>出队列</li></ol><p>尝试获取资源 <code>tryAcquire(arg)</code>，由子类实现，那下面则着手分别分析 <code>入队列</code>、<code>出队列</code>。</p><h6 id="入队列：addWaiter-Node-EXCLUSIVE"><a href="#入队列：addWaiter-Node-EXCLUSIVE" class="headerlink" title="入队列：addWaiter(Node.EXCLUSIVE)"></a>入队列：addWaiter(Node.EXCLUSIVE)</h6><p>使用 <code>addWaiter(Node.EXCLUSIVE)</code> 方法将节点插入到队列中，步骤如下：</p><ol><li>根据传入的模式创建节点</li><li>判断尾节点是否存在，不存在则需要使用 <code>enq(node)</code> 方法初始化节点，存在则直接<code>尝试</code>插入尾部。</li><li><code>尝试</code>插入尾部时使用 CAS 插入，防止并发情况，如果插入失败，会调用 <code>enq(node)</code> 自旋直到插入。</li></ol><pre><code class="java">private Node addWaiter(Node mode) &#123;    Node node = new Node(Thread.currentThread(), mode);    // 定位到队列末尾的 node    Node pred = tail;    if (pred != null) &#123;        // 新节点的上一个节点 指向尾节点        node.prev = pred;        // 使用 CAS 设置尾节点，tail 如果等于 pred 则更新为 node        if (compareAndSetTail(pred, node)) &#123;            // 更新成功则将 pred 的下一个节点指向 node            pred.next = node;            return node;        &#125;    &#125;    // 尾节点没有初始化，或竞争失败，自旋    enq(node);    return node;&#125;/** * tailOffset 也就是成员变量 tail 的值 * 此处相当于：比较 tail 的值和 expect 的值是否相等， 相等则更新为 update */private final boolean compareAndSetTail(Node expect, Node update) &#123;    return unsafe.compareAndSwapObject(this, tailOffset, expect, update);&#125;private final boolean compareAndSetHead(Node update) &#123;        return unsafe.compareAndSwapObject(this, headOffset, null, update);&#125;private Node enq(final Node node) &#123;    for (;;) &#123;        Node t = tail;        // 尾节点为空 需要初始化头节点，此时头尾节点是一个        if (t == null) &#123; // Must initialize            if (compareAndSetHead(new Node()))                tail = head;        &#125; else &#123;            // 不为空 循环赋值            node.prev = t;            if (compareAndSetTail(t, node)) &#123;                t.next = node;                return t;            &#125;        &#125;    &#125;&#125;</code></pre><p>看完代码和注释肯定还是有点模糊，现在用图一步一步进行说明。</p><p>因为根据<code>初始尾节点是否为空</code>分为两种情况，这里使用两幅图：</p><ol><li>第一幅为第一次添加节点，此时 head 会延迟初始化；</li><li>第二幅图为已经存在队列，进行插入节点；</li><li>注意看代码，enq 方法返回的是<code>之前的尾节点</code>；</li><li>addWaiter 方法 返回的是<code>当前插入的新创建的节点</code>。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/aqs-addwaiter-1.png" alt="aqs-addwaiter-1"></p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/cas-add-waiter-02.png" alt="cas-add-waiter-02"></p><p>节点添加到队列之后，返回当前节点，而下一步则需要调用方法 <code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</code> 不断的去获取资源。</p><h6 id="出队列：acquireQueued-addWaiter-Node-EXCLUSIVE-arg"><a href="#出队列：acquireQueued-addWaiter-Node-EXCLUSIVE-arg" class="headerlink" title="出队列：acquireQueued(addWaiter(Node.EXCLUSIVE), arg)"></a>出队列：acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</h6><p>方法会通过循环不断尝试获取拿到资源，直到成功。代码如下：</p><pre><code class="java">final boolean acquireQueued(final Node node, int arg) &#123;    // 是否拿到资源    boolean failed = true;    try &#123;        // 中断状态        boolean interrupted = false;        // 无限循环        for (;;) &#123;            // 当前节点之前的节点            final Node p = node.predecessor();            // 前一个节点是头节点， 说明当前节点是 头节点的 next 即真实的第一个数据节点 （因为 head 是虚拟节点）            // 然后再尝试获取资源            if (p == head &amp;&amp; tryAcquire(arg)) &#123;                // 获取成功之后 将头指针指向当前节点                setHead(node);                 p.next = null; // help GC                failed = false;                return interrupted;            &#125;            // p 不是头节点， 或者 头节点未能获取到资源 （非公平情况下被别的节点抢占）             // 判断 node 是否要被阻塞，            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())                interrupted = true;        &#125;    &#125; finally &#123;        if (failed)            cancelAcquire(node);    &#125;&#125;</code></pre><ol><li>不断获取本节点的上一个节点是否为 head，因为 head 是虚拟节点，如果当前节点的上一个节点是 head 节点，则当前节点为 <code>第一个数据节点</code>；</li><li>第一个数据节点不断的去获取资源，获取成功，则将 head 指向当前节点；</li><li>当前节点不是头节点，或者 <code>tryAcquire(arg)</code> 失败（失败可能是非公平锁）。这时候需要判断前一个节点状态决定<code>当前节点是否要被阻塞</code>（前一个节点状态是否为 SIGNAL）。</li></ol><pre><code class="java">/** * 根据上一个节点的状态，判断当前线程是否应该被阻塞 * SIGNAL -1 ：当前节点释放或者取消时，必须 unpark 他的后续节点。 * CANCELLED 1 ：由于超时（timeout）或中断（interrupt），该节点被取消。节点永远不会离开此状态。特别是，具有取消节点的线程永远不会再次阻塞。 * CONDITION -2 ：该节点目前在条件队列。 但它不会被用作同步队列节点，直到转移，转移时的状态将被设置为 0 。 * PROPAGATE -3 ：releaseShared 应该被传播到其他节点。  * 0：都不是 * */private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;    // 前一个节点的等待状态    int ws = pred.waitStatus;    // 前一个节点需要 unpark 后续节点    if (ws == Node.SIGNAL)        return true;    // 当前节点处于取消状态    if (ws &gt; 0) &#123;        do &#123;            // 将取消的节点从队列中移除            node.prev = pred = pred.prev;        &#125; while (pred.waitStatus &gt; 0);        pred.next = node;    &#125; else &#123;        // 设置前一个节点为 SIGNAL 状态        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);    &#125;    return false;&#125;</code></pre><p>在 <code>shouldParkAfterFailedAcquire</code> 方法中，会判断前一个节点的状态，同时取消在队列中当前节点前面无效的节点。</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/aqs-acquire.png" alt="aqs-acquire"></p><p>再继续阅读 出队列 acquireQueued 方法，发现有一个 finally 会判断状态后执行 <code>cancelAcquire(node);</code> ，也就是上面流程图中下面的红色方块。</p><h6 id="cancelAcquire-Node-node"><a href="#cancelAcquire-Node-node" class="headerlink" title="cancelAcquire(Node node)"></a>cancelAcquire(Node node)</h6><pre><code class="java">final boolean acquireQueued(final Node node, int arg) &#123;    // 是否拿到资源    boolean failed = true;    try &#123;        // 省略        // 在 finally 会将当前节点置为取消状态    &#125; finally &#123;        if (failed)            cancelAcquire(node);    &#125;&#125;private void cancelAcquire(Node node) &#123;    // 节点不存在 直接返回    if (node == null)        return;    // 取消节点关联线程    node.thread = null;    //跳过已经取消的节点，获取当前节点之前的有效节点    Node pred = node.prev;    while (pred.waitStatus &gt; 0)        node.prev = pred = pred.prev;    // 获取当前节点之前的有效节点的下一个节点    Node predNext = pred.next;    // 当前节点设置为取消    node.waitStatus = Node.CANCELLED;    // 当前节点如果是尾节点，则将最后一个有效节点设置为尾节点，并将 predNext 设置为空    if (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;        compareAndSetNext(pred, predNext, null);    &#125; else &#123;        int ws;        // pred 不是头节点(node 的上一个有效节点 不是 head) &amp;&amp; （ pred的状态是 SIGNAL ||  pred 的状态设置为 SIGNAL 成功 ） &amp;&amp; pred 的绑定线程不为空        if (pred != head &amp;&amp;         ((ws = pred.waitStatus) == Node.SIGNAL || (ws &lt;= 0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;         pred.thread != null) &#123;            // 当前节点的后继节点            Node next = node.next;            // 后继节点不为空 且 状态有效 将 pred 的 后继节点设置为 当前节点的后继节点            if (next != null &amp;&amp; next.waitStatus &lt;= 0)                compareAndSetNext(pred, predNext, next);        &#125; else &#123;            // node 的上一个有效节点 是 head， 或者其他情况 唤醒当前节点的下一个有效节点            unparkSuccessor(node);        &#125;        node.next = node; // help GC    &#125;&#125;private void unparkSuccessor(Node node) &#123;    // 判断当前节点状态    int ws = node.waitStatus;    if (ws &lt; 0)        // 将节点状态更新为 0         compareAndSetWaitStatus(node, ws, 0);    // 下一个节点， 一般是下一个节点应该就是需要唤醒的节点，即颁发证书。    Node s = node.next;    // 大于 0  CANCELLED ： 线程已取消    // 但是有可能 后继节点 为空或者被取消了。    if (s == null || s.waitStatus &gt; 0) &#123;        s = null;        // 从尾节点开始遍历，直到定位到 t.waitStatus &lt;= 0 的节点        // 定位到后并不会停止，会继续执行，相当于找到最开始的那个需要唤醒的节点        // t.waitStatus &lt;= 0 ： SIGNAL（ -1 后续线程需要释放）         //                     CONDITION （ -2 线程正在等待条件）         //                     PROPAGATE （ -3 releaseShared 应该被传播到其他节点）        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)            if (t.waitStatus &lt;= 0)                s = t;    &#125;    // 定位到需要唤醒的节点后 进行 unpark    if (s != null)        LockSupport.unpark(s.thread);&#125;</code></pre><p>流程分析：</p><ol><li>找到当前节点的前一个非无效节点 pred；</li><li>当前节点如果是尾节点，则将最后一个有效节点设置为尾节点，并将 predNext 设置为空；</li><li>pred 不是头节点 &amp;&amp; （ pred的状态是 SIGNAL ||  pred 的状态设置为 SIGNAL 成功 ） &amp;&amp; pred 的绑定线程不为空；</li><li>其他情况。</li></ol><p>下面分别画图：</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/1-RD0LEx.png" alt="1-RD0LEx"></p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/2-PHY9bi.png" alt="2-PHY9bi"></p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/3-rOnnvu.png" alt="3-rOnnvu"></p><p><strong>Q: 通过图可以看出来，只操作了 next 指针，但是没有操作 prev 指针，这是为什么呢？</strong></p><p><strong>A:</strong> 在 <code>出队列：acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</code> 方法中，<code>shouldParkAfterFailedAcquire</code> 方法会判断前一个节点的状态，同时取消在队列中当前节点前面无效的节点。这时候会移除之前的无效节点，此处也是为了防止指向一个已经被移除的节点。同时保证 prev 的稳定，有利于从 tail 开始遍历列表，这块在 <code>unparkSuccessor(node);</code> 中也可以看到是从后往前表里列表。</p><p><strong>Q: unparkSuccessor(Node node) 为什么从后往前遍历？</strong></p><p><strong>A:</strong></p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/AQS-8IDBPX.png" alt="AQS-8IDBPX"></p><p>在 <code>addWaiter(Node.EXCLUSIVE)</code> 插入新节点时，使用的是 <code>尾插法</code>，看红框部分，此时有可能还未指向next。</p><p><strong>Q: node.next = node; 这块导致 head不是指向最新节点，链表不就断了么？</strong><br><strong>A：</strong> acquireQueued 方法介绍中，里面有个循环，会不断尝试获取资源，成功之后会设置为 head。并且在 shouldParkAfterFailedAcquire 中也会清除当前节点前的无效节点。</p><h5 id="释放独占资源-release"><a href="#释放独占资源-release" class="headerlink" title="释放独占资源 release"></a>释放独占资源 release</h5><pre><code class="java">public final boolean release(int arg) &#123;    if (tryRelease(arg)) &#123;        Node h = head;        if (h != null &amp;&amp; h.waitStatus != 0)            unparkSuccessor(h);        return true;    &#125;    return false;&#125;</code></pre><p>以独占模式释放。 通过释放一个或多个线程，如果实现tryRelease返回true。 这种方法可以用来实现方法Lock.unlock 。</p><ol><li>tryRelease(arg) 操作释放资源，同样是由子类实现，后面介绍子类时会进行说明。返回 true 说明资源现在已经没有线程持有了，其他节点可以尝试获取；</li><li>释放成功，且 head != null &amp;&amp; h.waitStatus != 0, 会继续执行 unparkSuccessor(h)；</li><li>这块会看到 只要 tryRelease(arg) 操作释放资源成功， 后面无论执行是否成功，都会返回 true，unparkSuccessor(h) 相当于只是附加操作。</li></ol><h4 id="共享模式"><a href="#共享模式" class="headerlink" title="共享模式"></a>共享模式</h4><h5 id="获取共享资源-acquireShared"><a href="#获取共享资源-acquireShared" class="headerlink" title="获取共享资源 acquireShared"></a>获取共享资源 acquireShared</h5><pre><code class="java">public final void acquireShared(int arg) &#123;    // 小于 0 表示获取资源失败    if (tryAcquireShared(arg) &lt; 0)        doAcquireShared(arg);&#125;private void doAcquireShared(int arg) &#123;    // 添加到节点 此处是共享节点    final Node node = addWaiter(Node.SHARED);    // 根据是否拿到资源 判断是否需要取消    boolean failed = true;    try &#123;        boolean interrupted = false;        for (;;) &#123;            // 返回前一个节点            final Node p = node.predecessor();            if (p == head) &#123;                // 再次尝试获取共享资源                int r = tryAcquireShared(arg);                // 表示获取成功                if (r &gt;= 0) &#123;                    // 设置当前节点为头节点 并尝试唤醒后续节点                    setHeadAndPropagate(node, r);                    // 释放头节点 GC 会回收                    p.next = null; // help GC                    if (interrupted)                        selfInterrupt();                    failed = false;                    return;                &#125;            &#125;            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;                parkAndCheckInterrupt())                interrupted = true;        &#125;    &#125; finally &#123;        if (failed)            cancelAcquire(node);    &#125;&#125;</code></pre><ol><li>tryAcquireShared(arg)，尝试获取资源，这块由子类实现；</li><li>返回值分为 3 种：<ol><li>小于 0: 表示失败；</li><li>等于 0: 表示共享模式获取资源成功，但后续的节点不能以共享模式获取成功; </li><li>大于 0: 表示共享模式获取资源成功，后续节点在共享模式获取也可能会成功，在这种情况下，后续等待线程必须检查可用性。</li></ol></li><li>在失败后会使用 <code>doAcquireShared(arg);</code> 不断获取资源；</li><li><code>final Node node = addWaiter(Node.SHARED);</code> 同样会创建节点；</li><li>在循环中不断判断前一个节点如果是 head，则尝试获取资源；</li><li>在共享模式下获取到资源后会使用 <code>setHeadAndPropagate(node, r);</code> 设置头节点，同时唤醒后续节点。</li></ol><h6 id="设置头节点，并传播唤醒后续节点"><a href="#设置头节点，并传播唤醒后续节点" class="headerlink" title="设置头节点，并传播唤醒后续节点"></a>设置头节点，并传播唤醒后续节点</h6><pre><code class="java">// node 是当前节点// propagate 是 前一步 tryAcquireShared 的返回值 进来时 &gt;=0// 大于 0: 表示共享模式获取资源成功，后续节点在共享模式获取也可能会成功，在这种情况下，后续等待线程必须检查可用性。private void setHeadAndPropagate(Node node, int propagate) &#123;    // 记录下当前头节点    Node h = head; // Record old head for check below    // 设置传入 node 为头节点    setHead(node);    // 判断条件，唤醒后续节点    // propagate &gt; 0 有后续资源    // h == null 旧的头节点 因为前面 addWaiter， 肯定不会为空，应该是防止 h.waitStatus &lt; 0 空指针的写法    // (h = head) == null 当前的 头节点，再判断状态    // waitStatus &lt; 0 后续节点就需要被唤醒    if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 ||        (h = head) == null || h.waitStatus &lt; 0) &#123;        Node s = node.next;        // 后续节点为共享，则需要唤醒        if (s == null || s.isShared())            doReleaseShared();    &#125;&#125;</code></pre><h6 id="doReleaseShared-释放共享资源"><a href="#doReleaseShared-释放共享资源" class="headerlink" title="doReleaseShared() 释放共享资源"></a>doReleaseShared() 释放共享资源</h6><pre><code class="java">private void doReleaseShared() &#123;    // 循环    for (;;) &#123;        // 从头开始        Node h = head;        // 判断队列是否为空，就是刚初始化        if (h != null &amp;&amp; h != tail) &#123;            int ws = h.waitStatus;            // SIGNAL（ -1 后续线程需要释放）            if (ws == Node.SIGNAL) &#123;                // 将等待状态更新为 0 如果失败，会循环                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))                    continue;            // loop to recheck cases                // 唤醒后续节点， 同时将当前节点设置为 取消                unparkSuccessor(h);            &#125;            // 如果状态是 0 则会更新状态为 PROPAGATE            // PROPAGATE （ -3 releaseShared 应该被传播到其他节点）            else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))                continue;                // loop on failed CAS        &#125;        // 判断头节点有没有变化，有变化 是因为竞争，别的线程获取到了锁，会继续循环        // 没有变化直接结束        if (h == head)                   // loop if head changed            break;    &#125;&#125;</code></pre><ol><li>从头节点开始进行，如果 h != null &amp;&amp; h != tail 说明队列不是空或者刚初始化；</li><li>节点状态为 SIGNAL（ -1 ）说明后续线程需要释放；</li><li>会更改当前节点状态，成功后唤醒后续节点，失败则继续循环；</li><li>节点状态如果是 0 则更新为 PROPAGATE，会将状态传播。</li></ol><h5 id="释放共享资源-releaseShared"><a href="#释放共享资源-releaseShared" class="headerlink" title="释放共享资源 releaseShared"></a>释放共享资源 releaseShared</h5><pre><code class="java">public final boolean releaseShared(int arg) &#123;    if (tryReleaseShared(arg)) &#123;        // 释放共享资源        doReleaseShared();        return true;    &#125;    return false;&#125;</code></pre><p>以共享模式释放。 通过释放一个或多个线程，如果实现tryReleaseShared返回true。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>Q: AQS 到底是什么？</strong><br><strong>A:</strong> AQS 内部提供了一个先入先出（FIFO）双向等待队列，内部依靠 Node 实现，并提供了在<code>独占模式</code>和<code>共享模式</code>下的出入队列的公共方法。而关于状态信息 state 的定义是由子类实现。tryAcquire、tryRelease、tryAcquireShared、tryReleaseShared等尝试获取资源操作都是由子类进行定义和实现的。而 AQS 中提供了子类获取资源之后的相关操作，包括节点 Node 的出入队列，自旋获取资源等等。</p><p><strong>Q: AQS 获取资源失败后会如何操作？</strong><br><strong>A:</strong> 线程获取资源失败后，会放到等待队列中，在队列中会不断尝试获取资源（自旋），说明线程只是进入等待状态，后面还是可以再次获取资源的。</p><p><strong>Q: AQS 等待队列的数据结构是什么？</strong><br><strong>A:</strong> CLH变体的先入先出（FIFO）双向等待队列。（CLH锁是一个自旋锁。能确保无饥饿性。提供先来先服务的公平性。是一种基于链表的可扩展、高性能、公平的自旋锁，申请线程仅仅在本地变量上自旋，它不断轮询前驱的状态，如果发现前驱释放了锁就结束自旋。）</p><p><strong>Q: AQS 等待队列中的节点如何获取获取和释放资源的？</strong><br><strong>A:</strong> 可以看下<code>独占模式</code>中的讲述过程，通过代码梳理。</p><p>本文分别从 <code>独占模式</code> 和 <code>共享模式</code>介绍的 AQS 基本逻辑，并通过源码和作图理解基本思路。但是并没有对需要子类实现的业务逻辑做介绍。这块会在后面介绍 <code>ReentrantLock</code>、<code>CountDownLatch</code> 等子类的时候做介绍。</p>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码笔记 </tag>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JDK源码笔记】- JUC 包下工具类，它的名字叫 LockSupport ！你造么？</title>
      <link href="2020/07/05/source-code-locksupport.html"/>
      <url>2020/07/05/source-code-locksupport.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>LockSupport 是 JUC 中常用的一个工具类，主要作用是挂起和唤醒线程。在阅读 JUC 源码中经常看到，所以很有必要了解一下。</p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote><p>基本线程阻塞原语创建锁和其他同步类。Basic thread blocking primitives for creating locks and other synchronization classes.</p></blockquote><blockquote><p>LockSupport 类每个使用它的线程关联一个许可（在意义上的Semaphore类）。 如果许可可用，调用 park 将立即返回，并在此过程中消费它; 否则可能阻塞。如果许可不是可用，可以调用 unpark 使得许可可用。（但与Semaphore不同，许可不能累积。最多有一个。）</p><p>方法 park 和 unpark 提供了阻塞的有效手段和解锁线程不会遇到死锁问题，而 Thread.suspend 和 Thread.resume 是不能用于这种目的：因为许可的存在，一个线程调用 park 和另一个线程试图 unpark 它之间的竞争将保持活性。 此外，如果调用者线程被中断，park 将返回，并且支持设置超时。 该 park 方法也可能返回在其他任何时间，“毫无理由”，因此通常必须在一个循环中调用的返回后重新检查条件。 在这个意义上park作为“忙碌等待”不会浪费太多的时间自旋的优化，但必须以配对 unpark 使用。</p><p>这三种形式的 park 还支持 blocker 对象参数。而线程被阻塞时是允许使用监测和诊断工具，以确定线程被阻塞的原因。（诊断工具可以使用getBlocker(Thread) 方法 。）同时推荐使用带有 blocker 参数的 park方法，通常做法是 blocker 被设置为 this 。</p></blockquote><p>上面的意思总结下来个人理解是：</p><ol><li>许可（permit）的上限是1，也就是说只有 0 或 1 。</li><li>park: 没有许可的时候，permit 为 0 ，调用 park 会阻塞；有许可的时候，permit 为 1 ， 调用 park 会扣除一个许可，然后返回。</li><li>unpark：没有许可的时候，permit 为 0 ，调用 unpark 会增加一个许可，因为许可上限是 1 ， 所以调用多次也只会为 1 个。</li><li>线程初始的时候是没有许可的。</li><li>park 的当前线程如果被中断，会立即返回，并不会抛出中断异常。</li><li>park 方法的调用一般要放在一个循环判断体里面。</li></ol><p>大概如图所示：</p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/rGm1AX.png" align=center /><p>下面是源码注释中的案例：</p><pre><code class="java">/** * FIFO 独占锁 */class FIFOMutex &#123;   private final AtomicBoolean locked = new AtomicBoolean(false);   private final Queue&lt;Thread&gt; waiters = new ConcurrentLinkedQueue&lt;Thread&gt;();   public void lock() &#123;     boolean wasInterrupted = false;     Thread current = Thread.currentThread();     waiters.add(current);     // Block while not first in queue or cannot acquire lock     // 不在队列头，或者锁被占用，则阻塞， 就是只有队列头的可以获得锁     while (waiters.peek() != current || !locked.compareAndSet(false, true)) &#123;       LockSupport.park(this);       if (Thread.interrupted()) // ignore interrupts while waiting         wasInterrupted = true;     &#125;     waiters.remove();     if (wasInterrupted)          // reassert interrupt status on exit       current.interrupt();   &#125;   public void unlock() &#123;     locked.set(false);     LockSupport.unpark(waiters.peek());   &#125; &#125;</code></pre><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><h4 id="线程初始有没有许可？"><a href="#线程初始有没有许可？" class="headerlink" title="线程初始有没有许可？"></a>线程初始有没有许可？</h4><pre><code class="java">public class LockSupportTest &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;开始执行……&quot;);        LockSupport.park();        System.out.println(&quot;LockSupport park 之后……&quot;);    &#125;&#125;</code></pre><ol><li>执行后会发现，代码在 park 处阻塞。说明，线程初始是没有许可的。</li></ol><h4 id="添加许可并消耗许可"><a href="#添加许可并消耗许可" class="headerlink" title="添加许可并消耗许可"></a>添加许可并消耗许可</h4><pre><code class="java">public class LockSupportTest &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;开始执行……&quot;);        LockSupport.unpark(Thread.currentThread());        System.out.println(&quot;执行 - park&quot;);        LockSupport.park();        System.out.println(&quot;LockSupport park 之后……&quot;);    &#125;&#125;</code></pre><pre><code class="java">public class LockSupportTest &#123;    public static void main(String[] args) throws InterruptedException &#123;        Thread thread = new Thread(new Runnable() &#123;            @Override            public void run() &#123;                System.out.println(&quot;线程 &quot; + Thread.currentThread().getName() + &quot;开始执行 park&quot;);                LockSupport.park(this);                System.out.println(&quot;线程 &quot; + Thread.currentThread().getName() + &quot;执行 park 结束&quot;);            &#125;        &#125;);        thread.start();        // 保证 上面线程先执行，然后再主线程        Thread.sleep(5000);        System.out.println(&quot;开始执行 unpark(thread)&quot;);        LockSupport.unpark(thread);        Thread.sleep(5000);        System.out.println(&quot;执行 unpark(thread) 结束&quot;);    &#125;&#125;</code></pre><p>通过上面示例可以看出：</p><ol><li>执行 unpark 可以进行给予指定线程一个证书。</li><li>线程当前被 park 阻塞，此时给予证书之后， park 会消耗证书，然后继续执行。</li></ol><h4 id="许可上限为-1"><a href="#许可上限为-1" class="headerlink" title="许可上限为 1"></a>许可上限为 1</h4><pre><code class="java">public class LockSupportTest &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;unpark 1次&quot;);        LockSupport.unpark(Thread.currentThread());        System.out.println(&quot;unpark 2次&quot;);        LockSupport.unpark(Thread.currentThread());        System.out.println(&quot;执行 - park 1 次&quot;);        LockSupport.park();        System.out.println(&quot;执行 - park 2 次&quot;);        LockSupport.park();        System.out.println(&quot;LockSupport park 之后……&quot;);    &#125;&#125;</code></pre><ol><li>线程阻塞，可以看出 permit 只能有一个</li></ol><h4 id="中断可以使-park-继续执行并不会抛出异常"><a href="#中断可以使-park-继续执行并不会抛出异常" class="headerlink" title="中断可以使 park 继续执行并不会抛出异常"></a>中断可以使 park 继续执行并不会抛出异常</h4><pre><code class="java">public class LockSupportTest &#123;    public static void main(String[] args)  &#123;        Thread thread = new Thread(new Runnable() &#123;            @Override            public void run() &#123;                System.out.println(&quot;线程 &quot; + Thread.currentThread().getName() + &quot;开始执行 park&quot;);                LockSupport.park(this);                System.out.println(&quot;线程 &quot; + Thread.currentThread().getName() + &quot;执行 park 结束&quot;);                System.out.println(&quot;线程 &quot; + Thread.currentThread().getName() + &quot;开始执行 park 第二次&quot;);                LockSupport.park(this);                System.out.println(&quot;线程 &quot; + Thread.currentThread().getName() + &quot;执行 park 第二次 结束&quot;);            &#125;        &#125;);        try &#123;            thread.start();            // 保证 上面线程先执行，然后再主线程            Thread.sleep(5000);            System.out.println(&quot;开始执行 unpark(thread)&quot;);            // LockSupport.unpark(thread);            thread.interrupt();            Thread.sleep(5000);            System.out.println(&quot;执行 unpark(thread) 结束&quot;);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p>输出结果：</p><pre><code class="text">/Library/Java/JavaVirtualMachines/jdk1.8.0_221.jdk/Contents/Home/bin/java ...线程 Thread-0开始执行 park开始执行 unpark(thread)线程 Thread-0执行 park 结束线程 Thread-0开始执行 park 第二次线程 Thread-0执行 park 第二次 结束执行 unpark(thread) 结束</code></pre><ol><li>可以看出线程中断，park 会继续执行，并且没有抛出异常。</li><li>thread.interrupt(); 调用之后， 设置线程中断标示，unpark 没有清除中断标示，第二个 park 也会继续执行。</li></ol><h4 id="使用诊断工具"><a href="#使用诊断工具" class="headerlink" title="使用诊断工具"></a>使用诊断工具</h4><pre><code class="bash">liuzhihang % &gt; jps76690 LockSupportTest77130 Jpsliuzhihang % &gt; jstack 77265...&quot;main&quot; #1 prio=5 os_prio=31 tid=0x00007f7f3e80a000 nid=0xe03 waiting on condition [0x000070000dfcd000]   java.lang.Thread.State: WAITING (parking)        at sun.misc.Unsafe.park(Native Method)        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:304)        at com.liuzhihang.source.LockSupportTest.main(LockSupportTest.java:14)</code></pre><ol><li>中间省略部分，但是可以看出线程进入 <code>WAITING</code> 状态</li></ol><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><pre><code class="java">public class LockSupport &#123;    private static final sun.misc.Unsafe UNSAFE;    /**     * 为线程 thread 设置一个许可     * 无许可，则添加一个许可，有许可，则不添加     * 如果线程因为 park 被阻塞， 添加许可之后，会解除阻塞状态     */    public static void unpark(Thread thread) &#123;        if (thread != null)            UNSAFE.unpark(thread);    &#125;    /**     * 有许可，则使用该许可     * 没有许可，阻塞线程，直到获得许可     * 传递 blocker 是为了方便使用诊断工具     */    public static void park(Object blocker) &#123;        Thread t = Thread.currentThread();        setBlocker(t, blocker);        UNSAFE.park(false, 0L);        setBlocker(t, null);    &#125;    /**     * 设置线程的 blocker 属性     */    private static void setBlocker(Thread t, Object arg) &#123;        // Even though volatile, hotspot doesn&#39;t need a write barrier here.        UNSAFE.putObject(t, parkBlockerOffset, arg);    &#125;&#125;</code></pre><p>LockSupport 的 park unpark 方法，实际调用的是底层 Unsafe 类的 native 方法。</p><pre><code class="java">public final class Unsafe &#123;    public native void unpark(Object var1);    public native void park(boolean var1, long var2);&#125;</code></pre><p>既然调用了 Unsafe 到此处肯定不能善罢甘休。</p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/ffecad2c8644bab7d152be118c31722d.jpg" align=center /><h4 id="hotspot-源码"><a href="#hotspot-源码" class="headerlink" title="hotspot 源码"></a>hotspot 源码</h4><p>这块是下载的官方包中的源码，阅读并查阅资料了解的大概逻辑，不清楚之处，希望指导出来。</p><p>也可以直接跳过直接看结论。</p><p>查看jdk源码<br><a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/5a83b7215107/src/share/vm/runtime/park.hpp">http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/5a83b7215107/src/share/vm/runtime/park.hpp</a></p><p>这块在以 os_linux 代码为例<br><a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/5a83b7215107/src/os/linux/vm/os_linux.cpp">http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/5a83b7215107/src/os/linux/vm/os_linux.cpp</a></p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/c-parker.png" align=center /><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/c-park.png" align=center /><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/c-unpark.png" align=center /><ol><li>在底层维护了一个 <code>_counter</code> 通过更新 <code>_counter</code> 的值来标示是否有证明。</li><li>在 park 时，判断 <code>_counter</code> 为 0，则阻塞等待，为 1 则获得更新为 0 并返回。</li><li>在 unpark 时，判断 <code>_counter</code> 为 0，则给予凭证，并唤醒线程，为 1 则直接返回。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结也是和预想的是相同的。</p><ol><li>许可（permit）的上限是1，也就是说只有 0 或 1 。</li><li>park: 没有许可的时候，permit 为 0 ，调用 park 会阻塞；有许可的时候，permit 为 1 ， 调用 park 会扣除一个许可，然后返回。</li><li>unpark：没有许可的时候，permit 为 0 ，调用 unpark 会增加一个许可，因为许可上限是 1 ， 所以调用多次也只会为 1 个。</li><li>线程初始的时候是没有许可的。</li><li>park 的当前线程如果被中断，会立即返回，并不会抛出中断异常。</li></ol><h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><ul><li>park/unpark 和 wait/notify 区别</li></ul><ol><li>park 阻塞当前线程，unpark 唤醒指定线程。</li><li>wait() 需要结合锁使用，并释放锁资源，如果没有设置超时时间，则需要 notify() 唤醒。而 notify() 是随机唤醒线程。 </li></ol>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码笔记 </tag>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JDK源码笔记】- JDK 8 新增的 LongAdder，得过来看一下！</title>
      <link href="2020/06/28/source-code-longadder.html"/>
      <url>2020/06/28/source-code-longadder.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>在介绍 AtomicInteger 时，已经说明在高并发下大量线程去竞争更新同一个原子变量时，因为只有一个线程能够更新成功，其他的线程在竞争失败后，只能一直循环，不断的进行 CAS 尝试，从而浪费了 CPU 资源。而在 JDK 8 中新增了 LongAdder 用来解决高并发下变量的原子操作。下面同样通过阅读源码来了解 LongAdder 。</p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>一个或多个变量共同维持初值为 0 总和。 当跨线程竞争更新时，变量集可以动态增长以减少竞争。 方法 sum 返回当前变量集的总和。</p><p>当多个线程更新时，这个类是通常优选 AtomicLong ，比如用于收集统计信息，不用于细粒度同步控制的共同总和。 在低更新竞争，这两个类具有相似的特征。 但在高更新竞争时，使用 LongAdder 性能要高于 AtomicLong，同样要消耗更高的空间为代价。</p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/longadder-uml.png" align=center /><p>LongAdder 继承了 Striped64，内部维护一个 Cells 数组，相当于多个 Cell 变量， 每个 Cell 里面都有一个初始值为 0 的 long 型变量。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="Cell-类"><a href="#Cell-类" class="headerlink" title="Cell 类"></a>Cell 类</h4><p>Cell 类 是 Striped64 的静态内部类。</p><pre><code class="java">@sun.misc.Contended static final class Cell &#123;    volatile long value;    Cell(long x) &#123; value = x; &#125;    final boolean cas(long cmp, long val) &#123;        return UNSAFE.compareAndSwapLong(this, valueOffset, cmp, val);    &#125;    // Unsafe mechanics    private static final sun.misc.Unsafe UNSAFE;    private static final long valueOffset;    static &#123;        try &#123;            UNSAFE = sun.misc.Unsafe.getUnsafe();            Class&lt;?&gt; ak = Cell.class;            valueOffset = UNSAFE.objectFieldOffset                (ak.getDeclaredField(&quot;value&quot;));        &#125; catch (Exception e) &#123;            throw new Error(e);        &#125;    &#125;&#125;</code></pre><ol><li>Cell 使用 @sun.misc.Contended 注解。</li><li>内部维护一个被 volatile 修饰的 long 型 value 。</li><li>提供 cas 方法，更新value。</li></ol><p>其中 @sun.misc.Contended 注解作用是为了减少缓存争用。什么是缓存争用，这里只做下简要介绍。</p><blockquote><p>伪共享<br>CPU 存在多级缓存，其中最小存储单元是 Cache Line，每个 Cache Line 能存储 64 个字节的数据。<br>在多线程场景下，A B 两个线程数据如果被存储到同一个 Cache Line 上，此时 A B 更新各自的数据，就会发生缓存争用，导致多个线程之间相互牵制，变成了串行程序，降低了并发。<br>@sun.misc.Contended 注解，则可以保证该变量独占一个 Cache Line。<br>详细可参考：<a href="http://openjdk.java.net/jeps/142">http://openjdk.java.net/jeps/142</a></p></blockquote><h4 id="Striped64-核心属性"><a href="#Striped64-核心属性" class="headerlink" title="Striped64 核心属性"></a>Striped64 核心属性</h4><pre><code class="java">abstract class Striped64 extends Number &#123;    /** CPU 的数量，以限制表大小 */    static final int NCPU = Runtime.getRuntime().availableProcessors();    /**     * cell 数组，当非空时，大小是 2 的幂。     */    transient volatile Cell[] cells;    /**     * Base 值，在无争用时使用，表初始化竞赛期间的后备。使用 CAS 更新      */    transient volatile long base;    /**     * 调整大小和创建Cells时自旋锁（通过CAS锁定）使用。     */    transient volatile int cellsBusy;&#125;</code></pre><p>Striped64 类主要提供以下几个属性：</p><ol><li>NCPU：CPU 的数量，以限制表大小。</li><li>cells：Cell[] cell 数组，当非空时，大小是 2 的幂。</li><li>base：long 型，Base 值，在无争用时使用，表初始化竞赛期间的后备。使用 CAS 更新。</li><li>cellsBusy：调整大小和创建Cells时自旋锁（通过CAS锁定）使用。</li></ol><p>下面看是进入核心逻辑：</p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/uFCfpw.gif" align=center /><h4 id="LongAdder-add"><a href="#LongAdder-add" class="headerlink" title="LongAdder#add"></a>LongAdder#add</h4><pre><code class="java">public class LongAdder extends Striped64 implements Serializable &#123;    public void add(long x) &#123;        Cell[] as; long b, v; int m; Cell a;        // cells 是 数组，base 是基础值        if ((as = cells) != null || !casBase(b = base, b + x)) &#123;            boolean uncontended = true;            if (as == null || (m = as.length - 1) &lt; 0 ||                (a = as[getProbe() &amp; m]) == null ||                !(uncontended = a.cas(v = a.value, v + x)))                longAccumulate(x, null, uncontended);        &#125;    &#125;&#125;</code></pre><pre><code class="java">abstract class Striped64 extends Number &#123;    // 使用 CAS 更新 BASE 的值    final boolean casBase(long cmp, long val) &#123;        return UNSAFE.compareAndSwapLong(this, BASE, cmp, val);    &#125;    // 返回当前线程的探测值。 由于包装限制，从ThreadLocalRandom复制    static final int getProbe() &#123;        return UNSAFE.getInt(Thread.currentThread(), PROBE);    &#125;&#125;</code></pre><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/longadder-add.png" align=center /><ol><li>首先会对 Base 值进行 CAS 更新，当 Base 发生竞争时， 会更新数组内的 Cell 。</li><li>数组未初始化，Cell 未初始化， Cell 更新失败，即 Cell 也发生竞争时，会调用 Striped64 的 longAccumulate 方法。</li></ol><h4 id="Striped64-longAccumulate"><a href="#Striped64-longAccumulate" class="headerlink" title="Striped64#longAccumulate"></a>Striped64#longAccumulate</h4><pre><code class="java">abstract class Striped64 extends Number &#123;    /**     * x 要增加的值     * wasUncontended 有没有发生竞争      */    final void longAccumulate(long x, LongBinaryOperator fn, boolean wasUncontended) &#123;        int h;        // 当前线程有无初始化线程探测值， 给当前线程生成一个 非 0 探测值        if ((h = getProbe()) == 0) &#123;            ThreadLocalRandom.current(); // force initialization            h = getProbe();            wasUncontended = true;        &#125;        boolean collide = false;                // True if last slot nonempty        // 循环        for (;;) &#123;            Cell[] as; Cell a; int n; long v;            // 数组不为空切数组长度大于 0            if ((as = cells) != null &amp;&amp; (n = as.length) &gt; 0) &#123;                // (n - 1) &amp; h 获取到索引，索引处 cell 是否为 null， cell未初始化                if ((a = as[(n - 1) &amp; h]) == null) &#123;                    // 判断 cellsBusy 是否为 0                    if (cellsBusy == 0) &#123;       // Try to attach new Cell                        Cell r = new Cell(x);   // Optimistically create                        // cellsBusy == 0 且 使用 casCellsBusy 方法将其更新为 1，失败会继续循环                        if (cellsBusy == 0 &amp;&amp; casCellsBusy()) &#123;                            boolean created = false;                            try &#123;               // Recheck under lock                                Cell[] rs; int m, j;                                // 重新检查状态 并创建                                if ((rs = cells) != null &amp;&amp; (m = rs.length) &gt; 0 &amp;&amp; rs[j = (m - 1) &amp; h] == null) &#123;                                    rs[j] = r;                                    created = true;                                &#125;                            &#125; finally &#123;                                // 创建完成之后， 改回 cellsBusy 值                                cellsBusy = 0;                            &#125;                            if (created)                                break;                            // 未创建继续循环                            continue;           // Slot is now non-empty                        &#125;                    &#125;                    collide = false;                &#125;                // 传入的 wasUncontended 为 false 即发生碰撞了， 修改为未碰撞， 此处会继续循环，走到下一步，相当于会一直循环这个 cell                else if (!wasUncontended)       // CAS already known to fail                    wasUncontended = true;      // Continue after rehash                // cas 更新 cell 的 value， 成功则返回                else if (a.cas(v = a.value, ((fn == null) ? v + x : fn.applyAsLong(v, x))))                    break;                // 数组到最大长度 即大于等于 CPU 数量， 或者 cells 数组被改变，                else if (n &gt;= NCPU || cells != as)                    collide = false;            // At max size or stale                else if (!collide)                    collide = true;                // 乐观锁 进行扩容                else if (cellsBusy == 0 &amp;&amp; casCellsBusy()) &#123;                    try &#123;                        if (cells == as) &#123;      // Expand table unless stale                            Cell[] rs = new Cell[n &lt;&lt; 1];                            for (int i = 0; i &lt; n; ++i)                                rs[i] = as[i];                            cells = rs;                        &#125;                    &#125; finally &#123;                        cellsBusy = 0;                    &#125;                    collide = false;                    continue;                   // Retry with expanded table                &#125;                // 当前探针值不能操作成功，则重新设置一个进行尝试                h = advanceProbe(h);            &#125;            // 没有加 cellsBusy 乐观锁 且 没有初始化，且获得锁成功（此时 cellsBusy == 1）            else if (cellsBusy == 0 &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;                boolean init = false;                try &#123;                           // Initialize table                    if (cells == as) &#123;                        Cell[] rs = new Cell[2];                        rs[h &amp; 1] = new Cell(x);                        cells = rs;                        init = true;                    &#125;                &#125; finally &#123;                    cellsBusy = 0;                &#125;                if (init)                    break;            &#125;            // 尝试在base上累加            else if (casBase(v = base, ((fn == null) ? v + x : fn.applyAsLong(v, x))))                break;                          // Fall back on using base        &#125;    &#125;&#125;</code></pre><p>longAccumulate 方法一共有三种情况</p><ol><li><code>(as = cells) != null &amp;&amp; (n = as.length) &gt; 0</code> 数组不为空且长度大于 0 。<ol><li>获取索引处的 cell ， cell 为空则进行初始化。</li><li>cell 不为空，使用 cas 更新， 成功 <code>break;</code> 跳出循环， 失败则还在循环内，会一直尝试。</li><li>collide 指是否发生冲突，冲突后会进行重试。</li><li>冲突后会尝试获得锁并进行扩容，扩容长度为原来的 2 倍，然后继续重试。</li><li>获得锁失败（说明其他线程在扩容）会重新进行计算探针值。</li></ol></li><li><code>cellsBusy == 0 &amp;&amp; cells == as &amp;&amp; casCellsBusy()</code> 数组为空，获得乐观锁成功。<ol><li>直接初始化数组。</li><li>初始数组长度为 2 。</li></ol></li><li><code>casBase(v = base, ((fn == null) ? v + x : fn.applyAsLong(v, x)))</code> 获得乐观锁失败。<ol><li>说明有其他线程在初始化数组，直接 CAS 更新 base 。</li></ol></li></ol><h4 id="LongAdder-sum"><a href="#LongAdder-sum" class="headerlink" title="LongAdder#sum"></a>LongAdder#sum</h4><pre><code class="java">public class LongAdder extends Striped64 implements Serializable &#123;    public long sum() &#123;        Cell[] as = cells; Cell a;        long sum = base;        if (as != null) &#123;            for (int i = 0; i &lt; as.length; ++i) &#123;                if ((a = as[i]) != null)                    sum += a.value;            &#125;        &#125;        return sum;    &#125;&#125;</code></pre><ol><li>数组为空，说明没有发生竞争，直接返回 base 。</li><li>数组不为空，说明发生竞争，累加 cell 的 value 和 base 的和进行返回。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h4><ol><li>LongAdder 继承了 Striped64，内部维护一个 Cells 数组，相当于多个 Cell 变量， 每个 Cell 里面都有一个初始值为 0 的 long 型变量。</li><li>未发生竞争时（Cells 数组未初始化），是对 base 变量进行原子操作。</li><li>发生竞争时，每个线程对自己的 Cell 变量的 value 进行原子操作。</li></ol><h4 id="如何确定哪个线程操作哪个-cell？"><a href="#如何确定哪个线程操作哪个-cell？" class="headerlink" title="如何确定哪个线程操作哪个 cell？"></a>如何确定哪个线程操作哪个 cell？</h4><p>通过 <code>getProbe()</code> 方法获取该线程的探测值，然后和数组长度 <code>n - 1</code> 做 <code>&amp;</code> 操作 (n - 1) &amp; h 。</p><pre><code class="java">static final int getProbe() &#123;    return UNSAFE.getInt(Thread.currentThread(), PROBE);&#125;</code></pre><h4 id="Cells-数组初始化及扩容？"><a href="#Cells-数组初始化及扩容？" class="headerlink" title="Cells 数组初始化及扩容？"></a>Cells 数组初始化及扩容？</h4><p>初始化扩容时会判断 <code>cellsBusy</code>， cellsBusy 使用 <code>volatile</code> 修饰，保证线程见可见性，同时使用 CAS 进行更新。 0 表示空闲，1 表示正在初始化或扩容。</p><p>初始化时会创建长度为 2 的 Cell 数组。扩容是创建一个长度是原数组长度 2 倍的新数组，并循环赋值。</p><p>如果线程访问分配的 Cell 元素有冲突后，会使用 <code>advanceProbe()</code> 方法重新获取探测值，再次进行尝试。</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>在高并发情况下，需要相对高的性能，同时数据准确性要求不高，可以考虑使用 LongAdder。</p><p>当要保证线程安全，并允许一定的性能损耗时，并对数据准确性要求较高，优先使用 AtomicLong。</p>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码笔记 </tag>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JDK源码笔记】- 请介绍下你了解的ThreadLocal，它的底层原理！</title>
      <link href="2020/06/21/source-code-threadlocal.html"/>
      <url>2020/06/21/source-code-threadlocal.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>前言</strong></p><p>业务开发中经常使用 ThreadLocal 来存储用户信息等线程私有对象… ThreadLocal 内部构造是什么样子的？为什么可以线程私有？常说的内存泄露又是怎么回事？</p><p>公众号：liuzhihangs ，记录工作学习中的技术、开发及源码笔记；时不时分享一些生活中的见闻感悟。欢迎大佬来指导！</p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote><p>ThreadLocal 类提供了线程局部变量。和正常对象不同的是，每个线程都可以访问 get()、set() 方法，获取独属于自己的副本。 ThreadLocal 实例通常是类中的私有静态字段，并且其状态和线程关联。<br>每个线程都保持对其线程局部变量副本的隐式引用，只要线程是活动的并且 ThreadLocal 实例访问; 一个线程消失之后，所有的线程局部实例的副本都会被垃圾回收（除非存在对这些副本的其他引用）。</p></blockquote><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>有这么一种使用场景，收到 web 请求，先进行 token 验证，而这个 token，可以解析出用户 user 的信息。所以我这边一般是这样使用的：</p><ol><li>自定义注解， <code>@CheckToken</code> ， 标识该方法需要校验 token。</li><li>在 <code>Interceptor</code>（拦截器）中检查，如果方法有 <code>@CheckToken</code> 注解则校验 token。</li><li>从Header中获取 <code>Authorization</code> ，请求第三方或者自己的逻辑校验 token ，并解析成 user。</li><li>将user放到<code>ThreadLocal</code>中。</li><li>controller、service 在后续使用中， 如果需要 user 信息，可以直接从 <code>ThreadLocal</code> 中获取。</li><li>使用结束后进行remove。</li></ol><h4 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h4><pre><code class="java">public class LocalUserUtils &#123;    /**     * 用户信息保存至 ThreadLocal 中     */    private static final ThreadLocal&lt;User&gt; USER_THREAD_LOCAL = new ThreadLocal&lt;&gt;();    public static void set(User user) &#123;        USER_THREAD_LOCAL.set(user);    &#125;    public static User get() &#123;        return USER_THREAD_LOCAL.get();    &#125;    public static void remove() &#123;        USER_THREAD_LOCAL.remove();    &#125;&#125;/** * 1. 加上注解 CheckToken * 只有方法， 类忽略 */@CheckToken@PostMapping(&quot;/doXxx&quot;)public Result&lt;Resp&gt; doXxx(@RequestBody Req req) &#123;    Resp resp = xxxService.doXxx(req);    return result.success(resp);&#125;/** * 2. 3. 4. */@Componentpublic class TokenInterceptor implements HandlerInterceptor &#123;    @Override    public void afterCompletion(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception arg3)            throws Exception &#123;        LocalUserUtils.remove();    &#125;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        // 请求方法是否存在注解        boolean assignableFrom = handler.getClass().isAssignableFrom(HandlerMethod.class);        if (!assignableFrom) &#123;            return true;        &#125;        CheckToken checkToken = null;        if (handler instanceof HandlerMethod) &#123;            checkToken = ((HandlerMethod) handler).getMethodAnnotation(CheckToken.class);        &#125;        // 没有加注解 直接放过        if (checkToken == null) &#123;            return true;        &#125;        // 从Header中获取Authorization        String authorization = request.getHeader(&quot;Authorization&quot;);        log.info(&quot;header authorization : &#123;&#125;&quot;, authorization);        if (StringUtils.isBlank(authorization)) &#123;            log.error(&quot;从Header中获取Authorization失败&quot;);            throw CustomExceptionEnum.NOT_HAVE_TOKEN.throwCustomException();        &#125;        User user = xxxUserService.checkAuthorization(authorization);        // 放到        LocalUserUtils.set(user);        return true;    &#125;&#125;/** * 5. 使用 * 只有方法， 类忽略 */@Overridepublic Resp doXxx(Req req) &#123;    User user = LocalUserUtils.get();    // do something ...    return resp;&#125;</code></pre><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/640.jpeg"  div align=center /><h4 id="抛出问题"><a href="#抛出问题" class="headerlink" title="抛出问题"></a>抛出问题</h4><ol><li>为什么可以线程私有？</li><li>为什么建议声明为静态？</li><li>为什么强制使用后必须remove？</li></ol><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/19.png" alt="19"></p><p>图 | 阿里巴巴 - Java开发手册（截图）</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/6.png" alt="6"></p><p>图 | 阿里巴巴 - Java开发手册（截图）</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h4><pre><code class="java">public class Thread implements Runnable &#123;    // 省略 ...    ThreadLocal.ThreadLocalMap threadLocals = null;    ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;    // 省略 ...&#125;</code></pre><p>可以看出 <code>Thread</code> 对象中声明了 <code>ThreadLocal.ThreadLocalMap</code> 对象，每个线程都有自己的工作内存，每个线程都有自己的 <code>ThreadLocal. ThreadLocalMap</code> 对象，所以在线程之间是互相<code>隔离</code>的。</p><h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><p>ThreadLocal则是一个泛型类，同时提供 <code>set()</code>、<code>get()</code>、<code>remove()</code> 等<code>静态</code>方法。</p><pre><code class="java">public class ThreadLocal&lt;T&gt; &#123;    // 线程本地hashCode    private final int threadLocalHashCode = nextHashCode();    // 获取此线程局部变量的当前线程副本中的值    public T get() &#123;...&#125;    // 设置当前线程的此线程局部变量的复制到指定的值    public void set(T value) &#123;...&#125;    // 删除当前线程的此线程局部变量的值    public void remove() &#123;...&#125;    // ThreadLocalMap只是用来维持线程本地值的定制Map    static class ThreadLocalMap &#123;...&#125;&#125;</code></pre><h5 id="set-T-value-方法"><a href="#set-T-value-方法" class="headerlink" title="set(T value)方法"></a>set(T value)方法</h5><pre><code class="java">public void set(T value) &#123;    // 获取当前线程    Thread t = Thread.currentThread();    // 获取当前线程的 threadLocals 属性    ThreadLocalMap map = getMap(t);    if (map != null)        // 存在则赋值        map.set(this, value);    else        // 不存在则直接创建        createMap(t, value);&#125;// 根据线程获取当前线程的ThreadLocalMapThreadLocalMap getMap(Thread t) &#123;    return t.threadLocals;&#125;// 创建ThreadLocalMap 并赋值给当前线程的threadLocals字段void createMap(Thread t, T firstValue) &#123;    t.threadLocals = new ThreadLocalMap(this, firstValue);&#125;</code></pre><p>1.<code>Thread.currentThread()</code> 先获取到当前线程。<br>2. 获取当前线程的 <code>threadLocals</code> 属性，即 <code>ThreadLocalMap</code>。<br>3. 判断 Map 是否存在，存在则赋值，不存在则创建对象。</p><h5 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h5><pre><code class="java">public T get() &#123;    // 获取当前线程    Thread t = Thread.currentThread();    // 获取当前线程的 threadLocals 属性    ThreadLocalMap map = getMap(t);    // map不为空    if (map != null) &#123;        // 根据当前ThreadLocal获取的ThreadLocalMap的Entry节点        ThreadLocalMap.Entry e = map.getEntry(this);        if (e != null) &#123;            // 获取节点的value 并返回            @SuppressWarnings(&quot;unchecked&quot;)            T result = (T)e.value;            return result;        &#125;    &#125;    // 设置初始值并返回 （null）    return setInitialValue();&#125;</code></pre><p>1.<code>Thread.currentThread()</code> 先获取到当前线程。<br>2. 获取当前线程的 <code>threadLocals</code> 属性，即 <code>ThreadLocalMap</code> 。<br>3. 判断 Map 不为空，根据当前 <code>ThreadLocal</code> 对象获取 <code>ThreadLocalMap.Entry</code> 节点, 从节点中获取 value。<br>4.<code>ThreadLocalMap</code> 为空或者 <code>ThreadLocalMap.Entry</code> 为空，则初始化 ThreadLocalMap 并返回。</p><h5 id="remove-方法"><a href="#remove-方法" class="headerlink" title="remove()方法"></a>remove()方法</h5><pre><code class="java">public void remove() &#123;    // 获取当前线程的ThreadLocalMap    ThreadLocalMap m = getMap(Thread.currentThread());    // 不为空， 从ThreadLocalMap中移除该属性    if (m != null)        m.remove(this);&#125;</code></pre><p>阅读 <code>set()</code>、<code>get()</code>、<code>remove()</code> 的源码之后发现后面其实是操作的 <code>ThreadLocalMap</code>, 主要还是操作的 <code>ThreadLocalMap</code> 的 <code>set()</code>、<code>getEntry()</code>、<code>remove()</code> 以及构造函数。下面看是看 ThreadLocalMap 的源码。</p><h4 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h4><pre><code class="java">static class ThreadLocalMap &#123;    /**     * Entry节点继承WeakReference是弱引用     */    static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;        /** 与此ThreadLocal关联的值。 */        Object value;        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;            super(k);            value = v;        &#125;    &#125;    // 初始容量-必须是2的幂    private static final int INITIAL_CAPACITY = 16;    // 表，根据需要调整大小. table.length必须始终为2的幂.    private ThreadLocal.ThreadLocalMap.Entry[] table;    // 表中的条目数。     private int size = 0;    // 扩容阈值      private int threshold; // Default to 0    // 设置阀值为长度的 2/3       private void setThreshold(int len) &#123;        threshold = len * 2 / 3;    &#125;    // 构造函数    ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;...&#125;    // 根据ThreadLocal获取节点Entry    private ThreadLocal.ThreadLocalMap.Entry getEntry(ThreadLocal&lt;?&gt; key) &#123;...&#125;    // set ThreadLocalMap的k-v    private void set(ThreadLocal&lt;?&gt; key, Object value) &#123;...&#125;    // 移除当前值    private void remove(ThreadLocal&lt;?&gt; key) &#123;...&#125;&#125;</code></pre><ol><li>Entry 继承了 <code>WeakReference&lt;ThreadLocal&lt;?&gt;</code> 也就意味着， <code>Entry 节点的 key 是弱引用</code>。</li><li>Entry 对象的key弱引用，指向的是 <code>ThreadLocal</code> 对象。</li><li>线程对象执行完毕，线程对象内实例属性会被回收，此时线程内 <code>ThreadLocal</code> 对象的<code>引用</code>被置为 <code>null</code> ，即 Entry 的 <code>key</code> 为 <code>null</code>, key 会被垃圾回收。</li><li>ThreadLocal 对象通常为私有静态变量， 生命周期不会至少不会随着线程技术而结束。</li><li>ThreadLocal 对象存在，并且 <code>Entry的 key == null &amp;&amp; value != null</code> ，这时就会造成内存泄漏。</li></ol><ul><li>小补充</li></ul><ol><li>强引用、软引用、弱引用、虚引用<pre><code class="text">强引用（StrongReference）：最常见，直接 new Object(); 创建的即为强引用。当内存空间不足，Java虚拟机宁愿抛出 OOM，也不愿意随意回收具有强引用的对象来解决内存不足问题。软引用（SoftReference）：内存足够，垃圾回收器不会回收软引用对象；内存不足时，垃圾回收器会回收。弱引用（WeakReference）：垃圾回收器线程，发现就会回收。虚引用（PhantomReference）：任何时候都有可能被垃圾回收，必须引用队列联合使用。</code></pre></li><li>内存泄露：<pre><code class="text">内存泄漏（Memory leak）是在计算机科学中，由于疏忽或错误造成程序未能释放已经不再使用的内存。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费。—— 维基百科</code></pre></li></ol><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/SJPSIU.jpg"  div align=center /><h5 id="构造函数及hash计算"><a href="#构造函数及hash计算" class="headerlink" title="构造函数及hash计算"></a>构造函数及hash计算</h5><pre><code class="java">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;    // 初始化Entry数组， 长度为16    table = new Entry[INITIAL_CAPACITY];    // 获取key的hashCode，并计算出在数组中的索引，    // 长度是 2的幂的情况下，取模 a % b == a &amp; (b - 1)    int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);    table[i] = new Entry(firstKey, firstValue);    // 设置数组元素数    size = 1;    // 设置扩容阈值    setThreshold(INITIAL_CAPACITY);&#125;</code></pre><p>threadLocalHashCode 是 ThreadLocal 的静态属性，通过 nextHashCode 方法获取。</p><pre><code class="java">private final int threadLocalHashCode = nextHashCode();// 被赋予了接下来的哈希码。 原子更新。 从零开始。private static AtomicInteger nextHashCode = new AtomicInteger();private static final int HASH_INCREMENT = 0x61c88647;private static int nextHashCode() &#123;    // 返回下一个hash码，通过步长 0x61c88647 累加生成，这块注释说明是最佳哈希值    return nextHashCode.getAndAdd(HASH_INCREMENT);&#125;</code></pre><ol><li>初始化数组，长度16。</li><li>计算 key 的 hashCode，对2的幂取模。</li><li>设置元素，元素数及扩容阈值。</li></ol><p>hashCode 通过步长 0x61c88647 累加生成， 并且使用了 AtomicInteger，保证原子性。</p><h5 id="set-方法"><a href="#set-方法" class="headerlink" title="set()方法"></a>set()方法</h5><pre><code class="java">private void set(ThreadLocal&lt;?&gt; key, Object value) &#123;    Entry[] tab = table;    int len = tab.length;    // hashcode取模求数组索引    int i = key.threadLocalHashCode &amp; (len-1);    // 获取数组中对应的位置， 重点关注 e = tab[i = nextIndex(i, len)]    for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123;        // 获取key        ThreadLocal&lt;?&gt; k = e.get();        // key 存在则覆盖        if (k == key) &#123;            e.value = value;            return;        &#125;        // key 不存在则赋值        if (k == null) &#123;            replaceStaleEntry(key, value, i);            return;        &#125;    &#125;    // 此时 e == null 直接执创建节点    tab[i] = new Entry(key, value);    int sz = ++size;    // cleanSomeSlots 循环数组 查找全部key==null的Entry    if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)        rehash();&#125;</code></pre><ol><li>获取循环 Entry 数组，获取 tab[i] 处的 e， e != null 继续循环<ol><li>此时发现 e 的 key 不存在，并且不是 null （hash冲突了。）</li><li>那就通过 e = tab[i = nextIndex(i, len)]) 继续获取下一个 i，并获取新的 tab[i] 处的 e。</li><li>赋值替换值结束结束并返回。</li></ol></li><li>e == null 结束循环。</li></ol><pre><code class="java">// 下一个index，如果 i + 1 &lt; len 直接返回下一个位置  // 如果 i + 1 &gt;= len 则返回 0， 从头开始。private static int nextIndex(int i, int len) &#123;    return ((i + 1 &lt; len) ? i + 1 : 0);&#125;private static int prevIndex(int i, int len) &#123;    return ((i - 1 &gt;= 0) ? i - 1 : len - 1);&#125;</code></pre><ol><li>这块利用环形设计，如果长度到达数组长度，则从开头开始继续查找。</li><li>int i = key.threadLocalHashCode &amp; (len-1); 求出索引，并不是从0开始的。</li></ol><pre><code class="java">/** * staleSlot 为当前索引位置， 并且当前索引位置的 k == null */private void replaceStaleEntry(ThreadLocal&lt;?&gt; key, Object value, int staleSlot) &#123;    Entry[] tab = table;    int len = tab.length;    Entry e;    // 需要清除的 entry 的索引    int slotToExpunge = staleSlot;    // 循环获取到上一个 key==null 的节点及其索引，有可能还是自己    for (int i = prevIndex(staleSlot, len); (e = tab[i]) != null; i = prevIndex(i, len))        if (e.get() == null)            slotToExpunge = i;    // 继续上一层的循环，查找下一个 k == key 的节点索引    for (int i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) &#123;        ThreadLocal&lt;?&gt; k = e.get();        if (k == key) &#123;            // key 相等 则直接赋值            e.value = value;            // 并且将 此处的 entry替换为 tab[staleSlot]            tab[i] = tab[staleSlot];            tab[staleSlot] = e;            // 如果发现要清除的 entry和传入的在一个位置上， 则直接赋值            if (slotToExpunge == staleSlot)                slotToExpunge = i;            // 清除掉过期的 expungeStaleEntry(slotToExpunge) 会清除 entry的value，将其设置为null并将其设置为null， 并返回下一个需要清除的entry的索引位置            // cleanSomeSlots 循环数组 查找全部key==null的Entry            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);            return;        &#125;        // 如果向后扫描没有找到，并且已经到第初始传入的索引位置处了        if (k == null &amp;&amp; slotToExpunge == staleSlot)            slotToExpunge = i;    &#125;    // 没找到， 直接将旧值 Entry 设置为 null 并指向新创建的Entry    tab[staleSlot].value = null;    tab[staleSlot] = new Entry(key, value);    // 结束之后发现要清楚的 key的索引 不等于当前传入的索引， 说明还有其他需要清除。    if (slotToExpunge != staleSlot)        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);&#125;</code></pre><ol><li>这里存在三个属性 key， value，以及 staleSlot， staleSlot节点的 Entry != null 但是 k == null。</li><li>向前扫描获取到上一个  Entry != null 但是 k == null 的节点及其索引, 赋值给 slotToExpunge， 没有扫描到的话 slotToExpunge 还是等于 staleSlot。</li><li>向后扫描 Entry != null 的节点，因为在 set 方法中， 后面还有一段数组没有遍历。<ol><li>发现 key 相等的Entry节点了， 直接赋值，然后清除其他 Entry != null 但是 k == null 的节点， 并返回。</li><li>没有找到key相等的节点，但是找到了下一个 Entry != null 但是 k == null， 且此时 slotToExpunge 未发生变化，还是指向 staleSlot， 则 i 赋值给 slotToExpunge。</li></ol></li><li>向后扫描没有扫描到，则直接对当前节点（索引值为staleSlot）的节点的value设置为null，并指向新value。</li><li>结束之后发现 slotToExpunge 被改变了， 说明还有其他的要清除。</li></ol><h5 id="getEntry-方法"><a href="#getEntry-方法" class="headerlink" title="getEntry()方法"></a>getEntry()方法</h5><pre><code class="java">private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123;    // hashcode取模求数组索引    int i = key.threadLocalHashCode &amp; (table.length - 1);    Entry e = table[i];    if (e != null &amp;&amp; e.get() == key)        // 存在则返回        return e;    else        // 不存在        return getEntryAfterMiss(key, i, e);&#125;private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123;    Entry[] tab = table;    int len = tab.length;    while (e != null) &#123;        ThreadLocal&lt;?&gt; k = e.get();        if (k == key)            return e;        if (k == null)            // key 已经 == null 了 清除一下 value            expungeStaleEntry(i);        else            // 继续获取下一个            i = nextIndex(i, len);        e = tab[i];    &#125;    return null;&#125;</code></pre><ol><li>hashcode 取模求数组索引。</li><li>索引处获取到 Entry 则直接返回。</li><li>获取不到或者获取到的 Entry key 不相等时，有可能是因为 hash 冲突，被放到别的地方， 调用 getEntryAfterMiss 方法。</li><li>getEntryAfterMiss 方法中。<ol><li>e == null  返回null。</li><li>e != null  判断key， key相等返回 Entry， key == null， 那就需要清除这个节点，然后继续按照 <code>nextIndex(i, len)</code> 方法找下一个节点。</li></ol></li></ol><h4 id="remove-方法-1"><a href="#remove-方法-1" class="headerlink" title="remove()方法"></a>remove()方法</h4><pre><code class="java">private void remove(ThreadLocal&lt;?&gt; key) &#123;    Entry[] tab = table;    int len = tab.length;    // hashcode 取模求数组索引    int i = key.threadLocalHashCode &amp; (len-1);    // 清除当前节点的value    for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123;        if (e.get() == key) &#123;            // 清楚对象引用            e.clear();            // value 指向 null            expungeStaleEntry(i);            return;        &#125;    &#125;&#125;public void clear() &#123;    this.referent = null;&#125;</code></pre><ol><li>hashcode 取模求数组索引。</li><li>循环查找数组，将当前 key 的 Entry 的引用，将 value 设置为 null， 后面会被垃圾回收掉。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="为什么可以线程私有？"><a href="#为什么可以线程私有？" class="headerlink" title="为什么可以线程私有？"></a>为什么可以线程私有？</h4><p>ThreadLocal 的 get()、set()、remove()方法中都有 <code>Thread t = Thread.currentThread();</code> 操作的其实是本线程，获取本线程的ThreadLocalMap。</p><p>每个线程都有自己的 ThreadLocal，并且是将 value 存放在一个以 ThreadLocal 为 key 的 ThreadLocalMap 中的。所以线程间隔离。</p><h4 id="为什么建议声明为静态？"><a href="#为什么建议声明为静态？" class="headerlink" title="为什么建议声明为静态？"></a>为什么建议声明为静态？</h4><p>Java开发手册已经给出说明，还有就是，如果 ThreadLocal 设置为非静态，那就是某个线程的实例类，这样的话就会失去了线程共享的本质属性。</p><h4 id="为什么强制必须时候后remove-？"><a href="#为什么强制必须时候后remove-？" class="headerlink" title="为什么强制必须时候后remove()？"></a>为什么强制必须时候后remove()？</h4><p>这块可以和内存泄露一块说明， 通过上面的 <code>ThreadLocalMap</code> 处关于弱引用的讲解已经说明会产生内存泄露。至于如何解决也给出了答案：</p><p>1.<code>set()</code> 时清除 Entry != null &amp;&amp; key == null 的节点， 将其 value 设置为 null。<br>2.<code>getEntry()</code> 时清除<code>当前 key 到 nextIndex(i, len)==null 之间的</code> Entry != null &amp;&amp; key == null 的节点， 将其 value 设置为 null。<br>3.<code>remove()</code> 时清除<code>指定key</code>的 Entry != null &amp;&amp; key == null 的节点， 将其 value 设置为 null。</p><p>之所以使用remove()，还是为了解决内存泄露的问题。</p><h4 id="Last"><a href="#Last" class="headerlink" title="Last"></a>Last</h4><ol><li>使用时注意声明为 <code>private static final</code>。</li><li>使用后要 <code>remove()</code>。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码笔记 </tag>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JDK源码笔记】- 从JUC源码看CAS，我做了个笔记 ......</title>
      <link href="2020/06/12/source-code-cas.html"/>
      <url>2020/06/12/source-code-cas.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>前言<br>JUC包下大量使用了CAS，工作和面试中也经常遇到CAS，包括说到乐观锁，也不可避免的想起CAS，那CAS究竟是什么？</p></blockquote><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>说到CAS，基本上都会想到乐观锁、AtomicInteger、Unsafe … </p><p>当然也有可能啥也没想到！</p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/zoi3eG.jpg" div align=center /><p>不管你们怎么想， 我第一印象是乐观锁，毕竟做交易更新交易状态经常用到乐观锁，就自然想到这个SQL：</p><pre><code class="sql">update trans_order set order_status = 1 where order_no = &#39;xxxxxxxxxxx&#39; and order_status = 0;</code></pre><p>其实就是 set和where里面都携带order_status。</p><p>那什么是CAS？</p><p>CAS就是<code>Compare-and-Swap</code>，即比较并替换，在并发算法时常用，并且在JUC（java.util.concurrent）包下很多类都使用了CAS。</p><p>非常常见的问题就是多线程操作i++问题。一般解决办法就是添加 synchronized 关键字修饰，当然也可以使用 AtomicInteger 代码举例如下：</p><pre><code class="java">public class CasTest &#123;    private static final CountDownLatch LATCH = new CountDownLatch(10);    private static int NUM_I = 0;    private static volatile int NUM_J = 0;    private static final AtomicInteger NUM_K = new AtomicInteger(0);    public static void main(String[] args) throws InterruptedException &#123;        ExecutorService threadPool = Executors.newFixedThreadPool(10);        for (int i = 0; i &lt; 10; i++) &#123;            threadPool.execute(new Runnable() &#123;                public void run() &#123;                    for (int j = 0; j &lt; 10000; j++) &#123;                        NUM_I++;                        NUM_J++;                        NUM_K.incrementAndGet();                    &#125;                    LATCH.countDown();                &#125;            &#125;);        &#125;        LATCH.await();        System.out.println(&quot;NUM_I = &quot; + NUM_I);        System.out.println(&quot;NUM_J = &quot; + NUM_J);        System.out.println(&quot;NUM_K = &quot; + NUM_K.get());        threadPool.shutdown();    &#125;&#125;</code></pre><p>下面就从<code>AtomicInteger</code>开始了解CAS。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><pre><code class="java">public class AtomicInteger extends Number implements java.io.Serializable &#123;    private static final long serialVersionUID = 6214790243416807050L;    // setup to use Unsafe.compareAndSwapInt for updates    private static final Unsafe unsafe = Unsafe.getUnsafe();    private static final long valueOffset;    static &#123;        try &#123;            valueOffset = unsafe.objectFieldOffset                (AtomicInteger.class.getDeclaredField(&quot;value&quot;));        &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;    &#125;    private volatile int value;    public final int incrementAndGet() &#123;        return unsafe.getAndAddInt(this, valueOffset, 1) + 1;    &#125;    public final int decrementAndGet() &#123;        return unsafe.getAndAddInt(this, valueOffset, -1) - 1;    &#125;&#125;</code></pre><p>可以看出里面使用了<code>Unsafe</code>类下的<code>getAndAddInt</code>方法，<code>Unsafe</code>类很多方法是本地（native）方法，主要是硬件级别的<code>原子操作</code>。</p><pre><code class="java">/** * @param var1 当前对象 * @param var2 当前对象在内存偏移量，Unsafe可以根据内存偏移地址获取数据 * @param var4 操作值 * @return */public final int getAndAddInt(Object var1, long var2, int var4) &#123;    int var5;    do &#123;        // 获取在var1在内存的值        var5 = this.getIntVolatile(var1, var2);        // 将var1赋值为var5+var4， 赋值时会判断var1是否为var5    &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));    return var5;&#125;// 原子操作public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);</code></pre><p>至于 compareAndSwapInt 的分析就忽略了。 </p><p>看完代码过程其实就是：</p><ol><li>比较var1的值是否为var4，是的话将var1更新为var5。</li><li>如果不是的话就一直循环，直到var1是var4。</li></ol><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/3E5FDF0D-875A-4CD0-9B75-61D01ACBCD50_4_5005_c.jpeg"  div align=center /><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/iyLlPP.png"  div align=center /><ol><li>这要是一直获取不到，岂不是一直循环。线程多的情况下，会自旋很长时间，导致浪费资源。</li><li>你更新了， 我又给你更新回去了，你也不知道。ABA问题！比如像这样，A想更新值为a，还未抢到资源，这时候B进行了更新，将对象更新为了b，然后又马上更新回了a， 这时候A是什么都不知道的。</li></ol><p>以乐观锁举例：</p><pre><code class="sql">-- 0 -&gt; 1update trans_order set order_status = 1 where order_no = &#39;xxxxxxxxxxx&#39; and order_status = 0;-- 1 -&gt; 0update trans_order set order_status = 1 where order_no = &#39;xxxxxxxxxxx&#39; and order_status = 0;-- 0 -&gt; 1update trans_order set order_status = 1 where order_no = &#39;xxxxxxxxxxx&#39; and order_status = 0;</code></pre><p>解决办法可以添加version进行版本号控制。</p><pre><code class="sql">-- 0 -&gt; 1update trans_order set order_status = 1 where order_no = &#39;xxxxxxxxxxx&#39; and order_status = 0 and version = 0;-- 1 -&gt; 0update trans_order set order_status = 1 where order_no = &#39;xxxxxxxxxxx&#39; and order_status = 0 and version = 1;-- 0 -&gt; 1update trans_order set order_status = 1 where order_no = &#39;xxxxxxxxxxx&#39; and order_status = 0 and version = 0;</code></pre><p>代码中可以看 <code>AtomicStampedReference</code> 类：</p><pre><code class="java">/** * 以原子方式设置该引用和标志给定的更新值的值， * 如果当前引用==预期的引用，并且当前标志==预期标志。 * * @param expectedReference 预期引用 * @param newReference 更新的值 * @param expectedStamp 预期标志 * @param newStamp 更新的标志 * @return &#123;@code true&#125; if successful */public boolean compareAndSet(V   expectedReference,                                V   newReference,                                int expectedStamp,                                int newStamp) &#123;    Pair&lt;V&gt; current = pair;    return        expectedReference == current.reference &amp;&amp;        expectedStamp == current.stamp &amp;&amp;        ((newReference == current.reference &amp;&amp;            newStamp == current.stamp) ||            casPair(current, Pair.of(newReference, newStamp)));&#125;</code></pre><p>其实就是额外增加一个标志（<code>stamp</code>）来防止ABA的问题， 类似乐观锁的version。</p>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码笔记 </tag>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JDK源码笔记】- HashMap红黑树</title>
      <link href="2020/05/25/source-code-hashmap-red-black-tree.html"/>
      <url>2020/05/25/source-code-hashmap-red-black-tree.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>前言<br>在阅读HashMap源码时，会发现在HashMap中使用了红黑树，所以需要先了解什么是红黑树，以及其原理。从而再进一步阅读HashMap中的链表到红黑树的转换，红黑树的增删节点等。</p></blockquote><blockquote><ol><li>什么是红黑树？</li><li>在HashMap中是怎么应用的？</li></ol></blockquote><h3 id="什么是红黑树？"><a href="#什么是红黑树？" class="headerlink" title="什么是红黑树？"></a>什么是红黑树？</h3><blockquote><p>红黑树（英语：Red–black tree）是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组。它在1972年由鲁道夫·贝尔发明，被称为”对称二叉B树”，它现代的名字源于Leo J. Guibas和Robert Sedgewick于1978年写的一篇论文。红黑树的结构复杂，但它的操作有着良好的最坏情况运行时间，并且在实践中高效：它可以在O(logN)时间内完成查找、插入和删除，这里的n是树中元素的数目。</p></blockquote><h3 id="红黑树的性质"><a href="#红黑树的性质" class="headerlink" title="红黑树的性质"></a>红黑树的性质</h3><p>红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求：</p><ol><li>节点是红色或黑色。</li><li>根是黑色。</li><li>所有叶子都是黑色（叶子是NIL节点）。</li><li>每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）</li><li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/red-black-tree001.jpeg" alt="红黑树001"></p><h3 id="红黑树操作"><a href="#红黑树操作" class="headerlink" title="红黑树操作"></a>红黑树操作</h3><h4 id="左旋、右旋"><a href="#左旋、右旋" class="headerlink" title="左旋、右旋"></a>左旋、右旋</h4><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/krck8S.gif" alt="krck8S"></p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/OUd2GL.gif" alt="OUd2GL"></p><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><ol><li>以二叉查找树的方法增加节点</li><li>新插入节点为红色（如果设为黑色，就会导致根到叶子的路径上有一条路上，多一个额外的黑节点，这个是很难调整的。但是设为红色节点后，可能会导致出现两个连续红色节点的冲突，那么可以通过颜色调换（color flips）和树旋转来调整。）</li></ol><p>注意：</p><ol><li>性质1和性质3是永远保持着的。</li><li>性质4只在增加红色节点、重绘黑色节点为红色，或做旋转时受到威胁。</li><li>性质5只在增加黑色节点、重绘红色节点为黑色，或做旋转时受到威胁。</li></ol><p>插入时会遇到以下五种情形：</p><blockquote><p>情形1：插入第一个节点<br>情形2：插入新节点，父节点是黑色<br>情形3：插入新节点，父节点是红色，叔父节点是红色<br>情形4：插入新节点，父节点是红色，叔父节点是黑色或缺省，新节点是右子节点，父节点又是其父节点的左子节点<br>情形5：插入新节点，父节点是红色，叔父节点是黑色或缺省，新节点是左子节点，父节点又是其父节点的左子节点。</p></blockquote><ul><li>情形1：</li></ul><p>操作：插入第一个节点<br>违反性质2：” 根是黑色。 “<br>情形：直接插入红色节点，然后进行染色为黑色</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/red-black-tree1.gif" alt="红黑树1"></p><ul><li>情形2：</li></ul><p>操作：插入新节点，父节点是黑色<br>未违反性质<br>情形：直接插入</p><ul><li>情形3：</li></ul><p>操作：插入新节点，父节点是红色，叔父节点是红色<br>违反性质4：” 每个红色节点必须有两个黑色的子节点。 “<br>情形：将祖父节点染色，祖父节点染色后再进行重新判断进行染色或旋转</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/red-black-tree3.gif" alt="红黑树3"></p><ul><li>情形4：</li></ul><p>操作：插入新节点，父节点是红色，叔父节点是黑色或缺省，新节点是右子节点，父节点又是其父节点的左子节点<br>违反性质4：” 每个红色节点必须有两个黑色的子节点。 “<br>情形：进行左旋，旋转后父节点变成左子节点，新节点变成父节点，然后重新判断进行染色或旋转</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/red-black-tree4.gif" alt="红黑树4"></p><ul><li>情形5：</li></ul><p>操作：插入新节点，父节点是红色，叔父节点是黑色或缺省，新节点是左子节点，父节点又是其父节点的左子节点。<br>违反性质4：” 每个红色节点必须有两个黑色的子节点。 “<br>情形：父节点染色为黑色，进行右旋，祖父节点变为右子节点，然后重新判断进行染色或旋转</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/red-black-tree5.gif" alt="红黑树5"></p><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><pre><code class="java">static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123;    TreeNode&lt;K,V&gt; parent;  // red-black tree links    TreeNode&lt;K,V&gt; left;    TreeNode&lt;K,V&gt; right;    TreeNode&lt;K,V&gt; prev;    // needed to unlink next upon deletion    boolean red;    // ... 省略&#125;</code></pre><h4 id="三个参数"><a href="#三个参数" class="headerlink" title="三个参数"></a>三个参数</h4><pre><code class="java">/** * 链表转为树阈值。  * 大于等于8时，会转换为树。  * 8 是综合性能考虑确定的值 */static final int TREEIFY_THRESHOLD = 8;/** * 从树转换为链表的阈值 */static final int UNTREEIFY_THRESHOLD = 6;/** * 最小树形化容量，只有哈希表元素数到达64才会进行树转换 */static final int MIN_TREEIFY_CAPACITY = 64;</code></pre><h4 id="链表转红黑树-treeifyBin"><a href="#链表转红黑树-treeifyBin" class="headerlink" title="链表转红黑树-treeifyBin"></a>链表转红黑树-treeifyBin</h4><ol><li>数组（哈希表）长度到达64</li><li>当链表长度大于等于8是会将链表转换为红黑树</li></ol><pre><code class="java">final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123;    int n, index; Node&lt;K,V&gt; e;    // 数组为null或者数组长度小于MIN_TREEIFY_CAPACITY（64）时，进行扩容    if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)        resize();    else if ((e = tab[index = (n - 1) &amp; hash]) != null) &#123;        // 头尾节点 hd-头 tl-尾        TreeNode&lt;K,V&gt; hd = null, tl = null;        do &#123;            // 创建树节点 Node -&gt; TreeNode            // 循环执行完之后得到的是双向链表            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);            if (tl == null)                hd = p;            else &#123;                p.prev = tl;                tl.next = p;            &#125;            tl = p;        &#125; while ((e = e.next) != null);        // 此时得到的仅仅是双向链表        // 指针指向链表头        if ((tab[index] = hd) != null)            // 将双向链表转换为树            hd.treeify(tab);    &#125;&#125;</code></pre><pre><code class="java">final void treeify(Node&lt;K,V&gt;[] tab) &#123;    TreeNode&lt;K,V&gt; root = null;    for (TreeNode&lt;K,V&gt; x = this, next; x != null; x = next) &#123;        next = (TreeNode&lt;K,V&gt;)x.next;        x.left = x.right = null;        if (root == null) &#123;            // 情形1：插入第一个节点            x.parent = null;            x.red = false;            root = x;        &#125;        else &#123;            // 当前节点的 key 和 hash            K k = x.key;            int h = x.hash;            Class&lt;?&gt; kc = null;            // 再次循环            for (TreeNode&lt;K,V&gt; p = root;;) &#123;                int dir, ph;                // 内层循环的key                K pk = p.key;                // 当前节点的hash和内层循环的hash值作比较                if ((ph = p.hash) &gt; h)                    // &lt; 0 left查找                    dir = -1;                else if (ph &lt; h)                    // &gt; 0 right 查找                    dir = 1;                else if ((kc == null &amp;&amp;                            (kc = comparableClassFor(k)) == null) ||                            (dir = compareComparables(kc, k, pk)) == 0)                    // 比较对象                    dir = tieBreakOrder(k, pk);                TreeNode&lt;K,V&gt; xp = p;                // dir &lt;= 0 则走 left查找 &gt; 0 则走 right查找                if ((p = (dir &lt;= 0) ? p.left : p.right) == null) &#123;                    x.parent = xp;                    if (dir &lt;= 0)                        xp.left = x;                    else                        xp.right = x;                    // 正式转换为红黑树                    root = balanceInsertion(root, x);                    break;                &#125;            &#125;        &#125;    &#125;    moveRootToFront(tab, root);&#125;</code></pre><pre><code class="java">// root 根节点// x 要操作的节点static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceInsertion(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; x) &#123;    // 默认节点为红色    x.red = true;    // xp：x的父节点    // xpp：x的祖父节点    // xppl：x祖父节点的左子节点    // xppr：x祖父节点的右子节点    for (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;        // 情形1： 父节点为null， 直接置为根        if ((xp = x.parent) == null) &#123;            x.red = false;            return x;        &#125;        // 父节点黑色 或者 祖父节点为空，直接返回        // 情形2：插入新节点，父节点是黑色        else if (!xp.red || (xpp = xp.parent) == null)            return root;        // 父节点是祖父节点的左子节点        if (xp == (xppl = xpp.left)) &#123;            // 祖父节点的右子节点不为空且是红色            // 情形3：插入新节点，父节点是红色，叔父节点是红色            if ((xppr = xpp.right) != null &amp;&amp; xppr.red) &#123;                xppr.red = false; //祖父节点的右子节点设置为黑色                xp.red = false; // 父节点设置为黑色                xpp.red = true; // 祖父节点设置为红色                x = xpp; // 继续操作祖父节点            &#125;            // 旋转            else &#123;                // 新插入的是右子节点                if (x == xp.right) &#123;                    // 插入的x是父节点的右子节点， 进行左旋                    root = rotateLeft(root, x = xp);                    xpp = (xp = x.parent) == null ? null : xp.parent;                &#125;                if (xp != null) &#123;                    // 父节点设置为黑色                    xp.red = false;                    if (xpp != null) &#123;                        xpp.red = true;                        // 右旋                        root = rotateRight(root, xpp);                    &#125;                &#125;            &#125;        &#125;        // 父节点是祖父节点的右子节点        else &#123;            // 祖父节点的左子节点不为空且为红色            if (xppl != null &amp;&amp; xppl.red) &#123;                xppl.red = false; // 祖父节点的左子节点设置为黑色                xp.red = false; // 父节点设置为黑色                xpp.red = true; // 祖父节点设置为红色                x = xpp; // 继续操作祖父节点            &#125;            // 旋转            else &#123;                if (x == xp.left) &#123;                    root = rotateRight(root, x = xp);                    xpp = (xp = x.parent) == null ? null : xp.parent;                &#125;                if (xp != null) &#123;                    xp.red = false;                    if (xpp != null) &#123;                        xpp.red = true;                        root = rotateLeft(root, xpp);                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码笔记 </tag>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JDK源码笔记】- HashMap扩容</title>
      <link href="2020/05/17/source-code-hashmap-resize.html"/>
      <url>2020/05/17/source-code-hashmap-resize.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>描述下HashMap put(k,v)的流程？<br>它的扩容流程是怎么样的？</p></blockquote><h3 id="HashMap-put-k-v-流程"><a href="#HashMap-put-k-v-流程" class="headerlink" title="HashMap put(k,v)流程"></a>HashMap put(k,v)流程</h3><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/3pSob4.png" alt="3pSob4"></p><ol><li>通过hash(key方法)获取到key的hash值</li><li>调用put方法, 将value存放到指定的位置<ol><li>根据hash值确定当前key所在node数组的索引 <code>(n - 1) &amp; hash</code></li><li>如果node[i]==null 则直接创建新数组</li><li>如果node[i]!=null<ol><li>判断 当前node的头结点的 hash和key是否都相等, 相等则需要操作的就是该node</li><li>判断当前节点是否为TreeNode，对TreeNode进行操作，并返回结果e</li><li>如果是链表则遍历链表，key存在则返回节点e，不存在则赋值</li><li>判断节点e有没有被赋值，覆盖旧值</li></ol></li><li>hashMap size进行加1，同时判断v新size是否大于扩容阈值从而判断是否需要扩容</li></ol></li></ol><pre><code class="java">public V put(K key, V value) &#123;    return putVal(hash(key), key, value, false, true);&#125;</code></pre><pre><code class="java">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,                   boolean evict) &#123;        // 声明Node数组tab, Node节点        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;        // 对tab数组赋值为当前HashMap的table, 并判断是否为空, 或者长度为0        // 为0进行则resize()数组, 并对 n赋值为当前tab的长度        // resize() 对HashMap的table扩容, 并返回扩容后的新数组        if ((tab = table) == null || (n = tab.length) == 0)            n = (tab = resize()).length;        // 对 node p 进行赋值, 数组所在位置 即 node p 如果是null 则直接赋值        if ((p = tab[i = (n - 1) &amp; hash]) == null)            tab[i] = newNode(hash, key, value, null);        else &#123;            // p 不为null, 声明 node e, key k            Node&lt;K,V&gt; e; K k;            // 如果hash值相等且key相等, 直接将 e 赋值为当前node的头节点            if (p.hash == hash &amp;&amp;                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))                e = p;            else if (p instanceof TreeNode)            // 如果是红黑树, 则对树进行操作, 返回节点e                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);            else &#123;                // 对链表进行遍历, 找到对应的节点                for (int binCount = 0; ; ++binCount) &#123;                    // 将 e 赋值为  头节点p的next, 如果下一个节点为null                    if ((e = p.next) == null) &#123;                        // 对节点进行赋值                        p.next = newNode(hash, key, value, null);                        // 如果长度到达数转换阈值, 则需要转换为红黑树                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st                            treeifyBin(tab, hash);                        break;                    &#125;                    // 如果e节点的hash相等, key相等, 则 直接跳出循环 e 已经被赋值为 p.next                    // 此时e节点的value没有被赋值                    if (e.hash == hash &amp;&amp;                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                        break;                    // 指针指向下一个节点, 继续遍历                    p = e;                &#125;            &#125;            if (e != null) &#123; // existing mapping for key                V oldValue = e.value;                // 对旧值进行覆盖, 并返回旧值                if (!onlyIfAbsent || oldValue == null)                    e.value = value;                afterNodeAccess(e);                return oldValue;            &#125;        &#125;        ++modCount;        // 是否需要扩容        if (++size &gt; threshold)            resize();        afterNodeInsertion(evict);        return null;    &#125;</code></pre><h3 id="resize-扩容过程"><a href="#resize-扩容过程" class="headerlink" title="resize()扩容过程"></a>resize()扩容过程</h3><ol><li>JDK 1.7 扩容流程, 每次都需要数组扩容后, 链表需要重新计算在新数组的位置</li><li>JDK 1.8 不需要重新计算 (优化点)<ol><li>数组下标: (n - 1) &amp; hash 即数组长度-1 &amp; key的hash</li><li>扩容后的数组下标: ((n &lt;&lt; 1) - 1) &amp; hash 相当于在 高位1之前加了个1</li></ol></li></ol><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/GRQHSY.png" alt="GRQHSY"></p><p>如图所示, 真正发生影响的是新增的那一位(红色箭头所指), 所以 oldCap &amp; hash 完全可以判断该值是放在旧索引值的位置还是放在旧索引值+旧数组长度的位置</p><pre><code class="java">final Node&lt;K,V&gt;[] resize() &#123;    // 旧数组    Node&lt;K,V&gt;[] oldTab = table;    // 旧数组长度    int oldCap = (oldTab == null) ? 0 : oldTab.length;    // 旧的扩容阈值    int oldThr = threshold;    // 新的数组长度和新扩容阈值    int newCap, newThr = 0;    // 旧数组存在    if (oldCap &gt; 0) &#123;        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;            threshold = Integer.MAX_VALUE;            return oldTab;        &#125;        // 新数组长度为旧数组长度的2倍        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)            // 扩容阈值是旧扩容阈值的2倍            newThr = oldThr &lt;&lt; 1; // double threshold    &#125;    // 旧数组不存在, 相当于首次put(K, V)时, 将数组长度置为扩容阈值    else if (oldThr &gt; 0) // initial capacity was placed in threshold        newCap = oldThr;    else &#123;               // zero initial threshold signifies using defaults        // 旧数组不存在, new HashMap()未指定长度, 初次put(K, V), 设置为默认值        newCap = DEFAULT_INITIAL_CAPACITY;        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);    &#125;    // 新的扩容阈值是0, 则将扩容阈值设置为 新数组长度*负载因子    if (newThr == 0) &#123;        float ft = (float)newCap * loadFactor;        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?                  (int)ft : Integer.MAX_VALUE);    &#125;    // 对全局的扩容阈值进行赋值    threshold = newThr;    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)    // 创建新数组, 长度为新长度, 即原数组长度的2倍    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];    // 将table复制为新数组    table = newTab;    if (oldTab != null) &#123;        // 对旧数组进行遍历        for (int j = 0; j &lt; oldCap; ++j) &#123;            Node&lt;K,V&gt; e;            // 旧节点node赋值            if ((e = oldTab[j]) != null) &#123;                oldTab[j] = null;                if (e.next == null)                // 只有头结点, 直接计算新的位置并赋值                    newTab[e.hash &amp; (newCap - 1)] = e;                else if (e instanceof TreeNode)                // 树单独处理                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);                else &#123; // preserve order                    Node&lt;K,V&gt; loHead = null, loTail = null;                    Node&lt;K,V&gt; hiHead = null, hiTail = null;                    Node&lt;K,V&gt; next;                    do &#123;                        // next节点                        next = e.next;                        // 节点hash与旧数组长度 &amp; 的结果来决定元素所在位置, 参考上面图示所讲                        if ((e.hash &amp; oldCap) == 0) &#123;                            // 在元索引出创建新链表                            if (loTail == null)                                loHead = e;                            else                                loTail.next = e;                            loTail = e;                        &#125;                        else &#123;                            // 新索引出创建链表                            if (hiTail == null)                                hiHead = e;                            else                                hiTail.next = e;                            hiTail = e;                        &#125;                    &#125; while ((e = next) != null);                    if (loTail != null) &#123;                        loTail.next = null;                        // 索引j处直接赋值                        newTab[j] = loHead;                    &#125;                    if (hiTail != null) &#123;                        hiTail.next = null;                        // 索引 j + 老数组长度位置存放hiHead                        newTab[j + oldCap] = hiHead;                    &#125;                &#125;            &#125;        &#125;    &#125;    return newTab;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码笔记 </tag>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JDK源码笔记】- HashMap的初始化</title>
      <link href="2020/05/11/source-code-hashmap-init.html"/>
      <url>2020/05/11/source-code-hashmap-init.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>HashMap初始化参数都是什么？默认是多少？<br>为什么建议初始化设置容量？<br>tableSizeFor方法是做什么的？<br>如何获取到一个key的hash值？及计算下标？</p></blockquote><h3 id="HashMap初始化参数都是什么？默认是多少？"><a href="#HashMap初始化参数都是什么？默认是多少？" class="headerlink" title="HashMap初始化参数都是什么？默认是多少？"></a>HashMap初始化参数都是什么？默认是多少？</h3><p>HashMap初始化参数分别是初始容量和负载因子。</p><p>初始容量(threshold)：默认 16， 必须是2的幂， 最大容量为 1 &lt;&lt; 30</p><p>负载因子(loadFactor)：是指哈希表的负载因子，当哈希表的长度大于<code>capacity * loadFactor</code>时会进行扩容，默认 0.75f</p><h3 id="为什么建议初始化设置容量"><a href="#为什么建议初始化设置容量" class="headerlink" title="为什么建议初始化设置容量"></a>为什么建议初始化设置容量</h3><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/3aQLYq.png" alt="3aQLYq"></p><p>这块涉及到HashMap的扩容， 在<code>阿里巴巴Java开发手册</code>中已经说明了原因。主要是为了减少频繁的扩容造成的资源损耗。</p><h3 id="tableSizeFor方法是做什么的？"><a href="#tableSizeFor方法是做什么的？" class="headerlink" title="tableSizeFor方法是做什么的？"></a>tableSizeFor方法是做什么的？</h3><p>初始化HashMap时, 如果传入初始容量, 在初始化时会调用 <code>tableSizeFor(initialCapacity)</code> 方法寻找大于等于当前值的下一个2的幂值.</p><p>代码如下：</p><pre><code class="java">static final int tableSizeFor(int cap) &#123;    int n = cap - 1; //  -1操作, 防止当cap正好是2的幂时的处理    n |= n &gt;&gt;&gt; 1; // n无符号右移1位, 然后和n做 | 运算, (1|0=1 1|1=1 0|0=0 0|1=1)    n |= n &gt;&gt;&gt; 2; // n无符号右移2位, 然后和n做 | 运算,    n |= n &gt;&gt;&gt; 4; // n无符号右移4位, 然后和n做 | 运算,    n |= n &gt;&gt;&gt; 8; // n无符号右移8位, 然后和n做 | 运算,    n |= n &gt;&gt;&gt; 16; // n无符号右移16位, 然后和n做 | 运算,    // 最后获得的结果为 cap-1的下一个2的幂值-1, 只需要对n+1即可    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125;</code></pre><ol><li>假设cap值为100, 即0110 0100</li><li>cap的下一个2的幂为 0111 1111 即 1000 0000</li><li>0000 = 0111 1111 + 1</li><li>只需要考虑将 首个为1的最高位之后的值置为1, 然后+1即可</li><li>为防止cap本来就是2的幂, 则需要先进行减一操作</li></ol><p>如图所示:<br><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/51Xhtj.png" alt="51Xhtj"></p><p>最后执行的结果进行加1即可</p><h3 id="如何获取到一个key的hash值？"><a href="#如何获取到一个key的hash值？" class="headerlink" title="如何获取到一个key的hash值？"></a>如何获取到一个key的hash值？</h3><pre><code class="java">static final int hash(Object key) &#123;    int h;    // key的hashCode ^ 上自己的高16位， 如果是null的话则hash为0    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;</code></pre><p>获取到了hash值， 那如何计算在数组的那个位置呢？</p><pre><code class="java">// n为数组长度  数组下标i = (n - 1) &amp; hash</code></pre><p>数组长度都是 2的幂<br>假设 n = 1 &gt;&gt; x<br>则 n - 1 则表示 一个低x位全为1的数</p><p>(n - 1) &amp; hash 则相当于 一个低x位全为1的数和hash做&amp;操作.</p><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/article/OAZssV.png" alt="OAZssV"></p><p>通过图可以看出, 参与运算的只有低x位, 相当于之前的所有值都不会有效. 所以前面的hash(key) 将key.hashCode()高低16位做^操作, 可以保证, 高低16位都能参与运算.一定程度上避免hash碰撞.在源码注释中已经说明, 是肯定会有碰撞, 但是这是权衡之后的结果.</p>]]></content>
      
      
      <categories>
          
          <category> 源码笔记 </category>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码笔记 </tag>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown代码折叠</title>
      <link href="2020/04/20/markdown-code-folding.html"/>
      <url>2020/04/20/markdown-code-folding.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h3><h4 id="折叠内容"><a href="#折叠内容" class="headerlink" title="折叠内容"></a>折叠内容</h4><details><summary>折叠内容</summary>在markdown中折叠一部分内容, 点击可以展开.</details><h4 id="折叠代码"><a href="#折叠代码" class="headerlink" title="折叠代码"></a>折叠代码</h4><details><summary>折叠代码</summary><pre><code class="java">public class HelloWorld &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;HelloWorld&quot;);    &#125;&#125;</code></pre></details><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>使用html</p><pre><code class="html">&lt;details&gt;&lt;summary&gt;折叠内容&lt;/summary&gt;在markdown中折叠一部分内容, 点击可以展开.&lt;/details&gt;</code></pre><pre><code class="html">&lt;details&gt;&lt;summary&gt;折叠代码&lt;/summary&gt; 代码块&lt;/details&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
            <tag> 小技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>雪花算法</title>
      <link href="2020/04/13/snowflake-algorithm.html"/>
      <url>2020/04/13/snowflake-algorithm.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>简单介绍下雪花算法, 以及Java版雪花算法的代码.<br>仅仅是一个最简单版本, 更深层次的指针回拨等. 相当于在开发过成功可以先使用.<br>尽量还是使用统一的分布式流水号生成系统, 保证流水号全局唯一.</p></blockquote><h3 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h3><pre><code>0 0000000000 0000000000 0000000000 0000000000 0 00000 00000 000000000000</code></pre><p>使用64位long型数字作为全局唯一id<br>1位 无意义 0<br>41位 时间戳<br>5位 机房id<br>5位 机器id<br>12位自增序号 表示同一时间同一机房同一机器生成的序列号</p><ol><li><p>第一位为什么无意义<br> 二进制中 第一位代表符号位, 默认 0 表示生成的序列号为正数</p></li><li><p>41位时间戳<br> 41位最大能表示 2^41-1 的数字. 毫秒值 69.7年<br> (2^41-1)/1000/60/60/24</p><p> 当时间大于69.7即时间戳差值大于 2199023255551, 会开始出现负值流水号</p></li><li><p>10位<br> 机房id+机器id 2^10 1024台机器</p><pre><code class="java">// 但是使用中不可能每部署一台机器都改下编号, 所以我做出以下改动// 8位机器号(最大256) 2位机房号// 机器号使用IP地址后三位 机房id 默认1// 只需要确保机器的ip后三位不同即可private static final long MACHINE_BIT = 8;private static final long DATA_CENTER_BIT = 2;</code></pre></li></ol><p>private static final long DATA_CENTER_ID = 1;<br>private static long address;<br>static {<br>    InetAddress localIp = IpUtils.getLocalIp();<br>    address = localIp.getAddress()[3] &amp; 0xff;<br>    log.info(“当前系统的 address 为: {}”, address);<br>}</p><pre><code>4. 12位序列号    表示同一毫秒内生成的id 2^12-1 个正整数SnowFlake每秒能够产生26万ID左右优点:生成ID时不依赖于DB，完全在内存生成，高性能高可用。ID呈趋势递增，后续插入索引树的时候性能较好。缺点:依赖于系统时钟的一致性。如果某台机器的系统时钟回拨，有可能造成ID冲突，或者ID乱序### SerialNumber```javapublic class SerialNumber  &#123;    /**     * 起始的时间戳 2018-01-01 00:00:00     */    private static final long START_STAMP = 1514736000000L;    /**     * 每一部分占用的位数     * 序列号 占用位数 12 位 (同一毫秒内生成的id 2^12-1 个正整数)     * 机器标识  占用位数 8 位 (一般是使用5位)     * 数据中心 占用位数 2 位 (一般是使用5位)     *     */    private static final long SEQUENCE_BIT = 12;    private static final long MACHINE_BIT = 8;    private static final long DATA_CENTER_BIT = 2;    /**     * 每一部分的最大值     */    private static final long MAX_DATA_CENTER_NUM = ~(-1L &lt;&lt; DATA_CENTER_BIT);    private static final long MAX_MACHINE_NUM = ~(-1L &lt;&lt; MACHINE_BIT);    private static final long MAX_SEQUENCE = ~(-1L &lt;&lt; SEQUENCE_BIT);    /**     * 每一部分向左的位移     * 机器Id左移12位 (SEQUENCE_BIT = 12)     * 数据中心左移20位 (SEQUENCE_BIT + MACHINE_BIT = 12 + 8)     * 时间戳左移22位 (DATA_CENTER_LEFT + DATA_CENTER_BIT = 12 + 8 + 2)     *     */    private static final long MACHINE_LEFT = SEQUENCE_BIT;    private static final long DATA_CENTER_LEFT = SEQUENCE_BIT + MACHINE_BIT;    private static final long TIME_STAMP_LEFT = DATA_CENTER_LEFT + DATA_CENTER_BIT;    /**     * 数据中心 机器标识 序列号 上一次时间戳     * 数据中心标识和机器标识一般是外部传入     */    private static final long DATA_CENTER_ID = 1;    private static long address;    private long sequence = 0L;    private long lastStamp = -1L;    private static final DateTimeFormatter DATE_TIME_FORMATTER = DateTimeFormatter.ofPattern(&quot;yyMMdd&quot;);    static &#123;      InetAddress localIp = IpUtils.getLocalIp();      address = localIp.getAddress()[3] &amp; 0xff;      log.info(&quot;当前系统的 address 为: &#123;&#125;&quot;, address);    &#125;    /**     * 产生下一个ID     *     * @return     */    private synchronized long nextId() &#123;        long currStamp = getNewStamp();        if (currStamp &lt; lastStamp) &#123;            throw new RuntimeException(&quot;Clock moved backwards.  Refusing to generate id&quot;);        &#125;        if (currStamp == lastStamp) &#123;            // 相同毫秒内，序列号自增 (sequence + 1) &amp; (~(-1L &lt;&lt; SEQUENCE_BIT))            sequence = (sequence + 1) &amp; MAX_SEQUENCE;            // 同一毫秒的序列数已经达到最大            if (sequence == 0L) &#123;                currStamp = getNextMill();            &#125;        &#125; else &#123;            // 不同毫秒内，序列号置为0            sequence = 0L;        &#125;        lastStamp = currStamp;        // 时间戳部分 数据中心部分 机器标识部分 序列号部分        return (currStamp - START_STAMP) &lt;&lt; TIME_STAMP_LEFT | DATA_CENTER_ID &lt;&lt; DATA_CENTER_LEFT            | address &lt;&lt; MACHINE_LEFT | sequence;    &#125;    private long getNextMill() &#123;        long mill = getNewStamp();        while (mill &lt;= lastStamp) &#123;            mill = getNewStamp();        &#125;        return mill;    &#125;    private long getNewStamp() &#123;        return System.currentTimeMillis();    &#125;&#125;</code></pre><h3 id="IpUtils"><a href="#IpUtils" class="headerlink" title="IpUtils"></a>IpUtils</h3><pre><code class="java">import java.net.*;import java.util.Enumeration;/** * @author liuzhihang * @date 2019/12/19 16:03 */public class IpUtils &#123;    public static InetAddress getLocalIp() &#123;        try &#123;            for (Enumeration&lt;NetworkInterface&gt; e = NetworkInterface.getNetworkInterfaces(); e.hasMoreElements(); ) &#123;                NetworkInterface item = e.nextElement();                for (InterfaceAddress address : item.getInterfaceAddresses()) &#123;                    if (item.isLoopback() || !item.isUp()) &#123;                        continue;                    &#125;                    if (address.getAddress() instanceof Inet4Address) &#123;                        return address.getAddress();                    &#125;                &#125;            &#125;            return InetAddress.getLocalHost();        &#125; catch (SocketException | UnknownHostException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> 流水号 </tag>
            
            <tag> 雪花算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目启动失败:java.lang.NoClassDefFoundError</title>
      <link href="2020/04/12/no-class-def-found-error-rule-configuration.html"/>
      <url>2020/04/12/no-class-def-found-error-rule-configuration.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>近期遇到一个很久没有启动过的项目, 然后启动失败, 报 java.lang.NoClassDefFoundError, 现在记录问题排查情况.</p></blockquote><h4 id="错误代码"><a href="#错误代码" class="headerlink" title="错误代码"></a>错误代码</h4><ul><li>错误代码较长, 可以收缩, 直接看排查</li></ul><pre><code>Error starting ApplicationContext. To display the conditions report re-run your application with &#39;debug&#39; enabled.][2020-04-10 13:26:11.478]-[main]-[]-[ERROR]-[org.springframework.boot.SpringApplication:821]-[Application run failed]org.springframework.context.ApplicationContextException: Unable to start web server; nested exception is org.springframework.boot.web.server.WebServerException: Unable to start embedded Tomcat        at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.onRefresh(ServletWebServerApplicationContext.java:155) ~[spring-boot-2.1.6.RELEASE.jar!/:2.1.6.RELEASE]        at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:543) ~[spring-context-5.1.8.RELEASE.jar!/:5.1.8.RELEASE]        at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:140) ~[spring-boot-2.1.6.RELEASE.jar!/:2.1.6.RELEASE]        at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:742) [spring-boot-2.1.6.RELEASE.jar!/:2.1.6.RELEASE]        at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:389) [spring-boot-2.1.6.RELEASE.jar!/:2.1.6.RELEASE]        at org.springframework.boot.SpringApplication.run(SpringApplication.java:311) [spring-boot-2.1.6.RELEASE.jar!/:2.1.6.RELEASE]        at org.springframework.boot.SpringApplication.run(SpringApplication.java:1213) [spring-boot-2.1.6.RELEASE.jar!/:2.1.6.RELEASE]        at org.springframework.boot.SpringApplication.run(SpringApplication.java:1202) [spring-boot-2.1.6.RELEASE.jar!/:2.1.6.RELEASE]        at com.opay.im.WebApplication.main(WebApplication.java:32) [classes!/:1.0-SNAPSHOT]        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[?:1.8.0_221]        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[?:1.8.0_221]        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[?:1.8.0_221]        at java.lang.reflect.Method.invoke(Method.java:498) ~[?:1.8.0_221]        at org.springframework.boot.loader.MainMethodRunner.run(MainMethodRunner.java:48) [opay-im-web-1.0-SNAPSHOT.jar:1.0-SNAPSHOT]        at org.springframework.boot.loader.Launcher.launch(Launcher.java:87) [opay-im-web-1.0-SNAPSHOT.jar:1.0-SNAPSHOT]        at org.springframework.boot.loader.Launcher.launch(Launcher.java:50) [opay-im-web-1.0-SNAPSHOT.jar:1.0-SNAPSHOT]        at org.springframework.boot.loader.JarLauncher.main(JarLauncher.java:58) [opay-im-web-1.0-SNAPSHOT.jar:1.0-SNAPSHOT]Caused by: org.springframework.boot.web.server.WebServerException: Unable to start embedded Tomcat        at org.springframework.boot.web.embedded.tomcat.TomcatWebServer.initialize(TomcatWebServer.java:124) ~[spring-boot-2.1.6.RELEASE.jar!/:2.1.6.RELEASE]        at org.springframework.boot.web.embedded.tomcat.TomcatWebServer.&lt;init&gt;(TomcatWebServer.java:86) ~[spring-boot-2.1.6.RELEASE.jar!/:2.1.6.RELEASE]        at org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory.getTomcatWebServer(TomcatServletWebServerFactory.java:414) ~[spring-boot-2.1.6.RELEASE.jar!/:2.1.6.RELEASE]        at org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory.getWebServer(TomcatServletWebServerFactory.java:178) ~[spring-boot-2.1.6.RELEASE.jar!/:2.1.6.RELEASE]        at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.createWebServer(ServletWebServerApplicationContext.java:179) ~[spring-boot-2.1.6.RELEASE.jar!/:2.1.6.RELEASE]        at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.onRefresh(ServletWebServerApplicationContext.java:152) ~[spring-boot-2.1.6.RELEASE.jar!/:2.1.6.RELEASE]        ... 16 moreCaused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;servletEndpointRegistrar&#39; defined in class path resource [org/springframework/boot/actuate/autoconfigure/endpoint/web/ServletEndpointManagementContextConfiguration$WebMvcServletEndpointManagementContextConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.boot.actuate.endpoint.web.ServletEndpointRegistrar]: Factory method &#39;servletEndpointRegistrar&#39; threw exception; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#39;healthEndpoint&#39; defined in class path resource [org/springframework/boot/actuate/autoconfigure/health/HealthEndpointConfiguration.class]: Unsatisfied dependency expressed through method &#39;healthEndpoint&#39; parameter 1; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;healthIndicatorRegistry&#39; defined in class path resource [org/springframework/boot/actuate/autoconfigure/health/HealthIndicatorAutoConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.boot.actuate.health.HealthIndicatorRegistry]: Factory method &#39;healthIndicatorRegistry&#39; threw exception; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#39;org.springframework.boot.actuate.autoconfigure.jdbc.DataSourceHealthIndicatorAutoConfiguration&#39;: Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#39;dataSource&#39; defined in class path resource [com/opay/im/config/DatabaseConfig.class]: Unsatisfied dependency expressed through method &#39;dataSource&#39; parameter 0; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;defaultDataSource&#39; defined in class path resource [com/opay/im/config/DatabaseConfig.class]: Initialization of bean failed; nested exception is java.lang.NoClassDefFoundError: org/apache/shardingsphere/api/config/RuleConfiguration        at org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:627) ~[spring-beans-5.1.8.RELEASE.jar!/:5.1.8.RELEASE]        at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:607) ~[spring-beans-5.1.8.RELEASE.jar!/:5.1.8.RELEASE]        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1321) ~[spring-beans-5.1.8.RELEASE.jar!/:5.1.8.RELEASE]        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1160) ~[spring-beans-5.1.8.RELEASE.jar!/:5.1.8.RELEASE]        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:555) ~[spring-beans-5.1.8.RELEASE.jar!/:5.1.8.RELEASE]        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:515) ~[spring-beans-5.1.8.RELEASE.jar!/:5.1.8.RELEASE]        at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:320) ~[spring-beans-5.1.8.RELEASE.jar!/:5.1.8.RELEASE]        at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) ~[spring-beans-5.1.8.RELEASE.jar!/:5.1.8.RELEASE]        at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:318) ~[spring-beans-5.1.8.RELEASE.jar!/:5.1.8.RELEASE]        at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:204) ~[spring-beans-5.1.8.RELEASE.jar!/:5.1.8.RELEASE]        at org.springframework.boot.web.servlet.ServletContextInitializerBeans.getOrderedBeansOfType(ServletContextInitializerBeans.java:211) ~[spring-boot-2.1.6.RELEASE.jar!/:2.1.6.RELEASE]        at org.springframework.boot.web.servlet.ServletContextInitializerBeans.getOrderedBeansOfType(ServletContextInitializerBeans.java:202) ~[spring-boot-2.1.6.RELEASE.jar!/:2.1.6.RELEASE]        at org.springframework.boot.web.servlet.ServletContextInitializerBeans.addServletContextInitializerBeans(ServletContextInitializerBeans.java:96) ~[spring-boot-2.1.6.RELEASE.jar!/:2.1.6.RELEASE]        at org.springframework.boot.web.servlet.ServletContextInitializerBeans.&lt;init&gt;(ServletContextInitializerBeans.java:85) ~[spring-boot-2.1.6.RELEASE.jar!/:2.1.6.RELEASE]        at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.getServletContextInitializerBeans(ServletWebServerApplicationContext.java:252) ~[spring-boot-2.1.6.RELEASE.jar!/:2.1.6.RELEASE]</code></pre><h4 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h4><ol><li>开始排查是因为缺少 <code>sharding-core-api-4.0.0-RC2.2-1.8.jar</code> 包下的一个文件, 但是本地是有的</li><li>本地可以启动</li><li>服务器启动失败, 可能是jar包缺少</li><li>最后结果发现 sharding-core-api-4.0.0-RC2.2-1.8.jar 是通过公司封装的一个包传递进来的, 而封装的那个jar包在私服上已经被删除了. <del>删除原因</del></li></ol>]]></content>
      
      
      <categories>
          
          <category> issue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> error </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac创建data目录失败</title>
      <link href="2020/01/05/mac-create-data-directory-failed.html"/>
      <url>2020/01/05/mac-create-data-directory-failed.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><blockquote><p>部分项目log日志输出路径为 /data/log, 发现无法创建目录<br>错误信息: <code>mkdir: cannot create directory ‘data’: Read-only file system</code></p></blockquote><h4 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h4><h5 id="关闭SPI"><a href="#关闭SPI" class="headerlink" title="关闭SPI"></a>关闭SPI</h5><ol><li>重启 按住CMD+R进入恢复模式</li><li>打开终端<br><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/feature/mac-spi.jpg" alt="spi关闭"></li><li>终端输入命令：csrutil disable</li></ol><h5 id="挂载data"><a href="#挂载data" class="headerlink" title="挂载data"></a>挂载data</h5><ol><li>在用户目录(可以自己找一个目录下创建data)</li></ol><pre><code class="bash">~  % &gt; cd ~~  % &gt; mkdir data</code></pre><ol start="2"><li>执行 <code>sudo mount -uw /</code> 重新挂载根目录</li><li>建立软链<pre><code class="bash">sudo ln -s /Users/liuzhihang/data /data</code></pre></li><li>之后可以重启再打开spi了<br><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/feature/mac-spi2.png" alt="spi关闭"></li></ol>]]></content>
      
      
      <categories>
          
          <category> issue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> issue </tag>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo中插入Bilibili视频</title>
      <link href="2019/09/14/hexo-inserts-bilibili-video.html"/>
      <url>2019/09/14/hexo-inserts-bilibili-video.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>修改matery主题首页显示视频为Bilibili视频</p><p>在Markdown插入Bilibili视频, 并设置大小.</p></blockquote><h3 id="首先找到分享嵌入代码"><a href="#首先找到分享嵌入代码" class="headerlink" title="首先找到分享嵌入代码"></a>首先找到分享嵌入代码</h3><p><img src="https://i.loli.net/2019/10/10/di3Cxcr9VLvjqM6.png" alt="Bilibili分享截图"></p><pre><code class="html">&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=17963687&amp;cid=29326684&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt; &lt;/iframe&gt;</code></pre><h3 id="在markdown中使用嵌入代码"><a href="#在markdown中使用嵌入代码" class="headerlink" title="在markdown中使用嵌入代码"></a>在markdown中使用嵌入代码</h3><iframe src="//player.bilibili.com/player.html?aid=17963687&cid=29326684&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h3 id="调整大小和居中等"><a href="#调整大小和居中等" class="headerlink" title="调整大小和居中等"></a>调整大小和居中等</h3><p><a href="https://www.w3school.com.cn/tags/tag_iframe.asp">iframe标签属性设置</a></p><pre><code class="html">&lt;!--    调整大小: width=&quot;xxx&quot; height=&quot;xxx&quot;--&gt;&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=17963687&amp;cid=29326684&amp;page=1&quot;  width=&quot;600&quot; height=&quot;400&quot;  scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt; &lt;/iframe&gt;</code></pre><iframe src="//player.bilibili.com/player.html?aid=17963687&cid=29326684&page=1" width="700" height="480"  scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h3 id="设置自适应"><a href="#设置自适应" class="headerlink" title="设置自适应"></a>设置自适应</h3><pre><code class="html">&lt;div style=&quot;position: relative; width: 100%; height: 0; padding-bottom: 75%;&quot;&gt;    &lt;iframe src=&quot;//player.bilibili.com/player.html?aid=17963687&amp;cid=29326684&amp;page=1&quot;  scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot; style=&quot;position: absolute; width: 100%; height: 100%; left: 0; top: 0;&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;</code></pre><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="//player.bilibili.com/player.html?aid=17963687&cid=29326684&page=1"  scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div><h3 id="matery-主题修改首页展示视频"><a href="#matery-主题修改首页展示视频" class="headerlink" title="matery 主题修改首页展示视频"></a>matery 主题修改首页展示视频</h3><p>找到 /themes/hexo-theme-matery/layout/_widget/video.ejs 将第十一行左右代码改成Bilibili视频即可, 引入的 script 可以删掉.</p><p>修改后如下.</p><pre><code class="js">&lt;div class=&quot;video-player&quot;&gt;    &lt;% if (theme.video.showTitle) &#123; %&gt;        &lt;div class=&quot;title center-align&quot;&gt;            &lt;i class=&quot;fas fa-video-camera&quot;&gt;&lt;/i&gt;&amp;nbsp;&amp;nbsp;&lt;%- theme.video.title %&gt;        &lt;/div&gt;    &lt;% &#125; %&gt;    &lt;div class=&quot;row&quot;&gt;        &lt;div class=&quot;col l8 offset-l2 m10 offset-m1 s12&quot;&gt;            &lt;div id=&quot;dplayer&quot; class=&quot;dplayer-video&quot;&gt;                &lt;div style=&quot;position: relative; width: 100%; height: 0; padding-bottom: 75%;&quot;&gt;                    &lt;iframe src=&quot;//player.bilibili.com/player.html?aid=16316393&amp;cid=26620787&amp;page=1&quot;  scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot; style=&quot;position: absolute; width: 100%; height: 100%; left: 0; top: 0;&quot;&gt;&lt;/iframe&gt;                &lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis分布式锁的生产问题解决方案</title>
      <link href="2019/08/18/redis-distributed-lock-production-problem-solution.html"/>
      <url>2019/08/18/redis-distributed-lock-production-problem-solution.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>Java进阶训练营学习笔记<br>课程: <a href="https://apppukyptrl1086.pc.xiaoe-tech.com/detail/p_5d3110c3c0e9d_FnmTTtj4/6">Java进阶训练营</a><br>老师: 中华石杉<br>邀请码: <a href="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/feature/IMG_0340_phrrry.jpg">二维码</a></p></blockquote><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><pre><code>SET KEY VALUE TIME NXDEL KEY</code></pre><p>一般使用 NX, 只有在锁不存在的时候才加锁成功, 设置时间是为了锁永远得不到释放</p><h3 id="存在问题及解决方法"><a href="#存在问题及解决方法" class="headerlink" title="存在问题及解决方法"></a>存在问题及解决方法</h3><ol><li><p>A加锁, B释放</p><p> 方法: Redisson 在tryLock时</p><pre><code class="java">long threadId = Thread.currentThread().getId();protected String getLockName(long threadId) &#123;    return id + &quot;:&quot; + threadId;&#125;// id 为 UUID</code></pre><p> 会将当前 uuId+线程id写入到锁信息中, unlock时会校验是否是当前线程</p></li><li><p>A lock锁住之后, 设置了时间, 但是在时间内未完成, 导致锁自动释放, 然后B获取锁同时进行操作</p><p> 方法: Redisson 在lock时会启动异步线程, 自动延期, 时间为 lockWatchdogTimeout(默认30s)</p><pre><code class="java">Timeout task = commandExecutor.getConnectionManager().newTimeout(new TimerTask() &#123;    省略...&#125;, internalLockLeaseTime / 3, TimeUnit.MILLISECONDS);</code></pre><p> 看源码是延时 1/3的时间后开始, 就是每次1/3时间的时候延期一次. 这样理解不知道对不对</p></li><li><p>主从下, A 加锁 Master 成功后未同步给Slave 便宕机, 导致 B发现未加锁<br> 方法: 可以修改源码, 同时加锁Master-Slave 才算加锁成功</p></li><li><p>集群状态下可以参考RedLock(红锁), 加锁多台机器, 多数成功才算成功(locks.size()/2 + 1)</p><pre><code class="java">public class RedissonRedLock extends RedissonMultiLock &#123;    public RedissonRedLock(RLock... locks) &#123;        super(locks);    &#125;&#125;</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何落地最终一致性事务</title>
      <link href="2019/08/17/how-to-land-the-final-consistency-transaction.html"/>
      <url>2019/08/17/how-to-land-the-final-consistency-transaction.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>Java进阶训练营学习笔记<br>课程: <a href="https://apppukyptrl1086.pc.xiaoe-tech.com/detail/p_5d3110c3c0e9d_FnmTTtj4/6">Java进阶训练营</a><br>老师: 中华石杉<br>邀请码: <a href="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/feature/IMG_0340_phrrry.jpg">二维码</a></p></blockquote><h3 id="作业：如果对自己的系统落地最终一致性事务，如何落地实现？"><a href="#作业：如果对自己的系统落地最终一致性事务，如何落地实现？" class="headerlink" title="作业：如果对自己的系统落地最终一致性事务，如何落地实现？"></a>作业：如果对自己的系统落地最终一致性事务，如何落地实现？</h3><ol><li>首先熟悉自己负责的业务, 熟悉系统间交互流程, 哪些可以异步, 哪些是必须同步</li><li>异步的时候要考虑是否需要一致性, 当前系统通知流程如图</li></ol><h3 id="如何落地最终一致性事务"><a href="#如何落地最终一致性事务" class="headerlink" title="如何落地最终一致性事务"></a>如何落地最终一致性事务</h3><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/feature/0812-task.png" alt="最终一致性事务方案"></p><h3 id="根据课程思考最终一致性事务修改"><a href="#根据课程思考最终一致性事务修改" class="headerlink" title="根据课程思考最终一致性事务修改:"></a>根据课程思考最终一致性事务修改:</h3><ol><li>在收到交易请求, 成功时可以 commit half message</li><li>同时 需要实现 check方法, 供RocketMQ回调, 检查本地事务状态</li><li>在交易成功或失败时再进行commit或rollback</li><li>rollback消息 RocketMQ会定期删除</li><li>通知系统收到消息存储到本地并通知商户</li></ol><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>但是考虑到在这边系统完全没有必要增加事务, 因为发送消息到MQ是在交易结束后, 直接用一个字段判断状态, 然后用定时保证投递到MQ即可.</p><pre><code>RocketMQ的两段提交 half message执行流程根据流程结果: commit/rockback</code></pre><p>可以改成</p><pre><code>执行流程RocketMQ send(普通消息)</code></pre><p>在这边的使用场景中, 因为提交了 half message 也不会发送消息, 等到流程执行结束了, 然后使用send发送普通消息即可.</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>交易系统架构图</title>
      <link href="2019/08/10/trading-system-architecture.html"/>
      <url>2019/08/10/trading-system-architecture.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>Java进阶训练营学习笔记<br>课程: <a href="https://apppukyptrl1086.pc.xiaoe-tech.com/detail/p_5d3110c3c0e9d_FnmTTtj4/6">Java进阶训练营</a><br>老师: 中华石杉<br>邀请码: <a href="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/feature/IMG_0340_phrrry.jpg">二维码</a></p></blockquote><h3 id="交易系统架构"><a href="#交易系统架构" class="headerlink" title="交易系统架构"></a>交易系统架构</h3><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/feature/0806-task.png" alt="交易系统架构"></p><h3 id="请求流程"><a href="#请求流程" class="headerlink" title="请求流程:"></a>请求流程:</h3><ol><li>请求首先到SLB(阿里云)经过负载均衡后, 到Nginx</li><li>Nginx做简单负载均衡后发给交易API系统, 4C8G * 5 ECS(阿里云)</li><li>交易会根据请求参数, 路由到各个子系统, 使用dubbo</li><li>子系统收到请求, 请求风控系统校验风控</li><li>请求应用中心获取应用参数 (appId, appKey等)</li><li>拼装报文,请求渠道系统</li><li>返回信息</li></ol><h3 id="日志报送流程"><a href="#日志报送流程" class="headerlink" title="日志报送流程"></a>日志报送流程</h3><ol><li>交易成功报送清结算, 报送数据中心</li><li>filebeat拉取日志, 报送kafka, 因filebeat升级 同时存在5.x和6.x 需要加中间一层, 之前是直接报logstash</li><li>logstash对数据进行过滤然后根据type 分别保送到 elasticsearch和redis</li><li>监控系统监控redis队列数据, 满足规则, 报警(发消息到通知系统)</li><li>监控系统对es数据进行过滤, 放到mysql, 用来展示商户, 渠道的交易变化等信息</li><li>kibana(直接用的kibana)提供给技术支持查询日志. es数据会定期删除, 保留15-30天的数据, 仅仅技术支持用, 不需要效率很高, 所以机器配置相对较差.</li></ol><h3 id="扩容方案"><a href="#扩容方案" class="headerlink" title="扩容方案"></a>扩容方案</h3><p>公司体量较小, QPS高峰期也就500左右, TPS高峰期在100~200, 所以基本没有遇到问题.<br>之前有过一段时间公众号支付交易量较大, 主要做法是增加公众号机器, 同时增加API系统机器.<br>假如交易量提高, 一般应对就是增加机器, 和提高机器配置, 基本上都可以应对.</p><h3 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h3><p>定时系统是仅仅通过dubbo发送调用请求, 没有业务逻辑. 所以单体基本没有遇到挂掉. 也在考虑分布式定时任务.</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud架构原理图</title>
      <link href="2019/08/04/springcloud-architecture-schematic.html"/>
      <url>2019/08/04/springcloud-architecture-schematic.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>Java进阶训练营学习笔记<br>课程: <a href="https://apppukyptrl1086.pc.xiaoe-tech.com/detail/p_5d3110c3c0e9d_FnmTTtj4/6">Java进阶训练营</a><br>老师: 中华石杉<br>邀请码: <a href="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/feature/IMG_0340_phrrry.jpg">二维码</a></p></blockquote><h3 id="springcloud-通信原理"><a href="#springcloud-通信原理" class="headerlink" title="springcloud 通信原理"></a>springcloud 通信原理</h3><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/feature/0731-task.png" alt="通信原理"></p><h3 id="1-Eureka-集群"><a href="#1-Eureka-集群" class="headerlink" title="1. Eureka 集群"></a>1. Eureka 集群</h3><ol><li>Eureka启动后, 会向其他节点注册, 相互直接视为 peer, 并互相同步注册信息.</li></ol><h3 id="2-缓存机制"><a href="#2-缓存机制" class="headerlink" title="2. 缓存机制"></a>2. 缓存机制</h3><p>Eureka存在三个map: registry、readWriteCacheMap、readOnlyCacheMap</p><p>registry: CurrentHashMap 实时更新<br>readWriteCacheMap: Guava Cache/LoadingCache     也是实时更新<br>readOnlyCacheMap: CurrentHashMap 30秒同步 readWriteCacheMap一次</p><h3 id="3-服务注册"><a href="#3-服务注册" class="headerlink" title="3. 服务注册"></a>3. 服务注册</h3><p>服务注册后每30s发送一次心跳(renew)<br>客户端每30秒请注册中心获取一次配置, 并存到本地内存中</p><p>注册中心会定时检查心跳, 连续没有3个回踢掉服务</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dubbo底层原理架构图</title>
      <link href="2019/08/03/dubbo-bottom-structure-diagram.html"/>
      <url>2019/08/03/dubbo-bottom-structure-diagram.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>Java进阶训练营学习笔记<br>课程: <a href="https://apppukyptrl1086.pc.xiaoe-tech.com/detail/p_5d3110c3c0e9d_FnmTTtj4/6">Java进阶训练营</a><br>老师: 中华石杉<br>邀请码: <a href="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/feature/IMG_0340_phrrry.jpg">二维码</a></p></blockquote><h4 id="操作流程图"><a href="#操作流程图" class="headerlink" title="操作流程图"></a>操作流程图</h4><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/feature/0730-task.png" alt="操作流程"></p><h4 id="1-服务注册-故障及下线"><a href="#1-服务注册-故障及下线" class="headerlink" title="1. 服务注册, 故障及下线"></a>1. 服务注册, 故障及下线</h4><ol><li>注册: provider和consumer同时在zk上注册临时节点, 同时consumer订阅zk /dubbo/**/providers provider地址, providers发生变化, zk自动推送给consumer</li></ol><p>zk上结构如下</p><pre><code class="sh">ls /dubbo/cn.xxx.xxxService[consumers, routers, providers, configurators]</code></pre><pre><code class="url">[consumer://机器ip/接口?application=服务名&amp;category=consumers&amp;check=false&amp;default.check=false&amp;default.group=beta&amp;default.timeout=5000&amp;default.version=1.0.0&amp;dubbo=2.6.2&amp;interface=接口&amp;methods=方法1,方法2&amp;pid=7828&amp;revision=0.0.1&amp;side=consumer&amp;timestamp=1556173624632]</code></pre><pre><code class="url">[dubbo://机器1ip:端口/接口?anyhost=true&amp;application=WalletOrderApplicationConsumer&amp;delay=2000&amp;dubbo=2.5.3&amp;group=beta&amp;heartbeat=10000&amp;interface=接口&amp;methods=方法1,方法2&amp;pid=22419&amp;retries=0&amp;revision=1.0.0&amp;side=provider&amp;timeout=10000&amp;timestamp=1564743170669&amp;version=1.0.0,dubbo://机器2ip:端口/接口?anyhost=true&amp;application=WalletOrderApplicationConsumer&amp;delay=2000&amp;dubbo=2.5.3&amp;group=beta&amp;heartbeat=10000&amp;interface=cn.ipaynow.webank.wallet.order.api.provider.DataCenterTaskService&amp;methods=syncRechargesRefund,syncTrans,syncTransCancel,syncTransRefunds,syncRecharges&amp;pid=16801&amp;retries=0&amp;revision=0.0.1&amp;side=provider&amp;timeout=10000&amp;timestamp=1563792977340&amp;version=1.0.0]</code></pre><ol start="2"><li>故障: zk自动删除临时节点</li><li>下线: 取消注册, 主动删除节点</li></ol><h4 id="2-Proxy-动态代理"><a href="#2-Proxy-动态代理" class="headerlink" title="2. Proxy 动态代理"></a>2. Proxy 动态代理</h4><p>根据配置的接口, 生成动态代理对象, 使用 JDK + JAVAASSIST 方式</p><ol><li><p>在服务提供端，将服务的具体实现类转为Invoker</p></li><li><p>在消费端，通过 getProxy(Invoker<T> invoker)将invoker转为客户端需要的接口</p></li><li><p>Invoker封装了Provider地址及Service接口信息</p></li></ol><h4 id="3-Cluster-集群层"><a href="#3-Cluster-集群层" class="headerlink" title="3. Cluster 集群层"></a>3. Cluster 集群层</h4><p>获取到要调用的Invoker</p><ol><li>多个服务端会有多个 Invoker对象, 组合成Directory, Directory在zk推送Provider节点变更时, 会发生变化</li><li>Router, 按照路由规则选出本次可以调用的 Directory子集,  zk注册中心 routers节点下配置</li><li>LoadBalance 从子集中按照负载均衡选出本次调用<ol><li>Random LoadBalance 随机</li><li>RoundRobin LoadBalance 轮询</li><li>LeastActive LoadBalance 最少活跃</li><li>ConsistentHash LoadBalance 一致性哈希</li></ol></li><li>容错<ol><li>Failover Cluster 失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 retries=”2″ 来设置重试次数(不含第一次)。</li><li>Failfast Cluster：快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</li><li>Failsafe Cluster：失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</li><li>Failback Cluster：失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</li><li>Forking Cluster：并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=”2″ 来设置最大并行数。</li></ol></li></ol><h4 id="4-Protocol-远程调用层"><a href="#4-Protocol-远程调用层" class="headerlink" title="4. Protocol 远程调用层"></a>4. Protocol 远程调用层</h4><p>包含两个接口, 分别是 暴露服务(export) 和 引用服务(refer) 分别对应provider 和 consumer<br>选择通信协议 dubbo, hessian, http等</p><h4 id="5-Exchange-数据交换层"><a href="#5-Exchange-数据交换层" class="headerlink" title="5. Exchange 数据交换层"></a>5. Exchange 数据交换层</h4><p>将请求信息封装为Request, 然后发送给 Transport层, 并将返回信息封装为Response</p><h4 id="6-Transport-网络传输层"><a href="#6-Transport-网络传输层" class="headerlink" title="6. Transport 网络传输层"></a>6. Transport 网络传输层</h4><p>使用netty或mina进行网络通信</p><h4 id="7-serialize-序列化层"><a href="#7-serialize-序列化层" class="headerlink" title="7. serialize 序列化层"></a>7. serialize 序列化层</h4><p>将请求报文和返回报文记性序列化和反序列化</p><h4 id="8-provider收到请求后先进行反序列化-然后在解析请求-通过动态代理调用相应方法"><a href="#8-provider收到请求后先进行反序列化-然后在解析请求-通过动态代理调用相应方法" class="headerlink" title="8. provider收到请求后先进行反序列化, 然后在解析请求, 通过动态代理调用相应方法"></a>8. provider收到请求后先进行反序列化, 然后在解析请求, 通过动态代理调用相应方法</h4>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot项目中使用SpringSecurity和JWT做权限认证</title>
      <link href="2019/07/22/springsecurity-jwt-springboot-project.html"/>
      <url>2019/07/22/springsecurity-jwt-springboot-project.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote><p>前段时间做了一个项目, 因为涉及到权限认证, 所以分别调研了 SpringSecurity 和 Apache Shiro. 最后选择使用了 SpringSecurity + JWT做权限认证,  现在项目已经结束, 总相关笔记.<br>项目下载地址 <a href="https://github.com/liuzhihang/jwt-demo">jwt-demo</a></p></blockquote><ol><li>使用JWT生成token</li><li>token存储在数据库中</li><li>使用 application/json 登录</li><li>使用手机号进行登录</li><li>URI动态拦截</li></ol><h2 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h2><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><ol><li>分别添加 SpringSecurity JWT 和 fastjson 依赖</li></ol><pre><code class="xml">    &lt;dependency&gt;           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;           &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;       &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;        &lt;artifactId&gt;jjwt&lt;/artifactId&gt;        &lt;version&gt;0.9.0&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--json--&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;        &lt;artifactId&gt;fastjson&lt;/artifactId&gt;        &lt;version&gt;1.2.60&lt;/version&gt;    &lt;/dependency&gt;</code></pre><h3 id="基础准备对象"><a href="#基础准备对象" class="headerlink" title="基础准备对象"></a>基础准备对象</h3><ul><li>主要是在<strong>用户登录成功handle</strong>时使用JWT生成Token返回给客户端.</li></ul><h4 id="基础使用dto"><a href="#基础使用dto" class="headerlink" title="基础使用dto"></a>基础使用dto</h4><p>请求返回基类</p><pre><code class="java">@Datapublic class BaseReqDto implements Serializable &#123;    private String version;&#125;@Datapublic class BaseRespDto implements Serializable &#123;    private String resultCode;    private String resultMsg;    private String resultTime;&#125;</code></pre><p>登录请求返回对象</p><pre><code class="java">@Datapublic class LoginReqDto &#123;    private String username;    private String token;&#125;@Datapublic class LoginRespDto extends BaseRespDto &#123;    private String token;&#125;</code></pre><h4 id="用于验证的用户"><a href="#用于验证的用户" class="headerlink" title="用于验证的用户"></a>用于验证的用户</h4><pre><code class="java">package com.liuzhihang.demo.bean;import org.springframework.security.core.GrantedAuthority;import org.springframework.security.core.userdetails.UserDetails;import java.io.Serializable;import java.util.Collection;/** * 用户信息校验验证码 * * @author liuzhihang */public class UserDetailsImpl implements UserDetails, Serializable &#123;    /**     * 用户名     */    private String username;    /**     * 密码     */    private String password;    /**     * 权限集合     */    private Collection&lt;? extends GrantedAuthority&gt; authorities;    @Override    public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;        return this.authorities;    &#125;    public void setAuthorities(Collection&lt;? extends GrantedAuthority&gt; authorities) &#123;        this.authorities = authorities;    &#125;    @Override    public String getPassword() &#123;        return this.password;    &#125;    @Override    public String getUsername() &#123;        return this.username;    &#125;    public void setUsername(String username) &#123;        this.username = username;    &#125;    public void setPassword(String password) &#123;        this.password = password;    &#125;    @Override    public boolean isAccountNonExpired() &#123;        return true;    &#125;    @Override    public boolean isAccountNonLocked() &#123;        return true;    &#125;    @Override    public boolean isCredentialsNonExpired() &#123;        return true;    &#125;    @Override    public boolean isEnabled() &#123;        return true;    &#125;&#125;</code></pre><h4 id="用户未登录handle"><a href="#用户未登录handle" class="headerlink" title="用户未登录handle"></a>用户未登录handle</h4><pre><code class="java">/** * 用户登录认证, 未登录返回信息 * * @author liuzhihang * @date 2019-06-04 13:52 */@Componentpublic class AuthenticationEntryPointImpl implements AuthenticationEntryPoint &#123;    private static final DateTimeFormatter FORMATTER = DateTimeFormatter.ofPattern(&quot;yyyyMMddHHmmss&quot;);    @Override    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException e) throws IOException &#123;        response.setContentType(&quot;application/json;charset=UTF-8&quot;);        LoginRespDto respDto = new LoginRespDto();        respDto.setResultCode(&quot;0001&quot;);        respDto.setResultMsg(&quot;用户未登录&quot;);        respDto.setResultTime(LocalDateTime.now().format(FORMATTER));        response.getWriter().write(JSON.toJSONString(respDto));    &#125;&#125;</code></pre><h4 id="用户登录验证失败handle"><a href="#用户登录验证失败handle" class="headerlink" title="用户登录验证失败handle"></a>用户登录验证失败handle</h4><pre><code class="java">/** * 用户登录认证失败返回的信息 * * @author liuzhihang * @date 2019-06-04 13:57 */@Componentpublic class AuthenticationFailureHandlerImpl implements AuthenticationFailureHandler &#123;    private static final DateTimeFormatter FORMATTER = DateTimeFormatter.ofPattern(&quot;yyyyMMddHHmmss&quot;);    @Override    public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException &#123;        response.setContentType(&quot;application/json;charset=UTF-8&quot;);        LoginRespDto respDto = new LoginRespDto();        respDto.setResultCode(&quot;0001&quot;);        respDto.setResultMsg(&quot;用户登录认证失败&quot;);        respDto.setResultTime(LocalDateTime.now().format(FORMATTER));        response.getWriter().write(JSON.toJSONString(respDto));    &#125;&#125;</code></pre><h4 id="用户无权访问handle"><a href="#用户无权访问handle" class="headerlink" title="用户无权访问handle"></a>用户无权访问handle</h4><pre><code class="java">/** * 当用户访问无权限页面时, 返回信息 * * @author liuzhihang * @date 2019-06-04 14:03 */@Componentpublic class AccessDeniedHandlerImpl implements AccessDeniedHandler &#123;    private static final DateTimeFormatter FORMATTER = DateTimeFormatter.ofPattern(&quot;yyyyMMddHHmmss&quot;);    @Override    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException &#123;        response.setContentType(&quot;application/json;charset=UTF-8&quot;);        LoginRespDto respDto = new LoginRespDto();        respDto.setResultCode(&quot;0002&quot;);        respDto.setResultMsg(&quot;用户无权访问&quot;);        respDto.setResultTime(LocalDateTime.now().format(FORMATTER));        response.getWriter().write(JSON.toJSONString(respDto));    &#125;&#125;</code></pre><h4 id="用户登录成功handle"><a href="#用户登录成功handle" class="headerlink" title="用户登录成功handle"></a>用户登录成功handle</h4><pre><code class="java">/** * 用户登录成功之后的返回信息 * * @author liuzhihang * @date 2019-06-04 14:20 */@Slf4j@Componentpublic class AuthenticationSuccessHandlerImpl implements AuthenticationSuccessHandler &#123;    private static final DateTimeFormatter FORMATTER = DateTimeFormatter.ofPattern(&quot;yyyyMMddHHmmss&quot;);    @Resource    private JwtTokenUtil jwtTokenUtil;    @Override    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response,                                        Authentication authentication) throws IOException &#123;        UserDetailsImpl userDetails = (UserDetailsImpl) authentication.getPrincipal();        String jwtToken = jwtTokenUtil.generateToken(userDetails);        // 把生成的token更新到数据库中        // 更新DB操作 ...        response.setContentType(&quot;application/json;charset=UTF-8&quot;);        LoginRespDto respDto = new LoginRespDto();        respDto.setToken(jwtToken);        respDto.setResultCode(&quot;0000&quot;);        respDto.setResultMsg(&quot;登录成功&quot;);        respDto.setResultTime(LocalDateTime.now().format(FORMATTER));        response.getWriter().write(JSON.toJSONString(respDto));    &#125;&#125;</code></pre><h2 id="JwtTokenUtil"><a href="#JwtTokenUtil" class="headerlink" title="JwtTokenUtil"></a>JwtTokenUtil</h2><p>主要用来生成token和通过token解析对象等操作.</p><pre><code class="java">package com.liuzhihang.demo.utils;import com.liuzhihang.demo.bean.UserDetailsImpl;import io.jsonwebtoken.Claims;import io.jsonwebtoken.Jwts;import io.jsonwebtoken.SignatureAlgorithm;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.stereotype.Component;import java.time.Instant;import java.util.Date;/** * 使用 java-jwt jwt类库 * * @author liuzhihang * @date 2019-06-05 09:22 */@Componentpublic class JwtTokenUtil &#123;    private static final SignatureAlgorithm SIGN_TYPE = SignatureAlgorithm.HS256;    public static final String SECRET = &quot;jwt-secret&quot;;    /**     * JWT超时时间     */    public static final long EXPIRED_TIME = 7 * 24 * 60 * 60 * 1000L;    /**     * claims 为自定义的私有声明, 要放在前面     * &lt;p&gt;     * 生成token     */    public String generateToken(UserDetails userDetails) &#123;        long instantNow = Instant.now().toEpochMilli();        Claims claims = Jwts.claims();        claims.put(Claims.SUBJECT, userDetails.getUsername());        return Jwts.builder().setClaims(claims).setIssuedAt(new Date(instantNow))                .setExpiration(new Date(instantNow + EXPIRED_TIME))                .signWith(SIGN_TYPE, SECRET).compact();    &#125;    /**     * claims 为自定义的私有声明, 要放在前面     * &lt;p&gt;     * 生成token     */    public String generateToken(String userName) &#123;        long instantNow = Instant.now().toEpochMilli();        Claims claims = Jwts.claims();        claims.put(Claims.SUBJECT, userName);        return Jwts.builder().setClaims(claims).setIssuedAt(new Date(instantNow))                .setExpiration(new Date(instantNow + EXPIRED_TIME))                .signWith(SIGN_TYPE, SECRET).compact();    &#125;    /**     * 将token解析, 映射为 UserDetails     *     * @param jwtToken     * @return     */    public UserDetails getUserDetailsFromToken(String jwtToken) &#123;        Claims claimsFromToken = getClaimsFromToken(jwtToken);        String userName = claimsFromToken.get(Claims.SUBJECT, String.class);        UserDetailsImpl userDetails = new UserDetailsImpl();        userDetails.setUsername(userName);        return userDetails;    &#125;    /**     * 验证token     */    public Boolean validateToken(String token, UserDetails userDetails) &#123;        UserDetailsImpl user = (UserDetailsImpl) userDetails;        String username = getPhoneNoFromToken(token);        return (username.equals(user.getUsername()) &amp;&amp; !isTokenExpired(token));    &#125;    /**     * 刷新令牌     *     * @param token 原令牌     * @return 新令牌     */    public String refreshToken(String token) &#123;        String refreshedToken;        try &#123;            Claims claims = getClaimsFromToken(token);            long instantNow = Instant.now().toEpochMilli();            refreshedToken = Jwts.builder().setClaims(claims).setIssuedAt(new Date(instantNow))                    .setExpiration(new Date(instantNow + EXPIRED_TIME))                    .signWith(SIGN_TYPE, SECRET).compact();        &#125; catch (Exception e) &#123;            refreshedToken = null;        &#125;        return refreshedToken;    &#125;    /**     * 获取token是否过期     */    public Boolean isTokenExpired(String token) &#123;        Date expiration = getExpirationDateFromToken(token);        return expiration.before(new Date());    &#125;    /**     * 根据token获取username     */    public String getPhoneNoFromToken(String token) &#123;        return getClaimsFromToken(token).getSubject();    &#125;    /**     * 获取token的过期时间     */    public Date getExpirationDateFromToken(String token) &#123;        return getClaimsFromToken(token).getExpiration();    &#125;    /**     * 解析JWT     */    private Claims getClaimsFromToken(String token) &#123;        return Jwts.parser().setSigningKey(SECRET).parseClaimsJws(token).getBody();    &#125;&#125;</code></pre><h2 id="WebSecurityConfig-核心配置"><a href="#WebSecurityConfig-核心配置" class="headerlink" title="WebSecurityConfig 核心配置"></a>WebSecurityConfig 核心配置</h2><pre><code class="java">package com.liuzhihang.demo.config;import com.liuzhihang.demo.filter.CustomizeAuthenticationFilter;import com.liuzhihang.demo.filter.JwtPerTokenFilter;import com.liuzhihang.demo.service.UserDetailServiceImpl;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.config.http.SessionCreationPolicy;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.security.crypto.password.PasswordEncoder;import org.springframework.security.web.AuthenticationEntryPoint;import org.springframework.security.web.access.AccessDeniedHandler;import org.springframework.security.web.authentication.AuthenticationFailureHandler;import org.springframework.security.web.authentication.AuthenticationSuccessHandler;import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;import javax.annotation.Resource;/** * @author liuzhihang * @date 2019-06-03 14:25 */@EnableWebSecuritypublic class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123;    @Autowired    private UserDetailServiceImpl userDetailServiceImpl;    @Resource    private JwtPerTokenFilter jwtPerTokenFilter;    @Resource(name = &quot;authenticationEntryPointImpl&quot;)    private AuthenticationEntryPoint authenticationEntryPoint;    @Resource(name = &quot;authenticationSuccessHandlerImpl&quot;)    private AuthenticationSuccessHandler authenticationSuccessHandler;    @Resource(name = &quot;authenticationFailureHandlerImpl&quot;)    private AuthenticationFailureHandler authenticationFailureHandler;    @Resource(name = &quot;accessDeniedHandlerImpl&quot;)    private AccessDeniedHandler accessDeniedHandler;    /**     * 创建用于认证授权的用户     *     * @param auth     * @throws Exception     */    @Autowired    public void configureUserInfo(AuthenticationManagerBuilder auth) throws Exception &#123;        // 放入自己的认证授权用户, 内部逻辑需要自己实现        // UserDetailServiceImpl implements UserDetailsService        auth.userDetailsService(userDetailServiceImpl);    &#125;    @Override    protected void configure(HttpSecurity http) throws Exception &#123;        http                // 使用JWT, 关闭session                .csrf().disable().sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)                .and().httpBasic().authenticationEntryPoint(authenticationEntryPoint)                // 登录的权限, 成功返回信息, 失败返回信息                .and().formLogin().permitAll()                .loginProcessingUrl(&quot;/login&quot;)                // 配置url 权限 antMatchers: 匹配url 权限                .and().authorizeRequests()                .antMatchers(&quot;/login&quot;, &quot;/getVersion&quot;)                .permitAll()                // 其他需要登录才能访问                .anyRequest().access(&quot;@dynamicAuthorityService.hasPermission(request,authentication)&quot;)                // 访问无权限 location 时                .and().exceptionHandling().accessDeniedHandler(accessDeniedHandler)                // 自定义过滤                .and().addFilterAt(customAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class)                .addFilterBefore(jwtPerTokenFilter, UsernamePasswordAuthenticationFilter.class)                .headers().cacheControl();    &#125;    /**     * 密码加密器     */    @Bean    public PasswordEncoder passwordEncoder() &#123;        /**         * BCryptPasswordEncoder：相同的密码明文每次生成的密文都不同，安全性更高         */        return new BCryptPasswordEncoder();    &#125;    @Bean    CustomizeAuthenticationFilter customAuthenticationFilter() throws Exception &#123;        CustomizeAuthenticationFilter filter = new CustomizeAuthenticationFilter();        filter.setAuthenticationSuccessHandler(authenticationSuccessHandler);        filter.setAuthenticationFailureHandler(authenticationFailureHandler);        filter.setAuthenticationManager(authenticationManagerBean());        return filter;    &#125;&#125;</code></pre><h2 id="登录校验过程"><a href="#登录校验过程" class="headerlink" title="登录校验过程"></a>登录校验过程</h2><div class="mermaid">graph TD;    A(请求登录) --&gt; B(CustomizeAuthenticationFilter#attemptAuthentication 解析请求的json);    B --&gt; C(UserDetailServiceImpl#loadUserByUsername 验证用户名密码);    C --&gt; D(AuthenticationSuccessHandlerImpl#onAuthenticationSuccess 构建返回参数 包括token);    D --&gt; E(返回结果)</div><h3 id="自定义拦截器解析-json-报文"><a href="#自定义拦截器解析-json-报文" class="headerlink" title="自定义拦截器解析 json 报文"></a>自定义拦截器解析 json 报文</h3><p>前端请求登录报文类型为 application/json 需要后端增加拦截器, 对登录请求报文进行解析</p><pre><code class="java">package com.liuzhihang.demo.filter;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONException;import com.alibaba.fastjson.JSONObject;import lombok.extern.slf4j.Slf4j;import org.springframework.http.MediaType;import org.springframework.security.authentication.AuthenticationServiceException;import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;import org.springframework.security.core.Authentication;import org.springframework.security.core.AuthenticationException;import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.BufferedReader;import java.io.IOException;/** * * 自定义拦截器, 重写UsernamePasswordAuthenticationFilter 从而可以处理 application/json 中的json请求报文 * * @author liuzhihang * @date 2019-06-12 19:04 */@Slf4jpublic class CustomizeAuthenticationFilter extends UsernamePasswordAuthenticationFilter &#123;    @Override    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response)        throws AuthenticationException &#123;        // attempt Authentication when Content-Type is json        if (request.getContentType().equalsIgnoreCase(MediaType.APPLICATION_JSON_UTF8_VALUE)            || request.getContentType().equalsIgnoreCase(MediaType.APPLICATION_JSON_VALUE)) &#123;            try &#123;                BufferedReader br = request.getReader();                String str;                StringBuilder jsonStr = new StringBuilder();                while ((str = br.readLine()) != null) &#123;                    jsonStr.append(str);                &#125;                log.info(&quot;本次登录请求参数:&#123;&#125;&quot;, jsonStr);                JSONObject jsonObject = JSON.parseObject(jsonStr.toString());                UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(                    jsonObject.getString(&quot;username&quot;), jsonObject.getString(&quot;password&quot;));                setDetails(request, authRequest);                return this.getAuthenticationManager().authenticate(authRequest);            &#125; catch (IOException e) &#123;                log.info(&quot;用户登录, 请求参数 不正确&quot;);                throw new AuthenticationServiceException(&quot;获取报文请求参数失败&quot;);            &#125; catch (JSONException e) &#123;                log.info(&quot;用户登录, 请求报文格式 不正确&quot;);                throw new AuthenticationServiceException(&quot;请求报文, 转换Json失败&quot;);            &#125;        &#125; else &#123;            log.error(&quot;用户登录, contentType 不正确&quot;);            throw new AuthenticationServiceException(                &quot;请求 contentType 不正确, 请使用 application/json;charset=UTF-8 或者 application/json;&quot;);        &#125;    &#125;&#125;</code></pre><h3 id="用户认证模块"><a href="#用户认证模块" class="headerlink" title="用户认证模块"></a>用户认证模块</h3><ul><li>根据获取到的username从数据库中查询到密码, 将用户名密码赋值给UserDetails对象, 返回其他的框架会进行校验</li><li>这边使用中是使用的手机号+验证码登录, 所以 上面json解析的也是 phoneNo+verificationCode</li><li>在这块 username仅仅代指登录名, 可以是手机号可以是别的.</li><li>这边使用中验证码是从redis中获取的. 获取不到返回失败, 获取到和传递的不一致也算失败.</li></ul><pre><code class="java">package com.liuzhihang.demo.service;import com.liuzhihang.demo.bean.UserDetailsImpl;import lombok.extern.slf4j.Slf4j;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.core.userdetails.UsernameNotFoundException;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.stereotype.Component;/** * @author liuzhihang */@Slf4j@Component(&quot;userDetailServiceImpl&quot;)public class UserDetailServiceImpl implements UserDetailsService &#123;    /**     * 用来验证登录名是否有权限进行登录     *     * 可以通过数据库进行校验 也可以通过redis 等等     *     * @param username     * @return     * @throws UsernameNotFoundException     */    @Override    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;        UserDetailsImpl userDetailsImpl = new UserDetailsImpl();        userDetailsImpl.setUsername(&quot;liuzhihang&quot;);        userDetailsImpl.setPassword(new BCryptPasswordEncoder().encode(&quot;123456789&quot;));        return userDetailsImpl;    &#125;&#125;</code></pre><h2 id="请求校验过程"><a href="#请求校验过程" class="headerlink" title="请求校验过程"></a>请求校验过程</h2><div class="mermaid">graph TD;    A(请求接口) --&gt; B(JwtPerTokenFilter#doFilterInternal 验证Header中的token);    B --&gt; C(DynamicAuthorityService#hasPermission 验证有没有请求url权限);    C --&gt; D(处理逻辑);    D --&gt; E(返回结果)</div><h3 id="JWTToken拦截器"><a href="#JWTToken拦截器" class="headerlink" title="JWTToken拦截器"></a>JWTToken拦截器</h3><p>主要是拦截请求, 验证Header中的token是否正确</p><pre><code class="java">package com.liuzhihang.demo.filter;import com.liuzhihang.demo.utils.JwtTokenUtil;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;import org.springframework.security.core.context.SecurityContextHolder;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;import org.springframework.stereotype.Component;import org.springframework.web.filter.OncePerRequestFilter;import javax.servlet.FilterChain;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * @author liuzhihang * @date 2019-06-05 09:09 */@Slf4j@Componentpublic class JwtPerTokenFilter extends OncePerRequestFilter &#123;    @Autowired    private JwtTokenUtil jwtTokenUtil;    /**     * 存放Token的Header Key     */    private static final String HEADER_STRING = &quot;token&quot;;    @Override    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)            throws ServletException, IOException &#123;        String token = request.getHeader(HEADER_STRING);        if (null != token &amp;&amp; !jwtTokenUtil.isTokenExpired(token)) &#123;            UserDetails userDetails = jwtTokenUtil.getUserDetailsFromToken(token);            String username = userDetails.getUsername();            if (username != null &amp;&amp; SecurityContextHolder.getContext().getAuthentication() == null) &#123;                // 通过 username 查询数据库 获取token 然后和库中token作比较                if (username.equals(&quot;liuzhihang&quot;)) &#123;                    UsernamePasswordAuthenticationToken authentication =                            new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());                    authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));                    SecurityContextHolder.getContext().setAuthentication(authentication);                &#125;            &#125;        &#125;        filterChain.doFilter(request, response);    &#125;&#125;</code></pre><h3 id="URI动态校验"><a href="#URI动态校验" class="headerlink" title="URI动态校验"></a>URI动态校验</h3><pre><code class="java">package com.liuzhihang.demo.service;import lombok.extern.slf4j.Slf4j;import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;import org.springframework.security.core.Authentication;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.stereotype.Component;import javax.servlet.http.HttpServletRequest;import java.util.HashSet;import java.util.Set;/** * 动态权限认证 * * @author liuzhihang * @date 2019-06-25 15:51 */@Slf4j@Component(value = &quot;dynamicAuthorityService&quot;)public class DynamicAuthorityService &#123;    public boolean hasPermission(HttpServletRequest request, Authentication authentication) &#123;        try &#123;            Object principal = authentication.getPrincipal();            if (principal instanceof UserDetails &amp;&amp; authentication instanceof UsernamePasswordAuthenticationToken) &#123;                // 本次请求的uri                String uri = request.getRequestURI();                // 获取当前用户                UserDetails userDetails = (UserDetails) principal;                String username = userDetails.getUsername();                log.info(&quot;本次用户请求认证, username:&#123;&#125;, uri:&#123;&#125;&quot;, username, uri);                // 从数据库取逻辑                if (username.equals(&quot;liuzhihang&quot;))&#123;                    Set&lt;String&gt; set = new HashSet&lt;&gt;();                    set.add(&quot;/homeInfo&quot;);                    set.add(&quot;/getAllUser&quot;);                    set.add(&quot;/editUserInfo&quot;);                    if (set.contains(uri)) &#123;                        return true;                    &#125;                &#125;            &#125;        &#125; catch (Exception e) &#123;            log.error(&quot;用户请求登录, uri:&#123;&#125; error&quot;, request.getRequestURI(), e);            return false;        &#125;        return false;    &#125;&#125;</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>脚本在 <a href="https://github.com/liuzhihang/jwt-demo/blob/master/src/test/java/ReqTest.http">httpclient脚本</a></p><pre><code class="http">POST localhost:8080/loginContent-Type: application/json&#123;  &quot;username&quot;: &quot;liuzhihang&quot;,  &quot;password&quot;: &quot;123456789&quot;&#125;### 请求接口脚本POST localhost:8080/homeInfoContent-Type: application/jsontoken: eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJsaXV6aGloYW5nIiwiaWF0IjoxNTY5MDI1NjY4LCJleHAiOjE1Njk2MzA0Njh9.Kot_uLnwtcq-t5o4x3V-xBnpf-mKEi7OV2eAfgMCKLk###</code></pre><p>返回:</p><pre><code class="json">&#123;  &quot;resultCode&quot;: &quot;0000&quot;,  &quot;resultMsg&quot;: &quot;登录成功&quot;,  &quot;resultTime&quot;: &quot;20190920191038&quot;,  &quot;token&quot;: &quot;eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJsaXV6aGloYW5nIiwiaWF0IjoxNTY4OTc3ODM4LCJleHAiOjE1Njk1ODI2Mzh9.MAS9VkFdCF3agkCgTtc0VzPMFjY42vFyIvAEzkSeAfs&quot;&#125;</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/larger5/article/details/81063438">前后端分离 SpringBoot + SpringSecurity + JWT + RBAC 实现用户无状态请求验证</a></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JWT </tag>
            
            <tag> SpringSecurity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gitalk使用MD5生成Id</title>
      <link href="2019/07/20/gitalk-uses-md5-to-generate-an-id.html"/>
      <url>2019/07/20/gitalk-uses-md5-to-generate-an-id.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>Gitalk默认使用: location.pathname 作为 gitalk 的id, 但是location.path必须小于50位切换主题时, 每个主题使用的处理方式都不相同, 有可能会导致换了主题, 发现之前的评论不见了, 下面介绍使用MD5作为id, 同时在换主题时一定要修改这个id的规则.</p></blockquote><h3 id="Gitalk使用"><a href="#Gitalk使用" class="headerlink" title="Gitalk使用"></a>Gitalk使用</h3><p>使用<a href="https://github.com/gitalk/gitalk/blob/master/readme-cn.md">Gitalk</a>方法:</p><pre><code class="js">    var gitalk = new Gitalk(&#123;      clientID: &#39;GitHub Application Client ID&#39;,      clientSecret: &#39;GitHub Application Client Secret&#39;,      repo: &#39;GitHub repo&#39;,      owner: &#39;GitHub repo owner&#39;,      admin: [&#39;GitHub repo owner and collaborators, only these guys can initialize github issues&#39;],      id: location.pathname,      // Ensure uniqueness and length less than 50      distractionFreeMode: false  // Facebook-like distraction free mode    &#125;)    gitalk.render(&#39;gitalk-container&#39;)</code></pre><h3 id="使用MD5生成id"><a href="#使用MD5生成id" class="headerlink" title="使用MD5生成id"></a>使用MD5生成id</h3><ol><li>引入js</li></ol><p><a href="https://github.com/blueimp/JavaScript-MD5">MD5</a> js 下载地址</p><pre><code class="js">&lt;script src=&quot;js/md5.min.js&quot;&gt;&lt;/script&gt;</code></pre><ol start="2"><li>修改js</li></ol><pre><code class="js">&lt;script&gt;    var gitalk_id = md5(location.pathname)    if (&lt;%- page.comments_type == &#39;404&#39;   %&gt;) &#123;        gitalk_id = md5(&#39;https://liuzhihang.com/404&#39;)    &#125;    let gitalk = new Gitalk(&#123;        clientID: &#39;&lt;%- theme.gitalk.oauth.clientId %&gt;&#39;,        clientSecret: &#39;&lt;%- theme.gitalk.oauth.clientSecret %&gt;&#39;,        repo: &#39;&lt;%- theme.gitalk.repo %&gt;&#39;,        owner: &#39;&lt;%- theme.gitalk.owner %&gt;&#39;,        admin: &lt;%- JSON.stringify(theme.gitalk.admin) %&gt;,        id: gitalk_id,        distractionFreeMode: false  // Facebook-like distraction free mode    &#125;);    gitalk.render(&#39;gitalk-container&#39;);&lt;/script&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA插件--Toolkit</title>
      <link href="2019/05/11/idea-plugin-toolkit.html"/>
      <url>2019/05/11/idea-plugin-toolkit.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Toolkit"><a href="#Toolkit" class="headerlink" title="Toolkit"></a>Toolkit</h1><div><a href="https://plugins.jetbrains.com/plugin/12384-toolkit"><img src="https://img.shields.io/jetbrains/plugin/v/12384-toolkit.svg" alt="JetBrains Plugins"></a><a href="https://plugins.jetbrains.com/plugin/12384-toolkit/versions"><img src="http://phpstorm.espend.de/badge/12384/version" alt="Version"></a><a href="https://plugins.jetbrains.com/plugin/12384-toolkit"><img src="https://img.shields.io/jetbrains/plugin/d/12384-toolkit.svg" alt="Downloads"></a><a href="https://github.com/liuzhihang/toolkit/blob/master/LICENSE"><img src="https://img.shields.io/badge/license-MIT-red.svg" alt="License"></a></div><p>一个小工具包, 暂时还有很多功能需要扩展.</p><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><ul><li>Mybatis<ul><li>通过侧栏箭头在 MyBatis XML文件和 Mapper文件之间相互跳转</li><li>mapper文件id简单检查</li></ul></li><li>Json<ul><li>JavaBean复制为Json字符串</li><li>Json字符串格式化</li><li>Json字符串转换为JavaBean</li><li>Json压缩</li></ul></li><li>XML: Xml格式化</li></ul><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><ul><li>文末演示</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul><li><p><strong>在线安装:</strong></p><ul><li><code>File</code> -&gt; <code>Setting</code> -&gt; <code>Plugins</code> -&gt; 搜索 <code>Toolkit</code></li></ul></li><li><p><strong>手动安装:</strong></p><ul><li><a href="https://github.com/liuzhihang/toolkit/releases">下载插件</a> -&gt; <code>File</code> -&gt; <code>Setting</code> -&gt; <code>Plugins</code> -&gt; <code>Install Plugin from Disk...</code></li></ul></li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li>右键菜单选择 <code>Tookit</code></li></ul><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><h2 id="v1-0-7-2020-02-27"><a href="#v1-0-7-2020-02-27" class="headerlink" title="v1.0.7 (2020-02-27)"></a><a href="https://github.com/liuzhihang/toolkit/releases/tag/v1.0.7">v1.0.7</a> (2020-02-27)</h2><ul><li>修改使用包装类型</li></ul><p><a href="./doc/ChangeNotes.md">查看更多历史更新记录</a></p><h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><h5 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis:"></a>MyBatis:</h5><p>&emsp;mybatis support: <a href="https://github.com/zhaoqin102/mybatis-support">https://github.com/zhaoqin102/mybatis-support</a></p><p>&emsp;free-idea-mybatis: <a href="https://github.com/wuzhizhan/free-idea-mybatis">https://github.com/wuzhizhan/free-idea-mybatis</a></p><h5 id="Json"><a href="#Json" class="headerlink" title="Json:"></a>Json:</h5><p>&emsp;GsonFormat: <a href="https://github.com/zzz40500/GsonFormat">https://github.com/zzz40500/GsonFormat</a></p><h2 id="本工具使用-JetBrains-IDEA-进行开发"><a href="#本工具使用-JetBrains-IDEA-进行开发" class="headerlink" title="本工具使用 JetBrains IDEA 进行开发"></a>本工具使用 JetBrains IDEA 进行开发</h2><p><a href="https://www.jetbrains.com/?from=Toolkit"><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/toolkit/jetbrains-logo.png" width="20%" height="20%"></a><a href="https://www.jetbrains.com/?from=Toolkit"><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/toolkit/idea-logo.png" width="20%" height="20%"> </a></p><h2 id="演示-1"><a href="#演示-1" class="headerlink" title="演示"></a>演示</h2><p><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/toolkit/copy-as-json.png" alt="copy-as-json"><br><img src="https://cdn.jsdelivr.net/gh/liuzhihang/oss/pic/toolkit/gif.gif" alt="gif"></p>]]></content>
      
      
      <categories>
          
          <category> IDEA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> plugin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>elasticsearch cat API</title>
      <link href="2019/03/14/elasticsearch-cat-api.html"/>
      <url>2019/03/14/elasticsearch-cat-api.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="cat-API"><a href="#cat-API" class="headerlink" title="cat API"></a>cat API</h4><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/cat.html">官方地址</a></p><blockquote><p>GET /_cat/XXX?v<br>GET /_cat/XXX?v&amp;format=json</p></blockquote><p>v 是指带着列信息</p><p>支持指定返回内容的格式 默认为text</p><p>?format=text(json/smile/yaml/cbor)</p><a id="more"></a><h5 id="查看节点别名"><a href="#查看节点别名" class="headerlink" title="查看节点别名"></a>查看节点别名</h5><blockquote><p>GET /_cat/aliases?v<br>curl -X GET “192.168.xxx.xxx:9200/_cat/aliases?v”</p></blockquote><h5 id="每个节点分配了几个shard，对磁盘的占用空间大小，使用率"><a href="#每个节点分配了几个shard，对磁盘的占用空间大小，使用率" class="headerlink" title="每个节点分配了几个shard，对磁盘的占用空间大小，使用率"></a>每个节点分配了几个shard，对磁盘的占用空间大小，使用率</h5><blockquote><p>GET /_cat/allocation?v<br>curl -X GET “192.168.xxx.xxx:9200/_cat/allocation?v”</p></blockquote><h5 id="群集或单个索引的document计数"><a href="#群集或单个索引的document计数" class="headerlink" title="群集或单个索引的document计数"></a>群集或单个索引的document计数</h5><blockquote><p>GET /_cat/count?v<br>curl -X GET “192.168.xxx.xxx:9200/_cat/count?v</p><p>GET /_cat/count/index_name?v<br>curl -X GET “192.168.xxx.xxx:9200/_cat/count/index_name?v”</p></blockquote><h5 id="显示集群中每个数据节点上fielddata当前正在使用的堆内存量"><a href="#显示集群中每个数据节点上fielddata当前正在使用的堆内存量" class="headerlink" title="显示集群中每个数据节点上fielddata当前正在使用的堆内存量"></a>显示集群中每个数据节点上fielddata当前正在使用的堆内存量</h5><blockquote><p>GET /_cat/fielddata?v<br>curl -X GET “192.168.xxx.xxx:9200/_cat/fielddata?v”</p></blockquote><h5 id="查看集群健康情况"><a href="#查看集群健康情况" class="headerlink" title="查看集群健康情况"></a>查看集群健康情况</h5><blockquote><p>GET /_cat/health?v<br>curl -X GET “192.168.xxx.xxx:9200/_cat/health?v”</p></blockquote><h5 id="查看索引的信息"><a href="#查看索引的信息" class="headerlink" title="查看索引的信息"></a>查看索引的信息</h5><blockquote><p>GET _cat/indices?v<br>GET _cat/indices/index_name?v<br>curl -X GET “192.168.xxx.xxx:9200/_cat/indices/twi*?v&amp;s=index”</p></blockquote><h5 id="查看master信息"><a href="#查看master信息" class="headerlink" title="查看master信息"></a>查看master信息</h5><blockquote><p>GET /_cat/master?v<br>curl -X GET “192.168.xxx.xxx:9200/_cat/master?v”</p></blockquote><h5 id="查看node信息"><a href="#查看node信息" class="headerlink" title="查看node信息"></a>查看node信息</h5><blockquote><p>GET /_cat/nodes?v<br>curl -X GET “192.168.xxx.xxx:9200/_cat/nodes?v”</p></blockquote><h5 id="当前pending没执行完的task的具体情况，执行的是什么操作"><a href="#当前pending没执行完的task的具体情况，执行的是什么操作" class="headerlink" title="当前pending没执行完的task的具体情况，执行的是什么操作"></a>当前pending没执行完的task的具体情况，执行的是什么操作</h5><blockquote><p>创建索引，更新映射，分配或失败分片的列表<br>GET /_cat/pending_tasks?v<br>curl -X GET “192.168.xxx.xxx:9200/_cat/pending_tasks?v”</p></blockquote><h5 id="查看安装的插件"><a href="#查看安装的插件" class="headerlink" title="查看安装的插件"></a>查看安装的插件</h5><blockquote><p>GET /_cat/plugins?v&amp;s=component&amp;h=name,component,version,description<br>curl -X GET “192.168.xxx.xxx:9200/_cat/plugins?v&amp;s=component&amp;h=name,component,version,description”</p></blockquote><h5 id="shard-recovery恢复的过程情况"><a href="#shard-recovery恢复的过程情况" class="headerlink" title="shard recovery恢复的过程情况"></a>shard recovery恢复的过程情况</h5><blockquote><p>GET /_cat/recovery?v<br>curl -X GET “192.168.xxx.xxx:9200/_cat/recovery?v”</p></blockquote><h5 id="查看在群集中注册的快照存储库"><a href="#查看在群集中注册的快照存储库" class="headerlink" title="查看在群集中注册的快照存储库"></a>查看在群集中注册的快照存储库</h5><blockquote><p>GET /_cat/repositories?v<br>curl -X GET “192.168.xxx.xxx:9200/_cat/repositories?v</p></blockquote><h5 id="查看线程池使用"><a href="#查看线程池使用" class="headerlink" title="查看线程池使用"></a>查看线程池使用</h5><blockquote><p>GET /_cat/thread_pool<br>curl -X GET “192.168.xxx.xxx:9200/_cat/thread_pool”</p></blockquote><h5 id="查看shard情况"><a href="#查看shard情况" class="headerlink" title="查看shard情况"></a>查看shard情况</h5><blockquote><p>GET _cat/shards?v<br>GET _cat/shards/index_name?v<br>curl -X GET “192.168.xxx.xxx:9200/_cat/shards/index_name?v</p></blockquote><h5 id="索引segment文件的情况，在哪个node上，有多少个document，占用了多少磁盘空间，有多少数据在内存中，是否可以搜索"><a href="#索引segment文件的情况，在哪个node上，有多少个document，占用了多少磁盘空间，有多少数据在内存中，是否可以搜索" class="headerlink" title="索引segment文件的情况，在哪个node上，有多少个document，占用了多少磁盘空间，有多少数据在内存中，是否可以搜索"></a>索引segment文件的情况，在哪个node上，有多少个document，占用了多少磁盘空间，有多少数据在内存中，是否可以搜索</h5><blockquote><p>GET /_cat/segments?v<br>GET _cat/segments/index_name?v<br>curl -X GET “192.168.xxx.xxx:9200/_cat/segments/index_name?v</p></blockquote><h5 id="查看tempalte"><a href="#查看tempalte" class="headerlink" title="查看tempalte"></a>查看tempalte</h5><blockquote><p>GET /_cat/templates?v&amp;s=name<br>curl -X GET “192.168.xxx.xxx:9200/_cat/templates?v&amp;s=name”</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ELK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ELK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么es集群至少需要三个节点</title>
      <link href="2019/03/13/why-does-the-es-cluster-require-at-least-three-nodes.html"/>
      <url>2019/03/13/why-does-the-es-cluster-require-at-least-three-nodes.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="elasticsearch集群"><a href="#elasticsearch集群" class="headerlink" title="elasticsearch集群"></a>elasticsearch集群</h4><div class="mermaid">graph LR;    A(Master Node) --- B(Data Node);    A --- C(Data Node);    B --- C;</div><p>Master: 在Elasticsearch中Master仅仅负责维护集群的状态</p><blockquote><ol><li>创建或删除索引</li><li>跟踪哪些节点是集群的一部分</li><li>决定将哪些碎片分配给哪个节点</li><li>等集群范围的操作</li></ol></blockquote><p>上面的一些集群信息, 是由Master节点进行维护, 但是 Master也会把节点信息, 同步给其他节点, 但是只有master节点可以修改.</p><a id="more"></a><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-node.html">点击查看Elasticsearch节点介绍</a></p><h4 id="为什么要至少三个节点"><a href="#为什么要至少三个节点" class="headerlink" title="为什么要至少三个节点"></a>为什么要至少三个节点</h4><p>首先查看 Elasticsearch 的配置文件, 如下:<br><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-discovery-zen.html">Zen Discovery 官方介绍</a></p><pre><code class="yml"># 传递初始主机列表，以便在启动新节点时执行发现discovery.zen.ping.unicast.hosts: [&quot;192.168.xxx.xxx:9300&quot;, &quot;192.168.xxx.xxx:9300&quot;]# 选举Maste时需要的节点数 (total number of master-eligible nodes / 2 + 1) 防止“防止脑裂”discovery.zen.minimum_master_nodes: 2# 一个节点多久ping一次，默认1sdiscovery.zen.fd.ping_interval: 1s# 等待ping返回时间，默认30sdiscovery.zen.fd.ping_timeout: 30s# ping超时重试次数，默认3次discovery.zen.fd.ping_retries: 3</code></pre><pre><code>discovery.zen.minimum_master_nodes: 2</code></pre><p>其中 minimum_master_nodes 配置是为了防止脑裂</p><h5 id="假设-Elasticsearch-有两个节点"><a href="#假设-Elasticsearch-有两个节点" class="headerlink" title="假设 Elasticsearch 有两个节点"></a>假设 Elasticsearch 有两个节点</h5><div class="mermaid">graph LR;    A(Master Node) --- B(Data Node);</div><div class="mermaid">graph LR;    A(Master Node) -.X.- B(Data Node);</div><ol><li><p>discovery.zen.minimum_master_nodes: 1</p><blockquote><p>此时出现网络波动, 导致 A—B 之间短暂断开连接,  根据选举规则, B将自己选举为 Master, 当网络波动结束, 就会出现两个Master的情况.</p></blockquote> <div class="mermaid">graph LR;    A(Master Node 宕机) --- B(Data Node);</div></li></ol><ol start="2"><li>discovery.zen.minimum_master_nodes: 2<blockquote><p>Master 出现故障, 则 B 将永远不可能将自己选择为 Master</p></blockquote></li></ol><h5 id="Elasticsearch-有三个节点"><a href="#Elasticsearch-有三个节点" class="headerlink" title="Elasticsearch 有三个节点"></a>Elasticsearch 有三个节点</h5><p>三节点配置: discovery.zen.minimum_master_nodes: 2</p><div class="mermaid">graph LR;    A(Master Node) -.X.- B(Data Node);    A -.X.- C(Data Node);    B --- C;</div><p>出现网络波动 A 节点 和 别的节点短暂断开连接</p><div class="mermaid">graph LR;    A(Master Node -&gt; Data Node) -.X.- B(Data Node -&gt; Master Node);    A -.X.- C(Data Node);    B --- C;</div><p>A节点降级, B和C 进行选举, 此处模拟选举B为 Master Node</p><div class="mermaid">graph LR;    A(Data Node) --- B(Master Node);    A --- C(Data Node);    B --- C;</div><p>网络恢复后的节点状况.</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>以上可以看出, 通过配置 minimum_master_nodes 来防止出现脑裂<br>同时在生产过程中, 为了尽量保持集群高可用, 至少需要三台机器搭建集群</p>]]></content>
      
      
      <categories>
          
          <category> ELK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ELK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch 数据写入流程</title>
      <link href="2019/03/12/elasticsearch-data-writing-process.html"/>
      <url>2019/03/12/elasticsearch-data-writing-process.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="简单流程"><a href="#简单流程" class="headerlink" title="简单流程"></a>简单流程</h4><p><img src="/resources/image/elk/elasticsearch-writing-process.png" alt="elasticsearch写入过程"></p><ol><li><p>客户端随机选择一个node发送数据, 此时该node为协调节点(coordinating node)<br> 1.1. coordinating node 通过 _id计算出该document在哪个shard上, 假设为shard0, 计算方式如下:</p><blockquote><p>hash(_id) % number_of_primary_shards</p></blockquote><p> 1.2. node 根据 cluster state 获取到 shard0 在 node1 上</p><a id="more"></a></li><li><p>将消息发送到 node1 的 P0 上</p></li><li><p>P0 收到数据后, 将数据同步到 自己的 replica shard R0上</p></li><li><p>P0 和 R0 都处理完毕, 才会返回客户端成功</p></li></ol><blockquote><p>Px 为 primary shard<br>Rx 为 replica shard<br>当客户端请求为查询时, 路由到任意 shard(primary shard 或者 replica shard) 查询到数据即可返回.</p></blockquote><h4 id="详细流程"><a href="#详细流程" class="headerlink" title="详细流程"></a>详细流程</h4><p><img src="/resources/image/elk/elasticsearch-writing-detailed-process.png" alt="elasticsearch-writing-detailed-process"></p><ol><li>P0收到document, 同时将数据写入到 内存buffer和translog中</li><li>每隔1s或buffer满时, buffer中的数据会 refresh 到segment中, 而后进入os cache, 一旦segment进入到 cache中,其中的数据, 则可以被搜索到<blockquote><p>refresh 时间可以手动设置, 也可以手动触发 refresh</p></blockquote></li><li>清空buffer, translog不处理</li><li>重复1-3操作, translog不断增大, translog每隔30分钟,或大到一定量时, 会触发commit操作</li><li>将buffer中内容刷新到segment中, 并清空buffer</li><li>将一个commit point 写入到磁盘文件中, 标识此次commit 对应的 segment</li><li>执行 fsync 将 os cache 中的数据强制刷新到磁盘文件中</li><li>删除 translog 文件</li></ol><h5 id="删除和更新操作"><a href="#删除和更新操作" class="headerlink" title="删除和更新操作"></a>删除和更新操作</h5><blockquote><p>在commit时, 如果操作为删除, 生成一个 .del文件, 其中将该document标记位deleted, 并不是真正的物理删除, 此时如果有查询请求, 会先查询 .del文件中是否有该记录, 如果有, 则回复不存在.<br>在commit时, 如果为更新操作, 则是将原document标记位deleted, 同时写入一条新数据</p></blockquote><h5 id="服务宕机重启-translog-日志作用"><a href="#服务宕机重启-translog-日志作用" class="headerlink" title="服务宕机重启, translog 日志作用"></a>服务宕机重启, translog 日志作用</h5><blockquote><p>translog是先写入到 os cache中, 然后每隔5s写入到磁盘文件中, 假如服务宕掉, 可能会失去5s数据, 也可以修改写入磁盘的时机, 但是可能会影响性能<br>translog中记录的是数据操作信息, 在服务宕机重启时, 会读取translog磁盘文件, 然后将translog中的数据重新恢复到 segment中, 然后进行后续操作</p></blockquote><h5 id="segment-merge-过程"><a href="#segment-merge-过程" class="headerlink" title="segment merge 过程"></a>segment merge 过程</h5><blockquote><p>segment 持续生成, 会导致 segment不断变多, 占用<a href="https://baike.baidu.com/item/%E6%96%87%E4%BB%B6%E5%8F%A5%E6%9F%84">文件句柄</a>, cpu资源等等<br>es后台有一个专门的程序负责合并segment, 将小的 segment 合成大的segment, 同时写一个commit point, 标识 新的segment file.<br>打开新的segment供查询使用, 删除旧的 segment<br>segment 合并过程中, 被标记位 deleted 的document 不会被合并. 即: 在合并 segment时, 才将 document 真正物理删除<br>合并的segment 可以使磁盘上已经commit的索引 也可以是内存中还未commit的索引</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ELK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ELK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>logstash input多个kafka异常</title>
      <link href="2019/03/04/logstash-input-multiple-kafka-exceptions.html"/>
      <url>2019/03/04/logstash-input-multiple-kafka-exceptions.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><div class="mermaid">graph LR;    filebeat --&gt; logstash;    log4j --&gt; logstash;    logstash --&gt; es;</div><p>filebeat 和 log4j appender 同时到 kafka, logstash在启动时报错, 错误如下:</p><pre><code>javax.management.InstanceAlreadyExistsException: kafka.consumer:type=app-info,id=logstash-0</code></pre><a id="more"></a><h5 id="问题原因及解决"><a href="#问题原因及解决" class="headerlink" title="问题原因及解决"></a>问题原因及解决</h5><p>input 消费kafka时, 分别指定不同的 client_id.</p><pre><code>kafka &#123;        bootstrap_servers =&gt; [&quot;192.168.103.43:9092&quot;] # 注意这里配置的kafka的broker地址不是zk的地址        client_id =&gt; &quot;kafka_client_1&quot;        group_id =&gt; &quot;logstash&quot;        topics =&gt; [&quot;ipaynow_log&quot;]  # kafka topic 名称        consumer_threads =&gt; 5        decorate_events =&gt; true        type =&gt; &quot;string&quot;        codec =&gt; &quot;json&quot;&#125;kafka &#123;        bootstrap_servers =&gt; [&quot;192.168.103.43:9092&quot;] # 注意这里配置的kafka的broker地址不是zk的地址        client_id =&gt; &quot;kafka_client_2&quot;        group_id =&gt; &quot;logstash&quot;        topics =&gt; [&quot;ipaynow-hunter&quot;]  # kafka topic 名称        consumer_threads =&gt; 5        decorate_events =&gt; true        type =&gt; &quot;string&quot;        codec =&gt; plain &#123; charset=&gt;&quot;UTF-8&quot; &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> issue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ELK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序无异常中断</title>
      <link href="2019/02/15/no-abnormal-interruption-of-the-program.html"/>
      <url>2019/02/15/no-abnormal-interruption-of-the-program.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><ol><li>程序执行到某一处之后停顿, 不能继续执行, 不抛出异常, 无返回值</li><li>本地测试正常</li><li>debug可以正常执行</li><li>操作为入库之前, 创建对象, 是一个很简单的set操作</li></ol><blockquote><p>payInfoExtra.setToAccType(agPayReqDto.getToAccType().getValue());</p><p>其中get操作获取的为一个枚举, 主要操作为从枚举中获取value set到另一个对象中</p></blockquote><a id="more"></a><pre><code class="java">    public AccTypeEnum getToAccType() &#123;        return toAccType;    &#125;</code></pre><h4 id="问题原因及解决"><a href="#问题原因及解决" class="headerlink" title="问题原因及解决"></a>问题原因及解决</h4><p>小伙伴在他们项目中复用本项目中的枚举类, 没有修改包名类名, 但是把枚举中value字段从 byte改成了String, 同时放在了依赖中, 提供给我们使用.<br>解决方案就很简单了, 让小伙伴修改包名类名就可以了.<br>原枚举类如下:</p><pre><code class="java">public enum AccTypeEnum &#123;    PRI((byte) 0, &quot;对私&quot;),    PUB((byte) 1, &quot;对公&quot;);    private byte value;    private String desc;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> issue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> issue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>skywalking5集群部署</title>
      <link href="2018/12/27/skywalking5-cluster-deployment.html"/>
      <url>2018/12/27/skywalking5-cluster-deployment.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h4><ol><li>skywalking-5.0.0-GA</li><li>zookeeper-3.4.10</li><li>elasticsearch-5.6.14</li></ol><p>下载地址如下:</p><pre><code>skywalking: http://skywalking.apache.org/downloads/zookeeper: http://mirrors.hust.edu.cn/apache/zookeeper/elasticsearch: https://www.elastic.co/downloads/past-releases</code></pre><a id="more"></a><h4 id="安装zk集群"><a href="#安装zk集群" class="headerlink" title="安装zk集群"></a>安装zk集群</h4><ol><li>下载并解压zk<pre><code class="bash">wget http://mirrors.hust.edu.cn/apache/zookeeper/zookeeper-3.4.10/zookeeper-3.4.10.tar.gztar -xvf zookeeper-3.4.10.tar.gz</code></pre></li><li>修改配置文件<pre><code class="bash">cd zookeeper-3.4.10/conf/cp zoo_sample.cfg zoo.cfgvim zoo.cfg</code></pre></li><li>内容如下<pre><code class="bash">tickTime=2000initLimit=10syncLimit=5dataDir=/opt/export/app/zookeeper-3.4.10/dataclientPort=2181server.1=192.168.***.236:2888:3888server.2=192.168.***.237:2888:3888</code></pre></li><li>写入集群myid<pre><code class="bash">echo 1 &gt; /opt/export/app/zookeeper-3.4.10/data/myid# 另一台机器则写入2</code></pre></li><li>zk基本命令<pre><code class="bash"># 在zk的bin目录下# 启动./zkServer.sh start# 停止./zkServer.sh stop# 查看状态./zkServer.sh status# 查看zk的节点./zkCli.sh# 连接后使用 ls / 命令查看ls /skywalking</code></pre></li></ol><h4 id="安装es集群"><a href="#安装es集群" class="headerlink" title="安装es集群"></a>安装es集群</h4><ol><li>下载并解压es<pre><code class="bash">wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.6.14.tar.gztar -xvf elasticsearch-5.6.14.tar.gz</code></pre></li><li>修改配置文件<pre><code class="bash">cd elasticsearch-5.6.14/config/vim elasticsearch.yml</code></pre></li><li>内容如下<pre><code class="bash">cluster.name: CollectorDBClusternode.name: node-1path.data: /opt/export/app/elasticsearch-5.6.14/datapath.logs: /opt/export/app/elasticsearch-5.6.14/logsnetwork.host: 192.168.***.234discovery.zen.ping.unicast.hosts: [&quot;192.168.***.234:9300&quot;, &quot;192.168.***.235:9300&quot;]discovery.zen.minimum_master_nodes: 2bootstrap.memory_lock: falsebootstrap.system_call_filter: false# 修改上报数据线程池大小thread_pool.bulk.queue_size: 1000</code></pre></li><li>常用命令<pre><code class="bash"># 后台启动bin/elasticsearch -d# 删除所有索引curl -XDELETE 192.168.***.234:9200/*</code></pre></li></ol><h4 id="安装skywalking"><a href="#安装skywalking" class="headerlink" title="安装skywalking"></a>安装skywalking</h4><p>☞ <a href="https://github.com/apache/incubator-skywalking/blob/v5.0.0-GA/docs/cn/Deploy-backend-in-cluster-mode-CN.md">官方地址</a></p><ol><li>下载并解压<pre><code class="bash">wget http://mirrors.shu.edu.cn/apache/incubator/skywalking/5.0.0-GA/apache-skywalking-apm-incubating-5.0.0-GA.tar.gztar -xvf apache-skywalking-apm-incubating-5.0.0-GA.tar.gzmv apache-skywalking-apm-incubating-5.0.0-GA skywalking-5.0.0-GA</code></pre></li><li>修改配置<pre><code class="bash">cd skywalking-5.0.0-GA/config/vim application.yml</code></pre></li><li>修改内容如下<ol><li>集群配置<pre><code class="bash">cluster:    zookeeper:        hostPort: 192.168.***.236:2181,192.168.***.237:2181        sessionTimeout: 100000</code></pre></li><li>es配置<pre><code class="bash">storage:    elasticsearch:        clusterName: CollectorDBCluster        clusterTransportSniffer: true        clusterNodes: 192.168.***.234:9300,192.168.***.235:9300        # 其他配置</code></pre></li><li>其他配置<pre><code class="bash"># host配置修改host: 192.168.***.236</code></pre></li></ol></li><li>修改webapp配置<pre><code class="bash">vim webapp/webapp.yml</code></pre><pre><code class="yml">collector: path: /graphql ribbon:     ReadTimeout: 10000     listOfServers: 192.168.**.236:10800,192.168.**.237:10800</code></pre></li><li>常用命令<pre><code class="bash"># 启动collector+webUIbin/startup.sh# 只启动collector或webUIbin/collectorService.shbin/webappService.sh</code></pre></li><li>探针使用<br> ☞ <a href="https://github.com/apache/incubator-skywalking/blob/v5.0.0-GA/docs/cn/Deploy-skywalking-agent-CN.md">官方地址</a><pre><code> java -javaagent:/path/to/skywalking-agent/skywalking-agent.jar -jar yourApp.jar</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> skywalking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ELK </tag>
            
            <tag> skywalking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>logstash时间戳差8个小时</title>
      <link href="2018/12/20/logstash-timestamp-difference-8-hours.html"/>
      <url>2018/12/20/logstash-timestamp-difference-8-hours.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="问题说明"><a href="#问题说明" class="headerlink" title="问题说明"></a>问题说明</h4><p>原始配置:</p><pre><code class="logstash">elasticsearch &#123;        # manage_template =&gt; false        template_overwrite =&gt; true        template =&gt; &quot;/opt/export/app/logstash-6.4.2/bin/dynamic_templates.json&quot;        user =&gt; xxxxxxx        password =&gt; xxxxxxx        index =&gt; &quot;%&#123;sys_name&#125;-%&#123;+YYYY.MM.dd&#125;&quot;        hosts =&gt; [&quot;172.19.3.51:9200&quot;,&quot;172.19.3.52:9200&quot;]&#125;</code></pre><p>在使用logstash输出内容要es中时, 指定index为系统名称+时间(年月日), 时间会自动匹配‘@timestamp’字段并格式化, 但是在实际使用过程中, 发现在上午八点之前的消息会被创建到昨天的索引里面.查阅相关资料, 有介绍在时间戳上面增加8个小时的方式, 也可以使用. 这里结合自己业务使用的其他方式.</p><a id="more"></a><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ol><li><p>主要报送内容为filebeat的日志信息, 日志统一有时间戳, 格式如下:</p><pre><code> [trans-mediapay]-[2018-12-19 02:00:00:187]-[queryThreadPool-14]-[]-[WeBankServiceImpl.java:101]-[INFO ]-[测试2点的日志]</code></pre></li><li><p>解析时间戳的时间</p><ol><li><p>先匹配整体日志, 获取’log_time’字段</p></li><li><p>匹配’log_time’字段</p></li><li><p>生成元数据 ‘[@metadata][index_suffix]’</p><pre><code class="bash">filter &#123;#  日志聚合使用全量配置grok &#123; match =&gt; &#123; &quot;message&quot; =&gt; &quot;\[%&#123;DATA:sys_name&#125;\]-\[%&#123;DATA:log_time&#125;\]-\[%&#123;DATA:thread_name&#125;\]-\[%&#123;DATA:trace_id&#125;\]-\[%&#123;DATA:class_name&#125;\]-\[%&#123;DATA:log_level&#125;\]-%&#123;GREEDYDATA:log_msg&#125;&quot; &#125;&#125;grok&#123; match =&gt; &#123; &quot;log_time&quot; =&gt; [&quot;%&#123;INT:index_year&#125;-%&#123;INT:index_mouth&#125;-%&#123;INT:index_day&#125;&quot;]&#125;&#125;mutate &#123;# 使用元数据 [@metadata][index_suffix] add_field =&gt; &#123; &quot;[@metadata][index_suffix]&quot; =&gt; &quot;%&#123;index_year&#125;.%&#123;index_mouth&#125;.%&#123;index_day&#125;&quot; &#125; remove_field =&gt; [&quot;host&quot;,&quot;beat&quot;,&quot;tags&quot;,&quot;[beat][name]&quot;,&quot;[beat][version]&quot;,&quot;prospector&quot;,&quot;@version&quot;,&quot;offset&quot;,&quot;input&quot;,&quot;y_index&quot;,&quot;M_index&quot;,&quot;d_index&quot;]&#125;</code></pre></li></ol></li></ol><p>}</p><pre><code>3. 输出时使用元数据, 该字段不会出现在es的字段中```bashelasticsearch &#123;        # manage_template =&gt; false        template_overwrite =&gt; true        template =&gt; &quot;/opt/export/app/logstash-6.4.2/bin/dynamic_templates.json&quot;        user =&gt; xxxxxxx        password =&gt; xxxxxxx        index =&gt; &quot;%&#123;sys_name&#125;-%&#123;[@metadata][index_suffix]&#125;&quot;        hosts =&gt; [&quot;xxxx:9200&quot;,&quot;xxxx:9200&quot;]&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> issue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ELK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>获取IP和byte转long遇到的小问题</title>
      <link href="2018/12/10/get-the-small-problem-encountered-by-ip-and-byte-to-long.html"/>
      <url>2018/12/10/get-the-small-problem-encountered-by-ip-and-byte-to-long.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>因为业务需求新项目的流水号系统从 ‘数据库自增步长+分段式锁’ 换成使用 <a href="https://github.com/liuzhihang/tool_demo/blob/master/src/main/java/com/ipaynow/tool/snowflake/SnowFlake.java">雪花流水号</a>, 修改机器标识和数据中心字段为自动获取ip后三位, 人工保证ip后三位不相同</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><a href="https://github.com/liuzhihang/tool_demo/blob/master/src/main/java/com/ipaynow/tool/snowflake/SnowFlakeSerial.java">雪花流水号 - 改造版</a></p><p>修改内容如下:<br>删除构造, 修改数据位数, 添加静态代码块</p><a id="more"></a><pre><code class="java">private final static long MACHINE_BIT = 8;private final static long DATA_CENTER_BIT = 2;static &#123;    try &#123;        InetAddress localHost = InetAddress.getLocalHost();        address = localHost.getAddress()[3] &amp; 0xff;        System.out.println(&quot;当前系统的 address 为: &quot; + address);    &#125; catch (UnknownHostException e) &#123;        throw new IllegalArgumentException(&quot;DATA_CENTER_ID can&#39;t be greater than MAX_DATA_CENTER_NUM or less than 0&quot;);    &#125;&#125;</code></pre><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><h5 id="服务器配置host"><a href="#服务器配置host" class="headerlink" title="服务器配置host"></a>服务器配置host</h5><p>服务器对应的 hostname 需要配置ip地址</p><pre><code class="bash">cat /etc/hosts</code></pre><h5 id="byte-转换-long需要-amp-0xff"><a href="#byte-转换-long需要-amp-0xff" class="headerlink" title="byte 转换 long需要 &amp; 0xff"></a>byte 转换 long需要 &amp; 0xff</h5><p>当获取ip大于127时转换出来为负值, 所以需要 &amp; 0xff</p>]]></content>
      
      
      <categories>
          
          <category> issue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于LinkHashMap的LRU缓存淘汰</title>
      <link href="2018/11/19/elimination-of-lru-cache-based-on-linkhashmap.html"/>
      <url>2018/11/19/elimination-of-lru-cache-based-on-linkhashmap.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h5 id="LRU缓存淘汰"><a href="#LRU缓存淘汰" class="headerlink" title="LRU缓存淘汰"></a>LRU缓存淘汰</h5><p>LRU缓存淘汰是redis中的一种淘汰策略, 当内存大小不足以存放数据时, 此时存入新数据, 将删除较早存入的数据.<br>在dubbo中使用LRU来缓存 hostName.<br>在mysql中使用LRU来缓存 serverSideStatementCheckCache 和 serverSideStatementCache.</p><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><pre><code class="java">package com.ipaynow.tool.lru;import java.util.LinkedHashMap;import java.util.Map;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * 基于LinkedHashMap LRU 缓存淘汰, 以下框架中都有使用 * dubbo com.alibaba.dubbo.common.utils.LRUCache * com.mysql.jdbc.util.LRUCache * * @author liuzhihang * @date 2018/11/20 10:43 */public class LRULinkedHashMap&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; &#123;    /**     * 设置最大容量     */    private volatile int maxCapacity;    private static final int DEFAULT_MAX_CAPACITY = 1000;    private static final float DEFAULT_LOAD_FACTOR = 0.75f;    private final Lock lock = new ReentrantLock();    public LRULinkedHashMap() &#123;        this.maxCapacity = DEFAULT_MAX_CAPACITY;    &#125;    public LRULinkedHashMap(int maxCapacity) &#123;        // accessOrder设置为true 按照时间排序        super(maxCapacity, DEFAULT_LOAD_FACTOR, true);        this.maxCapacity = maxCapacity;    &#125;    /**     * 当链表长度大于最大容量时 删除最旧的元素     */    @Override    protected boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) &#123;        return size() &gt; maxCapacity;    &#125;    @Override    public boolean containsKey(Object key) &#123;        try &#123;            lock.lock();            return super.containsKey(key);        &#125; finally &#123;            lock.unlock();        &#125;    &#125;    @Override    public V get(Object key) &#123;        try &#123;            lock.lock();            return super.get(key);        &#125; finally &#123;            lock.unlock();        &#125;    &#125;    @Override    public V put(K key, V value) &#123;        try &#123;            lock.lock();            return super.put(key, value);        &#125; finally &#123;            lock.unlock();        &#125;    &#125;    @Override    public V remove(Object key) &#123;        try &#123;            lock.lock();            return super.remove(key);        &#125; finally &#123;            lock.unlock();        &#125;    &#125;    @Override    public int size() &#123;        try &#123;            lock.lock();            return super.size();        &#125; finally &#123;            lock.unlock();        &#125;    &#125;    @Override    public void clear() &#123;        try &#123;            lock.lock();            super.clear();        &#125; finally &#123;            lock.unlock();        &#125;    &#125;    public int getMaxCapacity() &#123;        return maxCapacity;    &#125;    public void setMaxCapacity(int maxCapacity) &#123;        this.maxCapacity = maxCapacity;    &#125;&#125;</code></pre><h5 id="测试代码及结果"><a href="#测试代码及结果" class="headerlink" title="测试代码及结果"></a>测试代码及结果</h5><pre><code class="java">package com.ipaynow.tool.lru;import java.time.LocalDateTime;import java.time.format.DateTimeFormatter;import java.util.Iterator;import java.util.Map;/** * @author liuzhihang * @date 2018/11/20 10:58 */public class LRUTest &#123;    public static void main(String[] args) throws InterruptedException &#123;        LRULinkedHashMap&lt;String, String&gt; map = new LRULinkedHashMap&lt;&gt;(5);        for (int i = 0; i &lt; 10; i++) &#123;            Thread.sleep(1000);            map.put(LocalDateTime.now().format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss SSS&quot;)), &quot;value&quot; + i);        &#125;        for (Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = map.entrySet().iterator(); iterator.hasNext(); ) &#123;            Map.Entry&lt;String, String&gt; entry = iterator.next();            String key = entry.getKey();            String value = entry.getValue();            System.out.println(key + &quot;------------&quot; + value);        &#125;    &#125;&#125;</code></pre><p>控制台输出结果:</p><pre><code class="bash">2018-11-20 11:13:21 398------------value52018-11-20 11:13:22 399------------value62018-11-20 11:13:23 400------------value72018-11-20 11:13:24 400------------value82018-11-20 11:13:25 400------------value9Process finished with exit code 0</code></pre>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
          <category> cache </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> cache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ELK常用启动命令</title>
      <link href="2018/10/29/elk-common-start-command.html"/>
      <url>2018/10/29/elk-common-start-command.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="elasticsearch启动命令"><a href="#elasticsearch启动命令" class="headerlink" title="elasticsearch启动命令"></a>elasticsearch启动命令</h4><pre><code class="bash"># 前台启动 关闭窗口连接后自动退出./bin/elasticsearch# 后台启动./bin/elasticsearch  -d</code></pre><a id="more"></a><h4 id="logstash启动命令"><a href="#logstash启动命令" class="headerlink" title="logstash启动命令"></a>logstash启动命令</h4><pre><code class="bash"># 前台启动 -f 后面为配置文件./logstash -f logstash.conf# 后台启动nohup ./logstash -f logstash.conf &amp;</code></pre><h4 id="kibana启动命令"><a href="#kibana启动命令" class="headerlink" title="kibana启动命令"></a>kibana启动命令</h4><pre><code class="bash"># 前台启动./bin/kibana# 后台启动./bin/kibana &amp;</code></pre><h5 id="kibana停止命令"><a href="#kibana停止命令" class="headerlink" title="kibana停止命令"></a>kibana停止命令</h5><p>当ps -ef | grep kibana 查不到时 可以<br>lsof -i:5601<br>kill -9 线程</p><h4 id="filebeat启动命令"><a href="#filebeat启动命令" class="headerlink" title="filebeat启动命令"></a>filebeat启动命令</h4><pre><code class="bash"># 前台启动./filebeat -e -c filebeat.yml# 后台启动 不输出日志/输出日志nohup ./filebeat -e -c filebeat.yml &gt;/dev/null 2&gt;&amp;1 &amp;nohup ./filebeat -e -c filebeat.yml &gt; filebeat.log &amp;</code></pre><h5 id="jar包启动命令"><a href="#jar包启动命令" class="headerlink" title="jar包启动命令"></a>jar包启动命令</h5><pre><code class="bash"># 前台启动java -jar server.ja# 后台启动nohup java -jar server.jar &amp;</code></pre>]]></content>
      
      
      <categories>
          
          <category> ELK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ELK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>search-guard-6 配置用户</title>
      <link href="2018/10/24/searchguard6-configuration-user.html"/>
      <url>2018/10/24/searchguard6-configuration-user.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="search-guard-配置用户"><a href="#search-guard-配置用户" class="headerlink" title="search-guard 配置用户"></a>search-guard 配置用户</h4><p>路径: /opt/export/app/elasticsearch-6.4.2/plugins/search-guard-6/sgconfig</p><h5 id="生成密码"><a href="#生成密码" class="headerlink" title="生成密码"></a>生成密码</h5><p>执行以下命令, 输入明文</p><pre><code class="bash">plugins/search-guard-6/tools/hasher.sh -p mycleartextpassword</code></pre><a id="more"></a><h5 id="1-配置用户及密码"><a href="#1-配置用户及密码" class="headerlink" title="1. 配置用户及密码"></a>1. 配置用户及密码</h5><p>文件: sg_internal_users.yml</p><pre><code class="yml">zhangsan:  hash: $2y$12$yKXk785zSTtB3kE7g.XnbOPrc690g9JE50Znwum924i2M/xYGG4qq  roles:    - trans_group</code></pre><p>格式:</p><pre><code class="yml">姓名:  密码: XXXX(明文的hash, 使用search-guard的工具生成)  角色:    - 角色名称</code></pre><h5 id="2-配置权限"><a href="#2-配置权限" class="headerlink" title="2. 配置权限"></a>2. 配置权限</h5><p>文件: sg_roles.xml</p><p>配置’?kibana’ 及’?kibana-6’ 权限是为了保证用户在kibana中能够正常使用kibana</p><pre><code class="yml">sg_trans_group:  cluster:    - cluster:monitor/nodes    - cluster:monitor/health  indices:    &#39;log-system&#39;:      &#39;*&#39;:        - indices:admin/mappings/fields/get        - indices:admin/validate/query        - indices:data/read/search        - indices:data/read/msearch        - indices:admin/get        - indices:data/read/field_stats    &#39;?kibana&#39;:      &#39;*&#39;:        - MANAGE        - INDEX        - READ        - DELETE    &#39;?kibana-6&#39;:      &#39;*&#39;:        - MANAGE        - INDEX        - READ        - DELETE</code></pre><p>格式:</p><pre><code class="yml">权限名称:  集群:    - 集群名称:权限  索引:    &#39;索引名称&#39;:      &#39;类型&#39;:        - 权限</code></pre><h5 id="3-配置角色映射"><a href="#3-配置角色映射" class="headerlink" title="3. 配置角色映射"></a>3. 配置角色映射</h5><p>文件: sg_roles_mapping.yml</p><p>配置完用户的账户密码, 以及相应角色权限之后, 需要将用户和权限进行关联, 关联之后即可使用</p><pre><code class="yml">sg_trans_group:   backendroles:    - trans_group</code></pre><p>格式:</p><pre><code class="yml">映射名称:  角色:    - 用户的角色</code></pre><p>也可以使用以下方式进行关联:</p><pre><code class="yml">sg_trans_group:   users:    - zhangsan    - lisi# 即映射名称:  用户名称:    - 用户名</code></pre><h5 id="4-使配置生效"><a href="#4-使配置生效" class="headerlink" title="4. 使配置生效"></a>4. 使配置生效</h5><p>使用以下命令</p><pre><code class="bash">./sgadmin.sh -cn 集群名称 -cd ../sgconfig -ks ../../../config/sgadmin-keystore.jks -kspass changeit -ts ../../../config/truststore.jks -tspass changeit -nhnv</code></pre>]]></content>
      
      
      <categories>
          
          <category> ELK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ELK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>search-guard-6 安装</title>
      <link href="2018/10/23/searchguard6-installation.html"/>
      <url>2018/10/23/searchguard6-installation.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="ES-安装-search-guard-6"><a href="#ES-安装-search-guard-6" class="headerlink" title="ES 安装 search-guard-6"></a>ES 安装 search-guard-6</h4><h6 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h6><p>☞ <a href="https://docs.search-guard.com/latest/demo-installer">官方网站</a><br>在ES目录下执行命令</p><pre><code>bin/elasticsearch-plugin install -b com.floragunn:search-guard-6:6.4.2-23.1</code></pre><p>注: 安装版本需要和Elasticsearch版本相对应. <a href="https://docs.search-guard.com/latest/search-guard-versions">查看版本</a></p><p>这里不使用官方的快速构建方法</p><a id="more"></a><h6 id="生成证书"><a href="#生成证书" class="headerlink" title="生成证书"></a>生成证书</h6><ol><li><p>下载脚本<br> <code>git clone https://github.com/floragunncom/search-guard-ssl.git</code></p></li><li><p>证书配置<br> 路径<br> <code>**/elasticsearch-6.4.2/search-guard-ssl/example-pki-scripts</code></p><p> 目录内容 etc下可对证书进行配置<br> <img src="/resources/image/elk/configuration.png" alt="证书配置"></p></li><li><p>修改<a href="search-guard-ssl/example-pki-scripts/example.sh">example.sh</a></p></li></ol><pre><code class="bash">#!/bin/bashOPENSSL_VER=&quot;$(openssl version)&quot;if [[ $OPENSSL_VER == *&quot;0.9&quot;* ]]; then        echo &quot;Your OpenSSL version is too old: $OPENSSL_VER&quot;        echo &quot;Please install version 1.0.1 or later&quot;        exit -1else    echo &quot;Your OpenSSL version is: $OPENSSL_VER&quot;fiset -e./clean.sh# 第一个参数为CA根证书密码，第二个参数为TS密码(truststore，信任证书密码)./gen_root_ca.sh capass changeit# 生成节点证书： 第一个参数为节点编号，第二个参数为keystore文件密码，第三个参数为CA根证书密码。# 此处我们只生成两个节点证书./gen_node_cert.sh 0 changeit capass &amp;&amp; ./gen_node_cert.sh 1 changeit capass# 生成客户端证书： 第一个参数为客户端名称, 第二个参数为keystore文件名称，第三个参数为CA根证书名称。./gen_client_node_cert.sh spock changeit capass./gen_client_node_cert.sh kirk changeit capass./gen_client_node_cert.sh logstash changeit capass./gen_client_node_cert.sh filebeat changeit capass./gen_client_node_cert.sh kibana changeit capass# 生成一个sgadmin客户端证书，用于配置管理./gen_client_node_cert.sh sgadmin changeit capass# 生成一个javaapi访问的客户端证书./gen_client_node_cert.sh javaapi changeit capassrm -f ./*tmp*</code></pre><ol start="4"><li>生成证书移动到elasticsearch config 在ES目录下</li></ol><pre><code class="bash">./example.shcp node-0-keystore.jks sgadmin-keystore.jks truststore.jks /opt/export/app/elasticsearch-6.4.2/config/</code></pre><ol start="5"><li>配置elasticsearch.yml, 增加以下配置</li></ol><pre><code class="yml"># 配置节点间通信证书，节点间通信使用TLS是强制的searchguard.ssl.transport.keystore_filepath: node-0-keystore.jkssearchguard.ssl.transport.keystore_password: changeitsearchguard.ssl.transport.truststore_filepath: truststore.jkssearchguard.ssl.transport.truststore_password: changeit# 设置不校验hostnamesearchguard.ssl.transport.enforce_hostname_verification: falsesearchguard.ssl.transport.resolve_hostname: false# 配置管理员证书DNsearchguard.authcz.admin_dn:  - CN=sgadmin,OU=client,O=client,L=Test, C=DEbootstrap.memory_lock: falsebootstrap.system_call_filter: falsexpack.security.enabled: false</code></pre><ol start="6"><li>启动访问需要权限</li></ol><h6 id="添加脚本权限并初始化用户"><a href="#添加脚本权限并初始化用户" class="headerlink" title="添加脚本权限并初始化用户"></a>添加脚本权限并初始化用户</h6><pre><code class="bash">cd /opt/export/app/elasticsearch-6.4.2/plugins/search-guard-6/toolschmod +x *.sh./sgadmin.sh -cn cluster-es -cd ../sgconfig -ks ../../../config/sgadmin-keystore.jks -kspass changeit -ts ../../../config/truststore.jks -tspass changeit -nhnv</code></pre><p>每次更新用户权限或者新增修改用户, 只需要重新执行第三条命令, 更新用户信息即可</p><h4 id="Kibana安装"><a href="#Kibana安装" class="headerlink" title="Kibana安装"></a>Kibana安装</h4><p>参照官方网站安装配置即可. <a href="https://docs.search-guard.com/latest/demo-installer">官方网站</a>, 或者按照以下步骤.</p><ol><li>在kibana安装目录下执行一下吗命令</li></ol><pre><code class="bash">bin/kibana-plugin install https://search.maven.org/remotecontent?filepath=com/floragunn/search-guard-kibana-plugin/6.4.2-15/search-guard-kibana-plugin-6.4.2-15.zip</code></pre><ol start="2"><li>修改kibana.yml</li></ol><pre><code class="yml"># Use HTTPS instead of HTTP# elasticsearch.url: &quot;https://localhost:9200&quot;elasticsearch.url: &quot;http://localhost:9200&quot;# Configure the Kibana internal server userelasticsearch.username: &quot;kibanaserver&quot;elasticsearch.password: &quot;kibanaserver&quot;# Disable SSL verification because we use self-signed demo certificateselasticsearch.ssl.verificationMode: none# Whitelist the Search Guard Multi Tenancy Headerelasticsearch.requestHeadersWhitelist: [ &quot;Authorization&quot;, &quot;sgtenant&quot; ]</code></pre><ol start="3"><li>打开对应域名登录<br><code>http://localhost:5601/</code></li></ol><h4 id="注"><a href="#注" class="headerlink" title="注:"></a>注:</h4><p>以上内容为参考自<a href="https://www.jianshu.com/u/d58afc984a4f">M醉逍遥</a>, 并搭建成功后总结记录, 以作备忘. 链接如下:<br><a href="https://www.jianshu.com/p/319913a944af">https://www.jianshu.com/p/319913a944af</a></p>]]></content>
      
      
      <categories>
          
          <category> ELK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ELK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo搭建博客</title>
      <link href="2018/10/08/hexo-build-blog.html"/>
      <url>2018/10/08/hexo-build-blog.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="安装node"><a href="#安装node" class="headerlink" title="安装node"></a>安装node</h3><p>下载地址: <a href="https://nodejs.org/en/">https://nodejs.org</a></p><p>查看当前版本: node -v</p><p><img src="/resources/hexo/node-v.png" alt="node-v"></p><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><pre><code>npm install</code></pre><p>也可以使用<a href="https://npm.taobao.org/">淘宝镜像</a></p><pre><code>npm install -g cnpm --registry=https://registry.npm.taobao.orgcnpm install hexo</code></pre><a id="more"></a><h3 id="hexo常用命令"><a href="#hexo常用命令" class="headerlink" title="hexo常用命令"></a>hexo常用命令</h3><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><pre><code>hexo init</code></pre><h5 id="清除缓存"><a href="#清除缓存" class="headerlink" title="清除缓存"></a>清除缓存</h5><pre><code>hexo clean</code></pre><h5 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h5><pre><code>hexo ghexo generate</code></pre><h5 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h5><pre><code>hexo shexo server</code></pre><h5 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h5><pre><code>hexo dhexo deploy</code></pre><h5 id="生成并部署"><a href="#生成并部署" class="headerlink" title="生成并部署"></a>生成并部署</h5><pre><code>hexo g -d</code></pre>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器cpu占用率高</title>
      <link href="2018/09/25/server-cpu-occupancy-rate-is-high.html"/>
      <url>2018/09/25/server-cpu-occupancy-rate-is-high.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-top-命令找到占用cpu最高的进程"><a href="#1-top-命令找到占用cpu最高的进程" class="headerlink" title="1. top 命令找到占用cpu最高的进程"></a>1. top 命令找到占用cpu最高的进程</h3><pre><code class="bash">top - 14:37:14 up 34 days, 13:27,  2 users,  load average: 0.21, 0.29, 0.29Tasks: 151 total,   1 running, 150 sleeping,   0 stopped,   0 zombieCpu(s):  4.4%us,  2.7%sy,  0.0%ni, 90.9%id,  0.5%wa,  0.0%hi,  0.2%si,  1.3%stMem:  16334064k total, 16171240k used,   162824k free,    16716k buffersSwap: 16383996k total,  4470816k used, 11913180k free,   539788k cachedPID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND1818 tomcat    20   0 3643m 983m 7548 S  0.7 24.8 190:40.13 java</code></pre><a id="more"></a><p>字段解释:<br>top - 时间 运行时间 用户 系统负载<br>Tasks: 进程相关信息<br>Cpu(s): cpu相关信息<br>Mem: 内存相关<br>Swap: 交换区相关信息</p><p>进程相关信息<br>PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND</p><h3 id="2-使用top-H-p-查看该进程内所有线程"><a href="#2-使用top-H-p-查看该进程内所有线程" class="headerlink" title="2. 使用top -H -p  查看该进程内所有线程"></a>2. 使用top -H -p <pid> 查看该进程内所有线程</h3><p>top -H -p 1818</p><pre><code class="bash">PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND6656 tomcat    20   0 4193m 608m  11m R 21.0  3.8   1419:44 java</code></pre><h3 id="3-printf-“-x-n”-将10进制线程号转换为16进制结果"><a href="#3-printf-“-x-n”-将10进制线程号转换为16进制结果" class="headerlink" title="3. printf “%x\n”  将10进制线程号转换为16进制结果"></a>3. printf “%x\n” <pid> 将10进制线程号转换为16进制结果</h3><pre><code class="bash">[liuzhihang@test08 ~]$ printf &quot;%x\n&quot; 1876754[liuzhihang@test08 ~]$</code></pre><h3 id="4-jstack-grep"><a href="#4-jstack-grep" class="headerlink" title="4. jstack  |grep "></a>4. jstack <pid> |grep <tid></h3><p>jstack 1818 | grep 754 -A 30</p><p>pid 为第一次执行top命令时的 pid<br>tid 为将第二次的pid进行十六进制转换后的结果</p><pre><code class="bash">&quot;catalina-8180-89&quot; #1842 daemon prio=5 os_prio=0 tid=0x00007f4ec4096000 nid=0x5d96 waiting on condition [0x00007f4e87545000]   java.lang.Thread.State: WAITING (parking)    at sun.misc.Unsafe.park(Native Method)    - parking to wait for  &lt;0x00000000f418f898&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)    at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)    at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)    at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)    at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:104)    at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:32)    at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1074)    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1134)    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)    at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)    at java.lang.Thread.run(Thread.java:748)&quot;catalina-8180-88&quot; #1841 daemon prio=5 os_prio=0 tid=0x00007f4eb848e800 nid=0x5d94 waiting on condition [0x00007f4e8bd8b000]   java.lang.Thread.State: WAITING (parking)    at sun.misc.Unsafe.park(Native Method)</code></pre>]]></content>
      
      
      <categories>
          
          <category> issue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> issue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>final finally finalize区别</title>
      <link href="2018/09/06/final-finally-finalize-difference.html"/>
      <url>2018/09/06/final-finally-finalize-difference.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>final为java关键字, 可以作用于成员变量、方法、类上<br>1.作用于成员变量上, 基本类型则值不可修改, 如果成员变量为对象, 则该对象的引用不可修改.<br>2.作用于方法, 该方法不可被重写<br>3.作用于类, 该类不可继承</p><a id="more"></a><h3 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h3><p>异常处理的关键字, 无论异常是否发生, finally内逻辑总会执行.</p><h4 id="finally-和-return-的执行顺序"><a href="#finally-和-return-的执行顺序" class="headerlink" title="finally 和 return 的执行顺序"></a>finally 和 return 的执行顺序</h4><p>1.一般使用逻辑, return在try-catch-finally之后, 证明, 无论是否异常, finally都会执行</p><pre><code class="java">public class MainTest &#123;    public static void main(String[] args) &#123;        System.out.println(finallyTest());    &#125;    private static String finallyTest() &#123;        try &#123;            System.out.println(&quot;处理逻辑&quot;);            // int i = 1 / 0;        &#125; catch (Exception e) &#123;            System.out.println(&quot;异常逻辑&quot;);        &#125; finally &#123;            System.out.println(&quot;finally执行了&quot;);        &#125;        return &quot;最终return返回&quot;;    &#125;&#125;</code></pre><p>2.在try/catch内添加return<br>try/catch内的return执行完后会继续执行finally, 但是从打印结果来开, finally的语句先打印, 原因是因为 return的</p><pre><code class="java">public class MainTest &#123;    public static void main(String[] args) &#123;        System.out.println(finallyTest());    &#125;    private static String finallyTest() &#123;        try &#123;            System.out.println(&quot;处理逻辑&quot;);            // int i = 1 / 0;            return &quot;try - return返回&quot;;        &#125; catch (Exception e) &#123;            System.out.println(&quot;异常逻辑&quot;);            // return &quot;catch - return返回&quot;;        &#125; finally &#123;            System.out.println(&quot;finally执行了&quot;);        &#125;        return &quot;最终return返回&quot;;    &#125;&#125;</code></pre><p>输出结果</p><pre><code class="bash">处理逻辑finally执行了try - return返回</code></pre><p>3.finally里面添加return语句<br>finally里面return执行完后会直接返回, 不会再执行try块中的return语句</p><pre><code class="java">public class MainTest &#123;    public static void main(String[] args) &#123;        System.out.println(finallyTest());    &#125;    private static String finallyTest() &#123;        try &#123;            System.out.println(&quot;处理逻辑&quot;);            // int i = 1 / 0;            return &quot;try - return返回&quot;;        &#125; catch (Exception e) &#123;            System.out.println(&quot;异常逻辑&quot;);            // return &quot;catch - return返回&quot;;        &#125; finally &#123;            System.out.println(&quot;finally执行了&quot;);            return &quot;finally - return返回&quot;;        &#125;        // return &quot;最终return返回&quot;;    &#125;&#125;</code></pre><p>执行结果</p><pre><code class="bash">处理逻辑finally执行了finally - return返回</code></pre><p>4.finally内添加逻辑改变变量值<br>1).try中的return值只是暂时放在栈中, 所以最终返回的还是 10, finally中并没有改变其值<br>2).try中的return值如果是对象, 栈中存放的是对象的引用, 对象属性值还是可以通过finally修改</p><pre><code class="java">public class MainTest &#123;    public static void main(String[] args) &#123;        System.out.println(finallyTest());    &#125;    private static String finallyTest() &#123;        int temp = 10;        try &#123;            System.out.println(&quot;处理逻辑&quot;);            return &quot;try - return返回: &quot; + temp;        &#125; catch (Exception e) &#123;            System.out.println(&quot;异常逻辑&quot;);            // return &quot;catch - return返回&quot;;        &#125; finally &#123;            temp = 100;            System.out.println(&quot;finally执行了&quot;);        &#125;        return &quot;最终return返回: &quot; + temp;    &#125;&#125;</code></pre><p>输出结果</p><pre><code class="bash">处理逻辑finally执行了try - return返回: 10</code></pre><pre><code class="java">public class MainTest &#123;    public static void main(String[] args) &#123;        Temp temp = new Temp();        temp.temp = 1;        System.out.println(finallyTest(temp).toString());    &#125;    private static Temp finallyTest(Temp temp) &#123;        try &#123;            System.out.println(&quot;处理逻辑&quot;);            return temp;        &#125; catch (Exception e) &#123;            System.out.println(&quot;异常逻辑&quot;);            // return &quot;catch - return返回&quot;;        &#125; finally &#123;            temp.temp = 100;            System.out.println(&quot;finally执行了&quot;);        &#125;        return temp;    &#125;&#125;class Temp &#123;    int temp;    @Override    public String toString() &#123;        return &quot;Temp&#123;&quot; +                &quot;temp=&quot; + temp +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><p>打印结果</p><pre><code class="bash">处理逻辑finally执行了Temp&#123;temp=100&#125;</code></pre><h3 id="finalize方法"><a href="#finalize方法" class="headerlink" title="finalize方法"></a>finalize方法</h3><p>Object类的方法, 子类可重写, 主要是垃圾回收时使用.</p>]]></content>
      
      
      <categories>
          
          <category> 源码学习 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池原理及源码解析</title>
      <link href="2018/09/05/thread-pool-principle-and-source-code-analysis.html"/>
      <url>2018/09/05/thread-pool-principle-and-source-code-analysis.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="线程池处理流程"><a href="#线程池处理流程" class="headerlink" title="线程池处理流程"></a>线程池处理流程</h3><p><img src="/resources/concurrent/thread-pool.png" alt="线程池处理流程"></p><ol><li>判断核心线程池是否已满, 不满则创建新线程执行任务</li><li>等待队列如果有界, 判断等待队列是否已满, 不满, 则添加任务到等待队列</li><li>判断最大线程数是否已满, 不满则创建新线程执行任务</li><li>最大线程数已满, 按照既定策略处理新任务<a id="more"></a><h3 id="全参构造及各参数含义"><a href="#全参构造及各参数含义" class="headerlink" title="全参构造及各参数含义"></a>全参构造及各参数含义</h3><pre><code class="java">public class ThreadPoolExecutor extends AbstractExecutorService &#123; public ThreadPoolExecutor(int corePoolSize, // 核心线程数                           int maximumPoolSize, // 最大线程数                           long keepAliveTime, // 核心线程外线程的存活时间                           TimeUnit unit, // 存活时间的单位                           BlockingQueue&lt;Runnable&gt; workQueue, // 保存等待执行的线程的阻塞队列                           ThreadFactory threadFactory, // 线程工厂                           RejectedExecutionHandler handler) &#123; // 线程拒绝策略     if (corePoolSize &lt; 0 ||         maximumPoolSize &lt;= 0 ||         maximumPoolSize &lt; corePoolSize ||         keepAliveTime &lt; 0)         throw new IllegalArgumentException();     if (workQueue == null || threadFactory == null || handler == null)         throw new NullPointerException();     this.acc = System.getSecurityManager() == null ?             null :             AccessController.getContext();     this.corePoolSize = corePoolSize;     this.maximumPoolSize = maximumPoolSize;     this.workQueue = workQueue;     this.keepAliveTime = unit.toNanos(keepAliveTime);     this.threadFactory = threadFactory;     this.handler = handler; &#125; // 省略 . . .&#125;</code></pre></li><li>workQueue阻塞队列<br>ArrayBlockingQueue: 是一个基于数组结构的有界阻塞队列, 此队列按 FIFO(先进先出) 原则对元素进行排序.<br>LinkedBlockingQueue: 一个基于链表结构的阻塞队列,此队列按 FIFO(先进先出) 排序元素, 吞吐量通常要高于ArrayBlockingQueue. 静态工厂方法Executors.newFixedThreadPool()使用了这个队列<br>SynchronousQueue: 一个不存储元素的阻塞队列. 每个插入操作必须等到另一个线程调用移除操作, 否则插入操作一直处于阻塞状态, 吞吐量通常要高于LinkedBlockingQueue, 静态工厂方法Executors.newCachedThreadPool使用了这个队列.<br>PriorityBlockingQueue: 一个具有优先级的无限阻塞队列.</li></ol><p>2.threadFactory线程工厂<br>可以使用默认的工厂也可以自定义工厂, 或者使用 google guava 提供的工厂, 可以为线程命名和设置是否为守护线程</p><pre><code class="bash">// 默认工厂ThreadFactory threadFactory = Executors.defaultThreadFactory();// google guava工具提供ThreadFactory namedThreadFactory = new ThreadFactoryBuilder().setNameFormat(&quot;demo-pool-%d&quot;).build();</code></pre><p>3.handler线程拒绝策略<br>当线程池达到最大线程数, 并且队列满了, 新的线程要采取的处理策略.<br>1.AbortPolicy 拒绝新任务并抛出RejectedExecutionException异常<br>2.CallerRunsPolicy 直接在调用程序的线程中运行<br>3.DiscardOldestPolicy 放弃最早的任务, 即队列最前面的任务<br>4.DiscardPolicy 丢弃, 不处理</p><h3 id="Executors初始化线程池的四种方式"><a href="#Executors初始化线程池的四种方式" class="headerlink" title="Executors初始化线程池的四种方式"></a>Executors初始化线程池的四种方式</h3><p>这四种初始化线程池的方式, 前三种都是调用 ThreadPoolExecutor 类的构造创建的线程池, 只不过使用的阻塞队列方式不同.</p><ol><li>newFixedThreadPool()</li></ol><pre><code class="java">public class Executors &#123;    /**     * 固定线程池     * 核心线程数 = 最大线程数     * 超时时间为0     * LinkedBlockingQueue无界队列, 会持续等待     * 使用默认拒绝策略 AbortPolicy     */    public static ExecutorService newFixedThreadPool(int nThreads) &#123;        return new ThreadPoolExecutor(nThreads, nThreads,                                      0L, TimeUnit.MILLISECONDS,                                      new LinkedBlockingQueue&lt;Runnable&gt;());    &#125;&#125;</code></pre><ol start="2"><li>newCachedThreadPool()</li></ol><pre><code class="java">public class Executors &#123;    /**     * 无界线程池     * 核心线程数0 最大线程数 (2³¹ -1)     * 超时时间 60秒     * SynchronousQueue不存储元素的阻塞队列     * 线程空闲时间超过60秒, 会自动释放资源, 提交任务如果没有空闲线程, 则会创建新线程     */    public static ExecutorService newCachedThreadPool() &#123;           return new ThreadPoolExecutor(0, Integer.MAX_VALUE,                                         60L, TimeUnit.SECONDS,                                         new SynchronousQueue&lt;Runnable&gt;());    &#125;&#125;</code></pre><p>3.newSingleThreadExecutor()</p><pre><code class="java">public class Executors &#123;    /**     * 创建只有 1个线程的线程池     * 如果线程异常, 则创建一个新的线程继续执行任务     *     */    public static ExecutorService newSingleThreadExecutor() &#123;        return new FinalizableDelegatedExecutorService            (new ThreadPoolExecutor(1, 1,                                    0L, TimeUnit.MILLISECONDS,                                    new LinkedBlockingQueue&lt;Runnable&gt;()));    &#125;&#125;</code></pre><p>4.newSingleThreadExecutor()</p><pre><code class="java">public class Executors &#123;    /**     * ScheduledThreadPoolExecutor 继承 ThreadPoolExecutor 类     * 可以在指定时间周期内执行任务     *     */    public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123;          return new ScheduledThreadPoolExecutor(corePoolSize);    &#125;&#125;</code></pre><h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><pre><code class="java">public class ThreadPoolExecutor extends AbstractExecutorService &#123;    /**    * ctx 为原子类型的变量, 有两个概念    * workerCount, 表示有效的线程数    * runState, 表示线程状态, 是否正在运行, 关闭等    */    private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));    // 29    private static final int COUNT_BITS = Integer.SIZE - 3;    // 容量 2²⁹-1    private static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1;    // runState is stored in the high-order bits 线程池的五中状态    // 即高3位为111, 接受新任务并处理排队任务    private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;    // 即高3位为000, 不接受新任务, 但处理排队任务    private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;    // 即高3位为001, 不接受新任务, 不处理排队任务, 并中断正在进行的任务    private static final int STOP       =  1 &lt;&lt; COUNT_BITS;    // 即高3位为010, 所有任务都已终止, 工作线程为0, 线程转换到状态TIDYING, 将运行terminate()钩子方法    private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;    // 即高3位为011, 标识terminate（）已经完成    private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;    // Packing and unpacking ctl 用来计算线程的方法    private static int runStateOf(int c)     &#123; return c &amp; ~CAPACITY; &#125;    private static int workerCountOf(int c)  &#123; return c &amp; CAPACITY; &#125;    private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125;&#125;</code></pre><h4 id="execute方法"><a href="#execute方法" class="headerlink" title="execute方法"></a>execute方法</h4><pre><code class="java">public class ThreadPoolExecutor extends AbstractExecutorService &#123;    public void execute(Runnable command) &#123;        // 空则抛出异常        if (command == null)            throw new NullPointerException();        // 获取当前线程池的状态        int c = ctl.get();        // 计算工作线程数 并判断是否小于核心线程数        if (workerCountOf(c) &lt; corePoolSize) &#123;            // addWorker提交任务, 提交成功则结束            if (addWorker(command, true))                return;            // 提交失败再次获取当前状态            c = ctl.get();        &#125;        // 判断线程状态, 并插入队列, 失败则移除        if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;            // 再次获取状态            int recheck = ctl.get();            // 如果状态不是RUNNING, 并移除失败            if (! isRunning(recheck) &amp;&amp; remove(command))                // 调用拒绝策略                reject(command);            // 如果工作线程为0 则调用 addWorker            else if (workerCountOf(recheck) == 0)                addWorker(null, false);        &#125;        // 提交任务失败 走拒绝策略        else if (!addWorker(command, false))            reject(command);    &#125;&#125;</code></pre><h4 id="addWorker方法"><a href="#addWorker方法" class="headerlink" title="addWorker方法"></a>addWorker方法</h4><pre><code class="java">public class ThreadPoolExecutor extends AbstractExecutorService &#123;    /**     * 检查任务是否可以提交     *     */    private boolean addWorker(Runnable firstTask, boolean core) &#123;        retry:        // 外层循环        for (;;) &#123;            // 获取当前状态            int c = ctl.get();            int rs = runStateOf(c);            // Check if queue empty only if necessary. 检查线程池是否关闭            if (rs &gt;= SHUTDOWN &amp;&amp;                ! (rs == SHUTDOWN &amp;&amp;                   firstTask == null &amp;&amp;                   ! workQueue.isEmpty()))                return false;            // 内层循环            for (;;) &#123;                int wc = workerCountOf(c);                // 工作线程大于容量 或者大于 核心或最大线程数                if (wc &gt;= CAPACITY ||                    wc &gt;= (core ? corePoolSize : maximumPoolSize))                    return false;                // CAS 线程数增加, 成功则调到外层循环                if (compareAndIncrementWorkerCount(c))                    break retry;                // 失败则再次获取线程状态                c = ctl.get();  // Re-read ctl                // 不相等则重新走外层循环                if (runStateOf(c) != rs)                    continue retry;                // else CAS failed due to workerCount change; retry inner loop            &#125;        &#125;        /**         * 创建新worker 开始新线程         */        boolean workerStarted = false;        boolean workerAdded = false;        Worker w = null;        try &#123;            w = new Worker(firstTask);            final Thread t = w.thread;            if (t != null) &#123;                final ReentrantLock mainLock = this.mainLock;                // 加锁                mainLock.lock();                try &#123;                    // Recheck while holding lock.                    // Back out on ThreadFactory failure or if                    // shut down before lock acquired.                    int rs = runStateOf(ctl.get());                    if (rs &lt; SHUTDOWN ||                        (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123;                        // 判断线程是否存活, 已存活抛出非法异常                        if (t.isAlive()) // precheck that t is startable                            throw new IllegalThreadStateException();                        //  设置包含池中的所有工作线程。仅在持有mainLock时访问 workers是 HashSet 集合                        //  private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;();                        workers.add(w);                        int s = workers.size();                        // 设置池最大大小, 并将 workerAdded设置为 true                        if (s &gt; largestPoolSize)                            largestPoolSize = s;                        workerAdded = true;                    &#125;                &#125; finally &#123;                    // 解锁                    mainLock.unlock();                &#125;                // 添加成功 开始启动线程 并将 workerStarted 设置为 true                if (workerAdded) &#123;                    t.start();                    workerStarted = true;                &#125;            &#125;        &#125; finally &#123;            // 启动线程失败            if (! workerStarted)                addWorkerFailed(w);        &#125;        return workerStarted;    &#125;    /**     * 启动线程失败, 加锁     * 移除线程, 并减少线程总数     * 转换状态     */    private void addWorkerFailed(Worker w) &#123;        final ReentrantLock mainLock = this.mainLock;        mainLock.lock();        try &#123;            if (w != null)                workers.remove(w);            decrementWorkerCount();            tryTerminate();        &#125; finally &#123;            mainLock.unlock();        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 并发和锁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程相关</title>
      <link href="2018/09/04/multithreaded-correlation.html"/>
      <url>2018/09/04/multithreaded-correlation.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>多个线程同时或交替运行, 单核CPU为顺序执行(交替执行), 多核情况下, 每个CPU有自己的运算器, 所以在多个CPU中可以同时运行.</p><a id="more"></a><h3 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h3><p>1.继承Thread</p><pre><code class="java">public class MyThread extends Thread &#123;    @Override    public void run() &#123;        super.run();        System.out.println(Thread.currentThread().getName() + &quot;执行完毕&quot;);    &#125;&#125;</code></pre><pre><code class="java">public class ThreadTest &#123;    public static void main(String[] args) &#123;        MyThread myThread = new MyThread();        myThread.setName(&quot;测试&quot;);        myThread.start();        System.out.println(Thread.currentThread().getName() + &quot;执行完毕&quot;);    &#125;&#125;</code></pre><p>开始线程, 可以看出main线程和测试线程是两个独立的线程<br>调用myThread.run();方法相当于直接在主线程运行run方法, 而不是开启一个新的线程去执行</p><p>2.实现Runnable接口</p><pre><code class="java">public class MyRunable implements Runnable &#123;    @Override    public void run() &#123;        System.out.println(Thread.currentThread().getName() + &quot;执行完毕&quot;);    &#125;&#125;</code></pre><pre><code class="java">public class ThreadTest &#123;    public static void main(String[] args) &#123;        MyRunable runable = new MyRunable();        Thread thread = new Thread(runable);        thread.start();        System.out.println(Thread.currentThread().getName() + &quot;执行完毕&quot;);    &#125;&#125;</code></pre><p>3.使用线程池<br>3.1 可以在spring中配置相关线程池, 使用时从容器取出即可, 也可以自己声明线程池</p><pre><code class="xml">&lt;bean id=&quot;threadPool&quot; class=&quot;org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor&quot;&gt;    &lt;!-- 核心线程数，默认为1 --&gt;    &lt;property name=&quot;corePoolSize&quot; value=&quot;5&quot;/&gt;    &lt;!-- 最大线程数，默认为Integer.MAX_VALUE --&gt;    &lt;property name=&quot;maxPoolSize&quot; value=&quot;20&quot;/&gt;    &lt;!-- 队列最大长度，一般需要设置值&gt;=notifyScheduledMainExecutor.maxNum；默认为Integer.MAX_VALUE    &lt;property name=&quot;queueCapacity&quot; value=&quot;1000&quot; /&gt; --&gt;    &lt;!-- 线程池维护线程所允许的空闲时间，默认为60s --&gt;    &lt;property name=&quot;keepAliveSeconds&quot; value=&quot;300&quot;/&gt;    &lt;!-- 队列最大长度 --&gt;    &lt;property name=&quot;queueCapacity&quot; value=&quot;2000&quot;/&gt;    &lt;!-- 线程池对拒绝任务（无线程可用）的处理策略，目前只支持AbortPolicy、CallerRunsPolicy；默认为后者 --&gt;    &lt;property name=&quot;rejectedExecutionHandler&quot;&gt;        &lt;!-- AbortPolicy:直接抛出java.utils.concurrent.RejectedExecutionException异常 --&gt;        &lt;!-- CallerRunsPolicy:主线程直接执行该任务，执行完之后尝试添加下一个任务到线程池中，可以有效降低向线程池内添加任务的速度 --&gt;        &lt;!-- DiscardOldestPolicy:抛弃旧的任务、暂不支持；会导致被丢弃的任务无法再次被执行 --&gt;        &lt;!-- DiscardPolicy:抛弃当前任务、暂不支持；会导致被丢弃的任务无法再次被执行 --&gt;        &lt;bean class=&quot;java.util.concurrent.ThreadPoolExecutor$CallerRunsPolicy&quot;/&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><p>3.2 Executors 创建线程池</p><pre><code class="java">public class ThreadTest &#123;    public static void main(String[] args) &#123;        ExecutorService threadPool = Executors.newCachedThreadPool();        for (int i = 0; i &lt; 10; i++) &#123;            threadPool.execute(new MyRunable());        &#125;    &#125;&#125;</code></pre><p>当手动创建线程池时, 如果IDEA安装阿里 P3C 插件后会报错提示以下内容, 建议</p><pre><code class="bash">线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。说明： Executors 返回的线程池对象的弊端如下：1） FixedThreadPool 和 SingleThreadPool:允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。2） CachedThreadPool 和 ScheduledThreadPool:允许的创建线程数量为 Integer.MAX_VALUE， 可能会创建大量的线程，从而导致 OOM。</code></pre><p>建议使用如下方式:</p><pre><code class="java">public class ThreadTest &#123;    public static void main(String[] args) &#123;        // 定时任务 建议为线程起名        ScheduledExecutorService executorService = new ScheduledThreadPoolExecutor(3,                new BasicThreadFactory.Builder().namingPattern(&quot;example-schedule-pool-%d&quot;).build());            executorService.scheduleAtFixedRate(new MyRunable(), 0, 1, TimeUnit.SECONDS);    &#125;&#125;</code></pre><pre><code class="java">public class ThreadTest &#123;    public static void main(String[] args) &#123;        // 线程工厂        ThreadFactory namedThreadFactory = new ThreadFactoryBuilder()                .setNameFormat(&quot;demo-pool-%d&quot;).build();        //Common Thread Pool        ExecutorService pool = new ThreadPoolExecutor(5, 20, 0L, TimeUnit.MILLISECONDS,                new LinkedBlockingQueue&lt;&gt;(1024), namedThreadFactory, new ThreadPoolExecutor.AbortPolicy());        pool.execute(()-&gt; System.out.println(Thread.currentThread().getName()));        pool.shutdown();//gracefully shutdown    &#125;&#125;</code></pre><h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><p>1.myThread.setPriority(1);设置优先级<br>2.优先级从低到高为 1-10, Thread类提供 Thread.MIN_PRIORITY=1, Thread.NORM_PRIORITY=5, Thread.MAX_PRIORITY=10<br>3.默认优先级为 5 即 NORM_PRIORITY<br>4.优先级高的仅代表获取进入运行机会的几率大, 并不代表一定会比优先级低的先执行</p><h3 id="sleep-和wait"><a href="#sleep-和wait" class="headerlink" title="sleep()和wait()"></a>sleep()和wait()</h3><p>1.sleep()线程未释放锁, 时间结束后线程继续执行<br>2.wait线程释放锁, 需要使用notify或notifyAll<br>3.wait常用于线程之间的交互</p><pre><code class="java">package com.liuzhihang.tool.alternate;/** * 交替打印奇偶数 * * @author liuzhihang * @date 2018/9/4 18:39 */public class AlternateNum &#123;    public static void main(String[] args) &#123;        Num num = new Num();        Thread thread1 = new Thread(new Odd(num));        Thread thread2 = new Thread(new Even(num));        thread1.start();        thread2.start();    &#125;&#125;class Num &#123;    int anInt = 1;    boolean flag = true;&#125;class Odd implements Runnable &#123;    private Num num;    public Odd(Num num) &#123;        this.num = num;    &#125;    @Override    public void run() &#123;        while (num.anInt &lt; 1000) &#123;            // 使用同一把锁            synchronized (num) &#123;                if (num.flag) &#123;                    System.out.println(&quot;奇数 -&gt; &quot; + num.anInt);                    num.anInt++;                    num.flag = false;                    num.notify();                &#125; else &#123;                    try &#123;                        num.wait();                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;class Even implements Runnable &#123;    private Num num;    public Even(Num num) &#123;        this.num = num;    &#125;    @Override    public void run() &#123;        while (num.anInt &lt; 1000) &#123;            // 使用同一把锁            synchronized (num) &#123;                if (!num.flag) &#123;                    System.out.println(&quot;偶数 -&gt; &quot; + num.anInt);                    num.anInt++;                    num.flag = true;                    num.notify();                &#125; else &#123;                    try &#123;                        num.wait();                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 并发和锁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射和序列化破解单例</title>
      <link href="2018/08/27/reflection-and-serialization-cracking-singleton.html"/>
      <url>2018/08/27/reflection-and-serialization-cracking-singleton.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>主要介绍通过反射的方式获取单例对象, 验证<a href="https://liuzhihangs.github.io/2018/02/21/lazy-singleton-mode-thread-safe.html">单例模式</a>的安全性.<br>主要从以下几个角度来介绍反射下的单例<br>饿汉式<br>双重锁检查<br><a href="https://liuzhihangs.github.io/2018/08/17/use-enumeration-to-implement-a-singleton.html">枚举单例</a></p><a id="more"></a><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p><a href="https://github.com/liuzhihang/demo_design_pattern/blob/master/src/main/java/com/liuzhihang/demo/singleton/HungerPattern.java">饿汉式</a>直接使用反射即可破解单例模式</p><pre><code class="java">public class ReflectTest &#123;    public static void main(String[] args) &#123;        try &#123;            HungerPattern hungerPattern = HungerPattern.getHungerPattern();            Class&lt;HungerPattern&gt; hungerPatternClass = HungerPattern.class;            Constructor&lt;HungerPattern&gt; conA = hungerPatternClass.getDeclaredConstructor();            Constructor&lt;HungerPattern&gt; conB = hungerPatternClass.getDeclaredConstructor();            conA.setAccessible(true);            conB.setAccessible(true);            HungerPattern instanceA = conA.newInstance();            HungerPattern instanceB = conB.newInstance();            // instanceA 和 instanceB 不是同一对象            System.out.println(hungerPattern.hashCode());            System.out.println(instanceA.hashCode());            System.out.println(instanceB.hashCode());        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p>输出结果</p><pre><code class="bash">D:\jdk1.8\bin\java.exe . . .713338599168423058821270929Process finished with exit code 0</code></pre><h3 id="双重锁检查"><a href="#双重锁检查" class="headerlink" title="双重锁检查"></a>双重锁检查</h3><p><a href="https://github.com/liuzhihang/demo_design_pattern/blob/master/src/main/java/com/liuzhihang/demo/singleton/DoubleCheckLockLazyPattern.java">双重锁检查</a>同样存在相同的情况</p><ol><li>直接使用<pre><code class="java">public class ReflectTest &#123;</code></pre></li></ol><pre><code>public static void main(String[] args) &#123;    try &#123;        DoubleCheckLockLazyPattern pattern = DoubleCheckLockLazyPattern.getDoubleCheckLockLazyPattern();        Class&lt;DoubleCheckLockLazyPattern&gt; patternClass = DoubleCheckLockLazyPattern.class;        Constructor&lt;DoubleCheckLockLazyPattern&gt; conA = patternClass.getDeclaredConstructor();        Constructor&lt;DoubleCheckLockLazyPattern&gt; conB = patternClass.getDeclaredConstructor();        conA.setAccessible(true);        conB.setAccessible(true);        DoubleCheckLockLazyPattern patternA = conA.newInstance();        DoubleCheckLockLazyPattern patternB = conA.newInstance();        System.out.println(pattern.hashCode());        System.out.println(patternA.hashCode());        System.out.println(patternB.hashCode());    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;&#125;</code></pre><p>}</p><pre><code>输出结果```bashD:\jdk1.8\bin\java.exe . . .713338599168423058821270929Process finished with exit code 0</code></pre><ol start="2"><li>在双重锁检查私有构造内加入异常</li></ol><pre><code class="bash">public class DoubleCheckLockLazyPattern &#123;    private DoubleCheckLockLazyPattern() &#123;        // 加入异常判断, 防止反射        if (doubleCheckLockLazyPattern != null) &#123;            throw new RuntimeException();        &#125;    &#125;    private static volatile DoubleCheckLockLazyPattern doubleCheckLockLazyPattern = null;    public static DoubleCheckLockLazyPattern getDoubleCheckLockLazyPattern() &#123;        try &#123;            if (doubleCheckLockLazyPattern == null) &#123;                // 一系列操作                Thread.sleep(100);                synchronized (DoubleCheckLockLazyPattern.class) &#123;                    // 二次检查                    if (doubleCheckLockLazyPattern == null) &#123;                        doubleCheckLockLazyPattern = new DoubleCheckLockLazyPattern();                    &#125;                &#125;            &#125;        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        return doubleCheckLockLazyPattern;    &#125;&#125;</code></pre><p>输出结果</p><pre><code class="bash">D:\jdk1.8\bin\java.exe . . .java.lang.reflect.InvocationTargetException    at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)    at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)    at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)    at java.lang.reflect.Constructor.newInstance(Constructor.java:423)    at com.liuzhihang.demo.singleton.ReflectTest.main(ReflectTest.java:24)Caused by: java.lang.RuntimeException    at com.liuzhihang.demo.singleton.DoubleCheckLockLazyPattern.&lt;init&gt;(DoubleCheckLockLazyPattern.java:15)    ... 5 more</code></pre><ol start="3"><li>通过序列化反序列化获取对象</li></ol><p>DoubleCheckLockLazyPattern 实现序列化</p><pre><code class="bash">public class ReflectTest &#123;    public static void main(String[] args) &#123;        try &#123;            DoubleCheckLockLazyPattern pattern = DoubleCheckLockLazyPattern.getDoubleCheckLockLazyPattern();            FileOutputStream fos= new FileOutputStream(&quot;C:/Users/liuzhihang/desktop/pattern.txt&quot;);            ObjectOutputStream oos = new ObjectOutputStream(fos);            oos.writeObject(pattern);            oos.close();            fos.close();            ObjectInputStream oisA = new ObjectInputStream(new FileInputStream(&quot;C:/Users/liuzhihang/desktop/pattern.txt&quot;));            DoubleCheckLockLazyPattern patternA= (DoubleCheckLockLazyPattern) oisA.readObject();            ObjectInputStream oisB = new ObjectInputStream(new FileInputStream(&quot;C:/Users/liuzhihang/desktop/pattern.txt&quot;));            DoubleCheckLockLazyPattern patternB= (DoubleCheckLockLazyPattern) oisB.readObject();            System.out.println(pattern.hashCode());            System.out.println(patternA.hashCode());            System.out.println(patternB.hashCode());        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p>输出结果</p><pre><code class="bash">D:\jdk1.8\bin\java.exe . . .25895249917022972011996181658Process finished with exit code 0</code></pre><ol start="4"><li>修改反序列化方法, 可以防止反序列化</li></ol><p>添加以下方法</p><pre><code class="bash">private Object readResolve() &#123;    return doubleCheckLockLazyPattern;&#125;</code></pre><p>输出结果</p><pre><code class="bash">D:\jdk1.8\bin\java.exe . . .258952499258952499258952499Process finished with exit code 0</code></pre><h3 id="枚举单例"><a href="#枚举单例" class="headerlink" title="枚举单例"></a>枚举单例</h3><pre><code class="java">public enum SingletonEnum &#123;    /**     * 单例     */    INSTANCE;    private Resource resource;    SingletonEnum() &#123;        this.resource = new Resource();    &#125;    public Resource getResource() &#123;        return resource;    &#125;&#125;class Resource &#123;&#125;</code></pre><h4 id="枚举单例分析"><a href="#枚举单例分析" class="headerlink" title="枚举单例分析"></a>枚举单例分析</h4><p>在枚举反射获取对象时抛出异常, 通过 Constructor类 源码可以看出, 在反射创建对象时会判断是否是枚举修饰, 是则抛出异常</p><pre><code class="bash">  @CallerSensitive    public T newInstance(Object ... initargs)        throws InstantiationException, IllegalAccessException,               IllegalArgumentException, InvocationTargetException    &#123;        if (!override) &#123;            if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;                Class&lt;?&gt; caller = Reflection.getCallerClass();                checkAccess(caller, clazz, null, modifiers);            &#125;        &#125;        if ((clazz.getModifiers() &amp; Modifier.ENUM) != 0)            throw new IllegalArgumentException(&quot;Cannot reflectively create enum objects&quot;);        ConstructorAccessor ca = constructorAccessor;   // read volatile        if (ca == null) &#123;            ca = acquireConstructorAccessor();        &#125;        @SuppressWarnings(&quot;unchecked&quot;)        T inst = (T) ca.newInstance(initargs);        return inst;    &#125;</code></pre><p>同时在父类 Enum类 中重写了 readObject方法, 所以枚举也可以避免反序列化</p><pre><code class="bash">    /**     * prevent default deserialization     */    private void readObject(ObjectInputStream in) throws IOException,        ClassNotFoundException &#123;        throw new InvalidObjectException(&quot;can&#39;t deserialize enum&quot;);    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 源码学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码学习 </tag>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射</title>
      <link href="2018/08/24/reflection.html"/>
      <url>2018/08/24/reflection.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>java反射可以在运行时获取对象的成员和属性, 并且可以动态的创建对象并调用对象的属性.<br>反射一般编程中很少使用,但是在很多框架中都使用了反射, 比如配置Spring的Xml配置文件中, 就使用全类名配置方式, 其实就是反射的一种使用方式.</p><p>同时反射对单例模式有一定的影响, 可以参考<a href="https://liuzhihang.com/2018/08/27/reflection-and-serialization-cracking-singleton.html">反射获取单例对象</a></p><a id="more"></a><h3 id="获取反射对象"><a href="#获取反射对象" class="headerlink" title="获取反射对象"></a>获取反射对象</h3><p>获取反射Class对象一共三种方式</p><pre><code class="bash">// 1. 使用实例获取User user = new User();Class&lt;? extends User&gt; aClass = user.getClass();// 2. 使用类获取Class&lt;User&gt; userClass = User.class;// 3. 全类名获取, 可能会抛出 ClassNotFoundException 异常Class&lt;?&gt; aClass1 = Class.forName(&quot;com.liuzhihang.tool.reflect.User&quot;);</code></pre><h3 id="获取属性"><a href="#获取属性" class="headerlink" title="获取属性"></a>获取属性</h3><ol><li>获取字段<pre><code class="bash">// 获取所有公有字段 (public)Field[] fields = aClass.getFields();// 获取所有字段 (public 缺省, protected, private)Field[] fields = aClass.getDeclaredFields()// 获取指定公共字段Field age = aClass.getField(&quot;age&quot;);// 获取指定字段 (public 缺省, protected, private)Field userName = aClass.getDeclaredField(&quot;userName&quot;);</code></pre></li></ol><h3 id="获取构造"><a href="#获取构造" class="headerlink" title="获取构造"></a>获取构造</h3><ol><li>获取构造<pre><code class="bash">// 获取所有构造 不能获取私有Constructor&lt;?&gt;[] constructors = aClass.getConstructors();</code></pre></li></ol><p>// 获取指定参数类型的构造 不能获取私有 空则获取空参构造 getConstructor(Class&lt;?&gt;… parameterTypes)<br>Constructor<User> constructor = aClass.getConstructor(String.class);</p><p>// 获取所有构造 包含私有<br>Constructor&lt;?&gt;[] declaredConstructors = aClass.getDeclaredConstructors();</p><p>// 获取指定参数类型的构造 可以获取私有 空则获取空参构造 getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)<br>Constructor<User> declaredConstructor = aClass.getDeclaredConstructor(String.class);</p><pre><code>2. 使用构造创建对象可以通过 constructor.setAccessible(true); 暴力破解忽略访问修饰符, 来使用私有构造参数```bashConstructor&lt;User&gt; constructor = aClass.getDeclaredConstructor(String.class);// 暴力破解constructor.setAccessible(true);User test = constructor.newInstance(&quot;test&quot;);</code></pre><h3 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h3><ol><li>获取方法<pre><code class="bash">// 获取所有公共方法(包含父类)Method[] methods = aClass.getMethods();// 获取所有方法Method[] methods = aClass.getDeclaredMethods();// 获取私有方法 第一个参数填方法名称Method address = aClass.getDeclaredMethod(&quot;setAddress&quot;, String.class);// 获取公共方法Method address = aClass.getMethod(&quot;setAddress&quot;, String.class);</code></pre></li></ol><pre><code>2. 使用方法```bashClass&lt;?&gt; aClass = Class.forName(&quot;com.liuzhihang.tool.reflect.User&quot;)Method address = aClass.getDeclaredMethod(&quot;setAddress&quot;, String.class);User user = aClass.getConstructor().newInstance();System.out.println(user.toString());// 解除私有限制address.setAccessible(true);// 使用invoke来调用方法address.invoke(user, &quot;北京&quot;);System.out.println(user.toString());</code></pre><h3 id="获取其他属性"><a href="#获取其他属性" class="headerlink" title="获取其他属性"></a>获取其他属性</h3><p>还可以获取类实现的接口, 父类, 注解, 以及判断类的类型等多种使用方式.</p>]]></content>
      
      
      <categories>
          
          <category> utils </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LinkList相关学习</title>
      <link href="2018/08/23/linklist-related-learning.html"/>
      <url>2018/08/23/linklist-related-learning.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote><p>LinkList也是工作中常见的集合, 底层使用双向链表结构<br>比较适合新增和删除, 查询和修改需要遍历相对<a href="https://liuzhihang.com/2018/08/23/arraylist-related-learning.html">ArrayList</a>比较消耗性能</p></blockquote><a id="more"></a><h3 id="内部类-Node"><a href="#内部类-Node" class="headerlink" title="内部类 Node"></a>内部类 Node</h3><pre><code class="java">private static class Node&lt;E&gt; &#123;    // 元素值    E item;    // 下一个节点    Node&lt;E&gt; next;    // 上一个几点    Node&lt;E&gt; prev;    // 构造一个新节点 指向上一个节点和下一个节点    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;        this.item = element;        this.next = next;        this.prev = prev;    &#125;&#125;</code></pre><h3 id="add-新增"><a href="#add-新增" class="headerlink" title="add 新增"></a>add 新增</h3><p>通过代码可以看出, 在新增元素时只需要创建一个新节点 Node, 并将原始链表最后一个Node的next指向新Node</p><pre><code class="bash">public boolean add(E e) &#123;    linkLast(e);    return true;&#125;/** * Links e as last element. */void linkLast(E e) &#123;    // 声明 l 为最后一个节点    final Node&lt;E&gt; l = last;    // 创建新节点, 指向上一个节点, 下一个节点为空    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);    // 最后一个节点为新创建的节点    last = newNode;    // 判断是否为第一个元素, 否则将 新创建的 Node加入链表    if (l == null)        first = newNode;    else        l.next = newNode;    size++;    modCount++;&#125;</code></pre><h3 id="remove-删除"><a href="#remove-删除" class="headerlink" title="remove 删除"></a>remove 删除</h3><p>1.删除操作需要遍历链表找到相应元素, 然后移动指针即可<br>2.删除首尾元素直接移动指针即可 removeFirst()/removeLast() 方法</p><pre><code class="bash">public boolean remove(Object o) &#123;    if (o == null) &#123;        // 遍历链表        for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123;            if (x.item == null) &#123;                unlink(x);                return true;            &#125;        &#125;    &#125; else &#123;        for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123;            if (o.equals(x.item)) &#123;                unlink(x);                return true;            &#125;        &#125;    &#125;    return false;&#125;/** * 删除元素 */E unlink(Node&lt;E&gt; x) &#123;    // assert x != null;    final E element = x.item;    final Node&lt;E&gt; next = x.next;    final Node&lt;E&gt; prev = x.prev;    // 判断上一个Node是否为空    if (prev == null) &#123;        // 空, 该节点为链表头, 将下一个节点设置为链表头        first = next;    &#125; else &#123;        // 不为空, 将上一个节点的next 指向当前节点的 next, 并将当前节点的 prev置为空        prev.next = next;        x.prev = null;    &#125;    // 判断下一个Node是否为空    if (next == null) &#123;        // 空, 该节点为链表尾, 将链表尾设置为当前节点的上一个节点        last = prev;    &#125; else &#123;        // 不为空, 将下一个节点的prev, 设置为上一个节点, 并将当前节点的 next置为空        next.prev = prev;        x.next = null;    &#125;    x.item = null;    size--;    modCount++;    return element;&#125;</code></pre><h3 id="get-set"><a href="#get-set" class="headerlink" title="get/set"></a>get/set</h3><p>get/set时都需要获取指定索引的元素, 使用二分法查找, 然后进行遍历查找, 所以此处相较于<a href="https://liuzhihang.com/2018/08/23/arraylist-related-learning.html">ArrayList</a>多了遍历查询, 虽然使用了二分法进行优化, 但是get/set操作相比ArrayList来说性能还是相对较差</p><pre><code class="bash">public E get(int index) &#123;    // 校验索引    checkElementIndex(index);    // 二分法遍历查找节点    return node(index).item;&#125;public E set(int index, E element) &#123;    // 校验索引    checkElementIndex(index);    // 二分法遍历查找节点    Node&lt;E&gt; x = node(index);    // 修改Node节点的 item值    E oldVal = x.item;    x.item = element;    return oldVal;&#125;/** * 返回指定索引处非null节点. */Node&lt;E&gt; node(int index) &#123;    // assert isElementIndex(index);    // 判断索引是否小于长度的一半 (二分法) 然后遍历查找    if (index &lt; (size &gt;&gt; 1)) &#123;        Node&lt;E&gt; x = first;        for (int i = 0; i &lt; index; i++)            x = x.next;        return x;    &#125; else &#123;        Node&lt;E&gt; x = last;        for (int i = size - 1; i &gt; index; i--)            x = x.prev;        return x;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 源码学习 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码学习 </tag>
            
            <tag> LinkList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList相关学习</title>
      <link href="2018/08/23/arraylist-related-learning.html"/>
      <url>2018/08/23/arraylist-related-learning.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>ArrayList是工作中常用的集合, 基于数组实现, 可以插入空数据, 也支持随机访问.<br>ArrayList比较适合 get/set操作, 因为 add/remove需要移动数据, 相对来说比较消耗性能.</p></blockquote><h3 id="默认初始长度"><a href="#默认初始长度" class="headerlink" title="默认初始长度"></a>默认初始长度</h3><p>1.默认初始长度为 10<br>2.底层结构为Object[] 数组</p><a id="more"></a><pre><code class="bash">private static final int DEFAULT_CAPACITY = 10;private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;/** * 构造一个初始容量为10的空列表 */public ArrayList() &#123;    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;</code></pre><h3 id="添加方法-add"><a href="#添加方法-add" class="headerlink" title="添加方法 add()"></a>添加方法 add()</h3><ol><li>向数组中添加元素, 流程如下</li></ol><pre><code class="bash">/** * 将指定的元素追加到此列表的末尾. */public boolean add(E e) &#123;    // 扩容    ensureCapacityInternal(size + 1);  // Increments modCount!!    // 添加元素    elementData[size++] = e;    return true;&#125;</code></pre><p>2.扩容过程</p><pre><code class="bash">transient Object[] elementData;// 扩容private void ensureCapacityInternal(int minCapacity) &#123;    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));&#125;// 计算容量, elementData为空 则使用默认容量 10, 指定容量private static int calculateCapacity(Object[] elementData, int minCapacity) &#123;    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;        return Math.max(DEFAULT_CAPACITY, minCapacity);    &#125;    return minCapacity;&#125;// 修改次数自增, 并且如果 新的长度-原长度&gt;0 则使用 grow(minCapacity)方法进行扩容private void ensureExplicitCapacity(int minCapacity) &#123;    modCount++;    // overflow-conscious code    if (minCapacity - elementData.length &gt; 0)        grow(minCapacity);&#125;</code></pre><ol start="3"><li>添加元素赋值<pre><code class="bash">elementData[size++] = e;</code></pre></li></ol><h3 id="扩容流程-grow-minCapacity"><a href="#扩容流程-grow-minCapacity" class="headerlink" title="扩容流程 grow(minCapacity)"></a>扩容流程 grow(minCapacity)</h3><p>通过扩容流程可以看出扩容过程中, 是将创建一个原数组1.5倍大小的新数组, 同时将数组元素复制到新数组, 所以一般使用中, 尽量指定数组大小, 从而避免数组的复制.</p><pre><code class="java">/** * 增加容量确保能容纳 minCapacity 数量的元素 */private void grow(int minCapacity) &#123;    // overflow-conscious code    // 获取当前 elementData 的长度    int oldCapacity = elementData.length;    // 获取新的长度 为当前长度的 1.5倍    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);    // 比较并交换    if (newCapacity - minCapacity &lt; 0)        newCapacity = minCapacity;    // 防止超出最大长度    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)        newCapacity = hugeCapacity(minCapacity);    // minCapacity is usually close to size, so this is a win:    // 数组复制    elementData = Arrays.copyOf(elementData, newCapacity);&#125;</code></pre><h3 id="删除-remove-方法"><a href="#删除-remove-方法" class="headerlink" title="删除 remove 方法"></a>删除 remove 方法</h3><p>删除过程中使用 System.arraycopy 本地方法, 对数组进行复制, 所以 ArrayList的 新增和删除方法性能不如, <a href="https://liuzhihang.com/2018/08/23/linklist-related-learning.html">LinkList</a>, 但是 get和set方法, 则直接根据索引修改数据, 比较适合对数据进行修改的操作.</p><pre><code class="bash">/** * 删除指定位置的元素, 后面的元素将前移 */public E remove(int index) &#123;    // 检查索引 否则抛出 IndexOutOfBoundsException(outOfBoundsMsg(index))    rangeCheck(index);    // 修改次数自增    modCount++;    E oldValue = elementData(index);    int numMoved = size - index - 1;    if (numMoved &gt; 0)        // 数组复制        System.arraycopy(elementData, index+1, elementData, index,                         numMoved);    elementData[--size] = null; // clear to let GC do its work    return oldValue;&#125;/** * 删除指定元素 */public boolean remove(Object o) &#123;    if (o == null) &#123;        for (int index = 0; index &lt; size; index++)            if (elementData[index] == null) &#123;                fastRemove(index);                return true;            &#125;    &#125; else &#123;        for (int index = 0; index &lt; size; index++)            if (o.equals(elementData[index])) &#123;                fastRemove(index);                return true;            &#125;    &#125;    return false;&#125;/** * System.arraycopy 方法拷贝 删除 */private void fastRemove(int index) &#123;    modCount++;    int numMoved = size - index - 1;    if (numMoved &gt; 0)        System.arraycopy(elementData, index+1, elementData, index,                         numMoved);    elementData[--size] = null; // clear to let GC do its work&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 源码学习 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>@Value注入属性的小bug</title>
      <link href="2018/08/21/value-injects-a-small-bug-in-the-property.html"/>
      <url>2018/08/21/value-injects-a-small-bug-in-the-property.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="Value注入属性"><a href="#Value注入属性" class="headerlink" title="@Value注入属性"></a>@Value注入属性</h4><p>工作中一些公共属性, 一般通过@Value注入的对象的属性中, 使用方式如下</p><pre><code class="java">@Configurationpublic class WeChatConfig &#123;    /**    * 微信支付参数    */    @Value(&quot;$&#123;wx.appId&#125;&quot;)    public String WX_APP_ID;&#125;</code></pre><p>通过@Value注解, 将配置文件中的值注入到对象属性中, 在使用时只需要注入WeChatConfig对象然后调用即可, 而实际工作中, 往往用静态属性, 方便使用, 于是可以写成如下方式</p><a id="more"></a><pre><code class="java">@Configurationpublic class WeChatConfig &#123;    /**    * 微信支付参数    */    @Value(&quot;$&#123;wx.appId&#125;&quot;)    public static String WX_APP_ID;&#125;</code></pre><p>使用此方式不会报错, 但是却取不到属性值, 并且不会报错. 变通方式可以如下:</p><pre><code class="java">@Configurationpublic class WeChatConfig &#123;    /**    * 微信支付参数    */    @Value(&quot;$&#123;wx.appId&#125;&quot;)    public static String WX_APP_ID;    @Value(&quot;$&#123;wx.app.id&#125;&quot;)    private void setWxAppId(String wxAppId) &#123;        WX_APP_ID = wxAppId;    &#125;&#125;</code></pre><p>注意: 此处的 set方法不可以设置为静态, 否则同样不能注入属性</p>]]></content>
      
      
      <categories>
          
          <category> issue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> issue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用枚举实现单例</title>
      <link href="2018/08/17/use-enumeration-to-implement-a-singleton.html"/>
      <url>2018/08/17/use-enumeration-to-implement-a-singleton.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>介绍使用枚举的方式创建单例, 其他方式可以参考<a href="https://liuzhihang.com/2018/02/21/singleton-pattern.html">单例模式</a></p><a id="more"></a><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="java">/** * 使用枚举单例 * * @author liuzhihang * @date 2018/8/17 17:34 */public class SingletonPattern &#123;    private SingletonPattern() &#123;    &#125;    public static SingletonPattern getInstance() &#123;      return   SingleEnum.INSTANCE.getSingletonPattern();    &#125;    private enum SingleEnum &#123;        /**         * 单例         */        INSTANCE;        private SingletonPattern singletonPattern;        SingleEnum() &#123;            this.singletonPattern = new SingletonPattern();        &#125;        public SingletonPattern getSingletonPattern() &#123;            return singletonPattern;        &#125;    &#125;&#125;</code></pre><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>1.比双重锁检查相对简洁<br>2.线程安全<br>3.自动处理序列化<br>4.防止反射</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch基本语句</title>
      <link href="2018/06/26/elasticsearch-basic-statement.html"/>
      <url>2018/06/26/elasticsearch-basic-statement.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="查看集群"><a href="#查看集群" class="headerlink" title="查看集群"></a>查看集群</h3><h4 id="1-查看集群健康"><a href="#1-查看集群健康" class="headerlink" title="1. 查看集群健康"></a>1. 查看集群健康</h4><pre><code class="bash">curl -X GET &quot;localhost:9200/_cat/health?v&quot;</code></pre><h4 id="2-查看集群节点"><a href="#2-查看集群节点" class="headerlink" title="2. 查看集群节点"></a>2. 查看集群节点</h4><pre><code class="bash">curl -X GET &quot;localhost:9200/_cat/nodes?v&quot;</code></pre><a id="more"></a><h4 id="3-查看集群所有索引"><a href="#3-查看集群所有索引" class="headerlink" title="3. 查看集群所有索引"></a>3. 查看集群所有索引</h4><pre><code class="bash">curl -X GET &quot;localhost:9200/_cat/indices?v&quot;</code></pre><h3 id="get-获取指定数据"><a href="#get-获取指定数据" class="headerlink" title="get 获取指定数据"></a>get 获取指定数据</h3><h4 id="1-直接获取数据"><a href="#1-直接获取数据" class="headerlink" title="1. 直接获取数据"></a>1. 直接获取数据</h4><pre><code class="bash">curl -X GET &quot;localhost:9200/monitor_log_mch_order_out/logs/AWSudIFgTuj3oZBEhyxK?pretty&quot;</code></pre><p>格式为 /{index}/{type}/{id}</p><table><thead><tr><th align="left">字段</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">monitor_log_mch_order_out</td><td align="left">索引 (_index)</td></tr><tr><td align="left">logs</td><td align="left">索引的类型 (_type), 不知道类型可以用 _all 匹配</td></tr><tr><td align="left">AWSudIFgTuj3oZBEhyxK</td><td align="left">id (_id)</td></tr><tr><td align="left">pretty</td><td align="left">json格式显示数据, 可省略</td></tr></tbody></table><h4 id="2-屏蔽或只查看-source"><a href="#2-屏蔽或只查看-source" class="headerlink" title="2. 屏蔽或只查看 _source"></a>2. 屏蔽或只查看 _source</h4><pre><code class="bash">curl -X GET &quot;localhost:9200/monitor_log_mch_order_out/logs/AWSudIFgTuj3oZBEhyxK?pretty&amp;_source=false&quot;</code></pre><p>添加 _source=false 即可</p><pre><code class="bash">curl -X GET &quot;localhost:9200/monitor_log_mch_order_out/logs/AWSudIFgTuj3oZBEhyxK/_source?pretty&quot;</code></pre><h4 id="3-过滤字段"><a href="#3-过滤字段" class="headerlink" title="3. 过滤字段"></a>3. 过滤字段</h4><pre><code class="bash">curl -X GET &quot;localhost:9200/monitor_log_mch_order_out/logs/AWSudIFgTuj3oZBEhyxK?pretty&amp;_source_include=log*&amp;_source_exclude=logType&quot;</code></pre><p>获取包含 log* 且不为 logType 的字段</p><pre><code class="bash">curl -X GET &quot;localhost:9200/monitor_log_mch_order_out/logs/AWSudIFgTuj3oZBEhyxK?pretty&amp;_source=logType,logLevel&quot;</code></pre><p>只查询指定字段的简易写法</p><h3 id="mget-多条件匹配查询"><a href="#mget-多条件匹配查询" class="headerlink" title="mget 多条件匹配查询"></a>mget 多条件匹配查询</h3><ol><li><p>匹配多个索引, 同时查询多个id的数据</p><pre><code class="bash">curl -X GET &quot;localhost:9200/_mget?pretty&quot; -H &#39;Content-Type: application/json&#39; -d&#39;&#123; &quot;docs&quot; : [     &#123;         &quot;_index&quot; : &quot;monitor_log_mch_order_out&quot;,         &quot;_type&quot; : &quot;logs&quot;,         &quot;_id&quot; : &quot;AWSudIFgTuj3oZBEhyxK&quot;     &#125;,     &#123;         &quot;_index&quot; : &quot;monitor_log_mch_order_out&quot;,         &quot;_type&quot; : &quot;logs&quot;,         &quot;_id&quot; : &quot;AWSuXewETuj3oZBEhywS&quot;     &#125; ]&#125;&#39;</code></pre></li><li><p>可以将索引写在host后面, 代表查询的都为同一索引下的数据</p><pre><code class="bash">curl -X GET &quot;localhost:9200/monitor_log_mch_order_out/_mget?pretty&quot; -H &#39;Content-Type: application/json&#39; -d&#39;&#123; &quot;docs&quot; : [     &#123;         &quot;_type&quot; : &quot;logs&quot;,         &quot;_id&quot; : &quot;AWSudIFgTuj3oZBEhyxK&quot;     &#125;,     &#123;         &quot;_type&quot; : &quot;logs&quot;,         &quot;_id&quot; : &quot;AWSuXewETuj3oZBEhywS&quot;     &#125; ]&#125;&#39;</code></pre></li><li><p>合并index和type, 代表查询的都为同一索引下type也相同的数据</p><pre><code class="bash">curl -X GET &quot;localhost:9200/monitor_log_mch_order_out/logs/_mget?pretty&quot; -H &#39;Content-Type: application/json&#39; -d&#39;&#123; &quot;docs&quot; : [     &#123;         &quot;_id&quot; : &quot;AWSudIFgTuj3oZBEhyxK&quot;     &#125;,     &#123;         &quot;_id&quot; : &quot;AWSuXewETuj3oZBEhywS&quot;     &#125; ]&#125;&#39;</code></pre><p>简化后如下:</p><pre><code class="bash">curl -X GET &quot;localhost:9200/monitor_log_mch_order_out/logs/_mget?pretty&quot; -H &#39;Content-Type: application/json&#39; -d&#39;&#123; &quot;ids&quot; : [&quot;AWSudIFgTuj3oZBEhyxK&quot;, &quot;AWSuXewETuj3oZBEhywS&quot;]&#125;&#39;</code></pre></li></ol><p>注: 当多个条件的 _type 相同时 可以使用 _all 或者省略</p><ol start="4"><li>过滤字段, 每个Id分别对 _source进行过滤<pre><code class="bash">curl -X GET &quot;localhost:9200/monitor_log_mch_order_out/_mget?pretty&quot; -H &#39;Content-Type: application/json&#39; -d&#39;&#123; &quot;docs&quot; : [     &#123;         &quot;_id&quot; : &quot;AWSudIFgTuj3oZBEhyxK&quot;,         &quot;_source&quot; : false     &#125;,     &#123;         &quot;_id&quot; : &quot;AWSuXewETuj3oZBEhywS&quot;,         &quot;_source&quot; : [&quot;bizId&quot;, &quot;method&quot;]     &#125;,     &#123;         &quot;_id&quot; : &quot;AWSuLAYqTuj3oZBEhysH&quot;,         &quot;_source&quot; : &#123;             &quot;include&quot;: [&quot;log*&quot;],             &quot;exclude&quot;: [&quot;logLevel&quot;]         &#125;     &#125; ]&#125;&#39;</code></pre></li></ol><h3 id="search-搜索"><a href="#search-搜索" class="headerlink" title="_search 搜索"></a>_search 搜索</h3><h4 id="1-匹配bizId-查询"><a href="#1-匹配bizId-查询" class="headerlink" title="1. 匹配bizId 查询"></a>1. 匹配bizId 查询</h4><pre><code class="bash">curl -X GET &quot;localhost:9200/monitor_log_mch_order_out/_search?pretty&amp;q=bizId:2009011201807190133430748068&quot;</code></pre><h4 id="2-同时指定类型"><a href="#2-同时指定类型" class="headerlink" title="2. 同时指定类型"></a>2. 同时指定类型</h4><p>同时指定类型, 多个类型用 ‘,’ 隔开, 也支持多个索引勇士搜索, 多个索引用 ‘,’ 隔开, 或者模糊搜索</p><pre><code class="bash">curl -X GET &quot;localhost:9200/monitor_log_mch_order_out/logs/_search?pretty&amp;q=bizId:2009011201807190133430748068&quot;</code></pre><h4 id="3-占位符-all-匹配所有索引"><a href="#3-占位符-all-匹配所有索引" class="headerlink" title="3. 占位符 _all 匹配所有索引"></a>3. 占位符 _all 匹配所有索引</h4><pre><code class="bash">curl -X GET &quot;localhost:9200/_all/logs/_search?pretty&amp;q=bizId:2009011201807190133430748068&quot;</code></pre><h4 id="4-匹配所有索引所有类型"><a href="#4-匹配所有索引所有类型" class="headerlink" title="4. 匹配所有索引所有类型"></a>4. 匹配所有索引所有类型</h4><pre><code class="bash">curl -X GET &quot;localhost:9200/_search?pretty&amp;q=bizId:2009011201807190133430748068&quot;</code></pre><p>注: q 代表映射query_string</p><h4 id="5-请求体的方式"><a href="#5-请求体的方式" class="headerlink" title="5. 请求体的方式"></a>5. 请求体的方式</h4><pre><code class="bash">curl -X GET &quot;localhost:9200/monitor_log_mch_order_out/logs/_search?pretty&quot; -H &#39;Content-Type: application/json&#39; -d&#39;&#123;    &quot;query&quot; : &#123;        &quot;term&quot; : &#123; &quot;bizId&quot; : &quot;2009011201807190133430748068&quot; &#125;    &#125;&#125;&#39;</code></pre><h4 id="6-分页查询-from-size"><a href="#6-分页查询-from-size" class="headerlink" title="6. 分页查询 from/size"></a>6. 分页查询 from/size</h4><pre><code class="bash">curl -X GET &quot;localhost:9200/monitor_log_mch_order_out/logs/_search?pretty&quot; -H &#39;Content-Type: application/json&#39; -d&#39;&#123;    &quot;from&quot; : 0, &quot;size&quot; : 1,    &quot;query&quot; : &#123;        &quot;term&quot; : &#123; &quot;bizId&quot; : &quot;2009011201807190133430748068&quot; &#125;    &#125;&#125;&#39;</code></pre><h4 id="7-查询并过滤字段"><a href="#7-查询并过滤字段" class="headerlink" title="7. 查询并过滤字段"></a>7. 查询并过滤字段</h4><p>根据字段查询并筛选掉指定字段</p><pre><code class="bash">curl -X GET &quot;localhost:9200/_search?pretty&quot; -H &#39;Content-Type: application/json&#39; -d&#39;&#123;    &quot;_source&quot;: &#123;        &quot;includes&quot;: [ &quot;costTime&quot;, &quot;bizId&quot; ],        &quot;excludes&quot;: [ &quot;logLevel&quot; ]    &#125;,    &quot;query&quot; : &#123;        &quot;term&quot; : &#123; &quot;bizId&quot; : &quot;2009011201807190133430748068&quot; &#125;    &#125;&#125;&#39;</code></pre><h3 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h3><h4 id="1-按照时间范围查询"><a href="#1-按照时间范围查询" class="headerlink" title="1. 按照时间范围查询"></a>1. 按照时间范围查询</h4><p>可以省略索引查询全部</p><pre><code class="bash">curl -X GET &quot;localhost:9200/monitor_log_mch_order_out/_search?pretty&quot; -H &#39;Content-Type: application/json&#39; -d&#39;&#123;    &quot;query&quot;: &#123;        &quot;range&quot; : &#123;            &quot;time&quot; : &#123;                &quot;gte&quot;: &quot;2018-07-19 00:14:25:000&quot;,                &quot;lte&quot;: &quot;2018-07-19 00:14:30:000&quot;,                &quot;format&quot;: &quot;yyyy-MM-dd HH:mm:ss:SSS&quot;            &#125;        &#125;    &#125;&#125;&#39;</code></pre>]]></content>
      
      
      <categories>
          
          <category> ELK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ELK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>logstash配置</title>
      <link href="2018/06/20/logstash-configuration.html"/>
      <url>2018/06/20/logstash-configuration.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><pre><code class="yaml">input &#123;    beats &#123;        port =&gt; &quot;5043&quot;    &#125;&#125;</code></pre><p>配置日志输入方式为 filebeat, 并配置端口</p><a id="more"></a><h3 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h3><pre><code class="yaml">filter &#123;    grok &#123;        match =&gt; &#123;        &quot;message&quot; =&gt; &quot;\[%&#123;DATA:time&#125;\]-\[%&#123;DATA:method&#125;\] - \[%&#123;DATA:catalina&#125;\] -\[%&#123;DATA:logLevel&#125;\] - \[%&#123;DATA:index_prefix&#125;\|%&#123;WORD:logType&#125;\|%&#123;WORD:sysNo&#125;\|%&#123;WORD:objType&#125;\|%&#123;DATA:funcode&#125;\|%&#123;WORD:monitorObjNo&#125;\|%&#123;WORD:bizId&#125;\|%&#123;WORD:respCode&#125;\|%&#123;DATA:respMsg&#125;\|%&#123;WORD:costTime&#125;|%&#123;DATA:exField&#125;\]&quot;        &#125;    &#125;    grok&#123;         match =&gt; &#123; &quot;time&quot; =&gt; [&quot;%&#123;INT:y_index&#125;-%&#123;INT:M_index&#125;-%&#123;INT:d_index&#125;&quot;]&#125;    &#125;    mutate &#123;        add_field =&gt; &#123; &quot;[@metadata][index_suffix]&quot; =&gt; &quot;%&#123;y_index&#125;%&#123;M_index&#125;%&#123;d_index&#125;&quot; &#125;        remove_field =&gt; [&quot;beat&quot;,&quot;host&quot;,&quot;thread&quot;,&quot;class&quot;,&quot;source&quot;,&quot;tags&quot;,&quot;type&quot;,&quot;y_index&quot;,&quot;M_index&quot;,&quot;d_index&quot;]        lowercase =&gt; [ &quot;index_prefix&quot; ]        lowercase =&gt; [ &quot;funcode&quot; ]        lowercase =&gt; [ &quot;objType&quot; ]        lowercase =&gt; [ &quot;monitorObjNo&quot; ]    &#125;&#125;</code></pre><ol><li>使用gork过滤器对日志进行筛选, 并对部分字段赋值.</li><li>使用mutate插件对字段进行转换, add_field 为添加字段 [@metadata][index_suffix] 意思是添加临时字段, 该字段不会输出到es中</li></ol><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><pre><code class="yaml">output &#123;        if  [logType] == &quot;info&quot;  &#123;                 elasticsearch &#123;                        hosts =&gt; [ &quot;xxx.xxx.xxx.xxx:9200&quot; ]                        index =&gt; &quot;%&#123;index_prefix&#125;_%&#123;objType&#125;_%&#123;funcode&#125;_%&#123;[@metadata][index_suffix]&#125;&quot;                        user =&gt; elastic                        password =&gt; xxx                 &#125;        &#125;        if [logType] == &quot;error&quot; &#123;                redis &#123;                        data_type =&gt; &quot;list&quot;                        db =&gt; 0                        #key =&gt; &quot;%&#123;index_prefix&#125;_%&#123;sysNo&#125;_%&#123;objType&#125;_%&#123;funcode&#125;_%&#123;[@metadata][index_suffix]&#125;&quot;                        key =&gt; &quot;%&#123;index_prefix&#125;_%&#123;sysNo&#125;_%&#123;objType&#125;_%&#123;monitorObjNo&#125;&quot;                        host =&gt; &quot;xxx.xxx.xxx.xxx&quot;                        port =&gt; &quot;6379&quot;                        password =&gt; &quot;xxx&quot;                &#125;        &#125;&#125;</code></pre><p>将过滤后的字段按照类型输出到Es或者redis队列中</p><h3 id="启动命令"><a href="#启动命令" class="headerlink" title="启动命令"></a>启动命令</h3><pre><code>    ./bin/logstash -f first-pipelines.yml    nohup ./logstash -f ../first-pipelines.yml &gt;/dev/null 2&gt;&amp;1 &amp;</code></pre><h3 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h3><pre><code class="yaml"># 输出到控制台stdout &#123; codec =&gt; rubydebug &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> ELK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ELK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>filebeat配置</title>
      <link href="2018/06/20/filebeat-configuration.html"/>
      <url>2018/06/20/filebeat-configuration.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="filebeat配置"><a href="#filebeat配置" class="headerlink" title="filebeat配置"></a>filebeat配置</h3><pre><code class="yaml">filebeat.prospectors:- input_type: log#读取日志的路径  paths:    - /opt/export/log/info-xxx.log  fields:    log_type: &quot;monitor_log&quot;  fields_under_root: true#过滤部分日志  include_lines: [&#39;Monitor_log&#39;]#----------------------------- Logstash output --------------------------------output.logstash:  # The Logstash hosts  hosts: [&quot;xxx.xxx.xxx.xxx:5043&quot;,&quot;xxx.xxx.xxx.xxx:5043&quot;]  loadbalance: true#================================ Logging =====================================logging.level: infologging.to_files: truelogging.to_syslog: falselogging.files:  path: /opt/export/app/filebeat/logs  name: mybeat.log  keepfiles: 5</code></pre><p>过滤不包含指定字段的日志, 并仅仅输出到logstash, 也可以直接输出到Elasticsearch</p><h3 id="启动命令"><a href="#启动命令" class="headerlink" title="启动命令"></a>启动命令</h3><ol><li>前台启动：关闭窗口连接后自动退出</li></ol><pre><code class="bash">./filebeat -e -c filebeat.yml</code></pre><ol start="2"><li>后台启动:</li></ol><pre><code class="bash">nohup ./filebeat -e -c filebeat.yml &gt;/dev/null 2&gt;&amp;1 &amp;</code></pre><ol start="3"><li>关闭:</li></ol><pre><code class="bash">kill -9 xxxx</code></pre>]]></content>
      
      
      <categories>
          
          <category> ELK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ELK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>监控系统架构</title>
      <link href="2018/06/20/monitoring-system-architecture.html"/>
      <url>2018/06/20/monitoring-system-architecture.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="监控系统基本框架"><a href="#监控系统基本框架" class="headerlink" title="监控系统基本框架"></a>监控系统基本框架</h3><p><img src="/resources/image/elk/elk.png" alt="监控系统基本架构"></p><a id="more"></a><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ol><li>各业务系统按照指定格式打印日志</li><li>filebeat自动读取日志信息, 并进行过滤, 输出到logstash</li><li>logstash进行二次处理, 将日志内容格式化, 并将 info日志和error日志分别存放到Elasticsearch和redis队列中</li><li>监控系统定时从Es和redis中获取数据, 存放到mysql并进行报警分析</li><li>使用EChart图形化展示信息<br>…</li></ol>]]></content>
      
      
      <categories>
          
          <category> ELK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ELK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程的生命周期</title>
      <link href="2018/06/15/thread-life-cycle.html"/>
      <url>2018/06/15/thread-life-cycle.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><p><img src="/resources/concurrent/thread-life.png" alt="java内存模型"></p><a id="more"></a><h3 id="图解析"><a href="#图解析" class="headerlink" title="图解析"></a>图解析</h3><p>1.一般情况下线程主要经历: 准备, 就绪, 运行, 死亡四种状态.<br>2.准备:即创建线程, 包括集成Thread, 线程池, spring方式等等<br>3.就绪:线程创建并调用start()方法并不代表线程将立即获得资源, 而是进入到就绪状态进行资源分配<br>4.运行:抢占到资源的线程将执行, 执行过程可能会含有一些别的操作<br>&emsp;1).线程等待, 直到调用 notify()或notifyAll()方法被唤醒, 这里唤醒后不会立即继续执行线程, 而是进入就绪状态重新抢占资源<br>&emsp;2).线程休眠, 直到休眠时间结束, 同样结束后不会立即继续执行线程, 而是进入就绪状态重新抢占资源<br>&emsp;3).线程阻塞, IO资源阻塞, 锁等方式使线程进入阻塞队列, 释放锁将继续执行<br>5.死亡: 调用<del>stop()</del>方法, 线程中断, 或线程执行完毕则线程死亡</p>]]></content>
      
      
      <categories>
          
          <category> 并发和锁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>synchronized锁的介绍</title>
      <link href="2018/06/13/introduction-of-synchronized-lock.html"/>
      <url>2018/06/13/introduction-of-synchronized-lock.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="synchronized锁的使用"><a href="#synchronized锁的使用" class="headerlink" title="synchronized锁的使用"></a>synchronized锁的使用</h3><p>synchronized可以使用在方法和代码块中, 使用的方式不同锁代表的含义不同, 下面将从几个方面进行介绍.</p><ul><li>普通方法</li><li>静态方法</li><li>代码块synchronized(this)</li><li>代码块synchronized(*.class)</li></ul><a id="more"></a><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul><li>在使用synchronized关键字中锁主要分为两类, 一种是对象锁, 另一种类锁</li><li>普通加锁方法和synchronized(this)都是对象锁, 静态加锁方法和synchronized(*.class)都是类锁</li><li>对象锁: 同一对象持有锁, 相同对象等待, 其他对象不受影响; 不同对象持有锁, 互不影响.</li><li>类锁: 类锁时, 只要该类的对象持有锁, 无论是否为同一对象访问静态同步方法时都等待, 访问非静态同步方法不受影响.</li><li>对象锁和类锁互相不影响</li></ul><h3 id="测试代码及过程"><a href="#测试代码及过程" class="headerlink" title="测试代码及过程"></a>测试代码及过程</h3><pre><code class="java">package com.liuzhihang.tool.sync;/** * @author liuzhihang * @date 2018/7/11 16:25 */public class SyncMainTest &#123;    public static void main(String[] args) &#123;        SyncTest syncTest1 = new SyncTest();        // SyncTest syncTest2 = new SyncTest();        new Thread(() -&gt; syncTest1.methodA(), &quot;线程 01 &quot;).start();        new Thread(() -&gt; syncTest1.methodB(), &quot;线程 02 &quot;).start();    &#125;&#125;class SyncTest &#123;    void methodA() &#123;        System.out.println(Thread.currentThread().getName() + &quot;start&quot;);        try &#123;            System.out.println(Thread.currentThread().getName() + &quot;sleep&quot;);            Thread.sleep(500);        &#125; catch (InterruptedException e) &#123;        &#125;        System.out.println(Thread.currentThread().getName() + &quot;end&quot;);    &#125;    void methodB() &#123;        System.out.println(Thread.currentThread().getName() + &quot;start&quot;);        try &#123;            System.out.println(Thread.currentThread().getName() + &quot;sleep&quot;);            Thread.sleep(300);        &#125; catch (InterruptedException e) &#123;        &#125;        System.out.println(Thread.currentThread().getName() + &quot;end&quot;);    &#125;&#125;</code></pre><p>以上为一个简单的测试代码, 指使用两个线程分别调用两个方法, 通过打印结果可以看出顺序是乱序的, 其中线程的 start() 顺序并不代表线程的执行顺序, 在下面测试中假设是 “线程01” 先执行.</p><h4 id="1-A-B-方法分别添加synchronized关键字-同一对象"><a href="#1-A-B-方法分别添加synchronized关键字-同一对象" class="headerlink" title="1.A B 方法分别添加synchronized关键字 + 同一对象"></a>1.A B 方法分别添加synchronized关键字 + 同一对象</h4><pre><code class="java">class SyncTest &#123;    synchronized void methodA() &#123;        // ...    &#125;    synchronized void methodB() &#123;        // ...    &#125;&#125;</code></pre><p>结论: 方法 A 阻塞, 方法 B 等待 A 执行完毕后才继续执行.</p><h4 id="2-A-B-方法分别添加synchronized关键字-不同对象"><a href="#2-A-B-方法分别添加synchronized关键字-不同对象" class="headerlink" title="2.A B 方法分别添加synchronized关键字 + 不同对象"></a>2.A B 方法分别添加synchronized关键字 + 不同对象</h4><pre><code class="java">public class SyncMainTest &#123;    public static void main(String[] args) &#123;        SyncTest syncTest1 = new SyncTest();        SyncTest syncTest2 = new SyncTest();        new Thread(() -&gt; syncTest1.methodA(), &quot;线程 01 &quot;).start();        new Thread(() -&gt; syncTest2.methodB(), &quot;线程 02 &quot;).start();    &#125;&#125;class SyncTest &#123;    synchronized void methodA() &#123;        // ...    &#125;    synchronized void methodB() &#123;        // ...    &#125;&#125;</code></pre><p>结论: 方法 A 阻塞, 方法 B 不受影响.</p><h4 id="3-A-方法分别添加synchronized关键字-B方法不添加"><a href="#3-A-方法分别添加synchronized关键字-B方法不添加" class="headerlink" title="3.A 方法分别添加synchronized关键字 B方法不添加"></a>3.A 方法分别添加synchronized关键字 B方法不添加</h4><pre><code class="java">class SyncTest &#123;    synchronized void methodA() &#123;        // ...    &#125;    void methodB() &#123;        // ...    &#125;&#125;</code></pre><p>结论: 方法 A 阻塞, 方法 B 不受影响.</p><h4 id="4-A-B-方法分别添加-static-synchronized-不同对象"><a href="#4-A-B-方法分别添加-static-synchronized-不同对象" class="headerlink" title="4.A B 方法分别添加 static synchronized  + 不同对象"></a>4.A B 方法分别添加 static synchronized  + 不同对象</h4><pre><code class="java">public class SyncMainTest &#123;    public static void main(String[] args) &#123;        SyncTest syncTest1 = new SyncTest();        SyncTest syncTest2 = new SyncTest();        new Thread(() -&gt; syncTest1.methodA(), &quot;线程 01 &quot;).start();        new Thread(() -&gt; syncTest2.methodB(), &quot;线程 02 &quot;).start();    &#125;&#125;class SyncTest &#123;    static synchronized void methodA() &#123;        // ...    &#125;    static synchronized void methodB() &#123;        // ...    &#125;&#125;</code></pre><p>结论: 方法 A 阻塞, 方法 B 等待 A结束后继续执行.</p><h4 id="5-A-方法添加-static-synchronized-B-方法添加-synchronized-不同对象"><a href="#5-A-方法添加-static-synchronized-B-方法添加-synchronized-不同对象" class="headerlink" title="5.A 方法添加 static synchronized, B 方法添加 synchronized  + 不同对象"></a>5.A 方法添加 static synchronized, B 方法添加 synchronized  + 不同对象</h4><pre><code class="java">public class SyncMainTest &#123;    public static void main(String[] args) &#123;        SyncTest syncTest1 = new SyncTest();        SyncTest syncTest2 = new SyncTest();        new Thread(() -&gt; syncTest1.methodA(), &quot;线程 01 &quot;).start();        new Thread(() -&gt; syncTest2.methodB(), &quot;线程 02 &quot;).start();    &#125;&#125;class SyncTest &#123;    static synchronized void methodA() &#123;        // ...    &#125;    synchronized void methodB() &#123;        // ...    &#125;&#125;</code></pre><p>结论: 方法 A 阻塞, 方法 B 不受影响.</p><h4 id="6-A-B-方法内添加-synchronized-this"><a href="#6-A-B-方法内添加-synchronized-this" class="headerlink" title="6.A B 方法内添加 synchronized(this)"></a>6.A B 方法内添加 synchronized(this)</h4><pre><code class="java">class SyncTest &#123;    void methodA() &#123;        synchronized (this) &#123;            // ...        &#125;    &#125;    void methodB() &#123;        synchronized (this) &#123;            // ...        &#125;    &#125;&#125;</code></pre><p>结论: 同一对象 A 阻塞 B等待, 不同对象 A阻塞 B不受影响</p><h4 id="7-A-B-方法内添加-synchronized-SyncTest-class"><a href="#7-A-B-方法内添加-synchronized-SyncTest-class" class="headerlink" title="7.A B 方法内添加 synchronized(SyncTest.class)"></a>7.A B 方法内添加 synchronized(SyncTest.class)</h4><pre><code class="java">class SyncTest &#123;    void methodA() &#123;        synchronized (SyncTest.class) &#123;            // ...        &#125;    &#125;    void methodB() &#123;        synchronized (SyncTest.class) &#123;            // ...        &#125;    &#125;&#125;</code></pre><p>结论: 同一/不同对象 A 阻塞 B等待</p><h4 id="8-A-方法内添加-synchronized-SyncTest-class-B-方法内添加-synchronized-this"><a href="#8-A-方法内添加-synchronized-SyncTest-class-B-方法内添加-synchronized-this" class="headerlink" title="8.A 方法内添加 synchronized(SyncTest.class), B 方法内添加 synchronized(this)"></a>8.A 方法内添加 synchronized(SyncTest.class), B 方法内添加 synchronized(this)</h4><pre><code class="java">class SyncTest &#123;    void methodA() &#123;        synchronized (SyncTest.class) &#123;            // ...        &#125;    &#125;    void methodB() &#123;        synchronized (this) &#123;            // ...        &#125;    &#125;&#125;</code></pre><p>结论: 同一/不同对象 A 阻塞 B不受影响</p><h4 id="9-A-方法内添加-synchronized-SyncTest-class-B-方法内添加-synchronized-OtherObj"><a href="#9-A-方法内添加-synchronized-SyncTest-class-B-方法内添加-synchronized-OtherObj" class="headerlink" title="9.A 方法内添加 synchronized(SyncTest.class), B 方法内添加 synchronized(OtherObj)"></a>9.A 方法内添加 synchronized(SyncTest.class), B 方法内添加 synchronized(OtherObj)</h4><pre><code class="java">class SyncTest &#123;    private String string = &quot;lock&quot;;    void methodA() &#123;        synchronized (SyncTest.class) &#123;            // ...        &#125;    &#125;    void methodB() &#123;        synchronized (string) &#123;            // ...        &#125;    &#125;&#125;</code></pre><p>结论: 同一/不同对象 A 阻塞 B不受影响</p>]]></content>
      
      
      <categories>
          
          <category> 并发和锁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>synchronized同步锁原理</title>
      <link href="2018/06/11/synchronized-synchronous-lock-principle.html"/>
      <url>2018/06/11/synchronized-synchronous-lock-principle.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul><li>在多线程操作中volatile关键字可以保证共享变量的内存可见性, 但是并不能保证操作的原子性, 这时候就需要用到锁, synchronized同步锁是java关键字, 是内置的语言实现.</li><li>synchronized加锁和线程结束或异常锁的释放过程由JVM进行控制</li><li>synchronized关键字可以使用在方法和同步代码块中, 不同的使用方式, 锁的结果是不同的</li><li>重量级锁 + 可重入</li></ul><a id="more"></a><h3 id="synchronized底层原理"><a href="#synchronized底层原理" class="headerlink" title="synchronized底层原理"></a>synchronized底层原理</h3><p>1.代码示例</p><pre><code class="java">package com.liuzhihang.tool.java;/** * @author liuzhihang * @date 2018/06/11 16:05 */public class SynchronizedTest &#123;    private int i;    private int j;    public void syncTest1() &#123;        synchronized (this) &#123;            i++;        &#125;    &#125;    public synchronized void syncTest2() &#123;            j++;    &#125;&#125;</code></pre><p>2.使用 javap -v SynchronizedTest.class 查看代码的对应字节码如下:</p><pre><code>$ javap -v SynchronizedTest.classClassfile /C:/Users/liuzhihang/Desktop/SynchronizedTest.class  Last modified 2018-7-10; size 518 bytes  MD5 checksum ba48def77b226e7b9ac28121ec423c16  Compiled from &quot;SynchronizedTest.java&quot;public class com.liuzhihang.tool.java.SynchronizedTest  minor version: 0  major version: 52  flags: ACC_PUBLIC, ACC_SUPERConstant pool:    // 常量池省略&#123;      // 构造方法省略  public void syncTest1();    descriptor: ()V    flags: ACC_PUBLIC    Code:      stack=3, locals=3, args_size=1         0: aload_0         1: dup         2: astore_1         3: monitorenter         4: aload_0         5: dup         6: getfield      #2                    // Field i:I         9: iconst_1        10: iadd        11: putfield      #2                    // Field i:I        14: aload_1        15: monitorexit        16: goto          24        19: astore_2        20: aload_1        21: monitorexit        22: aload_2        23: athrow        24: return      Exception table:          // 省略代码  public synchronized void syncTest2();    descriptor: ()V    flags: ACC_PUBLIC, ACC_SYNCHRONIZED    Code:      stack=3, locals=1, args_size=1         0: aload_0         1: dup         2: getfield      #3                  // Field j:I         5: iconst_1         6: iadd         7: putfield      #3                  // Field j:I        10: return      LineNumberTable:        line 22: 0        line 23: 10&#125;SourceFile: &quot;SynchronizedTest.java&quot;</code></pre><p>3.结论</p><ul><li>同步语句块的实现使用的是 monitorenter 和 monitorexit 指令, 其中有两个 monitorexit 因为不能确保是正常结束还是异常结束, 所以另一个是用来确保异常结束时释放 monitor指令.</li><li>同步方法时使用的是 flags中的 ACC_SYNCHRONIZED 来标识该方法为同步方法, JVM在调用该方法时便会执行相应的同步调用.</li><li>每个线程都维护自己的监视器(monitor), 只要是同步调用进行相关操作时要先获得 monitor, 否则将被阻塞</li></ul>]]></content>
      
      
      <categories>
          
          <category> 并发和锁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>volatile关键字</title>
      <link href="2018/06/09/volatile-keyword.html"/>
      <url>2018/06/09/volatile-keyword.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>在多线程操作共享变量时, 会使用volatile修饰共享变量, 比如单例模式的双重锁检查中, 并且在concurrent包下也大量使用了volatile关键字;<br>volatile可以对类属性进行修饰, 从而确保线程每次都是从主存中获取属性, 操作完毕后写回主存.</p><a id="more"></a><h3 id="java内存模型"><a href="#java内存模型" class="headerlink" title="java内存模型"></a>java内存模型</h3><img src="/resources/concurrent/volatile.png" width="800" hegiht="800" align=center /><p> 在多线程同时对共享变量进行操作过程中, 每个线程会拷贝一份共享变量到自己的工作内存中进行相关操作, 操作完毕后会将结果写入到主存中.<br> 而volatile关键字可以保证操作的可见性和有序性, 但是却不能保证原子性.</p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>指一个操作或者多个操作要么全部执行要么全部都不执行, 操作过程整体是一个原子, 不被分割打断.</p><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>当多个线程访问同一个变量时, 一个线程修改了这个变量的值, 其他线程能够立即看得到修改的值.</p><h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>即程序执行的顺序按照代码的先后顺序执行<br>主要原因是因为处理器在处理程序时会进行指令重排, 对代码进行优化, 指令重排在单线程中得到的结果是一致的, 但是在多线程中就会造成各种错误.</p><h3 id="volatile关键字作用"><a href="#volatile关键字作用" class="headerlink" title="volatile关键字作用"></a>volatile关键字作用</h3><p>1.使用volatile关键字修饰的变量,会强制将修改的值写入到主存中<br>2.volatile不保证原子性, 在多线程操作下仅能保证操作别的线程可见, 在多线程情况下同时操作共享变量依然会有数据不正确的情况.<br>3.volatile会防止指令重排</p>]]></content>
      
      
      <categories>
          
          <category> 并发和锁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> volatile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringAop代理的选择</title>
      <link href="2018/05/21/springaop-agent-selection.html"/>
      <url>2018/05/21/springaop-agent-selection.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Spring动态创建bean过程, 是如何进行选择使用 jdk还是cglib进行代理的, 可以通过源码进行解析</p><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><p>通过断点进行跟踪主要执行过程在 DefaultAopProxyFactory, 通过判断条件是使用Cglib还是Jdk</p><a id="more"></a><h3 id="相关源码解析"><a href="#相关源码解析" class="headerlink" title="相关源码解析"></a>相关源码解析</h3><pre><code class="java">public class DefaultAopProxyFactory implements AopProxyFactory, Serializable &#123;    @Override    public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException &#123;        //判断条件 是否优化, 返回是否直接代理目标类以及任何接口或者没有用户提供的代理接口        if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;            Class&lt;?&gt; targetClass = config.getTargetClass();            if (targetClass == null) &#123;                throw new AopConfigException(&quot;TargetSource cannot determine target class: &quot; +                        &quot;Either an interface or a target is required for proxy creation.&quot;);            &#125;            //判断是否是接口, 和已经使用jdk代理            if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;                return new JdkDynamicAopProxy(config);            &#125;            return new ObjenesisCglibAopProxy(config);        &#125;        else &#123;            return new JdkDynamicAopProxy(config);        &#125;    &#125;    /**     * Determine whether the supplied &#123;@link AdvisedSupport&#125; has only the     * &#123;@link org.springframework.aop.SpringProxy&#125; interface specified     * (or no proxy interfaces specified at all).     */    private boolean hasNoUserSuppliedProxyInterfaces(AdvisedSupport config) &#123;        Class&lt;?&gt;[] ifcs = config.getProxiedInterfaces();        return (ifcs.length == 0 || (ifcs.length == 1 &amp;&amp; SpringProxy.class.isAssignableFrom(ifcs[0])));    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> aop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cglib动态代理</title>
      <link href="2018/05/18/cglib-dynamic-proxy.html"/>
      <url>2018/05/18/cglib-dynamic-proxy.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Spring动态代理可以选择使用jdk动态代理, 或者cglib动态代理,  cglib动态代理位于 net.sf.cglib.proxy 包下.</p><p>使用时涉及<br>接口: net.sf.cglib.proxy.MethodInterceptor<br>用来生成动态子类的类类: net.sf.cglib.proxy.Enhancer</p><p>注意: cglib 动态代理是基于类的代理, 是通过对指定的业务类生成一个子类, 并覆盖其中业务方法实现代理. 因为使用继承, 所以被代理类不能使 final 修饰</p><a id="more"></a><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><p>1.创建MethodInterceptor接口的实现类, 并编写intercept方法的实现<br>2.通过methodProxy.invokeSuper(o, objects);调用父类的方法<br>3.创建Enhancer, 通过 setSuperclass(Class superclass)方法指定父类(被代理类), 通过 setCallback(final Callback callback)方法指定代理<br>4.enhancer.create() 生成代理, 调用被代理类的方法</p><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><p>按照步骤编写简易逻辑代码.</p><h4 id="创建MethodInterceptor接口的实现类"><a href="#创建MethodInterceptor接口的实现类" class="headerlink" title="创建MethodInterceptor接口的实现类"></a>创建MethodInterceptor接口的实现类</h4><pre><code class="java">/** * 基于类的代理 即使类没有实现接口也可以被代理 * 主要是基于类生成一个继承的子类 所以 类和方法不要声明为 final * * * @author liuzhihang * @date 2018/5/18 10:10 */public class MyMethodInterceptor implements MethodInterceptor &#123;    @Override    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;        System.out.println(&quot;cglib动态代理 before . . .&quot;);        Object invoke = null;        try &#123;            invoke = methodProxy.invokeSuper(o, objects);        &#125; catch (Throwable throwable) &#123;            throwable.printStackTrace();            System.err.println(&quot;cglib动态代理 error: &quot; + throwable.getMessage());        &#125; finally &#123;            System.out.println(&quot;cglib动态代理 after . . .&quot;);        &#125;        return invoke;    &#125;&#125;</code></pre><h4 id="创建Enhancer"><a href="#创建Enhancer" class="headerlink" title="创建Enhancer"></a>创建Enhancer</h4><p>创建Enhancer, 通过 setSuperclass(Class superclass)方法指定父类(被代理类), 通过 setCallback(final Callback callback)方法指定代理</p><pre><code class="java">public class CglibMainTest &#123;    public static void main(String[] args) &#123;        Enhancer enhancer = new Enhancer();        enhancer.setSuperclass(SubjectCglib.class);        enhancer.setCallback(new MyMethodInterceptor());        SubjectCglib subjectCglib = (SubjectCglib) enhancer.create();        System.err.println(subjectCglib.getAge(&quot;liuzhihang&quot;));    &#125;&#125;</code></pre><h4 id="可以将二者合并到MyInterceptor中"><a href="#可以将二者合并到MyInterceptor中" class="headerlink" title="可以将二者合并到MyInterceptor中"></a>可以将二者合并到MyInterceptor中</h4><pre><code class="java">/** * 基于类的代理 即使类没有实现接口也可以被代理 * * * @author liuzhihang * @date 2018/5/18 10:10 */public class MyCglibInterceptor implements MethodInterceptor &#123;    private Object object;    public Object getInstance(Object object) &#123;        this.object = object;        Enhancer enhancer = new Enhancer();        enhancer.setSuperclass(object.getClass());        enhancer.setCallback(this);        return enhancer.create();    &#125;    @Override    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;        System.out.println(&quot;cglib动态代理 before . . .&quot;);        Object invoke = null;        try &#123;            invoke = methodProxy.invokeSuper(o, objects);        &#125; catch (Throwable throwable) &#123;            throwable.printStackTrace();            System.err.println(&quot;cglib动态代理 error: &quot; + throwable.getMessage());        &#125; finally &#123;            System.out.println(&quot;cglib动态代理 after . . .&quot;);        &#125;        return invoke;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 动态代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jdk动态代理及源码解析</title>
      <link href="2018/05/17/jdk-dynamic-proxy-and-source-code-analysis.html"/>
      <url>2018/05/17/jdk-dynamic-proxy-and-source-code-analysis.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Spring动态代理可以选择使用jdk动态代理, 或者cglib动态代理,  jdk动态代理位于 java.lang.reflect 包下.</p><p>使用时涉及<br>接口: java.lang.reflect.InvocationHandler<br>动态代理类: java.lang.reflect.Proxy</p><p>注意: JDK 动态代理是基于接口的代理, 只能对实现接口的类生成代理, 不能对类进行代理</p><a id="more"></a><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><p>1.创建InvocationHandler接口的实现类, 并编写invoke方法的实现<br>2.创建被代理类的接口及实现类<br>3.使用动态代理类Proxy的静态方法生成代理类实例<br>4.使用实例调用方法</p><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><p>按照步骤编写简易逻辑代码.</p><h4 id="创建InvocationHandler接口的实现类"><a href="#创建InvocationHandler接口的实现类" class="headerlink" title="创建InvocationHandler接口的实现类"></a>创建InvocationHandler接口的实现类</h4><pre><code class="java">/** * JDK 动态代理 * 基于接口的代理, 只能对实现接口的类生成代理, 不能对类进行代理 * * @author liuzhihang * @date 2018/5/17 10:36 */public class MyInvocationHandler implements InvocationHandler &#123;    /**     * 目标对象     */    private Object target;    public MyInvocationHandler(Object target) &#123;        this.target = target;    &#125;    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;        System.out.println(&quot;jdk 动态代理 before . . . &quot;);        System.out.println(&quot;当前代理方法为:&quot; + method);        Object invoke = method.invoke(target, args);        System.out.println(&quot;jdk 动态代理 after . . . &quot;);        return invoke;    &#125;&#125;</code></pre><h4 id="创建被代理类的接口及实现类"><a href="#创建被代理类的接口及实现类" class="headerlink" title="创建被代理类的接口及实现类"></a>创建被代理类的接口及实现类</h4><pre><code class="java">/** * 被代理类的接口 * @author liuzhihang * @date 2018/5/17 10:47 */public interface Subject &#123;    /**     * 获取名字     * @return     */    String getName();    /**     * 获取年龄     * @param name     * @return     */    String getAge(String name);&#125;</code></pre><pre><code class="java">/** * 被代理类 * * @author liuzhihang * @date 2018/5/17 10:48 */public class SubjectImpl implements Subject &#123;    @Override    public String getName() &#123;        System.out.println(&quot;SubjectImpl的获取名字方法 . . .&quot;);        return &quot;liuzhihang&quot;;    &#125;    @Override    public String getAge(String name) &#123;        System.out.println(name + &quot;开始获取年龄 . . .&quot;);        return &quot;25&quot;;    &#125;&#125;</code></pre><h4 id="使用动态代理类Proxy的静态方法生成代理类实例"><a href="#使用动态代理类Proxy的静态方法生成代理类实例" class="headerlink" title="使用动态代理类Proxy的静态方法生成代理类实例"></a>使用动态代理类Proxy的静态方法生成代理类实例</h4><p>获取代理类实例有以下两种方式, 一种是通过Proxy.newProxyInstance(..)获取,  一种是通过 Proxy.getProxyClass(..) 方式获取<br>1.Proxy.newProxyInstance(..)</p><pre><code class="java">/** * 当代理类实例调用方法时, 会自动跳转到代理类关联的 handler 对象, 通过 method.invoke(target, args) 进行调用 * * * @author liuzhihang * @date 2018/5/17 10:49 */public class ProxyMainTest &#123;    public static void main(String[] args) &#123;        Subject subject = new SubjectImpl();        ClassLoader classLoader = subject.getClass().getClassLoader();        Class&lt;?&gt;[] interfaces = subject.getClass().getInterfaces();        MyInvocationHandler handler = new MyInvocationHandler(subject);        // 生成代理类实例        Subject proxyInstance = (Subject) Proxy.newProxyInstance(classLoader, interfaces, handler);        String name = proxyInstance.getName();        String instanceAge = proxyInstance.getAge(&quot;liuzhihang&quot;);        System.err.println(name + &quot; &quot; + instanceAge);    &#125;&#125;</code></pre><p>2.Proxy.getProxyClass(..)</p><pre><code class="java">/** * 当代理类实例调用方法时, 会自动跳转到代理类关联的 handler 对象, 通过 method.invoke(target, args) 进行调用 * 此方式有异常抛出 * * @author liuzhihang * @date 2018/5/17 10:49 */public class ProxyMainTest &#123;    public static void main(String[] args) &#123;        try &#123;        Subject subject = new SubjectImpl();        ClassLoader classLoader = subject.getClass().getClassLoader();        Class&lt;?&gt;[] interfaces = subject.getClass().getInterfaces();        MyInvocationHandler handler = new MyInvocationHandler(subject);            Class&lt;?&gt; proxyClass = Proxy.getProxyClass(classLoader, interfaces);            Constructor&lt;?&gt; constructor = proxyClass.getConstructor(InvocationHandler.class);            Subject subject1 = (Subject) constructor.newInstance(handler);            String name1 = subject1.getName();            String instanceAge1 = subject1.getAge(&quot;liuzhihang&quot;);            System.err.println(name1 + &quot; &quot; + instanceAge1);        &#125; catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException | InstantiationException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><h3 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h3><pre><code>D:\jdk1.8\bin\java.exe . . .liuzhihang 25jdk 动态代理 before . . .当前代理方法为:public abstract java.lang.String com.liuzhihang.tool.proxy.jdk.Subject.getName()SubjectImpl的获取名字方法 . . .jdk 动态代理 after . . .jdk 动态代理 before . . .当前代理方法为:public abstract java.lang.String com.liuzhihang.tool.proxy.jdk.Subject.getAge(java.lang.String)liuzhihang开始获取年龄 . . .jdk 动态代理 after . . .Process finished with exit code 0</code></pre><p>结论: 代理实例在每次调用方法是都会通过代理类进行调用</p><h3 id="相关源码解析"><a href="#相关源码解析" class="headerlink" title="相关源码解析"></a>相关源码解析</h3><p>完整注释可自己查看相关源码, 源码过程应当DeBug多走走.<br>1.调用 Proxy.newProxyInstance 方法</p><pre><code> /** * 返回指定接口的代理类实例，该接口将方法调用分派给指定的调用处理程序 */@CallerSensitivepublic static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException &#123;    // 非空校验    Objects.requireNonNull(h);    final Class&lt;?&gt;[] intfs = interfaces.clone();    // 获取系统安全接口    final SecurityManager sm = System.getSecurityManager();    if (sm != null) &#123;        // 校验权限        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);    &#125;    /*     * 从缓存中获取代理类 或者 生成新的代理类     */    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);    /*     * 通过反射获取构造函数对象并生成代理类实例     */    try &#123;        if (sm != null) &#123;            checkNewProxyPermission(Reflection.getCallerClass(), cl);        &#125;        // 获取构造        final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);        final InvocationHandler ih = h;        // 验证代理类的修饰符        if (!Modifier.isPublic(cl.getModifiers())) &#123;            // 修改访问权限            AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;                public Void run() &#123;                    // 将此对象的可访问标志设置为指定的布尔值, true表示反射对象在使用时应禁止Java语言访问检查, false表示反射对象应强制执行Java语言访问检查                    cons.setAccessible(true);                    return null;                &#125;            &#125;);        &#125;        //生成实例, 并将参数传入构造        return cons.newInstance(new Object[]&#123;h&#125;);    &#125; catch (IllegalAccessException | InstantiationException e) &#123;        throw new InternalError(e.toString(), e);    &#125; catch (InvocationTargetException e) &#123;        Throwable t = e.getCause();        if (t instanceof RuntimeException) &#123;            throw (RuntimeException) t;        &#125; else &#123;            throw new InternalError(t.toString(), t);        &#125;    &#125; catch (NoSuchMethodException e) &#123;        throw new InternalError(e.toString(), e);    &#125;&#125;</code></pre><p>可以看出获取代理类是在 Class&lt;?&gt; cl = getProxyClass0(loader, intfs); 处, 继续相关逻辑<br>2.获取代理类相关逻辑</p><pre><code>/** * 生成代理类, 之前必须进行权限检查 */private static Class&lt;?&gt; getProxyClass0(ClassLoader loader,                                       Class&lt;?&gt;... interfaces) &#123;    if (interfaces.length &gt; 65535) &#123;        throw new IllegalArgumentException(&quot;interface limit exceeded&quot;);    &#125;    //如果由实现给定接口的给定加载器定义的代理类存在，则它将简单地返回缓存副本; 否则，它将通过Proxy Class Factory创建代理类    return proxyClassCache.get(loader, interfaces);&#125;</code></pre><p>3.proxyClassCache.get(loader, interfaces);<br>java.lang.reflect.WeakCache#get(..) 介绍</p><pre><code> /** * 通过缓存查找值, 如果缓存中没有给定的（key，sub Key）对的条目或条目已被清除，则它总是评估&#123;Key sub Key Factory&#125;函数并可选择评估&#123;Factory value&#125;函数 */public V get(K key, P parameter) &#123;    // 非空校验    Objects.requireNonNull(parameter);    // 判断移除队列    expungeStaleEntries();    // 缓存key    Object cacheKey = CacheKey.valueOf(key, refQueue);    // 延迟加载使用二级map    ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap = map.get(cacheKey);    if (valuesMap == null) &#123;        ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; oldValuesMap                = map.putIfAbsent(cacheKey,                valuesMap = new ConcurrentHashMap&lt;&gt;());        if (oldValuesMap != null) &#123;            valuesMap = oldValuesMap;        &#125;    &#125;    // 创建子key 并根据key 检索supplier    Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));    // 根据key获取supplier    Supplier&lt;V&gt; supplier = valuesMap.get(subKey);    Factory factory = null;    while (true) &#123;        if (supplier != null) &#123;            // supplier 可能为 Factory 或者 CacheValue&lt;V&gt; 的实例, 从缓存中获取到则直接返回            V value = supplier.get();            if (value != null) &#123;                return value;            &#125;        &#125;        // factory不存在则创建        if (factory == null) &#123;            factory = new Factory(key, parameter, subKey, valuesMap);        &#125;        // supplier 为null        if (supplier == null) &#123;            // 从valuesMap获取supplier            supplier = valuesMap.putIfAbsent(subKey, factory);            if (supplier == null) &#123;                // successfully installed Factory                supplier = factory;            &#125;            // else retry with winning supplier        &#125; else &#123;            if (valuesMap.replace(subKey, supplier, factory)) &#123;                // successfully replaced                // cleared CacheEntry / unsuccessful Factory                // with our Factory                supplier = factory;            &#125; else &#123;                // retry with current supplier                supplier = valuesMap.get(subKey);            &#125;        &#125;    &#125;&#125;</code></pre><p>可以发现重点在 Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter)); 获取 subKey 的过程中.<br>4.subKeyFactory.apply(key, parameter)<br>Debug发现在此处调用的是 java.lang.reflect.Proxy.ProxyClassFactory 静态内部类,<br>此处根据接口的数量生成二级缓存</p><pre><code class="java"> /** * 一个工厂函数, 用于生成, 定义并返回给定ClassLoader和接口数组的代理类 */private static final class ProxyClassFactory        implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;&#123;    // 所有代理类的前缀    private static final String proxyClassNamePrefix = &quot;$Proxy&quot;;    // next number to use for generation of unique proxy class names    private static final AtomicLong nextUniqueNumber = new AtomicLong();    @Override    public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;        // 在IdentityHashMap中, 当且仅当两个key严格相等（key1==key2）时，IdentityHashMap才认为两个key相等        Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = new IdentityHashMap&lt;&gt;(interfaces.length);        // 循环接口数组        for (Class&lt;?&gt; intf : interfaces) &#123;            /*             * 验证类加载器是否将此接口的名称解析为同一个Class对象             */            Class&lt;?&gt; interfaceClass = null;            try &#123;                // 获取接口的 class                interfaceClass = Class.forName(intf.getName(), false, loader);            &#125; catch (ClassNotFoundException e) &#123;            &#125;            if (interfaceClass != intf) &#123;                throw new IllegalArgumentException(                        intf + &quot; is not visible from class loader&quot;);            &#125;            /*             * 验证interfaceClass是否为接口             */            if (!interfaceClass.isInterface()) &#123;                throw new IllegalArgumentException(                        interfaceClass.getName() + &quot; is not an interface&quot;);            &#125;            /*             * 验证接口是否重复             */            if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) &#123;                throw new IllegalArgumentException(                        &quot;repeated interface: &quot; + interfaceClass.getName());            &#125;        &#125;        String proxyPkg = null;     // package to define proxy class in        int accessFlags = Modifier.PUBLIC | Modifier.FINAL;        /*         * 验证所有非公开代理接口是否在同一个包中         */        for (Class&lt;?&gt; intf : interfaces) &#123;            int flags = intf.getModifiers();            if (!Modifier.isPublic(flags)) &#123;                accessFlags = Modifier.FINAL;                String name = intf.getName();                int n = name.lastIndexOf(&#39;.&#39;);                String pkg = ((n == -1) ? &quot;&quot; : name.substring(0, n + 1));                if (proxyPkg == null) &#123;                    proxyPkg = pkg;                &#125; else if (!pkg.equals(proxyPkg)) &#123;                    throw new IllegalArgumentException(                            &quot;non-public interfaces from different packages&quot;);                &#125;            &#125;        &#125;        if (proxyPkg == null) &#123;            // 如果没有非公开的代理接口，使用 com.sun.proxy package            proxyPkg = ReflectUtil.PROXY_PACKAGE + &quot;.&quot;;        &#125;        /*         * 为要生成的代理类选择一个名称         */        long num = nextUniqueNumber.getAndIncrement();        String proxyName = proxyPkg + proxyClassNamePrefix + num;        /*         * 生成代理类         */        byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);        try &#123;            return defineClass0(loader, proxyName,                    proxyClassFile, 0, proxyClassFile.length);        &#125; catch (ClassFormatError e) &#123;            /*             * A ClassFormatError here means that (barring bugs in the             * proxy class generation code) there was some other             * invalid aspect of the arguments supplied to the proxy             * class creation (such as virtual machine limitations             * exceeded).             */            throw new IllegalArgumentException(e.toString());        &#125;    &#125;&#125;</code></pre><p>5.生辰给代理类<br>byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);<br>可以在测试类中添加以下内容打印出代理类:</p><pre><code>System.setProperty(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);</code></pre><p>代理类内容如下:</p><pre><code class="java">//// Source code recreated from a .class file by IntelliJ IDEA// (powered by Fernflower decompiler)//package com.sun.proxy;import com.liuzhihang.tool.proxy.jdk.Subject;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.lang.reflect.UndeclaredThrowableException;public final class $Proxy0 extends Proxy implements Subject &#123;    private static Method m1;    private static Method m3;    private static Method m2;    private static Method m4;    private static Method m0;    public $Proxy0(InvocationHandler var1) throws  &#123;        super(var1);    &#125;    public final boolean equals(Object var1) throws  &#123;        try &#123;            return (Boolean)super.h.invoke(this, m1, new Object[]&#123;var1&#125;);        &#125; catch (RuntimeException | Error var3) &#123;            throw var3;        &#125; catch (Throwable var4) &#123;            throw new UndeclaredThrowableException(var4);        &#125;    &#125;    public final String getName() throws  &#123;        try &#123;            return (String)super.h.invoke(this, m3, (Object[])null);        &#125; catch (RuntimeException | Error var2) &#123;            throw var2;        &#125; catch (Throwable var3) &#123;            throw new UndeclaredThrowableException(var3);        &#125;    &#125;    public final String toString() throws  &#123;        try &#123;            return (String)super.h.invoke(this, m2, (Object[])null);        &#125; catch (RuntimeException | Error var2) &#123;            throw var2;        &#125; catch (Throwable var3) &#123;            throw new UndeclaredThrowableException(var3);        &#125;    &#125;    public final String getAge(String var1) throws  &#123;        try &#123;            return (String)super.h.invoke(this, m4, new Object[]&#123;var1&#125;);        &#125; catch (RuntimeException | Error var3) &#123;            throw var3;        &#125; catch (Throwable var4) &#123;            throw new UndeclaredThrowableException(var4);        &#125;    &#125;    public final int hashCode() throws  &#123;        try &#123;            return (Integer)super.h.invoke(this, m0, (Object[])null);        &#125; catch (RuntimeException | Error var2) &#123;            throw var2;        &#125; catch (Throwable var3) &#123;            throw new UndeclaredThrowableException(var3);        &#125;    &#125;    static &#123;        try &#123;            m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, Class.forName(&quot;java.lang.Object&quot;));            m3 = Class.forName(&quot;com.liuzhihang.tool.proxy.jdk.Subject&quot;).getMethod(&quot;getName&quot;);            m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;);            m4 = Class.forName(&quot;com.liuzhihang.tool.proxy.jdk.Subject&quot;).getMethod(&quot;getAge&quot;, Class.forName(&quot;java.lang.String&quot;));            m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;);        &#125; catch (NoSuchMethodException var2) &#123;            throw new NoSuchMethodError(var2.getMessage());        &#125; catch (ClassNotFoundException var3) &#123;            throw new NoClassDefFoundError(var3.getMessage());        &#125;    &#125;&#125;</code></pre><p>可以看出生成的$Proxy0类继承Proxy动态代理类并实现了Subject被代理接口, 实现所有方法<br>通过 super.h.invoke(this, m1, new Object[]{var1}) 内部调用了 InvocationHandler.invoke(…)方法, 通过反射调用代理实例的方法</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 动态代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>懒汉单例模式线程安全</title>
      <link href="2018/02/21/lazy-singleton-mode-thread-safe.html"/>
      <url>2018/02/21/lazy-singleton-mode-thread-safe.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>一个类中只有一个实例, 且能够自行实例化提供这个实例, 同时提供全局访问的方法.</p></blockquote><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>1.构造私有化: 确保外部不能使用new直接创建对象<br>2.内部静态属性创建实例<br>3.对外公共静态获取对象方法</p><a id="more"></a><h4 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h4><pre><code class="java">/** * 单例模式 * 1. 构造私有化: 确保外部不能使用new直接创建对象 * 2. 内部静态属性创建实例 * 3. 对外公共静态获取对象方法 * * @author liuzhihang * @date 2018/3/27 17:45 */public class SingletonPattern &#123;    private SingletonPattern() &#123;    &#125;    private static SingletonPattern singletonPattern = null;    public static SingletonPattern getSingletonPattern() &#123;        if (singletonPattern == null) &#123;            singletonPattern = new SingletonPattern();        &#125;        return singletonPattern;    &#125;&#125;</code></pre><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>1.懒汉式: 懒汉模式, 项目启动时不生成对象, 而是在首次创建该对象的时候生成唯一实例</p><pre><code class="java">/** * 懒汉模式, 项目启动时不生成对象, 而是在首次创建该对象的时候生成唯一实例 * * @author liuzhihang * @date 2018/4/2 16:24 */public class LazyPattern &#123;    private LazyPattern() &#123;    &#125;    private static LazyPattern lazyPattern = null;    public static LazyPattern getLazyPattern() &#123;        try &#123;            if (lazyPattern == null) &#123;                // 模拟一系列耗时操作                Thread.sleep(50);                lazyPattern = new LazyPattern();            &#125;        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        return lazyPattern;    &#125;&#125;</code></pre><p>2.饿汉式: 项目启动时, 进行加载, 会导致项目启动较慢, 并且无论后面是否用到都会进行加载</p><pre><code class="java">/** * * 饿汉式单例模式 * 项目启动时, 进行加载, 会导致项目启动较慢, 并且无论后面是否用到都会进行加载 * * @author liuzhihang * @date 2018/4/2 18:44 */public class HungerPattern &#123;    private HungerPattern() &#123;    &#125;    private static HungerPattern hungerPattern = new HungerPattern();    public static HungerPattern getHungerPattern() &#123;        return hungerPattern;    &#125;&#125;</code></pre><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><p>在多线程情况下对单例模式进行测试:</p><pre><code class="java">/** * @author liuzhihang * @date 2018/3/27 19:02 */public class SingletonTest &#123;    public static void main(String[] args) &#123;        ThreadTest[] threadTests = new ThreadTest[10];        for (int i = 0; i &lt; threadTests.length; i++) &#123;            threadTests[i] = new ThreadTest();        &#125;        for (int i = 0; i &lt; threadTests.length; i++) &#123;            threadTests[i].start();        &#125;    &#125;&#125;class ThreadTest extends Thread &#123;    @Override    public void run() &#123;        // 懒汉模式        System.out.println(LazyPattern.getLazyPattern().hashCode());        // 饿汉模式        // System.out.println(HungerPattern.getHungerPattern().hashCode());    &#125;&#125;</code></pre><p>结果:</p><p>1.饿汉模式</p><pre><code>D:\jdk1.8\bin\java.exe . . .1294123621129412362112941236211294123621129412362112941236211294123621129412362112941236211294123621Process finished with exit code 0</code></pre><p>2.懒汉模式</p><pre><code>D:\jdk1.8\bin\java.exe . . .14091981613591281341385166630924507082676413855088322625749263951409198161442414714896298396Process finished with exit code 0</code></pre><p>结论: 在懒汉单例模式下不能保证线程的安全性</p><h3 id="懒汉模式的线程安全优化"><a href="#懒汉模式的线程安全优化" class="headerlink" title="懒汉模式的线程安全优化"></a>懒汉模式的线程安全优化</h3><p>饿汉模式会造成资源浪费, 启动慢等结果, 下面对懒汉模式进行线程安全优化.</p><h4 id="synchronized-锁住静态方法"><a href="#synchronized-锁住静态方法" class="headerlink" title="synchronized 锁住静态方法"></a>synchronized 锁住静态方法</h4><p>锁住静态方法 类级锁 影响范围较大, 导致效率相对较低</p><pre><code class="java">/** * 懒汉式 * 在方法上添加 synchronized 关键字 锁类 * 同步方法的方式, 导致效率相对较低 * * @author liuzhihang * @date 2018/4/3 14:27 */public class SyncLazyPattern &#123;    private SyncLazyPattern() &#123;    &#125;    private static SyncLazyPattern syncLazyPattern = null;    public static synchronized SyncLazyPattern getSyncLazyPattern() &#123;        try &#123;            if (syncLazyPattern == null) &#123;                Thread.sleep(100);                syncLazyPattern = new SyncLazyPattern();            &#125;        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        return syncLazyPattern;    &#125;&#125;</code></pre><h4 id="synchronized-锁住代码块"><a href="#synchronized-锁住代码块" class="headerlink" title="synchronized 锁住代码块"></a>synchronized 锁住代码块</h4><pre><code class="java">package com.liuzhihang.demo.singleton;/** * 锁代码块的方式虽然可以保证结果一致性 * 但锁住很多操作, 同样会导致效率低下 * * @author liuzhihang * @date 2018/4/3 15:22 */public class SyncCodeBlockLazyPattern &#123;    private SyncCodeBlockLazyPattern() &#123;    &#125;    private static SyncCodeBlockLazyPattern syncCodeBlockLazyPattern = null;    public static SyncCodeBlockLazyPattern getSyncCodeBlockLazyPattern() &#123;        try &#123;            // 锁住具体执行业务逻辑的代码            synchronized (SyncCodeBlockLazyPattern.class) &#123;                if (syncCodeBlockLazyPattern == null) &#123;                    Thread.sleep(100);                    syncCodeBlockLazyPattern = new SyncCodeBlockLazyPattern();                &#125;            &#125;        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        return syncCodeBlockLazyPattern;    &#125;&#125;</code></pre><h4 id="双重检查锁机制-推荐"><a href="#双重检查锁机制-推荐" class="headerlink" title="双重检查锁机制(推荐)"></a>双重检查锁机制(推荐)</h4><pre><code class="java">package com.liuzhihang.demo.singleton;/** * 双重锁检查机制, 仅锁住创建对象的部分代码 * 注意: 在对象前 添加 volatile 关键字 确保可见性, 即 每次获取值从主内存中获取, 同时防止指令重排序 * * @author liuzhihang * @date 2018/4/3 15:29 */public class DubboCheckLockLazyPattern &#123;    private DubboCheckLockLazyPattern() &#123;    &#125;    private static volatile DubboCheckLockLazyPattern dubboCheckLockLazyPattern = null;    public static DubboCheckLockLazyPattern getDubboCheckLockLazyPattern() &#123;        try &#123;            if (dubboCheckLockLazyPattern == null) &#123;                // 一系列操作                Thread.sleep(100);                synchronized (DubboCheckLockLazyPattern.class) &#123;                    // 二次检查                    if (dubboCheckLockLazyPattern == null) &#123;                        dubboCheckLockLazyPattern = new DubboCheckLockLazyPattern();                    &#125;                &#125;            &#125;        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        return dubboCheckLockLazyPattern;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>poi读写Excel简单介绍</title>
      <link href="2018/02/15/poi-read-and-write-excel-brief-introduction.html"/>
      <url>2018/02/15/poi-read-and-write-excel-brief-introduction.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>Apache POI 可以对Microsoft Office 进行操作, 下面是工作中使用的对Excel进行读写操作的常用方式.</p></blockquote><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><pre><code class="xml">    &lt;!-- excel poi --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;        &lt;artifactId&gt;poi&lt;/artifactId&gt;        &lt;version&gt;3.17&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;        &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt;        &lt;version&gt;3.17&lt;/version&gt;    &lt;/dependency&gt;</code></pre><a id="more"></a><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>主要介绍读写时, 分别常用到的一些对象及其含义, 方便自己编写util.</p><pre><code class="java">package com.liuzhihang.tool.excel.poi;import org.apache.poi.hssf.usermodel.HSSFWorkbook;import org.apache.poi.ss.usermodel.Row;import org.apache.poi.ss.usermodel.Sheet;import org.apache.poi.ss.usermodel.Workbook;import org.apache.poi.xssf.usermodel.XSSFSheet;import org.apache.poi.xssf.usermodel.XSSFWorkbook;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStream;/** * @author liuzhihang * @date 2018/4/20 16:12 */public class ExcelTest &#123;    public static void main(String[] args) throws Exception &#123;        // readerTest();        writerTest();    &#125;    private static void writerTest() throws IOException &#123;        File file = new File(&quot;c:Users/liuzhihang/Desktop/test.xlsx&quot;);        if (file.exists()) &#123;            System.out.println(&quot;读取的文件存在!&quot;);            file.delete();        &#125;        file.createNewFile();        // 操作 .xls 的 workbook        Workbook hssfWorkbook = new HSSFWorkbook();        // 操作 .xlsx 的 workbook        XSSFWorkbook xssfWorkbook = new XSSFWorkbook();        // 创建 sheet 页        XSSFSheet sheet = xssfWorkbook.createSheet();        // 创建 0 行 操作对象        Row row0 = sheet.createRow(0);        // 创建单元格并赋值        row0.createCell(0).setCellValue(&quot;序号&quot;);        OutputStream outputStream = new FileOutputStream(file);        // 写入文件        xssfWorkbook.write(outputStream);    &#125;    private static void readerTest() throws Exception &#123;        File file = new File(&quot;c:Users/liuzhihang/Desktop/parkingLotTempLate.xlsx&quot;);        Workbook workBook = ExcelUtil.getWorkBook(file);        // 获取 excel 页        // Sheet sheetByIndex = workBook.getSheetAt(0);        // Sheet sheetByName = workBook.getSheet(&quot;Sheet0&quot;);        // 操作 sheet        Sheet sheet = workBook.getSheetAt(0);        // 获取最后一行行数 从 0 开始        int lastRowNum = sheet.getLastRowNum();        // 获取总行数        int physicalNumberOfRows = sheet.getPhysicalNumberOfRows();        // 操作行 获取第0行        Row row = sheet.getRow(0);        String value = row.getCell(0).getStringCellValue();    &#125;&#125;</code></pre><h3 id="ExcelUtil-简单工具"><a href="#ExcelUtil-简单工具" class="headerlink" title="ExcelUtil 简单工具"></a>ExcelUtil 简单工具</h3><p>poi读写 excel 的简单工具 <a href="https://github.com/liuzhihang/my_project/blob/master/my_project_tool/src/main/java/com/liuzhihang/tool/excel/poi/ExcelUtil.java">ExcelUtil</a>, 实际工作中可结合javaBean使用并重新编写util.</p><pre><code class="java">package com.liuzhihang.tool.excel.poi;import lombok.extern.log4j.Log4j2;import org.apache.commons.lang.StringUtils;import org.apache.poi.hssf.usermodel.HSSFWorkbook;import org.apache.poi.ss.usermodel.Cell;import org.apache.poi.ss.usermodel.Row;import org.apache.poi.ss.usermodel.Sheet;import org.apache.poi.ss.usermodel.Workbook;import org.apache.poi.xssf.usermodel.XSSFWorkbook;import java.io.*;import java.util.ArrayList;import java.util.List;/** * @author liuzhihang * @date 2018/4/20 12:02 */@Log4j2public class ExcelUtil &#123;    /**     * 读取两列excel 返回第二列的集合     *     * @param workbook     * @return     */    public static List&lt;String&gt; readExcelForTwoColumns(Workbook workbook) &#123;        if (workbook == null) &#123;            log.info(&quot;获取 workbook 为null&quot;);            return null;        &#125;        List&lt;String&gt; list = new ArrayList&lt;&gt;();        try &#123;            Sheet sheet = workbook.getSheetAt(0);            //获取总行数            int rowNum = sheet.getLastRowNum();            //正文内容应该从第二行开始，第一行为文件的标头的标题            for (int i = 0; i &lt; rowNum; i++) &#123;                Row row = sheet.getRow(i + 1);                String value = getCellValue(row.getCell(1)).toString();                if (StringUtils.isNotBlank(value)) &#123;                    list.add(value);                &#125;            &#125;        &#125; catch (Exception e) &#123;            log.error(e.getMessage());        &#125;        return list;    &#125;    /**     * 写 excel     *     * @param excelFile     * @param list     */    public static void writerExcelForTwoColumns(File excelFile, List&lt;String&gt; list) &#123;        OutputStream outputStream = null;        try &#123;            outputStream = new FileOutputStream(excelFile);            Workbook workBook = null;            String fileName = excelFile.getName();            if (fileName.endsWith(&quot;.xls&quot;)) &#123;                workBook = new HSSFWorkbook();            &#125; else if (fileName.endsWith(&quot;.xlsx&quot;)) &#123;                workBook = new XSSFWorkbook();            &#125; else &#123;                log.info(&quot;文件格式不正确!, 当前文件名:&#123;&#125;&quot;, fileName);                throw new Exception(&quot;文件格式不正确&quot;);            &#125;            // 创建第 0 页            Sheet sheet = workBook.createSheet();            Row row1 = sheet.createRow(0);            row1.createCell(0).setCellValue(&quot;序号&quot;);            row1.createCell(1).setCellValue(&quot;编号&quot;);            for (int i = 0; i &lt; list.size(); i++) &#123;                Row row = sheet.createRow(i + 1);                row.createCell(0).setCellValue(i + 1);                row.createCell(1).setCellValue(list.get(i));            &#125;            workBook.write(outputStream);        &#125; catch (Exception e) &#123;            log.error(&quot;写excel失败&quot;, e);        &#125; finally &#123;            try &#123;                outputStream.close();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    /**     * 获取工作表     *     * @param file     * @return     */    public static Workbook getWorkBook(File file) throws Exception &#123;        String fileName = file.getName();        Workbook workbook = null;        try &#123;            InputStream inputStream = new FileInputStream(file);            if (fileName.endsWith(&quot;.xls&quot;)) &#123;                workbook = new HSSFWorkbook(inputStream);            &#125; else if (fileName.endsWith(&quot;.xlsx&quot;)) &#123;                workbook = new XSSFWorkbook(inputStream);            &#125; else &#123;                log.info(&quot;文件格式不正确!, 当前文件名:&#123;&#125;&quot;, fileName);                throw new Exception(&quot;文件格式不正确&quot;);            &#125;        &#125; catch (Exception e) &#123;            throw e;        &#125;        return workbook;    &#125;    /**     * 获取单元格的数据     *     * @param cell     * @return     */    public static Object getCellValue(Cell cell) &#123;        if (cell != null) &#123;            switch (cell.getCellTypeEnum()) &#123;                // 数字                case NUMERIC:                    return cell.getNumericCellValue();                // 字符串                case STRING:                    return cell.getStringCellValue();                // 公式                case FORMULA:                    return cell.getCellFormula();                // 布尔                case BOOLEAN:                    return cell.getBooleanCellValue();                case ERROR:                    return cell.getErrorCellValue();                // 空                default:                    return &quot;&quot;;            &#125;        &#125;        return &quot;&quot;;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> utils </category>
          
      </categories>
      
      
        <tags>
            
            <tag> poi </tag>
            
            <tag> excel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>protostuff序列化工具</title>
      <link href="2018/02/05/protostuff-serialization-tool.html"/>
      <url>2018/02/05/protostuff-serialization-tool.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>在很多地方都需要用到序列化, 比如在使用redis缓存对象时, 一般情况是实现java Serializable接口. 简单介绍下在慕课网学习到的一个新的序列化工具 —- protostuff.</p><p>在学习中介绍使用该工具可以大大减少对象序列化后字节所占空间, 并提高序列化时间等.</p><p>1.<a href="https://www.imooc.com/video/11823">慕课网课程地址</a><br>2.<a href="https://github.com/eishay/jvm-serializers/wiki">序列化相关工具比较</a></p><a id="more"></a><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><pre><code class="xml">    &lt;!-- protostuff 序列化工具 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.dyuproject.protostuff&lt;/groupId&gt;        &lt;artifactId&gt;protostuff-core&lt;/artifactId&gt;        &lt;version&gt;1.1.3&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.dyuproject.protostuff&lt;/groupId&gt;        &lt;artifactId&gt;protostuff-runtime&lt;/artifactId&gt;        &lt;version&gt;1.1.3&lt;/version&gt;    &lt;/dependency&gt;</code></pre><h3 id="相关使用"><a href="#相关使用" class="headerlink" title="相关使用"></a>相关使用</h3><pre><code class="java">import com.dyuproject.protostuff.LinkedBuffer;import com.dyuproject.protostuff.ProtostuffIOUtil;import com.dyuproject.protostuff.runtime.RuntimeSchema;/** * @author liuzhihang * @date 2018/4/18 15:04 */public class ProtostuffUtil &#123;    public static &lt;T&gt; byte[] serialize(T t, Class&lt;T&gt; cls) &#123;        RuntimeSchema&lt;T&gt; schema = RuntimeSchema.createFrom(cls);        return ProtostuffIOUtil.toByteArray(t, schema, LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE));    &#125;    public static &lt;T&gt; T unSerialize(byte[] bytes, Class&lt;T&gt; cls) &#123;        RuntimeSchema&lt;T&gt; schema = RuntimeSchema.createFrom(cls);        T message = schema.newMessage();        ProtostuffIOUtil.mergeFrom(bytes, message, schema);        return message;    &#125;&#125;</code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><pre><code class="java">import lombok.Data;/** * @author liuzhihang * @date 2018/4/17 19:01 */@Datapublic class User &#123;    private String id;    private String userName;&#125;import com.alibaba.fastjson.JSON;/** * @author liuzhihang * @date 2018/4/17 19:02 */public class ProtostuffTest &#123;    public static void main(String[] args) &#123;        User user = new User();        user.setId(&quot;test0001&quot;);        user.setUserName(&quot;测试用户0001&quot;);        System.out.println(JSON.toJSONString(user));        byte[] serialize = ProtostuffUtil.serialize(user, User.class);        User unSerialize = ProtostuffUtil.unSerialize(serialize, User.class);        System.err.println(JSON.toJSONString(unSerialize));    &#125;&#125;结果:&#123;&quot;id&quot;:&quot;test0001&quot;,&quot;userName&quot;:&quot;测试用户0001&quot;&#125;&#123;&quot;id&quot;:&quot;test0001&quot;,&quot;userName&quot;:&quot;测试用户0001&quot;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> utils </category>
          
      </categories>
      
      
        <tags>
            
            <tag> utils </tag>
            
            <tag> serialize </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Transactional声明式事务</title>
      <link href="2018/01/27/transactional-declarative-transaction.html"/>
      <url>2018/01/27/transactional-declarative-transaction.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>1.声明式事务管理建立在AOP之上的. 其本质是对方法前后进行拦截, 然后在目标方法开始之前创建或者加入一个事务, 在执行完目标方法之后根据执行情况提交或者回滚事务.<br>2.声明式事务最大的优点就是不需要通过编程的方式管理事务, 这样就不需要在业务逻辑代码中掺杂事务管理的代码, 只需在配置文件中做相关的事务规则声明(或通过基于@Transactional注解的方式), 便可以将事务规则应用到业务逻辑中.<br>3.声明式事务不足的地方在于, 与编程式事务相比, 只能作用到方法级别, 无法像编程式事务那样可以作用到代码块级别.</p><h3 id="xml配置"><a href="#xml配置" class="headerlink" title="xml配置"></a>xml配置</h3><p>1.添加命名空间</p><a id="more"></a><pre><code class="xml">&lt;beans  xmlns=&quot;http://www.springframework.org/schema/beans&quot;        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;        . . .        xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;        xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;        xsi:schemaLocation=&quot;        . . .        http://www.springframework.org/schema/tx        http://www.springframework.org/schema/tx/spring-tx-3.0.xsd&quot;&gt;</code></pre><p>2.添加相关事务支持</p><pre><code class="xml">    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;        &lt;!-- 指向数据源 --&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;masterDataSource&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 开启事务的Annotation支持 --&gt;    &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;</code></pre><h3 id="Transactional注解-使用"><a href="#Transactional注解-使用" class="headerlink" title="@Transactional注解 使用"></a>@Transactional注解 使用</h3><p>@Transactional 可以作用于接口,接口方法,类以及类方法上. 只需要在相应接口,类或方法上加上@Transactional注解即可.</p><h3 id="Transactional-注解介绍"><a href="#Transactional-注解介绍" class="headerlink" title="@Transactional 注解介绍"></a>@Transactional 注解介绍</h3><pre><code class="java">package org.springframework.transaction.annotation;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import org.springframework.core.annotation.AliasFor;import org.springframework.transaction.TransactionDefinition;import org.springframework.transaction.annotation.Isolation;import org.springframework.transaction.annotation.Propagation;/** * @Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;) : 可用于接口, 类, 枚举, 注解, 方法 * @Retention(RetentionPolicy.RUNTIME) : 注解会在class字节码文件中存在，在运行时可以通过反射获取到 * @Inherited :　子类可以继承父类中的注解 * @Documented : 注解将被包含在javadoc中 */@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface Transactional &#123;    /**     * 事务管理器的别名     * 系统指定多个事务管理器时可通过别名进行区分     */    @AliasFor(&quot;transactionManager&quot;)    String value() default &quot;&quot;;    /**     * 可通过在 transactionManager 中设置 &lt;qualifier value=&quot;managerOne&quot;/&gt; 属性类指定名称     * 可用于确定目标事务管理器，匹配特定的限定符值（或bean名称）     */    @AliasFor(&quot;value&quot;)    String transactionManager() default &quot;&quot;;    /**     * 事务的传播机制     * 默认 Propagation.REQUIRED     */    Propagation propagation() default Propagation.REQUIRED;    /**     * 事务的隔离级别     * 默认 Isolation.DEFAULT     */    Isolation isolation() default Isolation.DEFAULT;    /**     * 事务超时时间     * 默认 TransactionDefinition.TIMEOUT_DEFAULT 即 -1     */    int timeout() default TransactionDefinition.TIMEOUT_DEFAULT;    /**     * 设置事务只读     */    boolean readOnly() default false;    /**     * 设置需要进行回滚的异常类数组，当方法中抛出指定异常数组中的异常时，则进行事务回滚     * rollbackFor = Exception.class 或 rollbackFor = &#123;RuntimeException.class, Exception.class&#125;     */    Class&lt;? extends Throwable&gt;[] rollbackFor() default &#123;&#125;;    /**     * 设置需要进行回滚的异常类名称数组，当方法中抛出指定异常名称数组中的异常时, 事务进行回滚     */    String[] rollbackForClassName() default &#123;&#125;;    /**     * 设置不需要进行回滚的异常类数组，当方法中抛出指定异常数组中的异常时，则不进行事务回滚     */    Class&lt;? extends Throwable&gt;[] noRollbackFor() default &#123;&#125;;    /**     * 设置不需要进行回滚的异常类名称数组，当方法中抛出指定异常名称数组中的异常时, 事务不进行回滚     */    String[] noRollbackForClassName() default &#123;&#125;;&#125;</code></pre><h3 id="传播行为介绍"><a href="#传播行为介绍" class="headerlink" title="传播行为介绍"></a>传播行为介绍</h3><p>事务的传播行为, 一共 7 种<br>1.枚举介绍</p><pre><code class="java">package org.springframework.transaction.annotation;import org.springframework.transaction.TransactionDefinition;public enum Propagation &#123;    /**     * 支持当前事务, 如果不存在, 则创建一个新事务     * 事务的默认设置     */    REQUIRED(TransactionDefinition.PROPAGATION_REQUIRED),    /**     * 支持当前事务, 如果不存在, 则以非事务方式执行     */    SUPPORTS(TransactionDefinition.PROPAGATION_SUPPORTS),    /**     * 支持当前事务, 如果不存在则抛出异常     */    MANDATORY(TransactionDefinition.PROPAGATION_MANDATORY),    /**     * 开始一个新的事务, 并暂停当前事务(如果存在)     */    REQUIRES_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW),    /**     * 以非事务方式执行, 暂停当前事务(如果存在)     */    NOT_SUPPORTED(TransactionDefinition.PROPAGATION_NOT_SUPPORTED),    /**     * 以非事务方式执行, 如果存在则抛出异常     */    NEVER(TransactionDefinition.PROPAGATION_NEVER),    /**     * 如果当前事务存在, 则在嵌套事务中执行.     * 如果事务不存在, 则等同于 PROPAGATION_REQUIRED     */    NESTED(TransactionDefinition.PROPAGATION_NESTED);    private final int value;    Propagation(int value) &#123; this.value = value; &#125;    public int value() &#123; return this.value; &#125;&#125;</code></pre><p>2.列表</p><table><thead><tr><th>Propagation</th><th>含义</th></tr></thead><tbody><tr><td>REQUIRED</td><td>支持当前事务, 如果不存在, 则创建一个新事务</td></tr><tr><td>SUPPORTS</td><td>支持当前事务, 如果不存在, 则以非事务方式执行</td></tr><tr><td>MANDATORY</td><td>支持当前事务, 如果不存在则抛出异常</td></tr><tr><td>REQUIRES_NEW</td><td>开始一个新的事务, 并暂停当前事务(如果存在)</td></tr><tr><td>NOT_SUPPORTED</td><td>以非事务方式执行, 暂停当前事务(如果存在)</td></tr><tr><td>NEVER</td><td>以非事务方式执行, 如果存在则抛出异常</td></tr><tr><td>NESTED</td><td>如果当前事务存在, 则在嵌套事务中执行. 如果事务不存在, 则等同于 PROPAGATION_REQUIRED</td></tr></tbody></table><h3 id="隔离级别介绍"><a href="#隔离级别介绍" class="headerlink" title="隔离级别介绍"></a>隔离级别介绍</h3><p>1.枚举介绍</p><pre><code class="java">package org.springframework.transaction.annotation;import org.springframework.transaction.TransactionDefinition;public enum Isolation &#123;    /**     * 使用底层数据存储默认的隔离级别     * 一般存储底层默认为: READ_COMMITTED     */    DEFAULT(TransactionDefinition.ISOLATION_DEFAULT),    /**     * 读未提交     * 会出现脏读和不可重复读, 一般不使用     */    READ_UNCOMMITTED(TransactionDefinition.ISOLATION_READ_UNCOMMITTED),    /**     * 读已提交     * 该级别仅禁止事务读取其中未提交更改的行     * 可能会出现不可重复读取和幻像读取     */    READ_COMMITTED(TransactionDefinition.ISOLATION_READ_COMMITTED),    /**     * 可重复读     * 禁止事务读取其中有未提交更改的行, 并且还禁止一个事务读取一行, 第二个事务更改该行. 并且第一个事务重新读取该行, 第二次获取不同值的情况     * 即 禁止 读未提交, 不可重复读     * 会出现幻读     */    REPEATABLE_READ(TransactionDefinition.ISOLATION_REPEATABLE_READ),    /**     * 串行     * 所有事物依次执行, 不会影响别的事务, 所以会防止 不可重复读 脏读 幻读     * 会影响性能     */    SERIALIZABLE(TransactionDefinition.ISOLATION_SERIALIZABLE);    private final int value;    Isolation(int value) &#123; this.value = value; &#125;    public int value() &#123; return this.value; &#125;&#125;</code></pre><p>2.列表</p><table><thead><tr><th>Isolation</th><th>含义</th></tr></thead><tbody><tr><td>DEFAULT</td><td>使用底层数据存储默认的隔离级别, 一般存储底层默认为: READ_COMMITTED</td></tr><tr><td>READ_UNCOMMITTED</td><td>读未提交, 会出现脏读和不可重复读, 一般不使用</td></tr><tr><td>READ_COMMITTED</td><td>该级别仅禁止事务读取其中未提交更改的行. 可能会出现不可重复读取和幻像读取</td></tr><tr><td>REPEATABLE_READ</td><td>可重复读, 禁止事务读取其中有未提交更改的行, 并且还禁止一个事务读取一行, 第二个事务更改该行. 并且第一个事务重新读取该行, 第二次获取不同值的情况. 即 禁止 读未提交, 不可重复读. 会出现幻读</td></tr><tr><td>SERIALIZABLE</td><td>串行, 所有事物依次执行, 不会影响别的事务, 所以会防止 不可重复读 脏读 幻读. 会影响性能</td></tr></tbody></table><p>3.脏读 幻读 不可重复读</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>脏读</td><td>当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。</td></tr><tr><td>幻读</td><td>事务读取时不存在该数据, 读取后发现该数据存在. 中间因为别的事务在进行插入操作</td></tr><tr><td>不可重复读</td><td>一个事务在读取该数据时另一个事务在修改该数据, 导致多次读取数据内容不一致</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> transactional </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整数包装类型的缓存</title>
      <link href="2018/01/15/integer-wrapper-type-cache.html"/>
      <url>2018/01/15/integer-wrapper-type-cache.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>部分包装类型存在缓存机制, 会在JVM启动时, 缓存一定数量的对象, 有助于节省内存, 提高性能.</p></blockquote><h3 id="缓存区间"><a href="#缓存区间" class="headerlink" title="缓存区间"></a>缓存区间</h3><table><thead><tr><th>类型</th><th>范围</th><th>是否修改</th></tr></thead><tbody><tr><td>Integer</td><td>-128 到 127</td><td>true : -XX:AutoBoxCacheMax=size 修改</td></tr><tr><td>ByteCache</td><td>-128 到 127</td><td>false</td></tr><tr><td>ShortCache</td><td>-128 到 127</td><td>false</td></tr><tr><td>LongCache</td><td>-128 到 127</td><td>false</td></tr><tr><td>CharacterCache</td><td>0 到 127</td><td>false</td></tr></tbody></table><a id="more"></a><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><pre><code class="java">    Integer a = 100;    Integer b = 100;    Integer c = 1000;    Integer d = 1000;    Integer e = new Integer(100);    Integer f = Integer.valueOf(100);    System.out.println(a == b); // true    System.out.println(c == d); // false    System.out.println(a == e); // false    System.out.println(f == e); // false    System.out.println(a == f); // true</code></pre><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>== 在比较对象时, 判断是否指向同一地址</p><p>a b f 都是从缓存中取出数据, 所以地址是相同的</p><p>c d 不在缓存范围内, 所以是新的对象</p><p>e 是新对象</p><h3 id="IntegerCache"><a href="#IntegerCache" class="headerlink" title="IntegerCache"></a>IntegerCache</h3><pre><code class="java">private static class IntegerCache &#123;        static final int low = -128;        static final int high;        static final Integer cache[];        static &#123;            // high value may be configured by property            int h = 127;            String integerCacheHighPropValue =                sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);            if (integerCacheHighPropValue != null) &#123;                try &#123;                    int i = parseInt(integerCacheHighPropValue);                    i = Math.max(i, 127);                    // Maximum array size is Integer.MAX_VALUE                    h = Math.min(i, Integer.MAX_VALUE - (-low) -1);                &#125; catch( NumberFormatException nfe) &#123;                    // If the property cannot be parsed into an int, ignore it.                &#125;            &#125;            high = h;            cache = new Integer[(high - low) + 1];            int j = low;            for(int k = 0; k &lt; cache.length; k++)                cache[k] = new Integer(j++);            // range [-128, 127] must be interned (JLS7 5.1.7)            assert IntegerCache.high &gt;= 127;        &#125;        private IntegerCache() &#123;&#125;    &#125;</code></pre><p>可以通过设置 java.lang.Integer.IntegerCache.high 来修改缓存的值. 方法为修改 JVM 的启动参数 -XX:AutoBoxCacheMax=size</p>]]></content>
      
      
      <categories>
          
          <category> 源码学习 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Interceptor拦截器</title>
      <link href="2018/01/10/interceptor.html"/>
      <url>2018/01/10/interceptor.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Interceptor: 拦截器，作用类似 Filter, 主要作用是拦截用户请求, 在 Action 执行的前后各执行一段代码, 进行相应的业务处理.</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>权限认证<br>统一逻辑处理<br>日志监控等</p><a id="more"></a><h3 id="使用方式及方法介绍"><a href="#使用方式及方法介绍" class="headerlink" title="使用方式及方法介绍"></a>使用方式及方法介绍</h3><p>使用方式分为两种, 一种为: 实现HandlerInterceptor接口或者是继承实现了HandlerInterceptor接口的类, 另一种为: 实现Spring的WebRequestInterceptor接口, 或者是继承实现了WebRequestInterceptor的类.<br>1.HandlerInterceptor 介绍</p><pre><code class="java">package org.springframework.web.servlet;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public interface HandlerInterceptor &#123;    /**     * 请求处理之前调用 链式 会按照声明顺序依次执行     * 返回 true 则继续执行下一个 Interceptor 无则执行 Controller     * 返回 false 请求结束     */    boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception;    /**     * 在请求处理之后，DispatcherServlet进行视图返回渲染之前进行调用，可以在这个方法中对Controller 处理之后的ModelAndView 对象进行操作。     * 调度程序Servlet在执行链中处理一个处理程序，由任意数量的拦截器组成，处理器本身在最后。 使用这种方法，每个拦截器可以后处理一个执行，并按照执行链的相反顺序进行应用     */    void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception;    /**     * 请求处理完成后的回调，即渲染视图后的回调。 将被调用处理程序执行的任何结果，从而允许适当的资源清理。     * 注意：只有当这个拦截器的预处理方法已经成功完成并返回时才会被调用     * 与postHandle方法一样，该方法将以相反的顺序在链中的每个拦截器上调用，因此第一个拦截器将成为最后被调用的拦截器     */    void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception;&#125;</code></pre><p>2.WebRequestInterceptor 介绍</p><pre><code class="java">package org.springframework.web.context.request;import org.springframework.ui.ModelMap;import org.springframework.web.context.request.WebRequest;public interface WebRequestInterceptor &#123;    /**     * 在调用之前拦截请求处理程序的执行。 允许准备上下文资源（如Hibernate Session）并将它们公开为请求属性或线程本地对象.     * 即 准备一些需要的资源, 例如, 将请求属性放置到 WebRequest 中     * 无返回对象     */    void preHandle(WebRequest request) throws Exception;    /**     * 在视图呈现前（如果有的话）在成功调用之后拦截请求处理程序的执行。     * 允许在成功处理程序执行后修改上下文资源（例如，刷新休眠会话）     * 可以通过修改 ModelMap 的属性来改变你返回的试图模型     */    void postHandle(WebRequest request, ModelMap model) throws Exception;    /**     * 求处理完成后的回调，即渲染视图后的回调。 将被调用处理程序执行的任何结果，从而允许适当的资源清理。     * 注意：只有在拦截器的预处理方法成功完成时才会调用     */    void afterCompletion(WebRequest request, Exception ex) throws Exception;&#125;</code></pre><h3 id="xml-配置"><a href="#xml-配置" class="headerlink" title="xml 配置"></a>xml 配置</h3><p>1.在 *-servlet.xml 中添加 MVC schema</p><pre><code class="xml">    xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;    xsi:schemaLocation=&quot; http://www.springframework.org/schema/mvc    http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd&quot;</code></pre><p>2.配置 mvc:interceptors 标签</p><pre><code class="xml">    &lt;mvc:interceptors&gt;        &lt;mvc:interceptor&gt;            &lt;!-- 拦截路径 --&gt;            &lt;mvc:mapping path=&quot;/**&quot;/&gt;            &lt;!-- 指定拦截器 --&gt;            &lt;bean class=&quot;com.liuzhihang.myprojext.controller.interceptor.RequestInterceptor&quot;/&gt;        &lt;/mvc:interceptor&gt;    &lt;/mvc:interceptors&gt;</code></pre><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><pre><code class="java">package com.liuzhihang.myprojext.controller.interceptor;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class RequestInterceptor implements HandlerInterceptor &#123;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        // 处理逻辑        return true;    &#125;    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;    &#125;    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interceptor </tag>
            
            <tag> Spring </tag>
            
            <tag> servlet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>utils工具--ValidationUtil 参数校验</title>
      <link href="2017/12/30/utils-tool-validationutil-parameter-check.html"/>
      <url>2017/12/30/utils-tool-validationutil-parameter-check.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在工作中不可避免的要面对很多参数校验, 比如写新接口时需要对传入VO的必要字段进行校验, String 是否为空, Integer 最小值, 对象是否为null, 等等.<br>而使用 hibernate的validator工具对参数进行校验, 可以极大的简化流程, 当然不可避免的就是需要在被校验字段上加上注解信息.</p><h6 id="1-相关依赖"><a href="#1-相关依赖" class="headerlink" title="1. 相关依赖"></a>1. 相关依赖</h6><pre><code class="xml">    &lt;!-- 参数校验工具 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.hibernate&lt;/groupId&gt;        &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;        &lt;version&gt;5.4.2.Final&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.glassfish.web&lt;/groupId&gt;        &lt;artifactId&gt;el-impl&lt;/artifactId&gt;        &lt;version&gt;2.2&lt;/version&gt;    &lt;/dependency&gt;</code></pre><a id="more"></a><h6 id="2-ValidationUtil"><a href="#2-ValidationUtil" class="headerlink" title="2. ValidationUtil"></a>2. ValidationUtil</h6><p>对加上相关注解字段进行校验, 使用到 <a href="https://github.com/liuzhihang/tool_demo/blob/master/src/main/java/com/liuzhihang/tool/xml/JaxbUtil.java">ValidationUtil.java</a>和<a href="https://github.com/liuzhihang/tool_demo/blob/master/src/main/java/com/liuzhihang/tool/validate/ValidationResult.java">ValidationResult.java</a>两个文件, 也可在工具中直接抛出异常.</p><p>ValidationUtil 内容如下:</p><pre><code class="java">package com.liuzhihang.tool.validate;import org.apache.commons.collections.CollectionUtils;import javax.validation.ConstraintViolation;import javax.validation.Validation;import javax.validation.Validator;import java.beans.IntrospectionException;import java.beans.Introspector;import java.beans.PropertyDescriptor;import java.util.Set;/** * 对添加 hibernate.validator 注解的字段进行校验 * * 使用前 需要引入 hibernate-validator 依赖 * * @author liuzhihang * @date 2017/11/22 11:08 */public class ValidationUtil &#123;    private static Validator validator = Validation.buildDefaultValidatorFactory().getValidator();    /**     * 会 验证 所有字段     *     * @param obj     * @param &lt;T&gt;     * @return 返回所有不符合的信息     */    public static &lt;T&gt; ValidationResult validateAllField(T obj) &#123;        ValidationResult result = new ValidationResult(true);        StringBuilder errorMsg = new StringBuilder();        if (obj == null) &#123;            result.setHasPass(false);            result.setErrorMsg(&quot;The class is null!&quot;);            return result;        &#125;        Set&lt;ConstraintViolation&lt;T&gt;&gt; violationSet = validator.validate(obj);        if (CollectionUtils.isNotEmpty(violationSet)) &#123;            for (ConstraintViolation&lt;T&gt; violation : violationSet) &#123;                errorMsg.append(violation.getMessage());            &#125;            result.setHasPass(false);            result.setErrorMsg(errorMsg.toString());        &#125;        return result;    &#125;    /**     * 验证指定字段 是否符合信息     *     * @param obj     * @param fieldName     * @param &lt;T&gt;     * @return     */    public static &lt;T&gt; ValidationResult validateOneField(T obj, String fieldName) &#123;        ValidationResult result = new ValidationResult(true);        if (obj == null) &#123;            result.setHasPass(false);            result.setErrorMsg(&quot;The class is null!&quot;);            return result;        &#125;        Set&lt;ConstraintViolation&lt;T&gt;&gt; violationSet = validator.validateProperty(obj, fieldName);        if (CollectionUtils.isNotEmpty(violationSet)) &#123;            for (ConstraintViolation&lt;T&gt; violation : violationSet) &#123;                result.setHasPass(false);                result.setErrorMsg(violation.getMessage());            &#125;        &#125;        return result;    &#125;    /**     * 验证 所有字段, 当第一个不符合时 则直接返回信息     *     * @param obj     * @param &lt;T&gt;     * @return     */    public static &lt;T&gt; ValidationResult validateAllFieldForOneBack(T obj) &#123;        ValidationResult result = new ValidationResult(true);        if (obj == null) &#123;            result.setHasPass(false);            result.setErrorMsg(&quot;The class is null!&quot;);            return result;        &#125;        try &#123;            PropertyDescriptor[] propertyDescriptors = Introspector.getBeanInfo(obj.getClass()).getPropertyDescriptors();            for (PropertyDescriptor propertyDescriptor : propertyDescriptors) &#123;                result = validateOneField(obj, propertyDescriptor.getName());                if (result.getHasPass()) &#123;                    return result;                &#125;            &#125;        &#125; catch (IntrospectionException e) &#123;            result.setHasPass(false);            result.setErrorMsg(&quot;This validate has error : &quot; + e);        &#125;        return result;    &#125;&#125;</code></pre><p>ValidationResult 内容如下:</p><pre><code class="java">package com.liuzhihang.tool.validate;/** * @Description: * @Author: liuzhihang * @Date: 2018/1/6 17:57 */public class ValidationResult &#123;    private Boolean hasPass;    private String errorMsg;    public ValidationResult(Boolean hasPass) &#123;        this.hasPass = hasPass;    &#125;    public Boolean getHasPass() &#123;        return hasPass;    &#125;    public void setHasPass(Boolean hasPass) &#123;        this.hasPass = hasPass;    &#125;    public String getErrorMsg() &#123;        return errorMsg;    &#125;    public void setErrorMsg(String errorMsg) &#123;        this.errorMsg = errorMsg;    &#125;    @Override    public String toString() &#123;        return &quot;ValidationResult&#123;&quot; +                &quot;hasPass=&quot; + hasPass +                &quot;, errorMsg=&#39;&quot; + errorMsg + &#39;\&#39;&#39; +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><h6 id="3-常用注解"><a href="#3-常用注解" class="headerlink" title="3. 常用注解"></a>3. 常用注解</h6><pre><code>Bean Validation 中内置的 constraint@Null   被注释的元素必须为 null@NotNull    被注释的元素必须不为 null@AssertTrue     被注释的元素必须为 true@AssertFalse    被注释的元素必须为 false@Min(value)     被注释的元素必须是一个数字，其值必须大于等于指定的最小值@Max(value)     被注释的元素必须是一个数字，其值必须小于等于指定的最大值@DecimalMin(value)  被注释的元素必须是一个数字，其值必须大于等于指定的最小值@DecimalMax(value)  被注释的元素必须是一个数字，其值必须小于等于指定的最大值@Size(max=, min=)   被注释的元素的大小必须在指定的范围内@Digits (integer, fraction)     被注释的元素必须是一个数字，其值必须在可接受的范围内@Past   被注释的元素必须是一个过去的日期@Future     被注释的元素必须是一个将来的日期@Pattern(regex=,flag=)  被注释的元素必须符合指定的正则表达式Hibernate Validator 附加的 constraint@NotBlank(message =)   验证字符串非null，且长度必须大于0@Email  被注释的元素必须是电子邮箱地址@Length(min=,max=)  被注释的字符串的大小必须在指定的范围内@NotEmpty   被注释的字符串的必须非空@Range(min=,max=,message=)  被注释的元素必须在合适的范围内</code></pre><h6 id="4-测试示例"><a href="#4-测试示例" class="headerlink" title="4 测试示例"></a>4 测试示例</h6><p><a href="https://github.com/liuzhihang/tool_demo/blob/master/src/main/java/com/liuzhihang/tool/validate/ValidationVo.java">代码</a>:</p><pre><code class="java">package com.liuzhihang.tool.validate;import lombok.Data;import org.hibernate.validator.constraints.NotBlank;import org.hibernate.validator.constraints.NotEmpty;import javax.validation.constraints.Min;import javax.validation.constraints.NotNull;/** * @author liuzhihang * @date 2017/11/22 18:25 */@Datapublic class ValidationVo &#123;    @NotBlank(message = &quot;The name must notEmpty!&quot;)    private String name;    @NotNull(message = &quot;The age must notNull!&quot;)    @Min(value = 1, message = &quot;The age must greater than 0!&quot;)    private Integer age;    public static void main(String[] args) &#123;        ValidationVo validationVo = new ValidationVo();        System.out.println(ValidationUtil.validateAllField(validationVo).toString());        validationVo.setAge(1);        System.out.println(ValidationUtil.validateAllField(validationVo).toString());        validationVo.setName(&quot;二蛋&quot;);        System.out.println(ValidationUtil.validateAllField(validationVo).toString());    &#125;&#125;</code></pre><p>输出结果:</p><pre><code>ValidationResult&#123;hasPass=false, errorMsg=&#39;The name must notEmpty!The age must notNull!&#39;&#125;ValidationResult&#123;hasPass=false, errorMsg=&#39;The name must notEmpty!&#39;&#125;ValidationResult&#123;hasPass=true, errorMsg=&#39;null&#39;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> utils </category>
          
      </categories>
      
      
        <tags>
            
            <tag> utils </tag>
            
            <tag> validation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xml解析--dom4j</title>
      <link href="2017/12/30/xml-parsing-dom4j.html"/>
      <url>2017/12/30/xml-parsing-dom4j.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在工作中有时候会用到dom4j对xml文件或者字符串进行解析, 以下内容为随手笔记, 防止以后遗忘.</p><h5 id="1-相关依赖"><a href="#1-相关依赖" class="headerlink" title="1. 相关依赖"></a>1. 相关依赖</h5><pre><code class="xml">    &lt;!-- dom4j --&gt;    &lt;dependency&gt;        &lt;groupId&gt;dom4j&lt;/groupId&gt;        &lt;artifactId&gt;dom4j&lt;/artifactId&gt;        &lt;version&gt;1.6.1&lt;/version&gt;    &lt;/dependency&gt;</code></pre><a id="more"></a><h5 id="2-获取dom对象"><a href="#2-获取dom对象" class="headerlink" title="2. 获取dom对象"></a>2. 获取dom对象</h5><p>获取dom对象方式主要以下几种:</p><pre><code class="java">    // 读取 xml 文件 方式    SAXReader reader = new SAXReader();    Document doc1 = reader.read(new File(&quot;src/main/java/com/liuzhihang/tool/xml/alipay.xml&quot;));    // 解析 xml 文本 方式    String aliPayStr = XmlTest.getAliPayStr();    Document doc2 = DocumentHelper.parseText(aliPayStr);    // 主动创建    Document doc3 = DocumentHelper.createDocument();    Element element = doc3.addElement(&quot;Test&quot;);</code></pre><h6 id="3-操作dom对象"><a href="#3-操作dom对象" class="headerlink" title="3. 操作dom对象"></a>3. 操作dom对象</h6><p>当获取到dom对象后便可以通过以下方式对dom进行操作</p><pre><code class="java">    // 获取根节点    Element rootElement = dom.getRootElement();    // System.out.println(rootElement.getName());    // 获取子节点    Element element = rootElement.element(&quot;response&quot;).element(&quot;alipay&quot;);    // System.out.println(element.asXML());    // 获取节点的文字    String text = element.element(&quot;alipay_buyer_login_id&quot;).getText();    // System.out.println(text);    // 获取节点下的所有节点 快捷键 iter / itco    List elements = element.elements();    // for (Object o : elements) &#123;    //     Element tempElement = (Element) o;    //     System.out.println(tempElement.getName() + &quot;\t&quot; + tempElement.getText());    // &#125;    // for (Iterator iterator = elements.iterator(); iterator.hasNext(); ) &#123;    //     Element next =  (Element)iterator.next();    //     System.out.println(next.getName() + &quot;\t&quot; + next.getText());    // &#125;    // 获取节点下所有节点 Iterator对象 快捷键 itit    Iterator iterator = element.elementIterator();    // while (iterator.hasNext()) &#123;    //     Element next =  (Element)iterator.next();    //     System.out.println(next.getName() + &quot;\t&quot; + next.getText());    // &#125;    // 添加节点    Element testElement = element.addElement(&quot;testElement&quot;);    // 指定添加文字    testElement.setText(&quot;测试添加文字&quot;);    System.out.println(element.asXML());    // 删除节点    boolean remove = element.remove(testElement);    System.out.println(remove + &quot;\n&quot; + element.asXML());</code></pre><h6 id="4-详细代码"><a href="#4-详细代码" class="headerlink" title="4. 详细代码"></a>4. 详细代码</h6><p><a href="https://github.com/liuzhihang/tool_demo/blob/master/src/main/java/com/liuzhihang/tool/xml/Dom4jTest.java">Dom4jTest.java</a></p>]]></content>
      
      
      <categories>
          
          <category> utils </category>
          
      </categories>
      
      
        <tags>
            
            <tag> utils </tag>
            
            <tag> xml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xml解析--JaxbUtil</title>
      <link href="2017/12/17/xml-parsing-jaxbutil.html"/>
      <url>2017/12/17/xml-parsing-jaxbutil.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>主要介绍使用jaxb对xml进行解析, 互转.</p><p>jaxb 是相对较多的xml工具, 只需要在javaBean的属性上添加相应注解, 就可以使用工具进行解析. 具体使用过程如下:</p><h5 id="1-编写javaBean并添加注解"><a href="#1-编写javaBean并添加注解" class="headerlink" title="1. 编写javaBean并添加注解"></a>1. 编写javaBean并添加注解</h5><p>使用过程中一般常用@XmlRootElement, @XmlAccessorType, @XmlElement, @XmlAttribute四个注解, 其余使用方式可以再自行深入研究.</p><pre><code class="java">@XmlRootElement: 根元素@XmlAccessorType: java对象生成xml文件时对java对象属性的访问方式    属性为XmlAccessType.FIELD 指java所有成员变量@XmlElement: 子节点, name 可指定节点名@XmlAttribute: 映射为xml文件的属性, name 可指定属性名</code></pre><a id="more"></a><p>javaBean:</p><pre><code class="java">@Data@XmlRootElement(name = &quot;alipay&quot;)@XmlAccessorType(XmlAccessType.FIELD)class AliPayXml &#123;    @XmlElement(name = &quot;alipay_buyer_login_id&quot; )    private String buyerLoginId;    @XmlElement(name = &quot;alipay_buyer_user_id&quot;)    private String buyerUserId;&#125;</code></pre><h5 id="2-使用-JaxbUtil"><a href="#2-使用-JaxbUtil" class="headerlink" title="2. 使用 JaxbUtil"></a>2. 使用 JaxbUtil</h5><p><a href="https://github.com/liuzhihang/tool_demo/blob/master/src/main/java/com/liuzhihang/tool/xml/JaxbUtil.java">JaxbUtil</a>代码</p><pre><code class="java">package com.liuzhihang.tool.xml;import javax.xml.bind.JAXBContext;import javax.xml.bind.JAXBException;import javax.xml.bind.Marshaller;import javax.xml.bind.Unmarshaller;import java.io.StringReader;import java.io.StringWriter;/** * Jaxb 工具 * * @author liuzhihang * @date 2017/11/28 19:13 */public class JaxbUtil &#123;    private static final String CHARTSET = &quot;UTF-8&quot;;    public static String bean2Xml(Object obj) throws JAXBException &#123;        return bean2Xml(obj, CHARTSET);    &#125;    public static String bean2Xml(Object obj, String chartset) throws JAXBException &#123;        JAXBContext jaxbContext = JAXBContext.newInstance(obj.getClass());        Marshaller marshaller = jaxbContext.createMarshaller();        marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);        marshaller.setProperty(Marshaller.JAXB_ENCODING, chartset);        StringWriter writer = new StringWriter();        marshaller.marshal(obj, writer);        return writer.getBuffer().toString();    &#125;    public static &lt;T&gt; T xml2Bean(String xmlString, Class&lt;T&gt; clazz) throws JAXBException &#123;        JAXBContext jaxbContext = JAXBContext.newInstance(clazz);        Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();        T t = (T) unmarshaller.unmarshal(new StringReader(xmlString));        return t;    &#125;&#125;</code></pre><h5 id="3-测试代码"><a href="#3-测试代码" class="headerlink" title="3. 测试代码"></a>3. 测试代码</h5><p>待测试字符串: xmlStr</p><pre><code class="xml">&lt;alipay&gt;  &lt;alipay_buyer_login_id&gt;176****3035&lt;/alipay_buyer_login_id&gt;  &lt;alipay_buyer_user_id&gt;2088912868994947&lt;/alipay_buyer_user_id&gt;&lt;/alipay&gt;</code></pre><p>测试代码:</p><pre><code class="java">/** * @Description: * @Author: liuzhihang * @Date: 2017/12/17 23:11 */public class JaxbTest &#123;    public static void main(String[] args) throws JAXBException &#123;        String aliPayXmlStr = &quot;&lt;alipay&gt;\n&quot; +                &quot;  &lt;alipay_buyer_login_id&gt;176****3035&lt;/alipay_buyer_login_id&gt;\n&quot; +                &quot;  &lt;alipay_buyer_user_id&gt;2088912868994947&lt;/alipay_buyer_user_id&gt;\n&quot; +                &quot;&lt;/alipay&gt;&quot;;        AliPayXml aliPayXml = JaxbUtil.xml2Bean(aliPayXmlStr, AliPayXml.class);        System.out.println(JSON.toJSONString(aliPayXml));    &#125;&#125;</code></pre><p>测试结果:</p><p>打印的为json格式结果, 可debugger查看. 同样也可以将javaBean转换为xmlStr</p><pre><code>&#123;&quot;buyerLoginId&quot;:&quot;176****3035&quot;,&quot;buyerUserId&quot;:&quot;2088912868994947&quot;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> utils </category>
          
      </categories>
      
      
        <tags>
            
            <tag> utils </tag>
            
            <tag> xml </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
